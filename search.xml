<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cpp阅读笔记-类]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FCPP%E7%B1%BB%2FCpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[# 类的基本概念 首先是一段自定义类的代码： \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212\#include&lt;bits/stdc++.h&gt; using namespace std; class Screen&#123; public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; string pr()const; Screen &amp;move(pos r,pos c); void move(pos r,pos c,int sit); Screen &amp;set(char); Screen &amp;set(pos,pos,char); Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125; const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; friend class window_mgr; //friend void window_mgr::clear(Screenindex); private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125; &#125;; Screen &amp;Screen::move(pos r,pos c) &#123; pos row=r*width; cursor=row+c; return *this; &#125; void Screen::move(pos r,pos c,int sit) &#123; pos row=r*width; cursor=row+c; //return *this; &#125; char Screen::get(pos r,pos c)const &#123; pos row=r*width; return contents[row+c]; &#125; Screen &amp;Screen::set(char c) &#123; contents[cursor]=c; return *this; &#125; Screen &amp;Screen::set(pos r,pos col,char ch) &#123; contents[r*width+col]=ch; return *this; &#125; string Screen::pr() const &#123; return contents; &#125; class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;; &#125;; void window_mgr::clear(window_mgr::Screenindex i) &#123; Screen &amp;s=screens[i]; s.contents.clear(); &#125; window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s) &#123; screens.push_back(s); return screens.size()-1; &#125; int main() &#123; int x=10; Screen screen1; Screen screen2(10, 10, 'a');screen2.sit=3; cout&lt;&lt;screen1.sit&lt;&lt;endl; //screen1.move(2,3); screen1.move(2,3,1); screen1.move(3,4).sit=screen2.sit; // cout &lt;&lt; x &lt;&lt; " " &lt;&lt; screen1.getH() &lt;&lt; endl; // cout&lt;&lt;screen1.sit&lt;&lt;endl; screen2.set(5,5,'d'); // cout&lt;&lt;screen2.get(5,5)&lt;&lt;endl; // cout&lt;&lt;screen2.pr()&lt;&lt;endl; screen2 .display(cout); window_mgr w1; // w1.screens[0].display(cout); w1.clear(0); return 0; &#125; \``` **成员函数（类似Screen1.set()这种）的声明必须在类的内部，定义则可以在类内部也可以在类外部。而接口组成部分的函数或者说只是使用了类的函数，比如说用两个类作为自己的参数的函数，声明和定义都在类外部** \### this 实例函数： std::string isbn() const{return bookNo;}123456**成员函数通过名为`this`的隐式参数来访问调用它的那个对象。例如，如果调用`total.isbn()`，编译器会把total的地址传递给isbn的隐式形参this，相当于 `Sales_data::isbn(&amp;total)`** this形参是隐式定义的，**任何自定义名为this的参数或变量的行为都是非法的**，我们可以在成员函数体内部使用this，虽然没有必要。例：isbn还能如下定义： std::string isbn() const{return this-&gt;bookNo;}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180isbn函数参数列表后的const的作用是修改this指针的类型，默认情况下，this的类型是指向类类型的**非常量版本**的**常量指针**。这就意味着在默认情况下我们不能把this绑定在一个常量对象上。 \### 类作用域和成员函数 编译器处理类时， **首先编译成员声明，然后才轮到成员函数体（如果有的话）**因此，成员函数体可以随意使用类中的其他成员函数而不必在意这些成员出现的先后顺序（即使出现在函数声明之后也没有问题）。 作用域运算符：类似于`Sales_data::avg_price`这样的：：，说明了以下事实： 有一个名为avg_price的函数，并且该函数被声明在类Sales_data的作用域内。 \##### 关于函数引用IO类型作为参数 IO类属于不能被拷贝的类型，因此只能通过引用来传递他们。 \### 构造函数 **构造函数的名称与类的名称相同** 只要类的对象被创造，就会执行构造函数。注意：构造函数没有返回类型 一个类可以包含多个构造函数，和其他重载函数类似。**但是，构造函数不能被声明成const的。** 如果一个类没有显式定义构造函数，那么编译器就会隐式地指定一个默认构造函数（即合成的默认构造函数），一般来说，容器都为空，数据都为0，bool都为false。在C++11中，如果需要默认行为，可以在参数列表后写上=default来要求编译器生成默认构造函数 构造函数举例： \```cpp Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(const std::string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125; \``` 冒号与花括号之间的部分称为**构造函数初始值列表**，它负责为新创建对象的一个或者几个数据成员赋值。如果有数据成员被初始化列表所忽略，那么它将被以与默认构造函数相同的方式隐式初始化。 注意：上面的函数中的函数体中还可以执行其他的任务或空置。 \### 拷贝，赋值和析构 通俗来说，一个类的对象可以直接被赋予另一个对象的值，例如`total=trans`,其中total跟trans都是类对象。**但是，管理动态内存的类通常不能这么做**。 不过使用vector跟string的类并不受此影响。 \# 访问控制与封装 访问说明符：public与private 定义在private之后的成员可以被类的成员函数以及友元访问，但不能被使用该类的函数访问。注意，struct默认为public，class默认为private \### 友元 类可以允许其他类或者函数访问他的private成员，只要给其他类或者函数加上friend（友元）的声明即可。 例如： \```cpp class Screen&#123; public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; friend class window_mgr;//将window_mgr声明为Screen的友元 //friend void window_mgr::clear(Screenindex); private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125; &#125;; class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,&apos; &apos;)&#125;; &#125;; \``` 这样一来，window_mgr就可以访问Screen类的私有数据成员了。 **友元声明只能出现在类的内部，但是类内部出现的具体位置不限** **友元的声明仅仅提供了一个访问权限，要想真的使用这个函数，在类的外部需要再专门声明一次** \# 类的其他特性（类成员） 除了定义数据和函数成员以外，类还可以自定义某种类型在类中的别名，由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。 和非成员函数一样，成员函数也可以被重载，只要函数之间在参数数量或者类型上有所区别即可。 \##### 类数据成员的初始值 可以给类的数据成员添加一个默认的初始值 \```cpp class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,&apos; &apos;)&#125;; &#125;; \``` \### 返回*this的成员函数 \```cpp Screen &amp;Screen::set(pos r,pos col,char ch) &#123; contents[r*width+col]=ch; return *this; &#125; \``` 返回引用的函数是**左值**的，意味着这些函数返回的是对象本身而不是对象的副本；如果这个函数是不是左值的，那么返回的数据只是函数中调用对象的一个copy； 举个例子，如果有这么一系列操作：`myscreen.move(4,0).set(&apos;#&apos;);` 这些操作会在同一个对象上执行，因为`move()` 和`set()`函数都是左值的； 也就是说，这个函数等价于`myscreen.move(4,0);myscreen.set(&apos;#&apos;);` 如果`move()` 和`set()`函数不是左值的，那么上述语句将会变成： Screen temp=myscreen.move(4,0);temp,set(‘#’); 也就是说，第2步并不会改变原来myscreen中的contents（内容）； **注意：一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用，也就是一个常量** \##### 基于const的重载 通过区分成员函数是否是const的，我们也可以对其进行重载 例如： \```cpp Screen &amp;display(ostream &amp;os){ do_display(os);return *this; } const Screen &amp;display(ostream &amp;os)const{ do_display(os);return *this; } \ 当我们在某个对象上调用display函数时，该对象是否是const决定了应该调用display的哪个版本； 例如： `cpp Screen myscreen(5,3); const Screen blank(5,3); myscreen.set(‘#’).display(cout);//调用非常量版本 blank.display(cout);//调用常量版本 ` #### 类类型 注意：即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类而言，它的成员和其他任何类的成员都是不一样的。 ##### 类的声明 我们可以仅声明类而暂时不定义它；这就是所谓的前向声明，在声明之后定义之前的类型被称为不完全类型； 不完全类型只能在非常有限的场景下使用：可以定义指向这种类型的指针和引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数； 对于一个类而言，我们在创造它的对象之前必须将其定义（不然编译器哪知道怎么初始化233）。但是一个类一旦名字出现后，它就被认为是声明过了，因此类允许包含指向它自身类型的引用或指针。]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
        <category>CPP类</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
        <tag>CPP类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本语法]]></title>
    <url>%2FPython%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注释# ### 基本数据类型 int可以是任何大小的整数 变量名的第一个字符必须是字母或下划线；变量名区分大小写； 使用单/双引号指定字符串，所有引号内的字符，包括空格与制表符都将原样保留。两种引号工作机制相同 ### 输出格式 三引号用于指定多行字符串（&quot;&quot;&quot;或&#39;&#39;&#39;均可以） 例如： `python print(‘’’this is the first line and this is the second hhahahah’’’) ` 就会原样输出3行 有时候我们会想要从其他信息中构建字符串。这正是 format() 方法大有用武之地的地方。 例如： `python age = 20 name = ‘Swaroop’ print(‘{} was {} years old when he wrote this book’.format(name, age)) print(‘Why is {} playing with that python?’.format(name)) ` Python 中 format 方法所做的事情便是将每个参数值替换至格式所在的位置。这之中可以有 更详细的格式，例如: `python # 对于浮点数 ‘0.333’ 保留小数点(.)后三位 print(‘{0:.3f}’.format(1.0/3)) # 或者省略花括号里面那个0也是可以的 print(‘{:.3f}’.format(1.0/3)) # 使用下划线填充文本，并保持文字处于中间位置 # 使用 (^) 定义 ‘hello‘字符串长度为 11 print(‘{0:_^11}’.format(‘hello’)) # 基于关键词输出 ‘Swaroop wrote A Byte of Python’ print(‘{name} wrote {book}’.format(name=’Swaroop’, book=’A Byte of Python’)) ` 由于我们正在讨论格式问题，就要注意 print 总是会以一个不可见的“新一行”字符( \n ) 结尾，因此重复调用 print 将会在相互独立的一行中分别打印。为防止打印过程中出现这一 换行符，你可以通过 end 指定其应以空白结尾: `python print(‘a’, end=’’) print(‘b’, end=’ ‘)#以空格结尾 ` ##### 转义序列 如果希望生成一串包含单引号( ‘ )的字符串，你应该如何指定这串字符串? 例如，你想要的字符串是 “What’s your name?” 。你不能指定 ‘What’s your name?’ ，因为这 会使 Python 对于何处是字符串的开始、何处又是结束而感到困惑。所以，你必须指定这个单引号不代表这串字符串的结尾。这可以通过转义序列(Escape Sequence) 来实现。你通过\ 来指定单引号:要注意它可是反斜杠。现在，你可以将字符串指定为 ‘What\’s your name?’ 另一种指定这一特别的字符串的方式是这样的: “What’s your name?” ，如这个例子般使用 双引号。类似地， 你必须在使用双引号括起的字符串中对字符串内的双引号使用转义序列。 同样，你必须使用转义序列 \ 来指定反斜杠本身。 如果你想指定一串双行字符串该怎么办?一种方式即使用如前所述的三引号字符串，或者你 可以使用一个表示新一行的转义序列——\n 来表示新一行的开始。（与cpp类似） 在一个字符串中，一个放置在末尾的反斜杠表示字符串将在下一行继续，但不会添加新的一行。来看看例子: `python “This is the first sentence. \ This is the second sentence.” ` 相当于&quot;This is the first sentence. This is the second sentence.&quot; ### 基础语法 所谓物理行(Physical Line)是你在编写程序时 你所看到的内容。所谓逻辑行(Logical Line)是 Python 所看到 的单个语句。Python 会假定每一物理行会对应一个逻辑行。如果你希望在一行物理行中指定多行逻辑行，那么你必须通过使用分号( ; )来明确表明逻辑行或语句的结束。 空白区在 Python 中十分重要。实际上，空白区在各行的开头非常重要。这被称作 缩进 (Indentation)。在逻辑行的开头留下空白区(使用空格或制表符)用以确定各逻辑行的缩 进级别，而后者又可用于确定语句的分组。这意味着放置在一起的语句必须拥有相同的缩进。每一组这样的语句被称为 块(block)。 Attention：使用四个空格来缩进。这是来自 Python 语言官方的建议。好的编辑器会自动为你完成这 一工作。请确保你在缩进中使用数量一致的空格，否则你的程序将不会运行，或引发不 期望的行为。 ### 运算符与优先级 #### 需要注意的运算符 ** (乘方) 返回 x 的 y 次方。 3**4 输出 81 (即 3 3 3* 3 )。 /(除) x 除以 y 13 / 3 输出 4.333333333333333 。 // (整除) x 除以 y 并对结果向下取整至最接近的整数。 13 // 3 输出 4 。 -13 // 3 输出 -5 。 &lt; (小于) &gt; (大于) 返回 x 是否小于 y。所有的比较运算符返回的结果均为 True 或 False 。请注意这 些名称之中的大写字母。 5&lt;3 输出 False ，3&lt;6 输出 True 。 比较可以任意组成链接: 3 &lt; 5 &lt; 7 返回 True 。 如果两个操作数均为数字，它们首先将会被转换至一种共同的类型。否则，它将总是返回 False 。 not (布尔“非”) 对应cpp的！ and (布尔“与”) 对应cpp的&amp; or (布尔“或”) 对应cpp的| 其余运算符与cpp基本一致 #### 优先级 以下运算符优先级由低至高排序 lambda :Lambda 表达式 if - else :条件表达式 or :布尔“或” and:布尔“与” not x :布尔“非” in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == :比较，包括成员资格测试 (Membership Tests)和身份测试(Identity Tests)。 | :按位或 ^ :按位异或 &amp; :按位与 &lt;&lt;, &gt;&gt; :移动 +, -:加与减 *, /, //, %:乘、除、整除、取余 +x, -x, ~x :正、负、按位取反 ** :求幂 x[index], x[index:index], x(arguments...), x.attribute :下标、切片、调用、属性引 用 (expressions...), [expressions...], {key: value...}{expressions...}:表示绑定或元 组、表示列表、表示字典、表示集合]]></content>
      <categories>
        <category>Python</category>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233]]></title>
    <url>%2Farticle%2F233%2F</url>
    <content type="text"><![CDATA[23323323312345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl; return 0;&#125; 2333 test ss s $233+34+A^3+A_5^4$ 2333 $A_5^4+A+23$ 233333333 哈哈哈 test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Farticle%2Ftest%2F</url>
    <content type="text"><![CDATA[233 test]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farticle%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[蒟蒻的Linux随笔]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FLinux%2Fe8-92-9f-e8-92-bb-e7-9a-84linux-e9-9a-8f-e7-ac-94%2F</url>
    <content type="text"><![CDATA[最近突然开始研究了一下Linux，随手记录一下一些用过的看起来比较有意思的命令吧QAQ 文件浏览&amp;常用乱七八糟编译命令： g++ a+b.cpp -o a+b+c -std=c++11 a+b.cpp是cpp文件名，a+b+c则是可执行文件名，后面则可以选择编译标准。 ls 浏览当前文件夹下的所有文件（不包含隐藏文件 ls -a 显示所有文件（包括隐藏文件） man ls man后面加东西，显示该命令的帮助，上下/空格浏览，q退出 cal 显示日历。cal 5 2018可显示指定月份。 文件打开&amp;新建&amp;删除 cd name 打开文件 cd/cd ~ 回到根目录 cd .. 回到上一级目录 pwd 显示当前路径 mkdir name 新建文件夹 mkdir -p name/name/name 按路径建立多个新文件夹 rmdir name 删除此文件夹（被删除文件夹必须为空） rm -r name 干翻name目录下所有文件（删库跑路？） 文件复制，移动，删除文件复制 cp ~/testpdf.pdf ~/test 将根目录下的文件copy到空格后的目录中，~/不填则默认为当前目录下的文件 可以在复制的同时对复制后的文件进行重命名： cp ~/testpdf.pdf ~/test/notest.pdf 复制过去的pdf名字就变了 可以加上-i选项，这样有同名文件覆盖前会询问是否覆盖： cp -i ~/testpdf.pdf ~/test 如果要复制一个目录，或者说是文件夹，那么需要加上指令 -r cp -r test1 test2 如果要强制执行，还可以使用-f指令；同时，多个指令可以叠加使用，例如： cp -rf test1 test2 强制复制目录 文件删除使用指令rm以达到目的，同样，删除目录需要使用-r，这是递归删除命令； rm -r test1 -i则会在删除前确认，-f表示强制执行。同时，还可以使用指令 rm test* 通过加上 “* ” 来删除此目录下所有文件名以test为前缀的文件； 文件移动使用mv指令来达成目的。mv指令可以移动普通文件和目录，因此不存在-r-f 强制，-i：如果存在同名文件，询问是否覆盖； -u：如果目标文件已存在，且当前来源较新才会更新 mv a+b ~/test/test2/ 将当前目录中的可执行文件a+b移动到指定文件夹中； mv a+b ~/test/test2/a+c 移动文件的同时进行名称变更； mv a+b a+c ~/test/ 同时移动多个文件；注意此时最后一个一定是目录！！！]]></content>
      <categories>
        <category>乱搞</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 18 (rated, Div. 1 + Div. 2)]]></title>
    <url>%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fmanthan-codefest-18-rated-div-1-div-2%2F</url>
    <content type="text"><![CDATA[1w年没更新了QAQ A. 傻逼题二进制分解一下即可 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=0;;i++){ if(n&lt;=(1&lt;&lt;i))break; n-=(1&lt;&lt;i); } cout&lt;&lt;i+1&lt;&lt;endl; return 0; } B. 排个序贪心搞搞就行，自己zz了还wa了3发… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { int num[200005],n,s,i,j,k; ll ans=0; cin&gt;&gt;n&gt;&gt;s; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); sort(num+1,num+1+n); int mid=(n+1)&gt;&gt;1; if(num[mid]==s){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(num[mid]&gt;s){ for(i=mid;i;i--){ if(num[i]&lt;=s)break; ans+=num[i]-s; } } else{ for(i=mid;i&lt;=n;i++){ if(num[i]&gt;=s)break; ans+=s-num[i]; //cout&lt;&lt;ans&lt;&lt;endl; } } //cout&lt;&lt;mid&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 除非相邻位置刚好要交换，否则都没有交换意义，随便搞搞即可 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k;string str1,str2; int ans=0; cin&gt;&gt;n; cin&gt;&gt;str1&gt;&gt;str2; for(i=0;i&lt;str1.size();i++){ if(str1[i]!=str2[i]){ if(i&lt;str1.size()-1&amp;&amp;str1[i+1]!=str2[i+1]&amp;&amp;str1[i]!=str1[i+1]){ ans++;i++; } else{ ans++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 其实就是一个二叉树的层次遍历，但是还有一点要注意的就是父亲层的遍历顺序决定了下一层的遍历顺序，所以这也要考虑。解决方案是每个点建一个map记录边，然后检测序列的时候弄两个指针，一个指示当前节点，另一个指示当前节点的儿子。如果是非法序列，最后第二个指针肯定没法走完所有的节点。同时还要注意特判根节点是否为1 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt;mp1[200005]; int main() { int n,i,j,k,x,y; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y);mp1[x][y]=1;mp1[y][x]=1; } int num[200005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); for(i=1,j=2;i&lt;=n;i++) while(mp1[num[i]][num[j]]) j++; if(j==n+1&amp;&amp;num[1]==1){//注意这里是j==n+1!! cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; //cout&lt;&lt;j&lt;&lt;endl; return 0; } E. 难点在于怎么去检测一个人是否有至少k个朋友，并且这些朋友也都有至少k个可以去旅游的朋友…标算很精妙… #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; set&lt;int&gt;s,G[maxn]; int k,a[maxn],b[maxn],ans[maxn],n,m; void check(int x) { if(G[x].size()&lt;k&amp;&amp;s.erase(x)){//如果这个人的朋友小于k,他肯定要滚蛋,同时在s里面也要删去此人 for(auto a:G[x]){ G[a].erase(x);check(a);//他的朋友也要check一发 } } } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); G[a[i]].insert(b[i]);G[b[i]].insert(a[i]);//建立朋友关系 } for(i=1;i&lt;=n;i++)s.insert(i); for(i=1;i&lt;=n;i++)check(i);//检查每一个人的朋友关系 for(i=m;i;i--){ ans[i]=s.size();//此时集合中的所有人都满足要求 G[a[i]].erase(b[i]);G[b[i]].erase(a[i]);//删去这天才成为朋友的人 check(a[i]);check(b[i]); } for(i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]); return 0; }]]></content>
      <categories>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意瑞法之旅——咕咕咕系列]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%97%85%E6%B8%B8%2Fe6-84-8f-e7-91-9e-e6-b3-95-e4-b9-8b-e6-97-85-e5-92-95-e5-92-95-e5-92-95-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[8.26一大早5点钟就滚去机场了，飞机倒是没延误，但是南航的这班飞机真心不敢恭维——首先飞机在远机位，坐摆渡车跑了半天，然后大概是飞机比较陈旧的缘故吧，连个人娱乐系统都没有，无聊得不行，要是飞国际线乘客估计能无聊死。餐食就更加无语了，面条非常难吃，还每人发了半个番薯…说起来番薯好像还是最好吃的。幸好航程不长，睡一觉也就到了。不过下降的时候飞越了广州市区倒是好评，第一次如此完整的在空中俯瞰广州——我甚至清晰地拍到了小蛮腰。 滚回家就12点了，睡了一觉起来5点了…搞了搞吃了个饭又愉快地去机场了，新航站楼的空调真的好冷QAQ。航班其实是凌晨00：35的…登机的时候前面有俩蛮帅的小哥哥，不过似乎是俩资本主义的国民，一直在哇哩哇啦不知道说啥😂 投奔资本主义~ 然后，南航不得不再吐槽一发…虽然说787一排343也是航空公司常态了…但是您这个前后间距敢不敢再窄一点，感觉我TM一路蹲到了罗马…作为5年的老787，WiFi自然没有，娱乐系统的分辨率…大概只有联想的垃圾泛白tn屏才能与之一战。飞了12个半小时，真的挺漫长的… 罗马机场WiFi界面倒是好评…估计也是为了讨好一下各位爆买的金主大妈吧… 8.27在罗马机场过海关队伍真的超级长…刚好排到了一个特别严肃的海关大姐把守的关卡，我前面的一个穆斯林小姐姐似乎被遣返了…还好后来换了个大叔来审核，这哥们倒是贼松散，上来一看中国游客直接就过了… 前面这个妹子被遣返了，左边那个大妈真的… 讲道理，罗马机场给我的感觉其实也挺一般的，跟北京的t2一个水平吧，略旧。 然后第一天就先滚去梵蒂冈了，看了看圣彼得大教堂，里面各种什么名画雕塑，埋了各种名人…不过对于对艺术一窍不通的我来说，感觉都是一堆石膏像，看不出什么大区别…倒是外面的瑞士雇佣兵蛮有意思，感觉像动物园里的动物被人疯狂拍照：-D 接着就滚去了斗兽场跟许愿池转了转，感觉还行，就是人略多（谁说只有中国人多来着，资本主义一样人挤人…)吃了个所谓意大利雪糕，个人感觉并没有麦当劳的新地好吃（呸 不过，罗马老建筑的保护还是普遍比国内好…这个不得不承认 似乎还是跨国大公司麦爸爸的东西最好吃：-D 然后就滚回酒店啦，吃了个麦爸爸，8点就睡着了（于是第二天4点就醒了） 8.288.31今天早上在琉森湖游了一会船，但是雾太大感觉啥都看不见，最有意思的似乎是湖里还能正常行驶的明轮蒸汽船。接着就是在卢塞恩（琉森）的自由活动时间了。考虑到对手表毫无兴趣（其实是买不起），又恰好发现附近有一个The Swiss Museum of Transport,于是就很开心的坐了4站公交过去看。买票的时候发现没有足够的硬币，上车跟司机聊了半天也没有解决问题，于是最后就逃了一波票。不得不说资本主义的公交坐起来还是挺舒服的，而且车上人贼好，还主动问我是不是去博物馆（大概是脸上写着“游客”两字？） 博物馆跟中国的相比其实并不是很大，但是维护得非常好，展品保养得也非常棒，更重要的是，]]></content>
      <categories>
        <category>生活</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 10]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E8%B5%9B%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-multi-university-training-contest-10%2F</url>
    <content type="text"><![CDATA[HDU6426~6437 G考虑使用容斥原理进行计数. 包含至少一个形如 $[i, i + 1] $或 $[n, 1] $这样的子串的环排列个数是 $\binom{n}{1} (n - 2)! $个; 可以推广为包含至少$ k (0 \leq k &lt; n)$个的环排列个数是 $\binom{n}{k} (n - k - 1)!$, 同时注意到包含 $n$ 个的环排列个数一定是 1个. 所以最终答案就是$ (-1)^n + \sum_{k = 0}^{n - 1} (-1)^k \binom{n}{k} (n - k - 1)!$ 或者，直接暴力打表找出前几项，推公式或者面向OEIS编程，得出公式： $a_n=(n-2)\times a_{n-1}+(n-1)\times a_{n-2}-(-1)^n$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=998244353; ll f[100005]; int main() { f[1]=1;f[2]=0;f[3]=1;f[4]=1; int i,j; for(i=5;i&lt;=100000;i++){ f[i]=((i-2)*f[i-1]%mod+(i-1)*f[i-2]%mod-(i&amp;1?-1:1))%mod; } int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; cout&lt;&lt;f[n]&lt;&lt;endl; } return 0; } Hprintf(“%.0f\n”, pow(2, n)); #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 10000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } int main() { int t,i,j,k; cin&gt;&gt;t; while(t--){ int n;cin&gt;&gt;n; bign ans=1; for(i=1;i&lt;=n;i++){ ans=ans*2; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } I.令 $a=i-j$, 先枚举$ i$ 再枚举 $a$ $ \sum_{i=1}^n \sum_{j=1}^{i-1} [\gcd(i+j,i-j)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i-a,a)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i,a)=1]$ 即对于每个 $i$, 求有多少个小于它的 $a$ 满足$ \gcd(i,a)=1 $且$ a $是奇数. 当 $i$ 是奇数时, 答案为$ \frac{\varphi(i)}{2}.$ （此时，所求就是$(n,1),(n,3),(n,5)…(n,n)$中$\gcd$为1的个数，也就是求 $(n,n-1),(n,n-3),…(n,n-n)$,即$(n,2),(n,4),(n,6)…(n,n-1)$,所以有 $\sum(1,3,…,n)=\frac{1}{2}\sum(1,2,…n)[gcd(n,i)=1]=\frac{phi(n)}{2}$ 当 $i$ 是偶数时, 答案为$\varphi(i).$ (显然a是偶数的时候gcd不会是1，所以直接求欧拉函数即可) 注意 $i=1$ 时, 答案为 0. 记个前缀和就好了, 复杂度为 $O(N+T)$. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e7+10; vector&lt;int&gt;prime; bool isnotprime[maxn+50]; long long phi[maxn+50]; void check(void) { int i,j,k; for(i=2;i&lt;=maxn;i++){ if(!isnotprime[i]){ prime.push_back(i);//[ptop++]=i; phi[i]=i-1; } for(j=0;j&lt;prime.size();j++){ int pi=prime[j]*i; if(pi&gt;maxn)break; isnotprime[pi]=true; if(i%prime[j]==0){ phi[pi]=prime[j]*phi[i]; break; } phi[pi]=(prime[j]-1)*phi[i]; } } for(i=1;i&lt;=maxn;i++) { if(i&amp;1)phi[i]&gt;&gt;=1; phi[i] += phi[i - 1]; } } int main() { int t,i,j; check(); cin&gt;&gt;t; while(t--){ int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,phi[n]); } return 0; } J.K 不大于 5, 仅是常数级别, 所以可以搞事情 我们发现 $|x_{MW}[i]-x_{SW}[i]| = max(x_{MW}[i]-x_{SW}[i],x_{SW}[i]-x_{MW}[i])$ 也就是说对于每一个维度只有两种选择, 同时$ 2^K \le 32$ 也不大, 所以可以枚举每一维的大小情况, 分别取主武器与副武器的最大值就好了, 复杂度 $O(2^Kn).$ 具体来说，对于每一个武器，枚举他的每一个x前面取+/-号的情况，然后更新$num[j]$数组，也就是记录在一种+/-取值状况下的最大值，然后我们枚举主副武器的num数组，当然枚举的时候要确保主武器的取值状况与副武器刚好是取反的状态，这样就可以求出最大值。当然会出现一些正负号不甚正确的情况，可是这些情况显然不会是最优解，所以不必担心。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=-(1ll&lt;&lt;60); const int maxn=100005; int S[maxn],s[maxn],X[maxn][6],x[maxn][6]; ll numm[60],numn[60]; int main() { int t,i,j,n,m,k; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=0;i&lt;(1&lt;&lt;5);i++) numm[i]=numn[i]=INF; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;S[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;X[i][j]); for(;j&lt;=5;j++) X[i][j]=0; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;s[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;x[i][j]); for(;j&lt;=5;j++) x[i][j]=0; } for(i=1;i&lt;=n;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=S[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?X[i][a+1]:-X[i][a+1]; } numm[j]=max(numm[j],temp); } } for(i=1;i&lt;=m;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=s[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?x[i][a+1]:-x[i][a+1]; } numn[j]=max(numn[j],temp); } } ll ans=0; for(i=0;i&lt;(1&lt;&lt;5);i++){ int pos=((1&lt;&lt;5)-1)&amp;(~i); ans=max(ans,numm[i]+numn[pos]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } L.咋一看以为是dp，后来发现是网络流…这里需要最大的满意值，而我们的模板是最小费用流，所以我们可以把满意值都弄成负的，这样求出来以后取个相反数就是满意值了… 考虑到每个video只能被一个人看，因此显然要拆点，流量1费用0，然后为了限制总流量也就是人数，起点向虚拟起点连边,限制总流量k。为了保证最大流，（有的人可以没video看），虚拟起点向终点连边,流量k费用0，确保最大流量（因为video费用为负，可流的情况下显然更优）。然后起点向每个点video的第一个点连边，以及每个video的第二个点向终点连边。对于每个video，枚举所有的video，下个video的起始时间晚于当前video的结束时间才可以连边，流量1，费用为下个video的w，并且要考虑类型带来的惩罚值。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=550; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } struct movie{ int s,t,w,op; }M[250]; int main() { int t,i,j,k,n,m,w,W; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;W; for(i=0;i&lt;=520;i++)G[i].clear(); for(i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;M[i].s,&amp;M[i].t,&amp;M[i].w,&amp;M[i].op); int s1=505,s2=506,t=510; add(s1,s2,k,0);//起点向虚拟起点连边,限制总流量 add(s2,t,k,0);//虚拟起点向终点连边,确保最大流量 flow=cost=0; for(i=1;i&lt;=m;i++) add(i+200,t,1,0);//每个video向终点连边 for(i=1;i&lt;=m;i++){ add(s2,i,1,-M[i].w);//起点向每个video连边 add(i,i+200,1,0);//每个video拆成两个点 for(j=1;j&lt;=m;j++){ if(i==j)continue; if(M[i].t&lt;=M[j].s){//下个video的起始时间晚于当前video的结束时间才可以连边 if(M[i].op!=M[j].op){//类型不同直接连 add(i+200,j,1,-M[j].w); } else{//减去惩罚值 add(i+200,j,1,-(M[j].w-W)); } } } } mincostmaxflow(s1,t); cout&lt;&lt;-cost&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>网络赛</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>网络赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 34 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-34-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.数据范围那么小直接暴力枚举啊 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x; cin&gt;&gt;n; while(n--){ cin&gt;&gt;x; for(i=0;3*i&lt;=x;i++){ if((x-i*3)%7==0){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;&apos;\n&apos;;break; } } if(3*i&gt;x) puts(&quot;NO&quot;); } return 0; } B.弱智* 2 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int h1,a1,c1,h2,a2,cnt=0; vector&lt;int&gt;ans; cin&gt;&gt;h1&gt;&gt;a1&gt;&gt;c1&gt;&gt;h2&gt;&gt;a2; while(h2&gt;0){ cnt++; if(h2-a1&lt;=0){ ans.push_back(1);break; } else{ if(h1-a2&lt;=0){ ans.push_back(0);h1=h1-a2+c1; } else { ans.push_back(1);h1-=a2;h2-=a1; } } } cout&lt;&lt;cnt&lt;&lt;endl; for(auto a:ans) if(a) puts(&quot;STRIKE&quot;); else puts(&quot;HEAL&quot;); return 0; } C.从大到小排序，然后维护一个大根堆，每次如果堆顶的箱子能放下当前箱子，就把当前箱子丢进去并更新箱子大小，否则这个箱子就得单独放。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,box[5005]; priority_queue&lt;int&gt;que; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;box[i]; sort(box+1,box+1+n); for(i=n;i;i--){ if(que.empty()||que.top()&lt;=box[i]){ que.push(box[i]); } else{ que.pop();que.push(box[i]); } } cout&lt;&lt;que.size()&lt;&lt;endl; return 0; } D.其实我的想法很简单：首先搞个map统计每个数的出现次数，再搞个后缀和。然后从前往后扫，对于每个数，先在map里对这个数–，然后看看在这个数-1~这个数+1的范围内还有多少个数（用map查询），然后处理一下后缀和就行了。然而这个万恶的题目卡long long…于是我就抄了个400行的高精度模板… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //最大长度，可以修改 using namespace std; class bign { public: int len, s[MAX_L];//数的长度，记录数组 //构造函数 bign(); bign(const char *); bign(int); bool sign;//符号 1正数 0负数 string toStr() const;//转化为字符串，主要是便于输出 friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//重载输入流 friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//重载输出流 //重载复制 bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //重载各种比较 bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //重载四则运算 bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //四则运算的衍生运算 bign operator%(const bign &amp;) const;//取模（余数） bign factorial() const;//阶乘 bign Sqrt() const;//整数开根（向下取整） bign pow(const bign &amp;) const;//次方 //一些乱乱的函数 void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005]; int main() { int n,i,j,k,num[200005]; bign ans=0; cin&gt;&gt;n; map&lt;int,int&gt;mp1; for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;num[i]),mp1[num[i]]++; for(i=n;i;i--){ sum[i]=num[i];sum[i]+=sum[i+1]; } for(i=1;i&lt;=n;i++){ mp1[num[i]]--; int tot=n-i; if(mp1[num[i]]==0)mp1.erase(num[i]); bign temp;temp=num[i]; sum[i]-=temp; if(mp1.count(num[i]-1)){ temp=(ll)mp1[num[i]-1]*(num[i]-1); sum[i]-=temp; tot-=mp1[num[i]-1]; } if(mp1.count(num[i])){ temp=(ll)mp1[num[i]]*(num[i]); sum[i]-=temp; tot-=mp1[num[i]]; } if(mp1.count(num[i]+1)){ temp=(ll)mp1[num[i]+1]*(num[i]+1); sum[i]-=temp; tot-=mp1[num[i]+1]; } temp=(ll)tot*num[i]; ans-=temp;ans+=sum[i]; } //ans*=-1; cout&lt;&lt;ans&lt;&lt;endl; return 0; } 然后我看提交记录的时候发现了一个简单得多的做法…其实也可能是因为拿long double代替了高精度所以显得比较简单。 首先从前往后扫，对于每一位数a[i]，我们拿a[i]* i减去前缀和就是没有相减为0条件下的答案，然后对于那些绝对值相差1 的数，我们先拿一个map cnt统计迄今为止各个数的出现次数，然后加上cnt[a[i]+1]-cnt[a[i]-1]即可。long double居然能搞过去… #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt; cnt; int main() { int n; long double ans=0,sum=0,num; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++){ scanf(&quot;%Lf&quot;,&amp;num); ans+=num*i-sum+cnt[(int)num+1]-cnt[(int)num-1]; sum+=num; cnt[(int)num]++; } printf(&quot;%.0Lf&quot;,ans+0.000000001); return 0; } E. 给定一堆字符串，问能不能构造一个字符串使得所有的字符串在交换自己的某两个字符之后都与构造出来的字符一模一样。 首先，如果所有的字符串长得都一样，那随便换两个字母的位置输出即可。 否则，我们找到两个不同的字符串（第一个不妨就是输入的第一个字符串），然后把他们所有不相同的位置的下标都保存在diff数组里。如果diff的size&gt;4，那么显然，无解（每个字符串最多交换2个字符，不可能使得5个以上不同的位置变得相同）。 然后，对于每个不同的下标，我们都尝试拿第一个字符串中不同位置的字符去与之交换，看看换完的字符串能不能是答案。 如何检查一个交换完的字符串是不是答案呢？ 对于所有的字符串（当然自己跟自己除外），我们都统计不同的位置的下标并保存在dif数组中，如果有任意一个字符串的dif数组的size!=0&amp;&amp;size!=2，显然这个换完的字符串是不能成为答案的。如果size=0，那么那个字符串如果所有的字符都是不一样的，也不行（因为每个字符串都要交换两个字符，全部不同的话换完就不可能满足当前答案了）。如果size=2，那么那个字符串交换完这俩位置之后必须与当前答案一样。 扫完所有可能以后，如果还没有找到答案，输出-1即可。 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(string str) { int cnt[30]={0}; for(auto a:str) cnt[a-&apos;a&apos;]++; for(int i=0;i&lt;26;i++) if(cnt[i]&gt;=2) return true; return false; } int main() { set&lt;string&gt;s; int k,n,i,j,a,b,len; cin&gt;&gt;n&gt;&gt;len; string str[2505],str1,str2; for(i=1;i&lt;=n;i++){ cin&gt;&gt;str[i];s.insert(str[i]); } if(s.size()==1){ swap(str[1][0],str[1][1]); cout&lt;&lt;str[1]&lt;&lt;endl;return 0; } str1=str[1]; for(i=2;i&lt;=n;i++) if(str[i]!=str[1]) { str2 = str[i];break; } vector&lt;int&gt;diff; for(i=0;i&lt;len;i++) if(str1[i]!=str2[i]) diff.push_back(i); if(diff.size()&gt;4){ puts(&quot;-1&quot;);return 0; } for(auto a:diff){ for(i=0;i&lt;len;i++){ if(i==a)continue; bool isok=true; string str3=str1;swap(str3[i],str3[a]); for(j=2;j&lt;=n;j++){ vector&lt;int&gt;dif; for(k=0;k&lt;len;k++){ if(str3[k]!=str[j][k]) dif.push_back(k); } if(dif.size()!=0&amp;&amp;dif.size()!=2){ isok=false; break; } if(dif.empty()){ if(!check(str[j])){ isok=false;break; } } else{ string str4=str[j];swap(str4[dif[0]],str4[dif[1]]); if(str4!=str3){ isok=false;break; } } } if(isok){ cout&lt;&lt;str3&lt;&lt;endl;return 0; } } } puts(&quot;-1&quot;); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 49 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-49-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.小心处理z与a的问题，以及注意每个字母都必须发生变化即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { string str1,str2; int n,i,j,k; int t; cin&gt;&gt;t; while(t--){ bool isok=true; cin&gt;&gt;n&gt;&gt;str1;str2=str1;reverse(str2.begin(),str2.end()); for(i=0;i&lt;str1.size();i++){ if(abs((int)(str1[i]-str2[i]))==1||abs((int)(str1[i]-str2[i]))&gt;2){ isok=false;break; } } if(isok)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } B.注意n为奇数的时候需要特别讨论,每两行为一组刚好n个数，然后可能多一行得单独讨论一下。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n, q, x, y; cin &gt;&gt; n &gt;&gt; q; int i,j,k; for (i = 1; i &lt;= q; i++) { cin &gt;&gt; x &gt;&gt; y; ll ans = 0; if ((x + y) &amp;1) { ans += (n * n - 1) / 2 + 1; } if (n &amp;1) { ans += (x - 1) / 2 * n; if ((x + y) % 2 == 1) ans += (x - 1) % 2 * (n / 2); else ans += (x - 1) % 2 * (n / 2 + 1); ans += (y + 1) / 2; } else if (n % 2 == 0) { ans += (x - 1) * n / 2; ans += (y + 1) / 2; } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } C.注意到取到的最小值的组合肯定是那些比较相邻长度的木棍，因此我们可以将木棍排序，然后暴力枚举相邻长度且根数&gt;=2的木棍。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 50; long double minnum; int num[maxn]; int main() { int i,j,k, t, n; int q1, q2, P1, P2; cin&gt;&gt;t; while(t--){ minnum = 1ll &lt;&lt; 60;P1 = P2 = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); } sort(num + 1, num + n + 1); for (i = 1; i &lt;= n; i++) { if (P1 == num[i]) { if (P2 != 0) { long double x(P1), y(P2); long double temp = (x + x + y + y)*(x + x + y + y) / (x*y); if (temp &lt; minnum) { q1 = P2; q2 = P1; minnum = temp; } } P2 = P1;P1 = 0; } else { P1 = num[i]; } } printf(&quot;%d %d %d %d\n&quot;,q1,q1,q2,q2); //cout &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; endl; } return 0; } D.每个房间都有出度…所以最后每个房间都可以归结于某个连通分量之中，求出这个连通分量中的最小的c就是这个连通分量的答案，但是还要注意那些a[i]=i的点，这种房间一定要在自己那里放一个。跑跑tarjan就完了。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; int dfn[maxn],low[maxn],scccnt=0,sccindex=0,belong[maxn]; bool instack[maxn]; stack&lt;int&gt;sta; vector&lt;int&gt;G[maxn]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v); } } int outdegree[maxn],c[maxn]; int minn[maxn],size1[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i]); long long ans=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);outdegree[i]++; if(j==i)ans+=c[i]; } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) size1[belong[i]]++; memset(minn,0x3f,sizeof(minn)); for(i=1;i&lt;=n;i++){ if(size1[belong[i]]&lt;=1)continue; minn[belong[i]]=min(minn[belong[i]],c[i]); } for(i=1;i&lt;=n;i++){ if(minn[i]!=0x3f3f3f3f) ans+=minn[i]; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. 题意大概是构造一个n* n的矩阵，要求满足相邻行与相邻列之间要么完全相同，要么完全相反。且不存在面积大于等于k的子矩阵颜色完全相同。 首先可以发现一个事实：一旦第一行第一列确定了，那么整个图的染色方案也就确定了。那么我们就可以设法去求第一行的染色方案（第一列跟第一行是一样的） 这可以用dp来求 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 510; const int mod = 998244353; ll f[maxn][maxn][2];//位置，连续数量，颜色； ll num[maxn]; int main() { //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, k,i,j,q; cin &gt;&gt; n &gt;&gt; k; for (q = 1; q &lt;= n; q++) { memset(f, 0, sizeof(f)); f[1][1][0] = f[1][1][1] = 1; for (i = 2; i &lt;= n; i++) {//位置 for (j = 1; j &lt;= min(i,q); j++) {//连续数量 f[i][1][1] += f[i - 1][j][0];//连续长度为1,那么前一个位置的颜色一定与这个位置不同 f[i][1][0] += f[i - 1][j][1]; f[i][j][1] += f[i - 1][j - 1][1];//与前一个位置颜色相同 f[i][j][0] += f[i - 1][j - 1][0]; f[i][1][0] %= mod; f[i][1][1] %= mod; f[i][j][0] %= mod; f[i][j][1] %= mod; } } for (i = 1; i &lt;= q; i++) { num[q] += f[n][i][0] + f[n][i][1]; num[q] %= mod; } } for (i = n; i &gt;= 2; i--) { num[i] = num[i] - num[i - 1] + mod;//减去不是这个长度的 数量 num[i] %= mod; } ll ans = 0; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { if (i*j &gt;= k)break;//如果这个矩形的面积大于等于k ans += num[i] * num[j]; ans %= mod; } } if (ans % 2 == 1)ans = (ans + mod) / 2;//答案是要除以2的(重复), // 但是模数是奇数且之前多次取模,因此如果答案是奇数,应该变成偶数再除以2 else ans /= 2; cout &lt;&lt; ans &lt;&lt; endl; return 0; } F. 有n个考试，每个考试有两个可以通过的日期，每天只能通过一个考试，问如何安排可以尽早完成所有考试。 暴力二分网络流是没错的，但是会t。但是可以从中得到启发，我们可以对每个考试的两天，先选择那个比较小的天，然后从比较小的天向比较大的天连一条边，表示选择的这一天也可以换成比较大的那一天。如果某个考试即使转移了以后也没法完成的话，就是没有可行解了。代码中利用了类似并查集的方式来维护转移； #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+50; struct e{ int x,y; }G[maxn]; bool cmp1(e a,e b) { return a.x&lt;b.x; } bool cmp2(e a,e b) { return a.y&lt;b.y; } int anotherchoice[maxn*2]; int find(int x) { return x==anotherchoice[x]?x:anotherchoice[x]=find(anotherchoice[x]); } int main() { int cnt=0,i,j,k,n; cin&gt;&gt;n; int ys[maxn*2]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;G[i].x,&amp;G[i].y);ys[++cnt]=G[i].x;ys[++cnt]=G[i].y; } sort(ys+1,ys+1+cnt); cnt=unique(ys+1,ys+1+cnt)-ys;int pos; sort(G+1,G+n+1,cmp1);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].x==ys[i])G[pos++].x=i; sort(G+1,G+n+1,cmp2);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].y==ys[i])G[pos++].y=i;//离散化,同时保证原大小关系不会改变 for(i=1;i&lt;=cnt;i++)anotherchoice[i]=i;//开始的时候每个日期的选择都只有自己 int ans=0; for(i=1;i&lt;=n;i++){ int ch1,ch2; ch1=find(G[i].x);ch2=find(G[i].y); if(!ch1&amp;&amp;!ch2){//如果这个考试的两个日期都没有选择了,那么显然无法完成 puts(&quot;-1&quot;);return 0; } else if(ch1==ch2||!ch1||!ch2){//如果这个考试只有一个可用的日期,那么显然只能唯一选择 ans=max(ans,max(ch1,ch2));anotherchoice[ch1]=anotherchoice[ch2]=0; } else{//考试有两个选择,那么先选那个日期比较小的,同时标记一下日期比较小的那题还有一个日期比较大的选择 ans=max(ans,min(ch1,ch2));anotherchoice[min(ch1,ch2)]=max(ch1,ch2); } } cout&lt;&lt;ys[ans]&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）快速读入]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e8-af-bb-e5-85-a5%2F</url>
    <content type="text"><![CDATA[与scanf，cin冲突（输出没问题），可返回EOF。 const int BufferSize=1&lt;&lt;16; char buffer[BufferSize],*fronthead,*fronttail; inline char GET_CHAR(){ if(fronthead==fronttail){ int l=fread(buffer,1,BufferSize,stdin); fronttail=(fronthead=buffer)+l; if(fronthead==fronttail)return EOF; } return *fronthead++; } inline int READ(){ int x=0,f=1;char c=GET_CHAR(); for(;!isdigit(c);c=GET_CHAR()){ if(c==EOF)return EOF; if(c==&apos;-&apos;)f=-1; } for(;isdigit(c);c=GET_CHAR())x=(((x&lt;&lt;2)+x)&lt;&lt;1)+c-&apos;0&apos;; return x*f; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #5]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-5%2F</url>
    <content type="text"><![CDATA[A.Gym - 101606L Lizard Lounge其实就是算出各个点位于哪条直线上，然后对每条直线算算LIS的问题…（就是把同一条直线上的蜥蜴丢到一起。我们用斜率来判断他们是不是在同一条直线上。之后要把他们按照在房间里的次序来排序，也就是按到显示器的距离来排序。）但是写起来有坑，首先斜率相同的点可能在tx，ty的两侧，他们是互不影响的。其次，直接算斜率会有精度问题。最后，算完斜率以后点的排序也要注意。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;P; const int maxn=1e6+10; map&lt;P,int&gt; mp1; vector&lt;P&gt;G[maxn]; int cnt=0; int gcd(int a,int b) { return b?gcd(b,a%b):a; } ll lenth(int x,int y) { return (ll)x*x+(ll)y*y; } void sit(int x, int y, int h) { ll d = lenth(x, y); if (x == 0) y /= abs(y); else if (y == 0) x /= abs(x); else { int z = gcd(abs(x), abs(y)); x /= z, y /= z; } if (mp1.count(P(x, y)) == 0) mp1[P(x, y)] = ++cnt; G[mp1[P(x, y)]].push_back(P(d, h)); } int main() { int tx, ty, n, i, j, k, x, y, h; cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; n; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;h); x -= tx;y -= ty; sit(x, y, h); } int ans = 0; int f[maxn], a[maxn]; for (i = 1; i &lt;= cnt; i++) { sort(G[i].begin(), G[i].end()); int len = G[i].size(); for (j = 0; j &lt; len; j++) a[j] = G[i][j].second, f[j + 1] = 1 &lt;&lt; 30; for (j = 0; j &lt; len; j++) { *lower_bound(f + 1, f + 1 + len, a[j]) = a[j]; } ans += lower_bound(f + 1, f + 1 + len, 1 &lt;&lt; 30) - f - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } B.CodeForces - 977D如果一个数是另一个数的两倍，或者是另一个数除以3的结果，那么就可以从那个数引一条边指向这个数，将问题转为一个有向图拓扑排序的问题即可解决了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { vector&lt;int&gt;G[105];int indegree[105]={0}; int n,i,j,k; cin&gt;&gt;n; ll num[105]; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;num[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ if(i==j)continue; if(num[j]==num[i]*2||(num[i]%3==0&amp;&amp;num[j]==num[i]/3)){ G[i].push_back(j);indegree[j]++; } } queue&lt;int&gt;que; for(i=1;i&lt;=n;i++)if(indegree[i]==0)que.push(i); int cnt=0; while(!que.empty()){ i=que.front();que.pop(); cout &lt;&lt; num[i] &lt;&lt; &apos; &apos;; for (j = 0; j &lt; G[i].size(); j++) { k = G[i][j]; indegree[k]--; if(!indegree[k])que.push(k); } } return 0; } D.CodeForces - 959D首先，不管b中的数字怎么放，要使得b中的数两两互质，那么每次往b里面丢一个数，这个数的约数的所有倍数都必须从可选集里滚蛋。因为b的字典序必须大于a且最小，所以如果有一个位置b比a大，那么后面的位置中尽量放最小的可放的数即可。基于这种考虑，我们首先使用类似埃氏筛的方法预处理出所有数的约数，然后每次先查找大于等于a的字典序最小的可选数，然后把这个数的所欲约数的倍数干掉。如果这个数&gt;a,那么GG，后面只要放最小的可放的数即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e6+5; bool isnot[N],erase1[N]; set&lt;int&gt;s; vector&lt;int&gt;G[N]; void getys(void) { for(int i=2;i&lt;N;i++){ //if(isnot[i])continue; if(!isnot[i]) { for (int j = i; j &lt; N; j += i) { isnot[j] = true; G[j].push_back(i); } } s.insert(i); } } int main() { int n,i,j,k; cin&gt;&gt;n; getys();bool islarge=false; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d&quot;,&amp;a);b=*s.begin(); if(!islarge) { b = *s.lower_bound(a); if(b!=a)islarge=true; } cout&lt;&lt;b&lt;&lt;&apos; &apos;; for(int j:G[b]){ if(erase1[j])continue; for(k=j;k&lt;N;k+=j){ if(!erase1[k]){ s.erase(k);erase1[k]=true; } } } } return 0; } E.CodeForces - 931B签到 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,a,b,cnt,i,j; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(i=0;;i++){ if(!(n&gt;&gt;i))break; } cnt=i-1;int cnt1=0; while(a!=b){ a=(a+1)&gt;&gt;1;b=(b+1)&gt;&gt;1;cnt1++; } if(cnt1==cnt)cout&lt;&lt;&quot;Final!&quot;&lt;&lt;endl; else cout&lt;&lt;cnt1&lt;&lt;endl; return 0; } F.CodeForces - 731F一个前缀和sum[i]记录小于等于I的个数，将序列排序，去重。枚举每一个数为“基数”，判断他[n倍—-(n+1) )倍（左闭右开，n从1开始）之间数的个数，这些数是要变成n* 基数的。记录和，记录最大值。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sum[200005],a[200005]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum[a[i]]++; } sort(a+1,a+1+n); int cnt=unique(a+1,a+1+n)-a-1; for(i=1;i&lt;=200000;i++) sum[i]+=sum[i-1];//记得变成前缀和 ll ans=0; for(i=1;i&lt;=cnt;i++){ ll val=0; for(j=1;a[i]*j&lt;=200000;j++){ int t1=a[i]*j,t2=a[i]*(j+1)&gt;200000?200000:a[i]*(j+1)-1;//注意区间的问题 int tot=sum[t2]-sum[t1-1]; val+=(ll)tot*t1; } ans=max(ans,val); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } G.CodeForces - 570D题目的朴素写法还是很好写的…但是数据规模过大导致必t无疑… 于是我们想到了离线处理，一次dfs… 但是依然不好做，这里我们处理的做法是利用异或…每次搜索到一个点的时候先把各个答案要问的深度的字母情况给保存起来，然后搜索这个节点下面子树各个深度的字母情况，最后再给每个答案异或一下，就可以得出这个节点下面的情况….emm,感觉不太好描述，总之还是挺巧妙的… #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500005; char node[maxn]; vector&lt;int&gt;G[maxn],query[maxn]; int dep[maxn],ans[maxn],tardep[maxn]; void dfs(int x,int depth) { for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//首先先把这个深度的字母个数情况保存起来 for (auto b:G[x]) dfs(b, depth + 1);//然后统计在当前节点下各个深度的字母情况,并更新dep数组 dep[depth] ^= (1 &lt;&lt; (int) (node[x] - &apos;a&apos;)); for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//新的dep数组异或旧的dep数组,就可以得出当前节点的子树中各个深度的字母情况 } bool check(int x) { int cnt=0; while(x){ cnt++;x-=x&amp;-x; } if(cnt&gt;1)return false; return true; } int main() { int n, m,i,j; cin&gt;&gt;n&gt;&gt;m; for (i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); G[j].push_back(i);//保存树 } scanf(&quot;%s&quot;, node + 1); for (i = 1; i &lt;= m; i++) { int v,h; scanf(&quot;%d%d&quot;, &amp;v, &amp;h); query[v].push_back(i);//离线处理问询 tardep[i] = h;//保存问询深度 } dfs(1, 1); for (i = 1; i &lt;= m; i++) { if(!check(ans[i]))//如果ans的二进制表示中有超过一个位置是1 printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #4]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-4%2F</url>
    <content type="text"><![CDATA[A.CodeForces 791D首先，先考虑一个问题：如何计算一棵树中所有点对之间的距离和。对于任意一个点，我们可以发现，如果这个点的子树的大小为$s$的话，那么这个点与其祖先之间的那条边在计算总和的过程中一定会被计算$(n-s)\times s$次（n为总的节点数）。但是目前有一个问题，就是每次只能走k步，比如说k=4，而距离为10，那就需要3步，此时如果直接求出总的距离之和去除以k，答案肯定是错误的。因此我们在dfs到每个节点的时候，还要计算他的各个子节点之间的距离，然后把所有mod k有余数的距离与k的倍数的差值都给补上。最后距离总和除以k即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5 + 50; ll n,k,ans=0,size[maxn][5],cntsub[maxn];//size代表节点x的距离它的距离为i的子节点的个数,cnt则为节点想的子树个数和 vector&lt;int&gt;G[maxn]; void dfs(ll x,ll fa,ll sit)//x为节点ID,fa为节点祖先,sit为当前节点到顶点的距离mod k { cntsub[x] = size[x][sit % k] = 1; ll i, j; for (auto a : G[x]) { if (a == fa)continue; dfs(a, x, sit + 1); for (i = 0; i &lt; k; i++) {//枚举到子节点的距离 for (j = 0; j &lt; k; j++) { ll t = (k - (i + j - 2 * (sit % k)) % k) % k; ans += t * size[x][i] * size[a][j]; } } for (i = 0; i &lt; k; i++)size[x][i] += size[a][i]; cntsub[x] += cntsub[a]; } ans += cntsub[x] * (n - cntsub[x]);//x与祖先连边被计算的次数 } int main() { int i, j, u, v; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, 0, 0); cout &lt;&lt; ans / k &lt;&lt; endl; return 0; } B.CodeForces - 2B求矩阵路径上数字的积末尾最少的0个数。那么其实就是统计路径上最少的2个数与5个数，取其中比较小的即可。有个问题就是路径中如果有0，那么就需要特判答案到底是1还是0了。路径输出的时候稍微要点小技巧，没了。 #include&lt;bits/stdc++.h&gt; using namespace std; int get2(int x) { int cnt=0; while(x&amp;&amp;x%2==0){ cnt++;x/=2; } return cnt; } int get5(int x) { int cnt=0; while(x&amp;&amp;x%5==0){ cnt++;x/=5; } return cnt; } int num[1005][1005]; typedef pair&lt;int,char&gt;P; P dp2[1005][1005],dp5[1005][1005]; int main() { int i,j,k,n; cin&gt;&gt;n; memset(dp2,0x3f, sizeof(dp2));memset(dp5,0x3f,sizeof(dp5)); int move1[2][2]={1,0,0,1}; bool haszero=false;int zerox,zeroy; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) { scanf(&quot;%d&quot;, &amp;num[i][j]); if(!num[i][j]){ haszero=true;zerox=i,zeroy=j; } } if(num[1][1]) { dp2[1][1].first = get2(num[1][1]), dp5[1][1].first = get5(num[1][1]); } else{ dp2[1][1].first=dp5[1][1].first=1; } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ //if(i==1&amp;&amp;j==1)continue; for(k=0;k&lt;2;k++){ int a=i+move1[k][0],b=j+move1[k][1]; if(num[a][b]==0){ dp2[a][b].first=0;dp5[a][b].first=0; } else { if (dp2[a][b].first &gt; dp2[i][j].first + get2(num[a][b])) { dp2[a][b].first = dp2[i][j].first + get2(num[a][b]); if (k)dp2[a][b].second = &apos;R&apos;; else dp2[a][b].second = &apos;D&apos;; } if (dp5[a][b].first &gt; dp5[i][j].first + get5(num[a][b])) { dp5[a][b].first = dp5[i][j].first + get5(num[a][b]); if (k)dp5[a][b].second = &apos;R&apos;; else dp5[a][b].second = &apos;D&apos;; } } } } int ans=1&lt;&lt;30; int sit=0; //cout&lt;&lt;dp2[n][n].first&lt;&lt;&apos; &apos;&lt;&lt;dp5[n][n].first&lt;&lt;endl; if(haszero&amp;&amp;dp2[n][n].first&gt;1&amp;&amp;dp5[n][n].first&gt;1){ ans=1;sit=1; } else{ if(dp2[n][n].first&gt;dp5[n][n].first){ ans=dp5[n][n].first;sit=3; } else{ ans=dp2[n][n].first;sit=2; } } cout&lt;&lt;ans&lt;&lt;endl; vector&lt;char&gt;way; if(sit==1){ for(i=1;i&lt;zerox;i++)way.push_back(&apos;D&apos;); for(j=1;j&lt;n;j++)way.push_back(&apos;R&apos;); for(i=zerox;i&lt;n;i++)way.push_back(&apos;D&apos;); } else if(sit==2){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp2[i][j].second); if(dp2[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } else if(sit==3){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp5[i][j].second); if(dp5[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } for(auto a:way) cout&lt;&lt;a; return 0; } C.CodeForces - 527A签到 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll ans=0; void cal(ll x,ll y) { if(!y)return; ans+=x/y;x%=y; cal(y,x); } int main() { ll a,b; cin&gt;&gt;a&gt;&gt;b; cal(a,b); cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.CodeForces - 785B主要考察英语阅读理解能力，注意先上哪个课程是不确定的。傻逼题* 2 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,ans,i,j,a,b,amin=0,amax=1&lt;&lt;30,bmin=0,bmax=1&lt;&lt;30; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); amin = max(amin, a); amax = min(amax, b); } cin&gt;&gt;m; for(i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); bmin = max(bmin, a); bmax = min(bmax, b); } ans=max(amin-bmax,bmin-amax); cout&lt;&lt;(ans&gt;=0?ans:0)&lt;&lt;endl; return 0; } F.CodeForces - 57C首先，注意到一点：每一个不下降数列反过来就是一个不上升数列，因此我们只要计算出不下降数列的个数，乘2，减去n（所有数字相同的数列个数），就是答案了。 然后，第一位肯定是要放一个数的，我们姑且不管。那么在后面的n-1个位置上，我们可以任意取若干个“上升点”，也就是这个点放的数比前面的数要来的大，相邻“上升点”之间的数字的值是相同的。在n-1个位置中选k个上升点，方案数是$C_{n-1}^{k}$,然后，选定k个上升点，那么我们这个数列中就需要k+1个不同的数（还记得第一位么？），会发现，任意选择1~n中的k+1个数，他都对应着唯一的一种排列方案，所以，总的答案就是$\sum_{i=0}^{n-1}C_{n-1}^{i}\times C_n^{i+1}$,算算组合数算算逆元就ok了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; const int maxn=1e5+10; ll c1[maxn],inv[maxn],jc[maxn],c2[maxn]; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int i,j,k,n; cin&gt;&gt;n; jc[1]=1;inv[1]=1,inv[0]=1; for(i=2;i&lt;=n;i++) jc[i]=jc[i-1]*i%mod,inv[i]=pow(jc[i],mod-2,mod); for(i=1;i&lt;=n;i++) { c1[i] = (jc[n - 1] * inv[i] % mod * inv[n - 1 - i]) % mod; c2[i] = (jc[n] * inv[i] % mod * inv[n - i]) % mod; } c1[0]=1;c2[0]=1; ll ans=0; for(i=0;i&lt;n;i++) ans=(ans+c1[i]*c2[i+1])%mod; ans=(ans+ans-n)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } I.HackerRank - game-with-cells傻逼题* 3 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; if(n&amp;1)n=n/2+1; else n&gt;&gt;=1; if(m&amp;1)m=m/2+1; else m&gt;&gt;=1; cout&lt;&lt;n*m&lt;&lt;endl; return 0; } J.CodeForces - 145C 给出一个长度为n的序列ai，问其长度为k的子序列中，同一个幸运数字至多出现一次的子序列个数，幸运数字即为全部由4和7组成的数字 假设有$res$个不同的幸运数字，有$sum$个非幸运数字，第$i$个幸运数字在原序列中出现了$num[i]$次，用$dp[i][j]$表示从前$i$个幸运数字中选$j$个的方案数，那么易得转移方程$dp[i][j]=dp[i−1][j]+num[i]⋅dp[i−1][j−1]$，之后枚举子序列中非幸运数字个数即可得到答案$ans=\sum_{i=0}^{min(k,sum)}C_{sum}^{i}\times dp[res][k-i]$。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+10; const int mod=1e9+7; ll fac[maxn],dp[3000][3000]; bool islucky(int v)//判断是否lucky number { while (v) { if (v % 10 != 4 &amp;&amp; v % 10 != 7) return false; v /= 10; } return true; } ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } ll C(ll v, ll u) { if (v &lt; u) return 0; ll x = (fac[u] * fac[v - u]) % mod; return (fac[v] * pow(x, mod - 2,mod)) % mod; } int main() { int i, j, n, k,sum=0;ll ans=0; cin&gt;&gt;n&gt;&gt;k; map&lt;int,int&gt;mp1; fac[0] = 1; for (i = 1; i &lt;= n; i++) fac[i] = (fac[i - 1] * i) % mod; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); if (islucky(j)) mp1[j]++;//统计幸运数个数 else sum++; } dp[0][0] = 1;i = 1; for (auto it = mp1.begin(); it != mp1.end(); it++, i++) for (j = 0; j &lt; i; j++) { dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod; dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j] * it-&gt;second) % mod; } int cnt = mp1.size(); for (i = 0; i &lt;= cnt &amp;&amp; i &lt;= k; i++) ans = (ans + (dp[cnt][i] * C(sum, k - i)) % mod) % mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } K.CodeForces - 691B难点在于如何找出所有对称的字符，傻逼题* 4 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(char x, char y) { if (x == &apos;A&apos; &amp;&amp; y == &apos;A&apos;||x == &apos;H&apos; &amp;&amp; y == &apos;H&apos;||x == &apos;I&apos; &amp;&amp; y == &apos;I&apos;||x == &apos;M&apos; &amp;&amp; y == &apos;M&apos;||x == &apos;O&apos; &amp;&amp; y == &apos;O&apos;) return true; if (x == &apos;T&apos; &amp;&amp; y == &apos;T&apos;||x == &apos;U&apos; &amp;&amp; y == &apos;U&apos;||x == &apos;V&apos; &amp;&amp; y == &apos;V&apos;||x == &apos;W&apos; &amp;&amp; y == &apos;W&apos;||x == &apos;X&apos; &amp;&amp; y == &apos;X&apos;) return true; if (x == &apos;Y&apos; &amp;&amp; y == &apos;Y&apos;||x == &apos;v&apos; &amp;&amp; y == &apos;v&apos;||x == &apos;w&apos; &amp;&amp; y == &apos;w&apos;||x == &apos;x&apos; &amp;&amp; y == &apos;x&apos;||x == &apos;o&apos; &amp;&amp; y == &apos;o&apos;) return true; if (x == &apos;p&apos; &amp;&amp; y == &apos;q&apos;||x == &apos;q&apos; &amp;&amp; y == &apos;p&apos;||x == &apos;b&apos; &amp;&amp; y == &apos;d&apos;||x==&apos;d&apos;&amp;&amp;y==&apos;b&apos;) return true; return false; } int main() { string str1,str2; cin&gt;&gt;str1;str2=str1; reverse(str2.begin(),str2.end()); for(int i=0;i&lt;str1.size();i++){ if(!check(str1[i],str2[i])){ cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Tarjan]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2FTarjan%2Fe6-a8-a1-e6-9d-bf-ef-bc-89tarjan%2F</url>
    <content type="text"><![CDATA[要注意的就是那些单独的点每个点都会被当做自身一个强联通分量，也就是有不少的强连通分量里面可能只有一个元素…… int dfn[105],low[105],scccnt=0,sccindex=0,belong[105]; bool instack[105]; stack&lt;int&gt;sta; vector&lt;int&gt;G[105]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i;//理论上用c++11的特性会比G[v].size()快一些; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v);//一定要注意这里并不是要把整个栈清空,只是要把属于当前联通分量的元素全部清空 } } 主函数中调用： int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ while(cin&gt;&gt;j&amp;&amp;j) G[i].push_back(j); } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小路径覆盖]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b7-af-e5-be-84-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[对于一个给定的有向无环图（DAG），求其最小路径覆盖。题目可参见洛谷P2764。 【问题分析】 有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 【建模方法】 构造二分图，把原图每个顶点i拆分成二分图X，Y集合中的两个顶点Xi和Yi。对于原图中存在的每条边(i,j)，在二分图中连接边(Xi,Yj)。然后把二分图最大匹配模型转化为网络流模型，求网络最大流。 最小路径覆盖的条数，就是原图顶点数，减去二分图最大匹配数。沿着匹配边查找，就是一个路径上的点，输出所有路径即可。 【建模分析】 对于一个路径覆盖，有如下性质： 1、每个顶点属于且只属于一个路径。 2、路径上除终点外，从每个顶点出发只有一条边指向路径上的另一顶点。所以我们可以把每个顶点理解成两个顶点，一个是出发，一个是目标，建立二分图模型。该二分图的任何一个匹配方案，都对应了一个路径覆盖方案。如果匹配数为0，那么显然路径数=顶点数。每增加一条匹配边，那么路径覆盖数就减少一个，所以路径数=顶点数 - 匹配数。要想使路径数最少，则应最大化匹配数，所以要求二分图的最大匹配。注意，此建模方法求最小路径覆盖仅适用于有向无环图，如果有环或是无向图，那么有可能求出的一些环覆盖，而不是路径覆盖。 洛谷题目参考代码： // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; struct edge { int to, cap, rev; }; vector&lt;edge&gt;G[500]; int level[500], iter[500]; int n, m; void addedge(int from, int to, int cap) { edge e; e.to = to; e.cap = cap; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.rev = G[from].size() - 1;//一定要小心反向边的cap为0！！！ G[to].push_back(e); } void bfs(int s) { memset(level, -1, sizeof(level));//每次bfs的时候构图都不同，要memset queue&lt;int&gt;que; level[s] = 0; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;level[e.to] &lt; 0) { level[e.to] = level[t] + 1; que.push(e.to); } } } } int dfs(int v, int t, int f) { if (v == t) return f; for (int &amp;i = iter[v]; i &lt; G[v].size(); i++) {//因为每次dfs的时候如果找到解就return了，所以有必要记录上次这个点搜到哪了 edge &amp;e = G[v][i]; if (e.cap&amp;&amp;level[e.to] &gt; level[v]) { int d = dfs(e.to, t, min(f, e.cap)); if (d) { e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } return 0; } int maxflow(int s, int t) { int flow = 0; for (;;) { bfs(s); if (level[t] &lt; 0)//说明此时已经不存在没有搜过的路了 return flow; memset(iter, 0, sizeof(iter)); int f; while (f = dfs(s, t, 1 &lt;&lt; 30))//要搜完当期状况下的所有可能 flow += f; } } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m ; for (i = 1; i &lt;= m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); addedge(a, b+150, 1); } for (i = 1; i &lt;= n; i++) { addedge(0, i, 1); addedge(i+150, 400, 1); } int ans = n - maxflow(0, 400); bool vis[500]; memset(vis, 0, sizeof(vis)); for (i = 1; i &lt;= n; i++) { if (!vis[i]) { cout &lt;&lt; i; int k = i; for (;;) { bool find = false; for (j = 0; j &lt; G[k].size(); j++) { if (G[k][j].cap == 0&amp;&amp;G[k][j].to&gt;150) { cout &lt;&lt; &quot; &quot; &lt;&lt; G[k][j].to-150; k = G[k][j].to - 150; vis[k] = true; find = true; break; } } if (!find)break; } cout &lt;&lt; endl; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小生成树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[Kruskal最重要的还是记得并查集要初始化！！ // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=1e6,M=1e6; int par[N]; struct edge{ int from,to,len; bool operator&lt;(const edge&amp;v)const{ return len&lt;v.len; } }G[M]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } bool unite(int x,int y) { x=find(x);y=find(y); if(x==y)return false; par[x]=y;return true; } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)par[i]=i; for(i=1;i&lt;=m;i++){ cin&gt;&gt;G[i].from&gt;&gt;G[i].to&gt;&gt;G[i].len; } sort(G+1,G+1+m); int cnt=0,ans=0; for(i=1;i&lt;=m;i++){ if(unite(G[i].from,G[i].to)) cnt++,ans+=G[i].len; if(cnt==n-1)break; } if(cnt&lt;n-1)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; return 0; } Prim算法跟Dijkstra很像 ，但是要特别注意两点： 1.最好使用一个额外的数组来保证每个点只被访问一次，否则的话应该保证在35行处使用e.dis&gt;=dis[e.num]而不仅是&gt;，否则会造成一些相等的额外相加。 2.40行的地方要注意与Dijkstra的区别！！不是加而是直接换！！！ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); G[b].push_back(edge{a,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[1]=0; priority_queue&lt;d&gt;que;que.push(d{1,0}); int ans=0; while(!que.empty()){ d t=que.top();que.pop(); if(vis[t.num])continue;//如果不用额外数组这里要注意 ans+=t.dis;vis[t.num]=true; for(i=0;i&lt;G[t.num].size();i++){ edge e=G[t.num][i]; if(dis[e.to]&gt;e.cost){ dis[e.to]=e.cost;//注意这里与Dijkstra的区别 que.push(d{e.to,dis[e.to]}); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>最小生成树</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）SPFA]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89spfa%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; bool inque[maxn]; int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; int dis[maxn]; for(i=1;i&lt;=n;i++)dis[i]=(1&lt;&lt;31)-1; dis[s]=0; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } queue&lt;int&gt;que;que.push(s);//inque[s]=true; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Dijkstra]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89dijkstra%2F</url>
    <content type="text"><![CDATA[自定义结构体#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{//记录各种被松弛后的点 int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[s]=0; priority_queue&lt;d&gt;que; que.push(d{s,0}); while(!que.empty()){ d e=que.top();que.pop(); if(e.dis&gt;dis[e.num])continue;//这里也可以利用一个额外的数组来保证每个点只被访 //问一次，或者说最短距离已经确定的点不再被更改 for(int i=0;i&lt;G[e.num].size();i++){ edge eg=G[e.num][i]; if(dis[eg.to]&gt;dis[e.num]+eg.cost){ dis[eg.to]=dis[e.num]+eg.cost; que.push(d{eg.to,dis[eg.to]}); } } } return 0; } using pair#include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; using namespace std; const int maxn=1e5+5; typedef struct { int to, cost; }Edge; vector&lt;Edge&gt;edge[maxn]; typedef pair&lt;int, int&gt;P; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;q;//从小到大的优先队列 int book[maxn], dis[maxn]; int main(void) { int n, m, s, i, j; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); fill(dis, dis + n+1, 2147483647); dis[s] = 0; for (i = 1; i &lt;= m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge temp; temp.to = b; temp.cost = c; edge[a].push_back(temp); } P p; p.first = 0; p.second = s; q.push(p); while (!q.empty()) { P p = q.top(); q.pop(); if (book[p.second] == 1) continue; book[p.second] = 1; for (i = 0; i &lt; edge[p.second].size(); i++) { Edge temp = edge[p.second][i]; if (dis[temp.to] &gt; dis[p.second] + temp.cost) { dis[temp.to] = dis[p.second] + temp.cost; P p1; p1.first = dis[temp.to]; p1.second = temp.to; q.push(p1); } } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）Floyd算法（多源最短路）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89floyd-e7-ae-97-e6-b3-95-ef-bc-88-e5-a4-9a-e6-ba-90-e6-9c-80-e7-9f-ad-e8-b7-af-ef-bc-89%2F</url>
    <content type="text"><![CDATA[需要注意的就是因为每次是拿一个点出来考虑能否把别的路变短，所以k一定是最外层循环。以及要记得初始化为无穷大或无穷小。 可以通过检查是否有dis[i][i]&lt;0来判定是否有负环存在 int dis[105][105]; memset(dis,0x7f,sizeof(dis)); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;dis[i][j]; for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）并查集]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-b9-b6-e6-9f-a5-e9-9b-86%2F</url>
    <content type="text"><![CDATA[两件事：记得初始化par，以及，路径压缩别写错了… int par[1005];//记得初始化！ int find(int x) { return par[x]==x?x:par[x]=find(par[x]);//后面这一块不要漏了par[x],否则就是不带路径压缩! } bool unite(int x,int y) { x=find(x),y=find(y); if(x==y)return false; par[x]=y; return true; } 按秩合并： int find(int x) { if (x == par[x]) return x; else return par[x] = find(par[x]);//后面这一块不要漏了par[x]!!!否则就是不带路径压缩(有时候有用） } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) { par[x] = y; } else { par[y] = x; if (rank[x] == rank[y]) rank[x]++; } } 一定要加上： for(i=1;i&lt;=n;i++){ par[i]=i; }!!!!!!]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）SG函数小结]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89sg-e5-87-bd-e6-95-b0-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[说是小结，其实我并没有怎么弄懂QAQ，简单写写概念跟板子吧… Sprague-Grundy函数给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有Impartial Combinatorial Games的抽象模型。也就是说，任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。 基本概念下面我们就在有向无环图的顶点上定义Sprague-Garundy函数。 首先定义$mex$(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如$mex[0,1,2,4]=3,mex[2,3,5]=0,mex[]=0$。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数$g$如下：$g(x)=mex[ g(y) | y是x的后继 ]$。 SG函数的性质首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。 对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。 对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。 P 以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了。 我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。 再考虑一个性质：任何一个ICG都可以抽象成一个有向图游戏。所以“SG函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每个ICG的每个position定义SG值，也可以定义n个ICG的和。所以说当我们面对由n个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个局面的SG值的方法，就可以把这些SG值全部看成Nim的石子堆，然后依照找Nim的必胜策略的方法来找这个游戏的必胜策略了！（Nim其实就是n个从一堆中拿石子的游戏求SG的变型，总SG=n个sg的异或）。 模板1.把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的异或。即$sg(G)=sg(G1)\oplus sg(G2)\oplus …\oplus sg(Gn)$。 2.分别考虑没一个子游戏，计算其SG值。1.可选步数为1~m的连续整数，直接取模即可，$SG(x) = x \ mod\ (m+1)$; 2.可选步数为任意步，$SG(x) = x$; 3.可选步数为一系列不连续的数，用模板计算。 模板1：打表 #include&lt;bits/stdc++.h&gt; using namespace std; //f[]：可以取走的石子个数 //sg[]:0~n的SG函数值 //Mex[]:mex{} int f[N],sg[N],Mex[N]; void getSG(int n) { int i, j; memset(sg, 0, sizeof(sg)); for (i = 1; i &lt;= n; i++) { memset(Mex, 0, sizeof(Mex)); for (j = 1; f[j] &lt;= i; j++) Mex[sg[i - f[j]]] = 1; for (j = 0; j &lt;= n; j++) //求mes{}中未出现的最小的非负整数 { if (Mex[j] == 0) { sg[i] = j; break; } } } } 模板2：dfs //注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍 //n是集合s的大小 S[i]是定义的特殊取法规则的数组 int s[110],sg[10010],n; int SG_dfs(int x) { int i; if(sg[x]!=-1) return sg[x]; bool vis[110];//bool数组一定要放在里面 memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) { if(x&gt;=s[i]) { SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; } } int e; for(i=0;;i++) if(!vis[i]) { e=i; break; } return sg[x]=e; } 一般DFS只在打表解决不了的情况下用，首选打表预处理。 还有一种dfs，题目给出的不是移动次数，而是可以移动的操作，类似于给定一幅有向图，知道下一步有哪些操作是可选的（参见HDU1524） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[1005]; int sg[1005]; int dfs(int x) { if(sg[x]!=-1) return sg[x]; bool vis[1005]={false}; for(int i=0;i&lt;G[x].size();i++){ vis[dfs(G[x][i])]=true; } for(int i=0;;i++) if(!vis[i]) return sg[x]=i; } int main() { int n,i,j,k,x,m; while(cin&gt;&gt;n){ for(i=0;i&lt;=1000;i++)G[i].clear(); memset(sg,-1,sizeof(sg)); for(i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;x); while(x--){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);//加边,下一步可以做的操作 } } while(scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m){ int ans=0; for(i=0;i&lt;m;i++){ scanf(&quot;%d&quot;,&amp;j); if(sg[j]!=-1) ans^=sg[j]; else ans^=dfs(j); } if(ans)puts(&quot;WIN&quot;); else puts(&quot;LOSE&quot;); } } return 0; } 3.计算$sg(G)=sg(G1)\oplus sg(G2)\oplus …\oplus sg(Gn)$，若$sg(G)=0$,即P-Position,即先手比败。]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #450 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-450-div-2%2F</url>
    <content type="text"><![CDATA[A.弱智题 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x,y,cnt[2]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&lt;0)cnt[0]++; else cnt[1]++; } if(cnt[0]&lt;=1||cnt[1]&lt;=1){ puts(&quot;Yes&quot;); } else puts(&quot;No&quot;); return 0; } B.首先要知道一个结论：对于$a/b$,他的小数部分的循环节长度不会超过$b$，所以我们只要检查小数点后的最多$b$位就可以知道$c$是否有出现过了。然后关键就是如何求小数点后的位数了。这个可以用长除法来做，具体思想其实就是不断把被除数乘10然后除以除数获得下一位小数位（相当于不断地将小数点右移一位），写写就明白了。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c,i,j,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=1;i&lt;=b;i++){ if(a*10/b==c){ cout&lt;&lt;i&lt;&lt;endl;return 0; } a=a*10%b; } cout&lt;&lt;-1&lt;&lt;endl; return 0; } C.其实很容易想到一个贪心的想法，就是从前往后扫一遍，对于每个数，如果前面恰好有一个数大于等于当前数，那么那个数的“删除值”就应该+1，然后找出”删除值“最大的数即可。但是还有一个问题就是每个数同时可能本身也是一个”record”，所以对于每个数，如果他是”record”，那么他的删除值就是1，然后每次找到一个后面的数要删除这个数，那么他的删除值就-1，最后找出删除值最小的数即可（初始删除值都为0） #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k,maxn=0,ans=0,premaxn=0; cin&gt;&gt;n; int num[100005],pos[100005]={0}; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]&gt;maxn){ pos[i]=1; premaxn=maxn;maxn=num[i];k=i; } else if(num[i]&gt;premaxn){ pos[k]--;premaxn=num[i]; } } int minn=2; for(i=1;i&lt;=n;i++){ if(pos[i]&lt;minn){ ans=num[i];minn=pos[i]; } else if(pos[i]==minn){ ans=min(ans,num[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.首先，如果x不能整除y，那么就可以直接滚蛋了。 令$f(t)$表示若干个数和为$t$，$gcd$为1。那么答案就是$f(\frac{y}{x})$. 令$g(t)$表示若干个数和为$t$,那么显然有$g(t)=2^{t-1}$:想象一下，把t分成t个1，那么相邻的1之间分开与否都是不同的（本题的序列是有序的）。 注意到有$g(t)=\sum_{i=1}^{t_i}f(\frac{t}{t_i})$($t_i$是$t$的约数)， 所以有$f(t)=g(t)-\sum_{i=2}^{sz}f(\frac{t}{t_i})$. 于是先把y除以x，然后求出y的所有约数，从小到大排序后，从大到小枚举每个约数，对于每个约数，我们可以先算出他的$g(i)$,然后枚举所有比他大的约数，如果某个约数能整除他，那么那个约数对应的$f(i)$就应该被减去。最后输出$f(1)$即可。以及，注意取模的问题，要用快速幂&amp;小心负数。 #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; typedef long long ll; ll mod_pow(ll x,ll y) { ll res=1; while(y){ if(y&amp;1){ res=res*x%mod; } y&gt;&gt;=1;x=x*x%mod; } return res; } ll f[100000]; int main() { int x,y,i,j,k; cin&gt;&gt;x&gt;&gt;y; if(y%x){ puts(&quot;0&quot;);return 0; } y/=x;vector&lt;int&gt;ys; for(i=1;i*i&lt;=y;i++){ if(y%i==0){ ys.push_back(i); if(i*i!=y) ys.push_back(y/i); } } sort(ys.begin(),ys.end()); for(i=ys.size()-1;~i;i--){ f[i]=mod_pow(2,y/ys[i]-1); for(j=ys.size()-1;j&gt;i;j--) if(ys[j]%ys[i]==0) f[i]=(f[i]-f[j]+mod)%mod; } cout&lt;&lt;(f[0]+mod)%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #502（Div. 1 + Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-502-ef-bc-88div-1-div-2%2F</url>
    <content type="text"><![CDATA[A.签到 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct mark{ int id,sum; bool operator&lt;(const mark&amp;v)const{ if(sum==v.sum) return id&lt;v.id; return sum&gt;v.sum; } }G[1005]; int main() { int n,i,j,k,a,b,c,d; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;G[i].sum+=a+b+c+d;G[i].id=i; } sort(G+1,G+1+n); for(i=1;i&lt;=n;i++){ if(G[i].id==1){ cout&lt;&lt;i&lt;&lt;endl;return 0; } } } B.首先，可以发现一个事实：第二个串的某个位置如果是1，那么第一个串是什么是不重要的，因为换完还是1.否则，第一个串如果是0，我们就研究有多少个1可以换。但是这样就会带来一个重复的问题，对此，我们可以做一个预处理，对于每个1，相当于要换0，而相应前面的0的位置必然要换1，那么我们就可以统计一下这个重复的问题。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string str1,str2;int n,i,j,k,cnt[2]={0},cnt1[2]={0}; cin&gt;&gt;n&gt;&gt;str1&gt;&gt;str2; for(auto a:str1)cnt[a-&apos;0&apos;]++; long long ans=0; for(i=0;i&lt;n;i++){ if(str2[i]==&apos;0&apos;){ if(str1[i]==&apos;1&apos;){ ans+=cnt[0];ans-=cnt1[1];cnt1[0]++; } else{ ans+=cnt[1];ans-=cnt1[0];cnt1[1]++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C.不太会证明…利用了一点类似分块的思想，反正平方分割肯定是对的… #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,pos; cin&gt;&gt;n;pos=n; int len=sqrt(n); while(pos&gt;=len){ for(i=pos-len+1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; pos-=len; } for(i=1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; } D.比赛的时候总觉得是建树，然后就t得怀疑人生了… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; struct node{ int son[2]; int cnt=0; bool tag; }ch[1&lt;&lt;14];//数组大小由所要插入字符的总长度决定 void insert(char*str,int n) { int now=0; ch[now].tag=true; for(int i=0;i&lt;n;i++){ int c=str[i]-&apos;0&apos;; now=ch[now].son[c]; ch[now].tag=true; } ch[now].cnt++; ch[now].tag=true; } int w[15],k;int cnt,n; void query(string str,int id,int quan,int ceng) { if(!ch[id].tag)return; if(ceng) { if ((id &amp; 1) != str[ceng - 1] - &apos;0&apos;) quan += w[ceng]; if (quan &gt; k)return; if (ceng == n) { cnt += ch[id].cnt; return; } } query(str,id&lt;&lt;1|1,quan,ceng+1); query(str,(id&lt;&lt;1)+2,quan,ceng+1); } int main() { int i,j; for(i=0;i&lt;(1&lt;&lt;12);i++){ //ch[i].cnt++; ch[i].son[0]=i&lt;&lt;1|1;ch[i].son[1]=(i&lt;&lt;1)+2; } int m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;=m;i++){ char str[15];scanf(&quot;%s&quot;,str); insert(str,n); } while(q--){ string str;cin&gt;&gt;str&gt;&gt;k; cnt=0; query(str,0,0,0); printf(&quot;%d\n&quot;,cnt); } return 0; } 正解是利用类似bitset的思想，因为两串相与只可能是0~2^12，所以我们可以预处理所有的情况，把他们转10进制表示，然后查询的时候就是$O(1)$的了. 有一点要注意的就是因为两个串都是0或者都是1 的时候权值都是有效的，为了方便统计，我们可以把set里面的串全部取反，然后查询的时候两个串异或一下，是1的位置就是权值有效的位置了。ans[i][j]代表模式串为i的时候两串相与为j的情况数。 以及，string会tle #include&lt;bits/stdc++.h&gt; using namespace std; int w[5000],s[5000],ans[5000][105],f[5000];//s是将字符串转化为数字串,ans存答案,f预处理 int main() { int n,m,q; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;w[n - i]);//注意这里层级要倒着来,不然没法从前往后匹配 for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j))//f[i]代表两个数相与等于i时的权值 f[i] += w[j]; for (int i = 1; i &lt;= m; i++) { char ss[15];scanf(&quot;%s&quot;,ss); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + 1 - (ss[j] - &apos;0&apos;);//注意这里是与原数取反的!!! //a=a*2+(ss[j]-&apos;0&apos;); s[a]++;//统计串个数 } for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; (1 &lt;&lt; n); j++) if (f[i ^ j] &lt;= 100)//题意:k&lt;=100才有效 ans[i][f[i ^ j]] += s[j];//ans[i][j]统计模式串为i时相与答案为j的个数 //ans[i][f[i&amp;j]]+=s[j]; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 1; j &lt;= 100; j++) ans[i][j] += ans[i][j - 1];//因为&lt;=j都可以,所以,要加成前缀和 for (int i = 1; i &lt;= q; i++) { char ss[15];scanf(&quot;%s&quot;,ss);int k;scanf(&quot;%d&quot;,&amp;k); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + (ss[j] - &apos;0&apos;); printf(&quot;%d\n&quot;, ans[a][k]); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training 网络流]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F%E5%9B%BE%E8%AE%BA%2F2018-bupt-summer-training-e7-bd-91-e7-bb-9c-e6-b5-81%2F</url>
    <content type="text"><![CDATA[A - Drainage Ditches POJ - 1273板子题，没什么好说的 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[210]; int level[205],iter[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ for(i=1;i&lt;=200;i++)G[i].clear(); for(i=1;i&lt;=n;i++){ int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);addedge(a,b,c); } cout&lt;&lt;maxflow(1,m)&lt;&lt;endl; } return 0; } C - Reactor Cooling ZOJ - 2314无源汇可行流模板题 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//记录边的id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//存答案 for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//反向边或者连向附加汇点的边无视 as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//这条边的反向边的容量+这条边的下界 } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } D - Number HYSBZ - 3275注意题目条件是同时满足两个条件的数才不能一起选。对于每个点a，我们拆成$a_x$和$a_y$,源点连接$a_x$,容量为数值，$a_y$连接汇点，容量为数值。如果两个数a，b不能同时选，那么我们就将$a_x$连接$b_y$,$b_x$ 连接$a_y$,容量为INF。那么答案就是所有数的和-maxflow/2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//记录边的id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//存答案 for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//反向边或者连向附加汇点的边无视 as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//这条边的反向边的容量+这条边的下界 } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } E - 软件开发 HYSBZ - 1221非常类似餐巾计划问题。唯一的不同就是洗的时间，第i天的毛巾在i+1天才开始洗，所以在第i+k+1天才洗好，其他就没什么区别了。 关于构图： 这是一道最小费用（费用指单价）最大流的题目。 首先，我们拆点，将一天拆成晚上和早上，每天晚上会受到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从原点获得），每天早上又有干净的餐巾（来源：购买、快洗店、慢洗店）。（本题中对应两种清洗方式，其实就是换了个名字而已） 1.从原点向每一天晚上连一条流量为当天所用餐巾x，费用为0的边，表示每天晚上从起点获得x条脏餐巾。 2.从每一天早上向汇点连一条流量为当天所用餐巾x，费用为0的边，每天白天,表示向汇点提供x条干净的餐巾,流满时表示第i天的餐巾够用 。 3.从每一天晚上向第二天晚上连一条流量为INF，费用为0的边，表示每天晚上可以将脏餐巾留到第二天晚上（注意不是早上，因为脏餐巾在早上不可以使用）。 4.从每一天晚上向这一天+快洗所用天数t1的那一天早上连一条流量为INF，费用为快洗所用钱数的边，表示每天晚上可以送去快洗部,在地i+t1天早上收到餐巾 。 5.同理，从每一天晚上向这一天+慢洗所用天数t2的那一天早上连一条流量为INF，费用为慢洗所用钱数的边，表示每天晚上可以送去慢洗部,在地i+t2天早上收到餐巾 。 6.从起点向每一天早上连一条流量为INF，费用为购买餐巾所用钱数的边，表示每天早上可以购买餐巾 。 注意，以上6点需要建反向边！3~6点需要做判断（即连向的边必须&lt;=n） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[5010]; int dis[5010],prevv[5010],preve[5010],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边 bool inque[5010]; const int INF=1&lt;&lt;30; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f) return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int n,a,b,f,fa,fb,i,j,k; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;fa&gt;&gt;fb; int peo[1005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;peo[i]); for(i=1;i&lt;=n;i++) add(0,i,peo[i],0); for(i=1;i&lt;=n;i++) add(i+n,2005,peo[i],0); for(i=1;i&lt;n;i++) add(i,i+1,INF,0); for(i=1;i+a+1&lt;=n;i++) add(i,i+a+n+1,INF,fa); for(i=1;i+b+1&lt;=n;i++) add(i,i+b+n+1,INF,fb); for(i=1;i&lt;=n;i++) add(0,i+n,INF,f); mincostmaxflow(0,2005); cout&lt;&lt;cost&lt;&lt;endl; return 0; } F - 修车 HYSBZ - 1070题目的难点在于怎么去计算总的等待时间。方法是把修车人员拆成n个点，每个人的第i个点分别表示这个人在倒数第i个对某辆车进行修理，那么等待修的车连向这个点的边就应该是 修车时间* i，因为还有i个人在等这个修车师傅。然后跑最小费用流即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int m,n,i,j,k,a,b; cin&gt;&gt;m&gt;&gt;n; for(i=1;i&lt;=n;i++) add(0,n*m+i,1,0); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ cin&gt;&gt;a; for(k=1;k&lt;=n;k++){ add(n*m+i,(j-1)*n+k,1,a*k); } } for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) add((i-1)*n+j,900,1,0); mincostmaxflow(0,900); printf(&quot;%.2f\n&quot;,(double)cost/n); return 0; } G - Firing POJ - 2987最大权闭合图的模板题 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } long long maxflow(int s,int t){ long long flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; } H - Being a Hero HDU - 3251添加汇点T，原图上的单向边依次建边，容量为花费，允许选择的f个点向汇点T连边，容量为点上权值。跑一遍最小割得到花费值cost，然后用总的能获得利润（就是f个点的权值之和）减去cost 从源点S在残留网络中dfs遍历能走到的点，那么这些点就是属于S集，其他剩下的点就属于T集了， 然后判断边的两个点所属的集合，如果属于不同的集合那么这条边就是割边。 对于原图上的边如果被割到，那么这条边就是要破坏的，需要特别注意的是一定要标记每条边是不是原图中的边，否则很可能反向边会被误判为割边！！！ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,rev,id; bool iscor; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap,int id) { G[from].push_back(edge{to,cap,(int)G[to].size(),id,true}); G[to].push_back(edge{from,0,(int)G[from].size()-1,id,false});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[1005]; void dfs(int x) { vis[x]=true; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]){ dfs(G[x][i].to); } } } int main() { int t,i,j,k,n,m,f; cin&gt;&gt;t;int case1=0; while(t--){ case1++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;f; for(i=1;i&lt;=1001;i++)G[i].clear(); //int ava[1005]={0}; for(i=1;i&lt;=m;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w,i);//连边 } long long sum=0; while(f--){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w);sum+=w;//ava[u]=1; addedge(u,1001,w,0);//1001为汇点 } printf(&quot;Case %d: &quot;,case1); cout&lt;&lt;sum-maxflow(1,1001)&lt;&lt;endl; memset(vis,0,sizeof(vis)); dfs(1); vector&lt;int&gt;road;//破坏的边 for(i=1;i&lt;=n;i++){ for(j=0;j&lt;G[i].size();j++){ edge e=G[i][j]; if(vis[i]&amp;&amp;!vis[e.to]&amp;&amp;e.id&amp;&amp;e.iscor){ road.push_back(e.id); } } } cout&lt;&lt;road.size(); //sort(road.begin(),road.end()); for(i=0;i&lt;road.size();i++) cout&lt;&lt;&apos; &apos;&lt;&lt;road[i]; cout&lt;&lt;endl; } return 0; } I - 志愿者招募 HYSBZ - 1061源点连第一天，最后一天（n+1）连汇点，容量为INF费用为0 这样跑网络流是沿时间流的（就是依次解决每一天的问题） 然后每一天向后一天连一条容量为INF-a[i]，费用为0的边（这其实是本题精髓） 为什么容量为INF-a[i]？这就相当于少了a[i]，得用带权边也就是招来的志愿者补全INF 这就是志愿者连续干时沿这条边跑，因为连续干不花钱，所以优先选这种边 然后将每一类志愿者s[i]与t[i]+1连一条容量为INF花费为c[i]的边，当连续干的人不够时，就得充钱使劲往里塞人，补全INF。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int INF = (1 &lt;&lt; 31) - 1; struct edge { int to, cap, cost, rev; }; vector&lt;edge&gt;G[2010]; int dis[2010], prevv[2010], preve[2010], n, m, flow = 0, cost = 0; bool inque[2010]; void add(int from, int to, int cap, int cost) { edge e; e.to = to; e.cap = cap; e.cost = cost; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.cost = -cost; e.rev = G[from].size() - 1;//-cost! G[to].push_back(e); } bool Spfa(int s, int t) { fill(dis, dis + 2000, 1 &lt;&lt; 30); memset(inque, 0, sizeof(inque)); queue&lt;int&gt;que; dis[s] = 0; inque[s] = true; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); inque[t] = false; for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;dis[e.to] &gt; dis[t] + e.cost) { dis[e.to] = dis[t] + e.cost; prevv[e.to] = t; preve[e.to] = i;//一个边一个点不要混淆！ if (!inque[e.to]) { que.push(e.to); inque[e.to] = true; } } } } if (dis[t] == 1 &lt;&lt; 30)//如果已经无法增广，返回 return false; int d = 1 &lt;&lt; 30; for (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);//此次可增广容量是全路径中容量最小的那个 flow += d; cost += d * dis[t];//dis是路径中单位费用和 for (int v = t; v != s; v = prevv[v]) {//更改容量 edge &amp;e = G[prevv[v]][preve[v]]; e.cap -= d; G[v][e.rev].cap += d;//v或者e.to都可以 } return true; } void mincostmaxflow(int s, int t) { while (Spfa(s, t)&amp;&amp;flow&lt;INF); } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m; add(0, 1, INF, 0); add(n + 1, 1500, INF, 0); for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); add(i, i + 1, INF - j, 0); } for (i = 1; i &lt;= m; i++) { int s, t, c; scanf(&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;c); add(s, t + 1, INF, c); } mincostmaxflow(0, 1500); cout &lt;&lt; cost &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）有上下界的网络流 总结]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-9c-89-e4-b8-8a-e4-b8-8b-e7-95-8c-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b5-81-e5-81-9a-e6-b3-95-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[无源汇可行流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 （上面在连每一条边的时候建一个cur数组记一下输入输出即可） 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) ，同时期望的流量值sum+=d（i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) 求解方法 在新图上跑ss到tt的最大流 若新图满流（流量等于sum），那么一定存在一种可行流 此时，原图中每一条边的流量应为新图中对应的边的流量+这条边的流量下界 EX：LOJ115 这是一道模板题。 n个点，m条边，每条边 e有一个流量下界 $lower(e) $ 和流量上界 $upper(e)$，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[310]; int level[305],iter[305],cur[305],lower[30500]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,flow; bool operator&lt;(const ans&amp;a)const{ return id&lt;a.id; } }; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int s,t,l,u; scanf(&quot;%d%d%d%d&quot;,&amp;s,&amp;t,&amp;lower[i],&amp;u); cur[s]-=lower[i];cur[t]+=lower[i]; addedge(s,t,u-lower[i]);G[s].back().id=i; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]); sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,250,-cur[i]); } } int flow=maxflow(0,250); if(flow!=sum){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return 0; } vector&lt;ans&gt;as; for(i=1;i&lt;=n;i++){ for(auto a:G[i]){ if(!a.id)continue; as.push_back(ans{a.id,lower[a.id]+G[a.to][a.rev].cap}); } } sort(as.begin(),as.end()); cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(auto a:as){ cout&lt;&lt;a.flow&lt;&lt;endl; } return 0; } 有源汇可行流建图方法在原图中添加一条边t-&gt;s，流量为inf 即让源点和汇点也满足流量平衡条件 这样就改造成了无源汇的网络流图，其余建图方法与无源汇可行流相同。 有源汇有上下界最大流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) （以上与无源汇可行流相同） 在原图中添加一条边t-&gt;s，流量为inf 即让源点和汇点也满足流量平衡条件 这样就改造成了无源汇的网络流图 （以上与有源汇可行流相同） 在新图上跑ss到tt的最大流 若新图满流，那么一定存在一种可行流 记此时$∑f(s,i)=sum1$ ，即此时t-&gt;s的最大流，也就是求反向边s-&gt;t的流量 将t-&gt;s这条边拆掉，在新图上跑s到t的最大流 记此时$∑f(s,i)=sum2 $，即maxflow（s，t） 最终答案即为sum1+sum2 EX:LOJ116 这是一道模板题。 n个点，m条边，每条边 e有一个流量下界$ lower(e) $和流量上界 $upper(e) $，给定源点 s与汇点 t，求源点到汇点的最大流。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; bool tag; }; vector&lt;edge&gt;G[410]; int level[405],iter[405],cur[405],lower[10005]; void addedge(int from,int to,int cap,int s) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! if(from==s)G[from].back().tag=true; } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,t,up; scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;t,&amp;lower[i],&amp;up); addedge(from,t,up-lower[i],s);cur[from]-=lower[i];cur[t]+=lower[i]; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i],s);sum+=cur[i]; } else{ addedge(i,250,-cur[i],s); } } addedge(t,s,(1&lt;&lt;31)-1,s); int flow=maxflow(0,250); if(sum!=flow){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } int ans=G[s].back().cap; G[s].pop_back();G[t].pop_back(); ans+=maxflow(s,t); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 有源汇有上下界最小流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) （以上与无源汇可行流相同) 求res=ss-&gt;tt最大流 连边t-&gt;s,inf 求res+=ss-&gt;tt最大流 如果res！=sum也就是期望中的满流，那么就没有可行解。 需要格外注意最小流判断是否有可行解的位置与时机与另外几种上下界网络流的不同！！！ 否则，输出G[s].back().cap也就是从t到s inf边的实际流量，即为所求。 EX:LOJ117 n 个点，m条边，每条边 e有一个流量下界 $lower(e) $和流量上界 $upper(e)$，给定源点 s与汇点 t，求源点到汇点的最小流。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; struct edge{ int to;ll cap;int rev; }; vector&lt;edge&gt;G[50210]; int level[50205],iter[50205],low[125050];ll cur[50205]; void addedge(int from,int to,ll cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } ll dfs(int v,int t,ll f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ ll d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } ll maxflow(int s,int t){ ll flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); ll f; while(f=dfs(s,t,0x7f7f7f7f7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,to,up;scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;to,&amp;low[i],&amp;up); cur[from]-=low[i];cur[to]+=low[i];addedge(from,to,up-low[i]); } ll sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]);sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,50050,-cur[i]); } } ll flow=maxflow(0,50050); addedge(t,s,(1LL&lt;&lt;63)-1); flow+=maxflow(0,50050); if(flow!=sum){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } cout&lt;&lt;G[s].back().cap&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #452 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-452-div-2%2F</url>
    <content type="text"><![CDATA[A.#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,cnt[3]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);cnt[j]++; } //cout&lt;&lt;min(cnt[1],cnt[2])&lt;&lt;endl; if(cnt[1]&lt;=cnt[2]){ cout&lt;&lt;cnt[1]&lt;&lt;endl; } else{ if(cnt[1]-cnt[2]&lt;3) cout&lt;&lt;cnt[2]&lt;&lt;endl; else cout&lt;&lt;cnt[2]+(cnt[1]-cnt[2])/3&lt;&lt;endl; } return 0; } B.就是打表暴力 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int init[15]={31,31,28,31,30,31,30,31,31,30,31,30,31},days[5][50]; int i,j,n,tar[30],k; for(i=1;i&lt;=4;i++) for(j=1;j&lt;=36;j++){ days[i][j]=init[j%12]; } days[1][2]=29;days[2][14]=29;days[3][26]=29; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;tar[i]); bool isok=false; for(i=1;i&lt;=4;i++){ for(j=1;j&lt;=36-n+1;j++){ for(k=1;k&lt;=n;k++){ if(tar[k]!=days[i][j+k-1]) break; } if(k&gt;n){ isok=true;break; } } } if(isok){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } C.如果数字不是1~n的话似乎是一个np问题…当然这里是连续的，因此其实是有规律可循的。讨论n模4的余数，然后就会发现当余数为0或2的时候都是可以构造出来差为0的，其他就只能差为1了。 构造房主要思想就是首位配对，因为这样配出来的每对的和都是相等的。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; vector&lt;int&gt;ans; cin&gt;&gt;n; int y=n%4; if(y==0){ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; } else if(y==1){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2+1&lt;&lt;&apos; &apos;&lt;&lt;1; for(i=2;i&lt;=n/4+1;i++) cout&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+2; } else if(y==2){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; cout&lt;&lt;n/2&lt;&lt;endl; } else{ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;endl; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; for(i=n-n/4;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; } return 0; } D.首先，如果在范围内最大的两个数加起来恰好是9999…99的形式的话，那么并不需要再讨论了，答案就是1.否则所求的9的位数就是最大两个数的和的位数-1； 然后我们就试着在目标个数的9前面依次填上0~8，看看有多少种方式能加起来等于我们当前构造的和。需要注意的是当和p比较小的时候，方式就是p/2，但是和比较大的时候就是n-p/2… 以及，如果n&lt;5的时候并不能构造出9，那就要特判… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,i,j,k; cin&gt;&gt;n; ll maxn=n+n-1; int cnt=0; ll t=maxn; while(t){ cnt++;t/=10; } if(maxn==(ll)pow(10,cnt)-1){ cout&lt;&lt;1&lt;&lt;endl;return 0; } ll ans=0,nine=pow(10,cnt-1)-1;//ans1=n-n/2; for(i=0;i&lt;9;i++){ ll p=(ll)pow(10,cnt-1)*i+nine; if(p&gt;maxn)break; //ans+=((ll)pow(10,cnt-1)*i+nine)/2; ans+=min(n-p/2,p/2); } cout&lt;&lt;(n&lt;5?n*(n-1)/2:ans)&lt;&lt;endl; return 0; } E.题目做法就是模拟，关键在于删去一个区间之后，他左右的区间可能会因为数字相同而造成合并。为了解决这个问题，我们用两个set，两个set中都存放pair，第一个set的第一元存放连续数字的长度*-1，第二元则存放连续数字的起始位置。第二个set的第一元存放连续数字的起始位置，第二元存放连续数字的长度。 然后每次我们把第一个set中的第一个pair找出来，他就是要被删除的，然后我们用lowerbound在第二个set中找出他前后的两个pair，看看他们是否需要合并即可。小心set访问非法位置… #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k; set&lt;P&gt;len,seg; //int pre=0,sum=0; cin&gt;&gt;n;int num[200005]={0},sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i]; if(num[i]!=num[i-1]){ if(i&gt;1){ len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); } sum=1; } else sum++; } len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); int ans=0; while(!len.empty()){ ans++; P p=*len.begin();len.erase(len.begin()); auto a=seg.lower_bound(P(p.second,0)); if(seg.size()&gt;=3&amp;&amp;a!=seg.begin()&amp;&amp;a!=--seg.end()){ auto b=a,c=a;b--,c++; if(num[b-&gt;first]==num[c-&gt;first]){ len.erase(P((b-&gt;second)*-1,b-&gt;first)); len.erase(P((c-&gt;second)*-1,c-&gt;first)); len.insert(P((b-&gt;second+c-&gt;second)*-1,b-&gt;first)); seg.insert(P(b-&gt;first,b-&gt;second+c-&gt;second)); seg.erase(b);seg.erase(c); } } seg.erase(a); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } F.其实做法也挺暴力的…我们建一堆set，每个里面都存这个字符出现所有位置，然后对于每次询问，我们找出l，r在原字符串中的位置，这个可以类似树状数组去维护一下，但是有点不同，需要好好理解一下…然后去这个字符对应的set里面lowerbound一下找出l，r对应原位置区间范围内的所有这些位置然后标记一下…最后从前往后，如果没有被标记过就输出即可。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e5+10; int bit[maxn],A; void add(int pos,int x) { while(pos&lt;=A){ bit[pos]+=x; pos+=pos&amp;-pos; } } int find(int x) { int s=0,j=A&gt;&gt;1; for(;j;j&gt;&gt;=1) if(x&gt;bit[s+j]) x-=bit[s+j],s+=j; return s+1; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str;cin&gt;&gt;str; set&lt;int&gt;s[150]; for(i=0;i&lt;str.size();i++) s[str[i]].insert(i+1); for(A=1;A&lt;n;A&lt;&lt;=1); for(i=1;i&lt;=n;i++)add(i,1); while(m--){ int l,r;char c[5];scanf(&quot;%d%d%s&quot;,&amp;l,&amp;r,c); l=find(l),r=find(r); //add() for(auto a=s[c[0]].lower_bound(l);a!=s[c[0]].end()&amp;&amp;(*a)&lt;=r;){ vis[*a]=true; add(*a,-1);s[c[0]].erase(a++); } } for(i=1;i&lt;=n;i++) if(!vis[i]) cout&lt;&lt;str[i-1]; cout&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）ST表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FRMQ%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89st-e8-a1-a8%2F</url>
    <content type="text"><![CDATA[概念ST表就是一个用来解决rmq（区间最值）问题的算法. ST表不支持在线修改 预处理时间复杂度$O(nlogn)$，查询时间$O(1)$ 算法详解（求最小值）：用$mn[i][j]$表示从$i$到$i+2^j-1$的最小值（长度显然为$2^i$）。 任意一段的最小值显然等于min（前半段最小值，后半段最小值）。 那么$mn[i][j]$如何用其他状态来继承呢？ $i$到$i+2^j-1$的长度为$2^j$，那么一半的长度就等于$2^{j-1}$。 那么前半段的状态表示为$mn[i][j-1]$。 后半段的长度也为$2^{j-1}$，起始位置为$i+2^{(j-1)}$。 那么后半段的状态表示为$mn[i+2^{j-1}][j-1]$。 所以： $mn[i][j]=min(mn[i][j-1],mn[i+2^{j-1}][j-1]$。 模板注意修改数组大小！ (洛谷P3865) #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=100010; int a[MAXN],dp[MAXN][50];//第二个括号内要根据最大数据范围改成2的幂次能大于最大的数据 //int Min(int x,int y)//有时候可以用于自定义一些特殊类型的比较 //{ // return a[x]&lt;=a[y]?x:y; //} void st_init(int n)//n为原始数组的长度 { for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); //dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } int query(int l,int r) { int k = log2(r - l + 1); return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); //return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); st_init(n); int l,r; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%dn&quot;,query(l,r)); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>数据结构</category>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #3]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-3%2F</url>
    <content type="text"><![CDATA[A.HackerRank array-partition首先注意到一点，如果有两个数a，b，$gcd(a,b)\geq 1$,那么a，b显然是要放在一组的。考虑到数组中的数字过多，因此我们并不能进行两两的枚举，但是数据的范围都非常有限。因此我们可以考虑枚举所有的质数，然后枚举质数的倍数，如果同一个质数存在一些倍数是数组中的数的话，就把这些数都合并起来（显然用并查集效率最高）。然后最后求出连通块的数量k。注意，因为数字1的特殊性，所以每个1都可以算一个单独的连通块，这个要额外统计。那么方案数就是$2^k-2$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; bool notprime[1000005]; vector&lt;int&gt;prime; void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(notprime[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++) notprime[j*i]=true; } } ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } bool s[1000005]; int par[1000005]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } void unite(int x,int y) { x=find(x),y=find(y); if(x==y) return; par[x]=y; } int main() { int t,i,j,k; checkprime(1000000); cin&gt;&gt;t; int num[100005]; while(t--){ int n;cin&gt;&gt;n; int num1=0; int maxn=0; memset(s,0,sizeof(s)); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);s[num[i]]=true; if(num[i]==1)num1++;maxn=max(maxn,num[i]); } for(i=1;i&lt;=maxn;i++)par[i]=i; for(auto a:prime){ int t=0; for(i=1;i*a&lt;=maxn;i++){ if(s[i*a]){ if(!t)t=i*a; else unite(t,i*a); } } } int cnt=1;find(num[1]);set&lt;int&gt;s; for(i=1;i&lt;=n;i++) s.insert(find(num[i])); cnt=s.size(); if(num1&gt;1)cnt+=num1-1; ll ans=mod_pow(2,cnt,mod); ans=(ans-2+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } B.CodeChef - F2NDMAX这道题其实是一幅图…设想一下，对于两个数a，b，如果$a&gt;b$,那么从a连边指向b，那么当满足题意的询问完成后，我们一定能得到一幅图，其中只有一个点入度为0，即最大的那个点，那么第二大的点应当就是它的一个直接的儿子。 于是我们可以先统计所有入度为0的点，对于这cnt个点，我们至少要询问cnt-1次才能明确其中最大的数，然后为了使总次数最少，我们把这些入度为0的点的儿子中当前入度为1的数量丢进一个小根堆，然后每次询问都应当找出堆顶最大的两个数a，b，那么至少要询问max(a,b)+1次才能找出合并这两组之后第二大的数。（似乎有点混乱？） #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn=3e5+5; int indegree[maxn], outdegree[maxn]; int main() { int t; cin &gt;&gt; t; int n,m,i,j,k; while(t--){ cin &gt;&gt; n &gt;&gt; m; memset(indegree, 0, sizeof(indegree));memset(outdegree, 0, sizeof(outdegree)); vector&lt;int&gt; adj[maxn]; while(m--) { int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adj[u].push_back(v); indegree[v]++; } for(i=1; i&lt;=n; i++) for(auto j : adj[i]) outdegree[i]+=(indegree[j]==1); int cnt=0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; for(i=1; i&lt;=n; i++) { cnt+=indegree[i]==0?1:0; if(!indegree[i]) que.push(outdegree[i]); } cnt--; while(que.size()&gt;1) { int a=que.top();que.pop(); int b=que.top();que.pop(); que.push(max(a, b)+1); } cout &lt;&lt; cnt+que.top()-1 &lt;&lt; endl; } return 0; } J.CodeChef - RIN首先，我们把分数进行转化，得到的分数变成100-得到的分数，也就是亏损的分数。如果分数是-1那么亏损无限大。那么我们的问题其实就变成了如何选择使得亏损尽可能的小。我们把每个课的每个学期都建成点，从源点向所有课的第一学期连权值为该亏损的课，从第一学期向第二学期连第二学期亏损的课…依次类推，最后一学期向汇点连容量无穷的边。那么，如果不考虑前置课程的要求，我们现在的问题其实就是在求图的最小割。 考虑到前置课程，假设a是b的前置课程，那么对于a的每个学期，我们都向b的下一学期连一条无限的边确保b的割不会发生在a之前。注意的是b的第一学期的肯定不能选的，因此从源点向该学期连权值INF的边。 答案就是$(n* 100-maxflow)/n$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e4+50; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } int main() { int n,m,k,i,j; int x[105][105]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ int mar; scanf(&quot;%d&quot;,&amp;mar); if(mar==-1)x[i][j]=1&lt;&lt;30; else x[i][j]=100-mar; } for(i=1;i&lt;=n;i++){ addedge(0,(i-1)*m+1,x[i][1]); for(j=2;j&lt;=m;j++){ addedge((i-1)*m+j-1,(i-1)*m+j,x[i][j]); } addedge((i-1)*m+m,10005,1&lt;&lt;30); } while(k--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(i=1;i&lt;m;i++) addedge((a-1)*m+i,(b-1)*m+i+1,1&lt;&lt;30); addedge(0,(b-1)*m+1,1&lt;&lt;30); //addedge((a-1)*m+m,10005,1&lt;&lt;30); } double ans=n*100-maxflow(0,10005); printf(&quot;%.2f\n&quot;,ans/n); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 48 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-48-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.明显签到，随便写 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; ll pre=0; long long sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;sum+=j; ll d=sum/m;;cout&lt;&lt;d-pre&lt;&lt;&apos; &apos;; pre=d; } return 0; } B.正解应该是想让你预处理字符串匹配，然后搞个前缀和去对付每个询问。然而串实在太短了以至于对于每次询问暴力kmp就可以轻松过。 暴力kmp： #include&lt;bits/stdc++.h&gt; using namespace std; int next1[1000005]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); while(q--) { int cnt=0; int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); string str3=str1.substr(l-1,r-l+1); int i = 0, j = 0; while (i &lt; str3.size()) { if (j == -1 || str3[i] == str2[j]) { if (j == str2.size() - 1) { cnt++;j = next1[j]; continue; } i++;j++; } else { while (j &gt;= 0 &amp;&amp; str2[j] != str3[i]) j = next1[j]; } } printf(&quot;%d\n&quot;,cnt); } return 0; } 预处理前缀和版：(数据有坑，不保证l&gt;=1) #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; int next1[1050]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int sum[1050]; int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); int i=0,j=0; while(i&lt;str1.size()){ if(j==-1||str1[i]==str2[j]){ if(j==str2.size()-1){ sum[i-str2.size()+2]++; j=next1[j];continue; } i++;j++; } else{ while(j&gt;=0&amp;&amp;str2[j]!=str1[i]) j=next1[j]; } } for(i=1;i&lt;=1000;i++)sum[i]+=sum[i-1]; int len=str2.size(); while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(r-len+1&gt;=l&amp;&amp;l&gt;=1) printf(&quot;%d\n&quot;,sum[r-len+1]-sum[l-1]); else printf(&quot;0\n&quot;); } return 0; } C.其实就是一个复杂版的前缀和问题。我们会发现其实走的方法就是样例里的那两种，当然第一种可以先走下面再走上面。最后的结果一定是先走第二种然后走第一种中的一种。那么我们就可以预处理每种走法的前缀和。第二种显然从左往右递推走到每个位置的前缀和即可。而第一种则要分上下讨论，并且从不同的列开始第一种，他后面的前缀和还要加上走第二种的时候所带来的系数(sum3). sum1是第二种的前缀和，sum2，sum4是第一种的两种前缀和。 最后枚举每个位置为第二，第一种的分界点求最值即可。 注意：第一个位置的系数是0不是1！ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+5; ll sum1[maxn],sum2[maxn],a[maxn],b[maxn],sum3[maxn],sum4[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]); for(i=1;i&lt;=n;i++){ //ll t=0; if(i&amp;1){ sum1[i]=(i*2-2)*a[i]+(i*2-1)*b[i]; } else{ sum1[i]=(i*2-2)*b[i]+(i*2-1)*a[i]; } sum1[i]+=sum1[i-1]; } for(i=n;~i;i--){ sum3[i]+=a[i]+b[i]; sum3[i]+=sum3[i+1]; } for(i=n;i;i--){ sum2[i]+=sum2[i+1]+sum3[i+1]; sum2[i]+=b[i]*((n-i+1)*2-1); sum4[i]+=sum4[i+1]+sum3[i+1]; sum4[i]+=a[i]*((n-i+1)*2-1); } ll ans=0; // for(i=1;i&lt;=n;i++) // cout&lt;&lt;sum2[i]&lt;&lt;&apos; &apos;&lt;&lt;sum4[i]&lt;&lt;endl; for(i=0;i&lt;=n;i++){ ll t=sum1[i]; if(i&amp;1){ t+=sum4[i+1]+sum3[i+1]*(i)*2; } else t+=sum2[i+1]+sum3[i+1]*i*2; ans=max(ans,t); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.其实只要$a_1\oplus a_2\oplus …a_n=b_1\oplus b_2\oplus…b_n$就是一定可以的。 然后除了最后一列及最后一行之外的所有位置其实都可以随便放。根据放的情况推最后一行最后一列即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int ma[105][105]; int a[105],b[106]; int main() { int n,m,i,j,k,sum1=0,sum2=0; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum1^=a[i]; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;b[i]);sum2^=b[i]; } if(sum1!=sum2){ puts(&quot;NO&quot;);return 0; } for(i=1;i&lt;n;i++){ for(j=1;j&lt;m;j++){ ma[i][j]=1; } if((m-1)&amp;1) sum1=1; else sum1=0; ma[i][m]=a[i]^sum1; } for(i=1;i&lt;=m;i++){ sum1=0; for(j=1;j&lt;n;j++) sum1^=ma[j][i]; ma[j][i]=b[i]^sum1; } puts(&quot;YES&quot;); for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,ma[i][j],j==m?&apos;\n&apos;:&apos; &apos;); } //cout&lt;&lt;(4^2^15)&lt;&lt;&apos; &apos;&lt;&lt;(2^15)&lt;&lt;endl; return 0; } E.对于每个点，我们连接它与a,b. 这两条线与x轴的交点可以构成一条线段len，那么，这个点在shade中的时长就是： |len中栅栏的长度|* |ab的长度|/|len的长度| 计算中用lowerbound找相交点，然后用相似三角形求解。 代码中用 |右端点的栅栏前缀和|-|左端点的栅栏前缀和| 求解栅栏长度。 #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;double&gt;v; const int maxn=2e5+5; double s[maxn]; int main() { double sy,a,b,l[maxn],r[maxn]; int n,i,j,k,q; scanf(&quot;%lf%lf%lf&quot;,&amp;sy,&amp;a,&amp;b); cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf&quot;,&amp;l[i],&amp;r[i]);s[i]+=s[i-1]+r[i]-l[i];//s为预处理的栅栏长的前缀和 v.push_back(l[i]);v.push_back(r[i]); } cin&gt;&gt;q; while(q--){ double x,y;scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); double pos=a-sy/(y-sy)*(x-a);//利用相似三角形求线与x轴的交点 int p=lower_bound(v.begin(),v.end(),pos)-v.begin();//求交点落在哪个位置 double ans=-s[p/2];//左端点前缀和,要减去所以带负号 if(p&amp;1)ans-=pos-v[p-1];//如果交点在在栅栏中间,那么这个栅栏在交点左边的一部分也是要减去的 pos=b-sy/(y-sy)*(x-b); p=lower_bound(v.begin(),v.end(),pos)-v.begin(); ans+=s[p/2]; if(p&amp;1)ans+=pos-v[p-1];//同理算右端点 ans=ans/y*(y-sy); printf(&quot;%.7f\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最大权闭合图]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-9d-83-e9-97-ad-e5-90-88-e5-9b-be%2F</url>
    <content type="text"><![CDATA[所谓闭合图，指的是图中每个点的后续都在图中。最大权闭合图，指的是点的权值之和最大的闭合图。 最大权闭合图的求解方法1.先构造网络流N，添加源点s，从s到正权值点做一条边，容量为点的权值。 2.添加汇点t，从负权值点到t做一条边，容量为点的权值的绝对值。 3.原来的边的容量统统设为无穷大 4.求解最小割，最大权=正权值之和-最小割权值 5.最小割所产生的两个集合中，其源点S所在集合(除去S)为最大权闭合图。（也就是POJ2987所求的裁员） EX:POJ2987 公司官僚成风，盘根错节，办实事的码农没几个。老板决定大裁员，每开除一个人，同时要将其下属一并开除，如果该下属还有下属，照斩不误。给出每个人的贡献值（可为负）和从属关系，求最小裁员数及最大贡献值和。 模板题，记得开longlong即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } long long maxflow(int s,int t){ long long flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小费用流]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b4-b9-e7-94-a8-e6-b5-81%2F</url>
    <content type="text"><![CDATA[最大流+SPFA #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int a,b,c,d; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); add(a,b,c,d); } mincostmaxflow(s,t); cout&lt;&lt;flow&lt;&lt;&apos; &apos;&lt;&lt;cost&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最大流与二分图的一些结论]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-b5-81-e4-b8-8e-e4-ba-8c-e5-88-86-e5-9b-be-e7-9a-84-e4-b8-80-e4-ba-9b-e7-bb-93-e8-ae-ba%2F</url>
    <content type="text"><![CDATA[匹配，边覆盖，独立集合顶点覆盖概念：$V$：全集 匹配——在图中两两没有公共顶点的边的集合 注意，图中的匹配有很多，一条边也可以算一个匹配。但是最大匹配却是可以确定的。最大匹配也就是要让选出尽可能多的边使得它们两两之间都没有交点（端点）。 边覆盖——图中的任意顶点都至少是集合$F$中某条边的的端点，满足这样条件的集合的最少的边的集合$F$称为最小边覆盖 独立集——在图中两两不相连的顶点集合 比如一条边$S$的顶点是$S_a,S_b$,那么这两个点就不能同时在一个独立集中。事实上，独立集中的任意两个点之间都不存在有边之间相连。 顶点覆盖——图中的任意边都至少有一个端点属于集合$S$的集合叫做顶点覆盖 结论(a)对于不存在孤立点的图，|最大匹配|+|最小边覆盖|=|$V$|（边的全集）（即任意一个顶点都至少在某条边中） （b）|最大独立集|+|最小顶点覆盖|=|$V$|（点的全集） （c）在二分图中，有：|最大匹配|=|最小顶点覆盖|（可用于求解二分图的最大独立集和最小顶点覆盖） （d）|图的最大流|=|图的最小割|（图有源汇）]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）网络流最大流(Dinic)]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-bd-91-e7-bb-9c-e6-b5-81-e6-9c-80-e5-a4-a7-e6-b5-81dinic%2F</url>
    <content type="text"><![CDATA[模板结论：图的最小割=图的最大流（最大流最小割定理）（图是有源汇的） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } int main() { return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）后缀数组]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-90-8e-e7-bc-80-e6-95-b0-e7-bb-84%2F</url>
    <content type="text"><![CDATA[定义字符串$s$连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 1开始，长度为$length(s)$ 。 后缀： $suffix(i)$表示字符串$s$从第$i$个位置开始的后缀，即由 $s[i]-s[n] $组成的子串。 字符串的比较： 两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小； 如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小； 如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。 注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件长度相同。 后缀数组： $sa$是一个一维数组，保存了对字符串$s$的所有后缀排序后的结果。 表示第$i$小的后缀在原串中的起始位置。 名次数组： $rank$是一个一维数组，按起始位置保存了每个后缀在 $sa$中的排名。 表示$suffix(i)$的排名，即 $rank[sa[i]]=i$（第$i$小的后缀的排名为$i$）。 高度数组： 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。 $height[i]=LCP(suffix(sa[i]),suffix[sa[i-1]))$(i&gt;0) 即$height[i]$表示在位置$i$存在最大的$x$,满足$\forall k \in [0,x)$有$s[sa[i]+k]=s[sa[i-1]+k]$ 最长公共前缀 通过高度数组$height$ ，我们可以得到排名相邻的两个后缀的最长公共前缀。 对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度一定不会比这两个后缀在后缀数组中确定的一段区间中任意两个相邻后缀的最长公共前缀长度更长。 所以，求出这段区间内最小的$height$值即为这两个不相邻后缀的最长公共前缀长度。 问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）**算法解决。该算法在$O(n\ logn)$ 的时间内预处理，并在 $O(1) $的时间内完成每个询问。 代码字符串/数组保存在s数组中，maxn是字符串/数组的最大长度，rk是$rank$数组，sa就是$sa$数组，ht是$height$数组。 （按照洛谷P3809的要求） #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+5; char s[maxn]; int rk[maxn],sa[maxn],ht[maxn]; inline void suffixArray() { int n=strlen(s+1); static int set[maxn + 1], a[maxn + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; static int fir[maxn + 1], sec[maxn + 1], tmp[maxn + 1], buc[maxn + 1]; for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; for (int t = 1; t &lt;= n; t *= 2) { for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; } for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;,s+1);int n=strlen(s+1); suffixArray(); for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,sa[i],i==n?&apos;\n&apos;:&apos; &apos;); return 0; } 详细参考：后缀数组学习笔记]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training 组合数学]]></title>
    <url>%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-e7-bb-84-e5-90-88-e6-95-b0-e5-ad-a6%2F</url>
    <content type="text"><![CDATA[D.组合数学+容斥原理 这个每个人必须要拿一个的限制条件非常讨厌…所以我们先不管他。 由于各种特产相互独立，所以可以先算一种特产的分配方法… 这样的话就相当于把m个相同的小球放入n个不同的盒子里(盒子就是人)，答案是$C_{m+n-1}^{\ n-1}$，然后把各个特产的这个值相乘得到答案。 非常科学，非常优雅对不对… 接下来考虑限制条件，每个人至少拿一个，我们把限制去掉后得到的是至少0人没有特产的方案数。 根据容斥原理 $ans=C_n^0 ans[至少0人没有特产]-C_n^1 ans[至少1人没有特产]+C_n^2 ans[至少2人没有特产]-……+……+/- C_m^m ans[至少m人没有特产]$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int mod=1e9+7; ll c[2005][2005]; int main() { int n,m,i,j,k; c[1][1]=c[1][0]=c[0][0]=1; for(i=2;i&lt;=2000;i++) { c[i][0]=1; for (j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//预处理组合数 } } cin&gt;&gt;n&gt;&gt;m; int tc[1005]; for(i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;tc[i]);//特产数量 ll ans=0;int cur=1; for(i=0;i&lt;=n;i++){ ll temp=cur;//容斥原理的系数(决定加减) for(j=1;j&lt;=m;j++){ temp=(temp*c[tc[j]+n-i-1][n-i-1])%mod; } ans+=temp*c[n][i]%mod;ans%=mod; cur*=-1; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0; } E.我们把左右区间分别处理： $ r = r / k; \ l = (l - 1) / k + 1$; 这样问题就转化为求[l,r] 区间内，选n个数其最大公约数为1的方案数 因为$r-l&lt;=10^5$, 所以这个区间内任意两个不相等的数的最大公约数最大不超过$10^5$ 证明很好证：因为两个数p &gt; q的最大公约数如果为x,那么$p / x - q / x \geq 1$,那么$p - q \geq x$ 所以可以暴力枚举所有的最大公约数,设[l,r]中选n个不完全相同的数其最大公约数为i的方案数为dp[i] 那么[l,r]中有多少含i因子的数呢？ 显然有$t = r / i - (l - 1) / i$个数 那么$dp[i] = t_n$ 种方案，但是这里面肯定有n个数都相同的方案一共有t个（这时候他们的GCD就不仅仅是i了），所以$dp[i] = (tn - t) mod\ p$种方案 但是这个时候求出的是所有n个数中有i因子的方案数，而不是gcd=i的方案数，所以$\forall j\ dp[i] = dp[i] - dp[j](j &lt;= r - l \ and\ j | i)$ 然后这样dp[1]就是正解了 但是我们注意到，我们的dp[1]是在[l,r]中选n个不完全相同的数其最大公约数为i的方案数，但是实际上,如果n个数都等于k的话，那么其实也是满足要求的。 所以当$k∈[l,r]时，dp[1] = dp[1] + 1$; #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int maxn=(100000 + 10); typedef long long ll; int dp[maxn]; int p = 1e9+7; ll mod_pow(ll n, ll k, ll mod) { ll re = 1; n = n % mod; while(k) { if(k &amp; 1) re = re * n % mod; k = k &gt;&gt; 1; n = n * n % mod; } return re; } int main() { int l,r,n,k; bool flag = false; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;l,&amp;r); if(k &gt;= l &amp;&amp; k &lt;= r)flag = true; r = r / k; l = (l - 1) / k; for(int i = r - l; i &gt;= 1; i --) { int t = r / i - l / i; dp[i] = (mod_pow(t, n, p) - t + p) % p; for(int j = 2; j * i &lt;= r - l; j ++) dp[i] = (dp[i] - dp[i * j] + p) % p; } if(flag == true) dp[1]++; printf(&quot;%d\n&quot;,dp[1] % p); return 0; } F.非常套路的题目，其实就是要你快速求1~x中有多少个数跟给定的n互质，那么把n分解一下质因数然后用容斥原理求一下这些质因数的倍数的总和就可以了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum(ll x,ll n) { vector&lt;ll&gt;prime; ll i,j,y=x; for(i=2;i*i&lt;=n;i++){//注意分解要从2开始!! if(n%i==0){ prime.push_back(i); } while(n%i==0) n/=i; } ll res=0; if(n&gt;1)prime.push_back(n); for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){//注意一定要从1开始!!! ll val=1,cnt=0;//二进制枚举每个因数是否要选 for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1LL){ res+=y/val; } else res-=y/val; } //cout&lt;&lt;res&lt;&lt;endl; return x-res; } int main() { int t;ll a,b,n; cin&gt;&gt;t;int cnt=0; while(t--){ cnt++; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;n); printf(&quot;Case #%d: %lld\n&quot;,cnt,sum(b,n)-sum(a-1,n)); } return 0; } G.题目求的其实就是$\forall a_i\ a_ix=b(mod\ m )$中b的和。 那么显然b必须满足$GCD(a_i,m)|b$,那么所有的这样的b显然都是m的某个约数的倍数（ m除外，因为$b\leq m-1$)。于是，对于每个ai，我们枚举其与m的gcd与各个约数的关系，如果它的gcd能整除某个约数，那么这个约数的所有倍数都是可行的，并且和可以用等差数列求和公式求出。但是这显然就带来了一个重复的问题，那么我们在求和的过程中还要统计每个数被求和的次数，然后进行处理。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; bool vis[10005]; int cnt[10005]; int gcd(int x,int y) { return y?gcd(y,x%y):x; } int main() { int t,i,j,k; cin&gt;&gt;t;int case1=0; while(t--){ case1++; int n,m;vector&lt;int&gt;ys; memset(vis,0,sizeof(vis));memset(cnt,0,sizeof(cnt)); cin&gt;&gt;n&gt;&gt;m; for(i=1;i*i&lt;=m;i++){//求m的约数 if(m%i==0){ ys.push_back(i); if(i*i!=m)ys.push_back(m/i); } } sort(ys.begin(),ys.end());ys.pop_back();//使约数从小到大排列方便后面求重复的问题 for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;k);// k=gcd(k,m); for(j=0;j&lt;ys.size();j++){ if(ys[j]%k==0) vis[j]=1;//这个约数及其倍数都是可行的 } } ll ans=0; for(i=0;i&lt;ys.size();i++){ if(vis[i]&amp;&amp;cnt[i]!=1){ int last1=(m-1)/ys[i]*ys[i],num=(m-1)/ys[i]+1; ans+=(ll)(0+last1)*num/2*(1-cnt[i]); for(j=i+1;j&lt;ys.size();j++) if(ys[j]%ys[i]==0)//所有是这个约数的倍数的约数都被重复计数了,标记一下 cnt[j]+=1-cnt[i]; } } printf(&quot;Case #%d: %lld\n&quot;,case1,ans); //cout&lt;&lt;ans&lt;&lt;endl; } return 0; } H.题目可以比较暴力的求解，因为有个结论：如果a和m互质，那么$k* m+a$和$m$也互质，于是我们暴力求1~m的范围内与m互质的数的个数n，然后每m个数中就有n个数与m互质。需要注意的就是当$n|k$时要特判一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } int main() { ll n,m,i,j,k; while(cin&gt;&gt;m&gt;&gt;k){ vector&lt;ll&gt;rp; for(i=1;i&lt;=m;i++){ if(gcd(i,m)==1) rp.push_back(i); } ll xs=k/rp.size(); ll ans; if(k%rp.size()) ans=m*xs+rp[k%rp.size()-1]; else ans=m*(xs-1)+rp[rp.size()-1];//注意特判 printf(&quot;%lld\n&quot;,ans); } return 0; } I.非常套路的题，枚举集合内的数然后求一下他们的LCM，然后容斥原理搞一搞他们的倍数的个数就ok了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } ll sum(ll x,vector&lt;int&gt;v) { ll res=0,i,j; for(i=1;i&lt;(1&lt;&lt;v.size());i++){ ll val=1,cnt=0; for(j=0;j&lt;v.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val=val*v[j]/gcd(val,v[j]);//一定要求LCM!集合里的数不见得两两互质 cnt++; } } if(cnt&amp;1LL)res+=x/val; else res-=x/val; } return res; } int main() { ll n,m; int i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ vector&lt;int&gt;v;//bool haszero=false; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);if(j)v.push_back(j); } printf(&quot;%lld\n&quot;,sum(n-1,v)); //else cout&lt;&lt;0&lt;&lt;endl; } return 0; } J.其实就是求1~b/k跟1~d/k中有多少对互质的数。假设b&gt;d，我可以认为从后一个集合中挑的数一定都是比较小的数（避免重复），那么对于互质对(x,y),x&gt;=y,当x&lt;=d/k时，其实y的取值就是x的欧拉函数值。而当d/k&lt;=x&lt;=b/k时，就用之前题目中求过的那种方式求1~d/k中与x互质的数的个数即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll eular(ll x) { ll res = x, a = x; for (ll i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } ll sum(ll x,ll n) { ll i,j; vector&lt;ll&gt;prime; for(i=2;i*i&lt;=n;i++){ if(n%i==0){ prime.push_back(i); while(n%i==0) n/=i; } } if(n&gt;1)prime.push_back(n); ll res=0; for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){ ll val=1;ll cnt=0; for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1){ res+=x/val; } else res-=x/val; } return x-res; } ll phi[1000005]; void phi_table(ll n)///欧拉函数值表 { phi[1]=1; for(ll i=2; i&lt;=n; i++) { if(!phi[i]) { for(ll j=i; j&lt;=n; j+=i) { if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); } } } } int main() { int t;ll a,b,c,d,i,j,k; cin&gt;&gt;t; phi_table(100010); for(ll i=2; i&lt;=100000; i++) phi[i]+=phi[i-1];///前缀和 int cnt=0; while(t--){ ll ans=0; cnt++; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0 || k &gt; b || k &gt; d) { printf(&quot;Case %d: 0\n&quot;, cnt); continue; } if(b&lt;d)swap(b,d); b/=k;d/=k; // for(i=1;i&lt;=d;i++) // ans+=eular(i); for(i=d+1;i&lt;=b;i++) ans+=sum(d,i); printf(&quot;Case %d: %lld\n&quot;,cnt,ans+phi[d]); } return 0; }]]></content>
      <categories>
        <category>组合数学</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）最小圆覆盖]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e5-9c-86-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[算法目的：在线性时间复杂度内求出覆盖n个点的最小圆算法步骤：①首先现将所有点随机排列 ②按顺序把点一个一个的加入（一步一步的求前i个点的最小覆盖圆），每加入一个点就进入③ ③如果发现当前i号点在当前的最小圆的外面，那么说明点i一定在前i个点的最小覆盖圆边界上，我们转到④来进一步确定这个圆，否则前i个点的最小覆盖圆与前i-1个点的最小覆盖圆是一样的，则不需要更新，返回② ④此时已经确认点i一定在前i个点的最小覆盖圆的边界上了，那么我们可以把当前圆的圆心设为第i个点，半径为0，然后重新把前i-1个点加入这个圆中（类似上面的步骤，只不过这次我们提前确定了点i在圆上，目的是一步一步求出包含点i的前j个点的最小覆盖圆），每加入一个点就进入⑤ ⑤如果发现当前j号点在当前的最小圆的外面，那么说明点j也一定在前j个点（包括i）的最小覆盖圆边界上，我们转到⑥来再进一步确定这个圆，否则前j个点（包括i）的最小覆盖圆与前i-1个点（包括i）的最小覆盖圆是一样的，则不需要更新，返回④ ⑥此时已经确认点i，j一定在前j个点（包括i）的最小覆盖圆的边界上了，那么我们可以把当前圆的圆心设为第i个点与第j的点连线的中点，半径为到这两个点的距离（就是找一个覆盖这两个点的最小圆），然后重新把前j-1个点加入这个圆中（还是类似上面的步骤，只不过这次我们提前确定了两个点在圆上，目的是求出包含点i，j的前k个点的最小覆盖圆），每加入一个点就进入⑦ ⑦如果发现当前k号点在当前的最小圆的外面，那么说明点k也一定在前k个点（包括i，j）的最小覆盖圆边界上，我们不需要再进一步确定这个圆了（因为三个点能确定一个圆！），直接求出这三点共圆，否则前k个点（包括i，j）的最小覆盖圆与前k-1个点（包括i，j）的最小覆盖圆是一样的，则不需要更新。 时间复杂度：O(N) 空间复杂度：O(N) 注意事项: 以上时间复杂度的证明全部基于点的排列随机，如果点的排列不随机，那么时间复杂度将有可能达到O(N3) 所以最小圆覆盖算法只能在O(N)时间内求出N的点的最小覆盖圆，而不能在O(N)的时间内求出所有的前i个点的最小覆盖圆 代码 给定n个点求最小覆盖圆圆心及半径 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; const int N=505; using namespace std; struct node { double x, y; }b[N]; node O; double R; double sqr(double x) { return x * x; } double dis(node x,node y)//距离 { return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y)); } bool incircle(node x)//判断点是否在圆内 { if(dis(O,x)&lt;=R) return true; return false; } node solve(double a,double b,double c,double d,double e,double f) { node t; t.y=(f*a-c*d)/(b*d-e*a); t.x=(f*b-c*e)/(a*e-b*d); return t; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int i, j, k; for (i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;b[i].x, &amp;b[i].y); random_shuffle(b + 1, b + n + 1); R = 0;O.x=O.y=0; for (i = 1; i &lt;= n; i++) if (!incircle(b[i])) { O.x = b[i].x; O.y = b[i].y; R = 0; for (j = 1; j &lt; i; j++) if (!incircle(b[j])) { O.x = (b[i].x + b[j].x) / 2; O.y = (b[i].y + b[j].y) / 2; R = dis(O, b[i]); for (k = 1; k &lt; j; k++) if (!incircle(b[k])) { O = solve( b[i].x - b[j].x, b[i].y - b[j].y, (sqr(b[j].x) + sqr(b[j].y) - sqr(b[i].x) - sqr(b[i].y)) / 2, b[i].x - b[k].x, b[i].y - b[k].y, (sqr(b[k].x) + sqr(b[k].y) - sqr(b[i].x) - sqr(b[i].y)) / 2 ); R = dis(b[i], O); } } } printf(&quot;%.2f %.2f %.2f\n&quot;, O.x, O.y,R);//坐标,半径 } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）任意多边形的重心]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e4-bb-bb-e6-84-8f-e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e9-87-8d-e5-bf-83%2F</url>
    <content type="text"><![CDATA[计算多边形重心方法：（1）划分多边形为三角形： 以多边形的一个顶点V为源点（V可取输入的第一个顶点），作连结V与所有非相邻顶点的线段，即将原N边形或分为（N-2）个三角形； （2）求每个三角形的重心和面积： 设某个三角形的重心为$G（c_x，c_y）$，顶点坐标分别为$A_1（x_1，y_1），A_2（x_2，y_2），A_3（x_3，y_3）$，则有$C_x = \frac{(x_1 + x_2 + x_3)}{3}$.同理求得cy。求面积的方法是 $S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$，当$A_1,A_2,A_3$顺时针排列时取-，否则取正（叉积）。事实上，在求每个三角形时不需要辨别正负，之后有方法抵消负号。 （3）求原多边形的重心： 公式：$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ，其中$C_{xi},C_{yi},S_i$分别是所划分三角形的重心坐标和面积；注意如果在求各个三角形重心的时候没有除以3则最后要统一除以3； 总结每个三角形重心：$C_x = \frac{(x_1 + x_2 + x_3)}{3}$；cy同理。 每个三角形面积：$S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$； 多边形重心：$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ 代码 给定一个n边形，求重心坐标 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;double,double&gt;P; P node[105]; P mass_node(P a,P b,P c)//求重心 { return P((a.first+b.first+c.first)/3,(a.second+b.second+c.second)/3); } double square(P a,P b,P c)//求面积 { double s = ((b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second)) / 2; return s; } int main() { int n,i,j,k;int cnt=0; while(cin&gt;&gt;n&amp;&amp;n){ cnt++; for(i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].first,&amp;node[i].second); vector&lt;P&gt;mass;vector&lt;double&gt;s; double tots=0; for(i=2;i&lt;n;i++){ P t=mass_node(node[1],node[i],node[i+1]);mass.push_back(t);//划分三角形求重心 double s1=square(node[1],node[i],node[i+1]);s.push_back(s1);//求面积 tots+=s1; } double cx=0,cy=0; for(i=0;i&lt;mass.size();i++){ cx+=mass[i].first*s[i];cy+=mass[i].second*s[i];//求多边形重心 } cout&lt;&lt;&quot;Stage #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;; printf(&quot;%.6f %.6f\n&quot;,cx/tots,cy/tots); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #2]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-2%2F</url>
    <content type="text"><![CDATA[A. 有两个数组A，B，每次可以选择一个A，B中出现过的数字x并将它替换为另一个随意的数y，一次操作会把A，B中的所有的x都换成y，并且，最后应当使得A，B完全相等，即对应位上的数一样。同时，问在操作数最少时有多少种操作的方法。 首先，应该想到的一点是因为一个数可能重复出现很多次，而他在不同位置出现时与他同一位置的不同数组的数很可能是不一样的，这就意味着所有的这些数最后是要变成一个相同的数的。那么为了确定有多少组这样最后要变成一样的数，可以搜素或者并查集搞一波。注意的是每一组里面如果有n个数，那么他只需要做n-1次变换。 对于第二问，首先我们假设这一组中有n个数（相同的数搜索的时候会被合并，所以计算的时候肯定不会有重复），那么最后变成的数就有n种选择，这个数确定了以后，对于其余n-1个数而言，他们先后变换一次（不一定一次就变为选定的这个数），那么可能有$(n-1)!$种。同时，每个数变换的时候一定是变为这一组中剩下数中的一个（每当一个数发生了变换，他就永久从数组中消失了，因为我们要求总操作次数最少），所以对于第一个变的数而言，它的选择是$n-1$，第二个数是$n-2$…，因此，每一组大小为n的数的可能是$n\times (n-1)!\times (n-1)!$种。而对于全体数而言，我们的先后顺序是无所谓的，所以可能数应该是$m!$,但是因为对于每一组数，其内部的顺序已经计算过了一次，根据除法原理，每一组大小为n的数都会带来$(n-1)!$的重复，所以应当除去。所以最后总的可能数就是$\prod {n!}\ \times m!$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int mod=1e9+7; vector&lt;int&gt; G[maxn]; bool vis[maxn]; ll fac[maxn]; int cnt; void dfs(int u) { vis[u]=true;cnt++; for(auto a:G[u]) if(!vis[a]) dfs(a); } int main() { fac[0] = 1;int t; cin &gt;&gt; t; while (t--) { for (int i = 0; i &lt; maxn; i++) { G[i].clear(); } memset(vis,0,sizeof(vis)); for (int i = 1; i &lt; maxn; i++) fac[i] = (fac[i - 1] * i) % mod; int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = 0; ll a[maxn], b[maxn]; for (int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;,&amp;b[i]); if (b[i] != a[i]) { G[a[i]].push_back(b[i]);G[b[i]].push_back(a[i]); } } ll ans1 = 1; for (int i = 0; i &lt; n; i++) { if (vis[a[i]])continue; cnt = 0;dfs(a[i]); ans += (cnt - 1); ans1 = ans1 * fac[cnt] % mod; } ans1 = ans1 * fac[ans] % mod; cout &lt;&lt; ans &lt;&lt; &quot; &quot;; if (k == 2)cout &lt;&lt; ans1; cout &lt;&lt; endl; } return 0; } D.画画图大胆猜结论啊，其实我们会发现如果一个图形能被分割为有限个平行四边形的话，那么它一定可以被分割为随意数量的更多的平行四边形（在分割好的平行四边形里面不断做平行线不就好了）。因此就是要判断一个图形能不能分成若干个平行四边形。 猜结论：每条边至少有另外一条边与其平行且长度相等。 计算斜率的时候为了避免分母为0要注意一下。 代码#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,ll&gt;P; const double eps=1e-6; int main() { int n,i,j,k; cin&gt;&gt;n; vector&lt;P&gt;v; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b);v.push_back(P(a,b));//边 } vector&lt;P&gt;xl;vector&lt;double&gt;len; for(i=0;i&lt;v.size();i++){ xl.push_back(P(v[(i+1)%n].first-v[i].first, v[(i+1)%n].second-v[i].second));//斜率(防止分母0没有直接除) len.push_back(sqrt((v[(i+1)%n].first-v[i].first) * (v[(i+1)%n].first-v[i].first) + (v[(i+1)%n].second-v[i].second)*(v[(i+1)%n].second-v[i].second)));//边长度 } for(i=0;i&lt;xl.size();i++){ bool isok=false; for(j=0;j&lt;xl.size();j++){//暴力枚举 if(i==j)continue; if(xl[i].first*xl[j].second==xl[i].second*xl[j].first&amp;&amp;fabs(len[i]-len[j])&lt;eps){ isok=true;break; } } if(!isok){ puts(&quot;no&quot;);return 0; } } puts(&quot;yes&quot;); return 0; } H.首先明确一点，即题目中给的函数$f(l,r)$他的值是唯一确定的（$（l，r）$代表其左右边界位置），但是我们要求的是在$(l,r)$范围内的所有$f(l_1,r_1)$的最大值，这就不确定了。因此想法很简单：先算出所有的$f$，然后区间dp求答案。 当然，首先要简单写写，推出公式： $f(l,r)=f(l,r-1)\ \oplus\ f(l+1,r)=f(l,r-2)\ \oplus\ f(l+2,r)$（拿哪个公式来推都没问题） 代码#include&lt;bits/stdc++.h&gt; using namespace std; int num[5005][5005],f[5005][5005]; int main() { int n,i,j,k,len; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i][i];f[i][i]=num[i][i]; num[i-1][i]=num[i-1][i-1]^num[i][i]; } for(len=2;len&lt;n;len++) for(i=1;i+len&lt;=n;i++){ num[i][i+len]=num[i][i+len-2]^num[i+2][i+len]; } for(len=1;len&lt;n;len++){ for(i=1;i+len&lt;=n;i++){ f[i][i+len]=max(num[i][i+len],max(f[i+1][i+len],f[i][i+len-1]));//注意这里的比较 } } int q,l,r; cin&gt;&gt;q; while(q--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\n&quot;,f[l][r]); } return 0; } I. 给定两个等长数组A，B，要求对于每个$a_i$,在B中找一个数与其异或，并且B中每个数只能用一次，求异或后字典序最小的A数组 显然就是对A从前往后找它异或后最小的b就行了呀，为了找出最小的b，建立一棵二进制trie树即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn=3e6+5; struct node{ int sum; node*next1[2]; bool tag,ask; node(){//新建函数 sum=0;tag=false;ask=false;next1[0]=next1[1]=NULL; } }*root=new node(); void add(int x) { int i,j; struct node*p=root; for(i=30;~i;i--) { if((1&lt;&lt;i)&amp;x){ if(!p-&gt;next1[1]) { node*t=new node(); p-&gt;next1[1] = t; } p=p-&gt;next1[1]; } else { if(!p-&gt;next1[0]) { node*t=new node(); p-&gt;next1[0] = t; } p=p-&gt;next1[0]; } p-&gt;sum++; } } int query(int x) { int i,j;node*p=root,*pre; int res=0; for(i=30;~i;i--){ pre=p; if((1&lt;&lt;i)&amp;x){ if(p-&gt;next1[1]&amp;&amp;p-&gt;next1[1]-&gt;sum) p=p-&gt;next1[1],res=res&lt;&lt;1|1; else p=p-&gt;next1[0],res&lt;&lt;=1; } else{ if(p-&gt;next1[0]&amp;&amp;p-&gt;next1[0]-&gt;sum) p=p-&gt;next1[0],res&lt;&lt;=1; else p=p-&gt;next1[1],res=res&lt;&lt;1|1; } p-&gt;sum--; } return res; } int main() { int n,i,j,k; cin&gt;&gt;n;int a[maxn]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);add(j); } for(i=1;i&lt;=n;i++){ int ans=query(a[i]);ans^=a[i]; cout&lt;&lt;ans&lt;&lt;&apos; &apos;; } return 0; } J. 给定n个形如$y=(x-a_i)^2+b_i$的抛物线，求它们划分平面的区域数。 注意到给定的抛物线都是同一种形式的，当$a_i\neq a_j$时，这两个抛物线就有一个交点，否则没有。因此可以类比直线划分平面来做：对于每一条新的抛物线，我们计算它与之前抛物线的交点数，它划分出来的新区域数就是（交点数+1）。注意查重，即交点重复问题。 #include&lt;bits/stdc++.h&gt; using namespace std; pair&lt;int,int&gt; p[1010]; pair&lt;double,double&gt; s[1010]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second); sort(p + 1, p + n + 1); n = unique(p + 1, p + n + 1) - p - 1; int ans = 1; for (int i = 1; i &lt;= n; i++) { int tot = 0; for (int j = 1; j &lt; i; j++) if (p[i].first != p[j].first) { double x = (double) (p[i].first * p[i].first + p[i].second - p[j].first * p[j].first - p[j].second) / (2 * (p[i].first - p[j].first)); double y = (double) (x - p[i].first) * (x - p[i].first) + p[i].second; s[++tot] = make_pair(x, y); } sort(s + 1, s + tot + 1); tot = unique(s + 1, s + tot + 1) - s - 1; ans += tot + 1; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）矩阵快速幂]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-9f-a9-e9-98-b5-e5-bf-ab-e9-80-9f-e5-b9-82%2F</url>
    <content type="text"><![CDATA[矩阵乘法的计算公式：（第一个矩阵为m s,第二个为s n，结果为m* n矩阵） $C_{ij}=\sum a_{ik}\times b_{kj}$ 暴力计算代码（模拟）： const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N { memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } 矩阵快速幂 给定$n\times n$的矩阵$A$，求$A^k$ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; const int maxn=105; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//暴力计算矩阵乘法,N为矩阵大小 { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////n是幂，N是矩阵大小 { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01矩阵 while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn],k; cin&gt;&gt;n&gt;&gt;k;//n为矩阵大小,k为幂次 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;matrci[i][j]; Pow(matrci,k,n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,res[i][j],j==n?&apos;\n&apos;:&apos; &apos;); return 0; } 应用主要通过把数放到矩阵的不同位置，然后把普通递推式变成”矩阵的等比数列”，最后快速幂求解递推式； POJ3070 题目：斐波那契数列f(n),给一个n，求f(n)%10000,n&lt;=1e9; (这题是可以用fibo的循环节去做的，不过这里不讲，反正是水题) 矩阵快速幂是用来求解递推式的，所以第一步先要列出递推式: $ f(n)=f(n-1)+f(n-2)$ 第二步是建立矩阵递推式，找到转移矩阵: $\binom{1\ 1}{1\ 0}\times \binom{f_{n-1}}{f_{n-2}}=\binom{f_n}{f_{n-1}}$ 所以通项就是：$A_n=T^{n-1}\times A_1\ $,$\ T$就是那个转移矩阵。 那么我们要求的其实就是res[1][1]; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int mod=1e4; const int maxn=5; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//暴力计算矩阵乘法,N为矩阵大小 { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////n是幂，N是矩阵大小 { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01矩阵 while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn]={0},k; while(cin&gt;&gt;n&amp;&amp;n!=-1){ if(n==0){ cout&lt;&lt;0&lt;&lt;endl;continue; } matrci[1][1]=1,matrci[1][2]=1,matrci[2][1]=1,matrci[2][2]=0; Pow(matrci,n-1,2); ll fibo[5][5]={0};fibo[1][1]=1; multi(res,fibo,2); cout&lt;&lt;res[1][1]&lt;&lt;endl; } return 0; } 简单递推式： $1.\ f(n)=a\times f(n-1)+b\times f(n-2)+c\ $ (a,b,c为常数) $\binom{a\ b\ 1}{\binom{1\ 0\ 0}{0\ 0\ 1}}\times \binom{f_{n-1}}{\binom{f_{n-2}}{c}}=\binom{f_{n}}{\binom{f_{n-1}}{c}}$(因为矩阵有点问题所以暂时这样) $2.f(n)=c^n-f(n-1)$（c是常数） $\binom{-1\ c}{0\ \ c}\times \binom{f_{n-1}}{c^{n-1}}=\binom{f_n}{c^n}$]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）线性同余方程组（中国剩余定理）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b-e7-bb-84-ef-bc-88-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86-ef-bc-89%2F</url>
    <content type="text"><![CDATA[中国剩余定理求同余方程组 $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $…$ $x\equiv c_k(mod\ m_k)$ 其中，$\forall i,j$有$gcd(m_i,m_j)=1$, 的最小正整数（非负整数）解； 结论令$M=m_1\times m_2\times …\times m_k$， 则$x=(\sum c_i\times \frac{M}{m_i}\times inv(\frac{M}{m_i},m_i))$; 其中,$inv(\frac{M}{m_i},m_i)$即$\frac{M}{m_i}$相对于$m_i$的乘法逆元。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; ll extgcd(ll a,ll b,ll&amp;x,ll&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } ll d=extgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d; } int main() { ll n,a,b,i,j,m[20],k[20];//m为各个模数,k为余数 cin&gt;&gt;n; ll M=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;m[i]&gt;&gt;k[i]; M*=m[i];//求M } ll x,y;ll X=0; for(i=1;i&lt;=n;i++){ ll a=M/m[i];ll b=m[i]; extgcd(a,b,x,y); x=(x+b)%b; if(!x)x+=b; X+=k[i]*a*x; } X%=M; } 模板题 扩展中国剩余定理求同余方程组 $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $…$ $x\equiv c_k(mod\ m_k)$ 的最小正整数（非负整数）解；（即删去了模数互质的条件） 结论对于两个方程 $x\equiv c_1(mod\ m_1)$及$x\equiv c_2(mod\ m_2)$，将其合并为一个方程，有解条件为$gcd(m_1,m_2)|(c_2-c_1)$. 那么（有解时），$m=\frac{m_1\times m_2}{gcd(m_1,m_2)}$, $c=(inv(\frac{m_1}{gcd(m_1,m_2)},\frac{m_2}{gcd(m_1,m_2)})\times \frac{c_2-c_1}{gcd(m_1,m_2)}\ mod \ \frac{m_2}{gcd(m_1,m_2)}\times m_1+c_1$， 如此从前往后递推下去，直到求出一个式子： $x\equiv c(mod\ m)$， 那么原方程组的一个解即为$x=c\ mod\ m$ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int N=1005; int k; ll c[N],m[N],c1,c2,m1,m2,t;//c为余数,m为模数 bool flag; ll gcd(ll a,ll b) { if (!b) return a; else return gcd(b,a%b); } void exgcd(ll a,ll b,ll &amp;x,ll &amp;y) { if (!b) x=1LL,y=0LL; else exgcd(b,a%b,y,x),y-=a/b*x; } ll inv(ll a,ll b) { ll x=0LL,y=0LL; exgcd(a,b,x,y); x=(x%b+b)%b; if (!x) x+=b; return x; } int main() { while (~scanf(&quot;%d&quot;,&amp;k))//同余方程个数 { flag=true; for (int i=1;i&lt;=k;i++) scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;c[i]); for (int i=2;i&lt;=k;i++) { m1=m[i-1],m2=m[i],c1=c[i-1],c2=c[i]; t=gcd(m1,m2); if ((c2-c1)%t!=0) { flag = false; break;//不整除则无解 } m[i]=m1*m2/t; c[i]=inv(m1/t,m2/t)*((c2-c1)/t)%(m2/t)*m1+c1; c[i]=(c[i]%m[i]+m[i])%m[i]; } if (!flag) puts(&quot;-1&quot;); else printf(&quot;%lld\n&quot;,c[k]); } return 0; } 此时的最小正整数解就是$c[k]$（小于0就加上$m_1\times m_2$) 模板运行过程中似乎会遇到取模时值为负数导致出错的问题，解决方法如下： a[i] = m1 * m2 / t; ll temp=(c2 - c1) / t; if(temp&lt;0){ ll t1=abs(temp)/(m2/t);temp+=(m2/t)*(t1+1); } ll temp2=inv(m1 / t, m2 / t); if(temp2&lt;0){ ll t1=abs(temp2)/(m2/t);temp2+=(m2/t)*(t1+1); } c[i] = (temp2)%(m2 / t) * ((temp) % (m2 / t)) % (m2 / t)* m1 + c1; c[i] = (c[i] % a[i] + a[i]) % a[i]; 模板题：POJ2891]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）线性同余方程]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[定义:a,b是整数，形如$ax≡b(mod \ m)$，且x是未知整数的同余式称为一元线性同余方程。 定理：a,b,m是整数且m&gt;0,$gcd(a,m)=d$,如果$d|b$，则方程恰好有d个模m不同余的解，否则方程无解。 由同余方程的定义式可得$ax+my=b$，这个方程称为二元一次不定方程。 由扩展欧几里得算法可求出方程$ax+my=gcd(a,m)$的特解，则原方程的通解为 $ x = x_0 \times \frac{b}{gcd(a,m)}+ \frac{m}{gcd(a,m)}\times t$ $ y = y_0 \times \frac{b}{gcd(a,m)}– \frac{a}{gcd(a,m)}\times t$ $t=0,1,2,3…$ 扩展欧几里得： int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } x，y即为$ax+my=gcd(a,m)$的特解。 例子：NOIP2012 同余方程 求关于 x 的同余方程 $ax≡1(mod\ b) $的最小正整数解。 因为题目保证了一定有解，所以直接求即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } int main() { int a,b,x,y; cin&gt;&gt;a&gt;&gt;b; extgcd(a,b,x,y); x=(x+b)%b; cout&lt;&lt;x&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）高精度算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[__int128最简单粗暴的做法。 这种类型只有部分GCC编译器支持。经测试，正常运算与普通int无异，但是输入输出时无论是cin，cout还是printf都会报错，所以必须自己写输入输出函数。 定义时与别的数据类型并没有什么区别 eg: __int128 a,b,c; 输入暂时采用字符串读入方式。 方法一：重载输出 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, __int128 T) { if (T&lt;0) os&lt;&lt;&quot;-&quot;;if (T&gt;=10 ) os&lt;&lt;T/10;if (T&lt;=-10) os&lt;&lt;(-(T/10)); return os&lt;&lt;( (int) (T%10) &gt;0 ? (int) (T%10) : -(int) (T%10) ) ; } 方法二：变为字符串式输入输出 输入： void scan(__int128 &amp;x)//输入 { x = 0; int f = 1; char ch; if((ch = getchar()) == &apos;-&apos;) f = -f; else x = x*10 + ch-&apos;0&apos;; while((ch = getchar()) &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) x = x*10 + ch-&apos;0&apos;; x *= f; } 输出： void print(__int128 x) { if(x &lt; 0) { x = -x; putchar(‘-‘); } if(x &gt; 9) print(x/10); putchar(x%10 + ‘0‘); } 简单模板（不支持负数）#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 1000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } 更完善的模板支持负数之类的操作。需要注意的是如果涉及bign与常规类型的数值之间的之间计算，比如一个bign+ll，可能需要额外新增重载运算符，因为默认的似乎只有bign+int的重载，否则可能溢出出错。 以及，大数的长度需要额外注意，开太大容易爆内存。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //最大长度，可以修改 using namespace std; class bign { public: int len, s[MAX_L];//数的长度，记录数组 //构造函数 bign(); bign(const char *); bign(int); bool sign;//符号 1正数 0负数 string toStr() const;//转化为字符串，主要是便于输出 friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//重载输入流 friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//重载输出流 //重载复制 bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //重载各种比较 bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //重载四则运算 bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //四则运算的衍生运算 bign operator%(const bign &amp;) const;//取模（余数） bign factorial() const;//阶乘 bign Sqrt() const;//整数开根（向下取整） bign pow(const bign &amp;) const;//次方 //一些乱乱的函数 void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005];]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）欧拉函数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e6-8b-89-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[1~n中与n互质的数的个数称为欧拉函数 int eular(int x) { int res = x, a = x; for (int i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } 性质1：1~n中与n互质的数的和为$n\times eular（n）\div2$; 性质2：若a，b互质，则$eular（a\times b）=eular（a）\times eular（b）$；]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）质数筛法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-b4-a8-e6-95-b0-e7-ad-9b-e6-b3-95%2F</url>
    <content type="text"><![CDATA[埃拉托斯特尼筛法#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; bool notprime[10000005]; void checkprime(int n) { for(int i=2;i&lt;=n;i++){//注意线性筛法做完以后1是没有被标记的... if(notprime[i])continue;//如果已经被标记为合数,那就滚蛋 for(int j=i;j&lt;=n/i;j++)//注意这里一定要小心j*i可能爆int的事实，写成 //j=i*i的时候也是一样要小心！！！最好用long long notprime[j*i]=true;//标记合数 } } int main() { int n,m,i; cin&gt;&gt;n&gt;&gt;m; checkprime(n);notprime[1]=true;//特别注意要标记1 for(i=1;i&lt;=m;i++){ int t; scanf(&quot;%d&quot;,&amp;t); if(notprime[t])cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } return 0; } 线性筛（似乎不大常用） #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int v[10000005],prime[10000000],cnt=0;//v记录每个数的最小质因数,prime记录素数 void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(v[i]==0){//如果i是素数 v[i]=i; prime[++cnt]=i; } for(int j=1;j&lt;=cnt;j++){ if(prime[j]&gt;v[i]||prime[j]&gt;n/i)//如果当前的质数已经比I的最小质因数大了,那么就没有必要再继续下去了,因为后面的i*prime[j] break;//肯定已经被v[i]或者其他更小的质数标记过了;同时,超过n自然也是不用管了 v[i*prime[j]]=prime[j];//标记最小质因数 } } } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; checkprime(n); for(int i=1;i&lt;=m;i++){ int t;scanf(&quot;%d&quot;,&amp;t); if(v[t]==t)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）求乘法逆元]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-b1-82-e4-b9-98-e6-b3-95-e9-80-86-e5-85-83%2F</url>
    <content type="text"><![CDATA[乘法逆元$x\times x^{-1}=1\ (mod\ p)$ 费马小定理前提是模数必须是质数；因为$a^{p-1}\ mod\ p=1$,所以a模p的乘法逆元就是$a^{p-2}$ 运用快速幂: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int n,p,i,j; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt;ans; for(i=1;i&lt;=n;i++){ ll t=pow(i,p-2,p); ans.push_back(t); } for(i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; } 扩展欧几里得算法给定模数m，求a的逆相当于求解$ax=1(mod \ m) $ 这个方程可以转化为$ax-my=1 $ 然后套用求二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd 检查$gcd(a,m)$是否为1 gcd不为1则说明逆元不存在 若为1，则调整 x0 到0~m-1的范围中即可 void exgcd (ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return ; } exgcd (b, a % b, x, y); ll tmp = x; x = y; y = tmp - a / b * y; } //主函数部分调用 ll x, y; exgcd (a, b, x, y);//求a在模b意义下的乘法逆元 x = (x + p) % p; printf (&quot;%d\n&quot;, x); 递推求逆元用于求连续很多数的乘法逆元，时间复杂度基本上是线性 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; int main() { ll n,p,i,j; cin&gt;&gt;n&gt;&gt;p; ll inv[3000005]; inv[1]=1; for(i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p;//关键 for(i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,inv[i]); return 0; } 求连续阶乘的乘法逆元先求出$n!$的逆元，倒序递推。 $inv_i = (inv_{i+1}* (i+1))mod\ p$]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）欧几里得算法]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e5-87-a0-e9-87-8c-e5-be-97-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[欧几里得算法（GCD）： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;gcd(x,y)&lt;&lt;endl; return 0; } 扩展欧几里得算法： int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } 扩欧求出的$x$,$y$ 是$a x + b y = gcd(a,b)$的一个特解，我们就可以用 x0 和 y0 表示出整个不定方程的通解： $ x = x_0 + (b/gcd) t$ $ y = y_0 – (a/gcd) t$]]></content>
      <categories>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）快速幂与快速乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e5-b9-82-e4-b8-8e-e5-bf-ab-e9-80-9f-e4-b9-98-e6-b3-95%2F</url>
    <content type="text"><![CDATA[快速幂对于任何一个整数的模幂运算 $a^b\ mod \ c$ 对于b我们可以拆成二进制的形式 $b=b_0+b_1 2+b_2 2^2+…+b_n* 2^n$ 这里我们的$b_0$对应的是b二进制的第一位 ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } 快速乘法 由于计算机底层设计的原因，做加法往往比乘法快的多，因此将乘法转换为加法计算将会大大提高（大数，比较小的数也没必要）乘法运算的速度，除此之外，当我们计算a* b%mod的时候，往往较大的数计算a＊b会超出long long int的范围，这个时候使用快速乘法方法也能解决上述问题． 快速乘法的原理就是利用乘法分配率来将a＊b转化为多个式子相加的形式求解（注意这时使用乘法分配率的时候后面的一个乘数转化为二进制的形式计算）． EX：$ 20＊ 14 ＝ 20＊ (1110)_2 = 20 ＊ (2^3)＊1 + 20＊(2^2)＊1+20＊(2^1)＊１+20＊ (2^0)＊ 0 = 160+80+40=280$ 上面即为快速乘法的基本原理 ll quick_mul(ll a, ll b, ll c) { ll ans = 0; a %= c; b %= c; while (b) { if (b &amp; 1)//如果对应位为1 ans = (ans + a) % c; a &lt;&lt;= 1; a %= c;//对应b的位每次的幂次会增加，加在a上 b &gt;&gt;= 1; } return ans; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）计算几何]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-ae-a1-e7-ae-97-e5-87-a0-e4-bd-95%2F</url>
    <content type="text"><![CDATA[模板如下，解释见注释： #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 100000; const double EPS = 1e-8; // 带误差比较 inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } /* * 向量（Vector）或点 * * 使用原点到一个点 (x, y) 的有向线段表示向量 * 从点 A 到点 B 的向量表示为 A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // 相加 Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // 相减 Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // 数乘（伸长、缩短） Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // 范数，用来比较长度，等于长度的平方 double norm() const { return x * x + y * y; } } Pt; // 点乘 double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // 叉乘 double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } // 线段（Segment），用两个点表示 struct Seg { Pt a, b; Seg(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} // 线段包含点（点在线段上） bool include(const Pt &amp;p) { // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上 // PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } }; // 直线，用两个点表示 struct Line { Pt a, b; Line() {} // 提供一个不需要参数的构造函数 Line(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } // 两直线关系（交点个数） // 0 表示平行（无交点） // 1 表示相交（一个交点） // -1 表示重合（无数个交点） static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } // 求两直线交点（需要保证两直线有交点） static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } }; // 求凸包用的点 int n; Pt a[MAXN + 1]; // 凸包极角排序的比较函数 inline bool compare(const Pt &amp;a, const Pt &amp;b) { // 两个向量 Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB 是逆时针，则 A 极角序在先 else return va.norm() &lt; vb.norm(); // norm 较小的长度较小 } struct Poly { std::vector&lt;Pt&gt; pts; //如果不求凸包的话,把多边形的点直接保存在这里,否则把多边形的点保存在外面的a数组中 bool include(const Pt &amp;p) const { int cnt = 0; // 判断与每条边有没有交点 for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举相邻的每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // 如果点 P 在边 AB 上 if (Seg(a, b).include(p)) return true; // 详见图 double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // 奇数的交点 return cnt % 2 == 1; } // 多边形面积（有向面积） double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } // 求凸包（Convex），结果储存在自身 pts 中 void convex() { // 找出最左下角的点 int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // 排序 std::sort(a + 2, a + n + 1, &amp;compare); // 极角序扫描 pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // 比较，如果最后一个点需要被删掉则弹出（pop_back） while (pts.size() &gt;= 2 &amp;&amp; cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) &gt;= 0) pts.pop_back(); pts.push_back(a[i]); } } }; 旋转卡壳（在原有模板上求出凸包后增加以下代码即可）：注意：模板里的ans没有开方！返回的是最远点对距离的平方！解释：http://www.cnblogs.com/Booble/archive/2011/04/03/2004865.html double cross(Pt a,Pt b,Pt c)//求叉积 { return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x); } double dist2(Pt a,Pt b)//求距离 { Pt x=a-b; return (x.norm());//因为本题只要求求距离的平方所以没有开方 } double rotating_calipers(Poly p)//旋转卡壳 { int j=1,n=p.pts.size();p.pts.push_back(p.pts[0]); double ans=0; for(int i=0;i&lt;n;i++) { while(cross(p.pts[i],p.pts[i+1],p.pts[j])&lt;cross(p.pts[i],p.pts[i+1],p.pts[j+1])) j=(j+1)%n; ans=max(ans,max(dist2(p.pts[i],p.pts[j]),dist2(p.pts[i+1],p.pts[j+1]))); } return ans; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Splay维护区间翻转]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fe6-a8-a1-e6-9d-bf-ef-bc-89splay-e7-bb-b4-e6-8a-a4-e5-8c-ba-e9-97-b4-e7-bf-bb-e8-bd-ac%2F</url>
    <content type="text"><![CDATA[您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1 输入输出格式输入格式：第一行为n,m n表示初始序列有n个数，这个序列依次是 $(1,2,…n-1,n)$ ,m表示翻转操作次数 接下来m行每行两个数$ [l,r][l,r]$ 数据保证 $1≤l≤r≤n$ 输出格式：输出一行n个数字，表示原始序列经过m次变换后的结果 类似线段树的lazytab操作. Splay可以用来维护序列。这样的话是把Splay当作一棵区间树。 所谓区间树和权值树的区别，大概就是区间树每个节点代表的是一段区间（典型代表就是一般的线段树） 权值树好理解一点，就是每个点真的代表一个点。 至于翻转操作，我们可以利用Splay的过程实现。 #include&lt;bits/stdc++.h&gt; #define N 100005 using namespace std; int n,m; int fa[N],ch[N][2],size[N],rev[N],rt; inline void pushup(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; } void pushdown(int x){ if(rev[x]){ swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0; } } void rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],kind; if(ch[y][0]==x)kind=1;else kind=0; if(y==k)k=x; else{if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} ch[y][kind^1]=ch[x][kind];fa[ch[y][kind^1]]=y; ch[x][kind]=y;fa[y]=x;fa[x]=z; pushup(x);pushup(y); } void splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } void build(int l,int r,int f){ if(l&gt;r)return; int mid=(l+r)/2; if(mid&lt;f)ch[f][0]=mid;else ch[f][1]=mid; fa[mid]=f;size[mid]=1; if(l==r)return; build(l,mid-1,mid);build(mid+1,r,mid); pushup(mid); } int find(int x,int k){ pushdown(x);int s=size[ch[x][0]]; if(k==s+1)return x; if(k&lt;=s)return find(ch[x][0],k); else return find(ch[x][1],k-s-1); } void rever(int l,int r){ int x=find(rt,l),y=find(rt,r+2); splay(x,rt);splay(y,ch[x][1]);int z=ch[y][0]; rev[z]^=1; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt=(n+3)/2;build(1,n+2,rt); for(int i=1;i&lt;=m;i++){ int L,R;scanf(&quot;%d%d&quot;,&amp;L,&amp;R); rever(L,R); } for(int i=2;i&lt;=n+1;i++)printf(&quot;%d &quot;,find(rt,i)-1); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #499 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-499-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力搞搞就行 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int main() { int n,k,i,j; string str; cin&gt;&gt;n&gt;&gt;k&gt;&gt;str; vector&lt;char&gt;v; for(auto a:str)v.push_back(a); sort(v.begin(),v.end()); int pre=0;int cnt=0,w=0; for(i=0;i&lt;v.size();i++){ if(v[i]-pre&lt;2)continue; else{ cnt++;pre=v[i];w+=v[i]-&apos;a&apos;+1; } if(cnt==k)break; } if(cnt&lt;k){ puts(&quot;-1&quot;); } else{ cout&lt;&lt;w&lt;&lt;endl; } return 0; } B. 比赛的时候傻逼了，写了半天优先队列，数据那么小骑士暴力枚举每个人能分多少个就可以了，数据要是大一点二分也行。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int cnt[105], b[105]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; cnt[i]; b[cnt[i]]++; } for (int i = 100; i &gt;= 1; i--) { int t = 0; for (int j = 1; j &lt;= 100; j++) { t += b[j] / i; } if (t &gt;= n) { cout &lt;&lt; i; return 0; } } cout &lt;&lt; 0; return 0; } C. 感觉这题非常签到呀，直接递推就行了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,m,i,j,k,a[1005],b[1005]; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; if(a[i]==1){ puts(&quot;-1&quot;);return 0; } } for(i=1;i&lt;=n;i++){ cin&gt;&gt;b[i]; if(b[i]==1){ puts(&quot;-1&quot;);return 0; } } double w=m; w+=w/(b[1]-1); for(i=n;i&gt;1;i--){ w+=w/(a[i]-1); w+=w/(b[i]-1); } w+=w/(a[1]-1); printf(&quot;%.10f\n&quot;,w-m); return 0; } D. 题目比较长，难度主要是在读题上还有输出flush上。其实本身不太难，首先我们不知道真假序列是什么的话显然是无从下手的，因此我们只要问n次最大值m或者n次1就可以了，因为我们知道这种情况下的答案（如果返回0的话那直接结束程序就行了），这样就可以求出整个序列了。然后因为m的范围有限，而我们知道任何一个正整数都可以用2的若干个幂次的和表现出来，因此我们可以二分一下。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int wrong[31], poww[31]; int main() { int m, n, q1,i,j,k; cin &gt;&gt; m &gt;&gt; n; poww[0] = 1; for (i = 1; i &lt; 31; i++) { poww[i] = poww[i - 1] &lt;&lt; 1;//预处理2的幂次方 } for (i = 0; i &lt; n; i++) { printf(&quot;%d\n&quot;, m);//询问n次m fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (q1 == -1) wrong[i] = 1; else if (q1 == 1) wrong[i] = 0; else return 0;//如果是0直接返回 } int ans = 0;int num = 0; for (i = 29; ~i ; i--) { if (ans + poww[i]&gt;m)continue; printf(&quot;%d\n&quot;, ans + poww[i]); fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (wrong[num%n] == 0)q1 *= -1;//根据预处理真假序列改变 if (q1 == 1) { ans += poww[i]; } else if (q1 == 0) { return 0; } num++; } printf(&quot;%d\n&quot;, ans); return 0; } E. 题目真的挺难懂的。其实就是给定n种数及k，每个数可以用无限次，问这些数随意组合的和%k有多少种可能，并输出所有可能。 其实就是求同余方程$a_1 x_1+a_2 x_2+…+a_n* x_n=m (mod k)$中所有的m。 根据贝祖定理可以知道，这等价于问有多少个m满足$gcd(a_1,a_2,a_3…a_n)|m$ 那么其实就很好求了。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; //set&lt;int&gt;s; int d=k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); d=gcd(d,j%k); } int cnt=0; for(i=0;i&lt;k;i+=d) cnt++; cout&lt;&lt;cnt&lt;&lt;endl; for(i=0;i&lt;k;i+=d) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2486 树链剖分（区间更改，区间查重）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fp2486-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8c-ba-e9-97-b4-e6-9b-b4-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-9f-a5-e9-87-8d-ef-bc-89%2F</url>
    <content type="text"><![CDATA[树剖，用线段树维护： 数组a[N]表示此时的颜色段数。 数组left1[N]表示此时最左边的节点的颜色。 数组right1[N]表示此时最右边的节点的颜色。 则： 首先我们要明确，线段树的叶子节点一定只有一种颜色，也就是一条颜色段。 a[父亲]=a[左儿子]+a[右儿子]； if (left1[右儿子]==right1[左儿子]) {a[父亲]–;} 即如果右儿子的最左边颜色和左儿子的最右边颜色相同，那么肯定有中间部分属于同一颜色段。 以及往上跳的时候重链连接处颜色是否相同的问题，相同的话也要减。 #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=100000+10; vector&lt;int&gt;G[maxn]; //int mod; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],left1[maxn&lt;&lt;2],right1[maxn&lt;&lt;2]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 //int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void pushdown(int rt) { a[rt&lt;&lt;1]=a[rt&lt;&lt;1|1]=1; lazytab[rt&lt;&lt;1]=lazytab[rt&lt;&lt;1|1]=left1[rt&lt;&lt;1]=right1[rt&lt;&lt;1]=left1[rt&lt;&lt;1|1]=right1[rt&lt;&lt;1|1]=lazytab[rt]; lazytab[rt]=0; } void pushup(int r) { a[r]=a[r&lt;&lt;1]+a[r&lt;&lt;1|1]; left1[r]=left1[r&lt;&lt;1];right1[r]=right1[r&lt;&lt;1|1]; if(right1[r&lt;&lt;1]==left1[r&lt;&lt;1|1])a[r]--; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=1; left1[rt]=right1[rt]=wt[l]; //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); //a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); pushup(rt); } inline int query(int rt,int l,int r,int L,int R) { int ans=0; if(L&lt;=l&amp;&amp;r&lt;=R){ return a[rt]; } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))ans+=query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)ans+=query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); if(L&lt;=((l+r)&gt;&gt;1)&amp;&amp;R&gt;(l+r)&gt;&gt;1&amp;&amp;right1[rt&lt;&lt;1]==left1[rt&lt;&lt;1|1])ans--;//这里也要注意的两边都有的情况下才要减 } return ans; } inline void update(int rt,int l,int r,int L,int R,int color) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]=color;left1[rt]=right1[rt]=color;a[rt]=1; return; //a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,color); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,color); pushup(rt); } } //---------------------------------以上为线段树 int QAQ(int rt, int l, int r, int p) { if (l==r) return left1[rt]; if (lazytab[rt]) pushdown(rt); if (p&gt;(l+r&gt;&gt;1)) return QAQ((rt &lt;&lt; 1 | 1), (l + r &gt;&gt; 1) + 1, r, p); else return QAQ((rt &lt;&lt; 1), l, (l + r &gt;&gt; 1), p); }//返回重链顶点的颜色 inline int queryrange(int x, int y,int n)//查询从x到y最短路径上的点的权值之和,n就是节点的总数 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 //res=0; ans+=query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 int nc= QAQ(1, 1, n, id[top[x]]);//往顶端跳的时候还要留意一个问题,就是不同重链之间的连接处颜色是否相同的问题 int fc= QAQ(1, 1, n, id[fa[top[x]]]); if(nc==fc) ans--; x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 //res=0; ans+=query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 //ans+=res; return ans?ans:1;//%mod; } inline void addrange(int x, int y, int color,int n)//x到y最短路径上的点都加上k {//同上 //color%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],color); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],color); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;n;i++){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); G[x].push_back(y);G[y].push_back(x); } dfs1(1,0,1);dfs2(1,1);build(1,1,n); for(i=1;i&lt;=m;i++){ char con;cin&gt;&gt;con; if(con==&apos;C&apos;){ int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); addrange(a,b,c,n); } else{ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,queryrange(a,b,n)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2590 树链剖分（单点修改，区间求和and单点查询）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-b4-9b-e8-b0-b7p2590-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8d-95-e7-82-b9-e4-bf-ae-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-b1-82-e5-92-8cand-e5-8d-95-e7-82-b9-e6-9f-a5-e8-af-a2-ef-bc-89%2F</url>
    <content type="text"><![CDATA[一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。 我们将以下面的形式来要求你对这棵树完成一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 III. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身 在板子的基础上类似线段树那样修改即可，注意n的位置！！定义在了所有函数前面 #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int n,m,r; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],mx[maxn]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l];mx[rt]=wt[l];//增加max数组 //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);//更新时更新max } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];return;//求和的询问 } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } int query1(int rt,int l,int r,int L,int R) { int q1=-99999999,q2=-99999999;//初始化不能为0!可能有很多负数! if(L&lt;=l&amp;&amp;r&lt;=R){ return mx[rt];//求最大值的询问 } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))q1=query1(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)q2=query1(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } return max(q1,q2); } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ //lazytab[rt]+=k; a[rt]=k;mx[rt]=k; } else{ //if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]); } } //---------------------------------以上为线段树 inline int queryrange(int x, int y)//查询从x到y最短路径上的点的权值之和 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 res=0; query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 ans+=res; //ans%=mod;//按题意取模 x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 res=0; query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 ans+=res; return ans;//%mod; } inline int querymax(int x, int y)//查询从x到y最短路径上的点的最大权值 { int ans=-99999999;//初始化! while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 //res=0; ans=max(ans,query1(1,1,n,id[top[x]],id[x]));//ans加上x点到x所在链顶端 这一段区间的最大权值 x=fa[top[x]];//把x跳到x所在链顶端的那个点 的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 //res=0; ans=max(ans,query1(1,1,n,id[x],id[y])); //ans+=res; //return ans%mod; return ans; } inline void addrange(int x, int y, int k)//x到y最短路径上的点变为k {//同上 //k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); dfs1(1,0,1);dfs2(1,1);build(1,1,n); int q;cin&gt;&gt;q; while(q--){ string str;int u,t; cin&gt;&gt;str&gt;&gt;u&gt;&gt;t; if(str==&quot;CHANGE&quot;){ addrange(u,u,t); } else if(str==&quot;QMAX&quot;){ printf(&quot;%d\n&quot;,querymax(u,t)); } else{ printf(&quot;%d\n&quot;,queryrange(u,t)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分（模板）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89%2F</url>
    <content type="text"><![CDATA[先来回顾两个问题： 1，将树从x到y结点最短路径上所有节点的值都加上z 这也是个模板题了吧 我们很容易想到，树上差分可以以O(n+m)的优秀复杂度解决这个问题 2，求树从x到y结点最短路径上所有节点的值之和 lca大水题，我们又很容易地想到，dfs O(n)预处理每个节点的dis（即到根节点的最短路径长度） 然后对于每个询问，求出x,y两点的lca，利用lca的性质distance ( x , y ) = dis ( x ) + dis ( y ) - 2 * dis ( lca )求出结果 时间复杂度O(mlogn+n) 现在来思考一个bug： 如果刚才的两个问题结合起来，成为一道题的两种操作呢？ 模板要求： 如题，已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作： 操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z 操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和 操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z 操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和 以下模板请务必注意： 不需要mod的时候请注意特殊处理！！！以及每个函数里基本都有的n这个参数，就是读入的时候节点的总数！！！#include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int mod; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void pushdown(int rt,int lenn) { lazytab[rt&lt;&lt;1]+=lazytab[rt]; lazytab[rt&lt;&lt;1|1]+=lazytab[rt]; a[rt&lt;&lt;1]+=lazytab[rt]*(lenn-(lenn&gt;&gt;1)); a[rt&lt;&lt;1|1]+=lazytab[rt]*(lenn&gt;&gt;1); a[rt&lt;&lt;1]%=mod; a[rt&lt;&lt;1|1]%=mod; lazytab[rt]=0; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l]; if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];res%=mod;return; } else{ if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]+=k; a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } } //---------------------------------以上为线段树 inline int queryrange(int x, int y,int n)//查询从x到y最短路径上的点的权值之和,n就是节点的总数 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 res=0; query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 ans+=res; ans%=mod;//按题意取模 x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 res=0; query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 ans+=res; return ans%mod; } inline void addrange(int x, int y, int k,int n)//x到y最短路径上的点都加上k {//同上 k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline int qSon(int x,int n)//查询x的子树的权值和 { res=0; query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 return res; } inline void updSon(int x,int k,int n)//x的子树中的点都加上k {//同上 update(1,1,n,id[x],id[x]+siz[x]-1,k); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int n,m,r; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } dfs1(r,0,1); dfs2(r,r); build(1,1,n);//建树 while(m--){ int k,x,y,z; cin&gt;&gt;k; if(k==1){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addrange(x, y, z,n); } else if(k==2){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\n&quot;, queryrange(x, y, n)); } else if(k==3){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); updSon(x,y,n); } else{ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\n&quot;,qSon(x,n)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #455 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-455-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力枚举即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;set&gt; using namespace std; int main() { set&lt;string&gt;s; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int i,j; for(i=0;i&lt;str1.size();i++){ string str11=str1.substr(0,i+1); for(j=0;j&lt;str2.size();j++){ string str22=str2.substr(0,j+1); s.insert(str11+str22); } } cout&lt;&lt;*s.begin()&lt;&lt;endl; return 0; } B. 结论题。首先想象对于一个区间[i,i+1],所有覆盖这个区间的线段都必然属于不同的层，否则任意两个线段都会相交，显然不行。那么我们有一个大胆的想法：枚举所有的i，找出(i+1)* (n-i)中最大的即是答案。事实上确实如此。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,i,j,ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++){ ans=max(ans,(i+1)*(n-i)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 题意：f代表for语句，它后面的语句至少有一句是它内部的，其他语句要么在内部要么在外部，s语句是普通语句。给一个没有缩进的f, s代码，求一共有多少种满足上述的缩进方案，结果模1e9+7。 令f[i][j]代表第i行有j个缩进的可能数。那么对于每一行的语句，如果他是f的话，那么显然，这一行的缩进只能++；但如果这一行是s的话，那么其实这一个语句可以是上面任意一个f的缩进。因此对于j=1…cnt,有f[i][j]+=f[i-1]k，因此我们可以趁机压缩一维（前缀和dp），对于j=1..cnt，有f[j]+=f[j-1]即可，当然要取模； 最后一行如果不是紧接着f的，那么f[cnt]就是前缀和dp，否则就是f在有cnt个缩进下的情况，因此输出f[cnt]即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; long long f[5005]; const int mod=1e9+7; int main() { int n,i,j,cnt=0;char c; cin&gt;&gt;n; f[0]=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;c; if(c==&apos;f&apos;) cnt++; else{ for(j=1;j&lt;=cnt;j++) f[j]=(f[j]+f[j-1])%mod; } } cout&lt;&lt;f[cnt]&lt;&lt;endl; return 0; } D. 我们可以设想，如果我们把这些点按照相邻的相同颜色为标准分为连续的一组组的话，那么每次操作后被删去的点肯定都是每一组左右两端的两个点，因为这两个点与不同颜色的段接壤（当然第一段与最后一段除外，他们每次只减1）。那么我们可以重复此操作，直到至少有一段被删光，这时，他的左右两个区间可能因为颜色相同变成一个区间，这时候就必要重新安排了。写法还是挺精妙的 。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef pair&lt;char,int&gt;P; const int maxn=1e6+5; char s[maxn]; int main() { int cnt,i,j,ans=0,tot=0; scanf(&quot;%s&quot;,s+1); P pa[maxn]; int n=strlen(s+1); for(i=1;i&lt;=n;i++) { if (s[i] != s[i - 1]) pa[++tot] = P(s[i], 1);//预处理段 else pa[tot].second++; } for(;tot&gt;1;tot=cnt,ans++){ pa[1].second--;pa[tot].second--;//处理头尾 for(i=2;i&lt;tot;i++)//中间各段-=2 pa[i].second-=2; for(cnt=0,i=1;i&lt;=tot;i++){ if(pa[i].second&gt;0) {//如果这一段还没有被删完 if (pa[i].first != pa[cnt].first)//如果他跟前面接壤的区间颜色不相同,记为新的区间 pa[++cnt]=pa[i]; else pa[cnt].second += pa[i].second;//否则重新计量该区间 } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. 可以想象，是什么情况下分给副核的任务需要分成几次？显然是因为副核依赖一个主核的任务，而这个主核的任务又依赖于一个副核的任务。除此之外，其余任务都是可以一次丢进核中完成的。因此，我们采用两个队列，每次把所有可以一次完成的任务分别丢进主副核的队列中（类似拓扑排序的思想），直到队列为空。 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int N=100050; vector&lt;int&gt; E[N]; queue&lt;int&gt; q[2]; int c=0,in[N],col[N],sol=0; int main() { int n,m,u,v,i; scanf(&quot;%i %i&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;col[i]); while(m--) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); E[v].push_back(u); in[u]++;//入度 } for(i=0;i&lt;n;i++) if(!in[i]) q[col[i]].push(i); while(!q[0].empty() || !q[1].empty()) { if(q[c].empty()) {//此队列空了而另一个队列未空,说明需要换队列执行任务了 if (!c) sol++;//副核清空而主核未清空,显然副核需要次数++ c ^= 1;//换核 } u=q[c].front(); q[c].pop(); for(i=0;i&lt;E[u].size();i++) { v=E[u][i]; in[v]--; if(!in[v]) q[col[v]].push(v); } } printf(&quot;%d\n&quot;,sol); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Flucas-e5-ae-9a-e7-90-86%2F</url>
    <content type="text"><![CDATA[Lucas定理是用来解决大组合数取模的，即求$C_n ^m \ mod\ p$,其中$p$为质数。 公式：$C_n ^m\ mod\ p=C_{n/p}^{m/p}\times C_{n\ mod\ p}^{m\ mod\ p}\ mod\ p$ 当模数p在变化时运用暴力方法计算组合数：#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; ll Power_mod(ll a, ll b, ll p)//快速幂 { ll res = 1; while(b!=0) { if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; } return res; } ll Comb(ll a,ll b, ll p)//暴力计算组合数 { if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b;//组合数的性质,C(m,n)=C(m,m-n); ll ans = 1, ca = 1, cb = 1; for(ll i=0; i&lt;b; ++i) {//暴力计算阶乘 ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; } ans = (ca*Power_mod(cb, p-2, p))%p; return ans; } ll Lucas(int n, int m, int p)//Lucas { ll ans = 1; while(n &amp;&amp; m &amp;&amp; ans) { ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; } return ans; } int main() { int n,m,p; while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p) !=EOF) { printf(&quot;%lld\n&quot;, Lucas(n, m, p)); } return 0; } 当模数p固定时则对组合数进行预处理，递推求逆元；#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1e5+5; typedef long long ll; ll inv[maxn],fac[maxn];ll p; void init() { fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=fac[i-1]*i%p;//求阶乘 inv[0] = inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (p - p / i) * inv[p % i] % p;//递推求逆元 } ll C(ll n,ll m) { if (n&lt;m) return 0; return fac[n]*inv[fac[m]]*inv[fac[n-m]]%p;//利用逆元求组合数 } ll lucas(ll n,ll m) { if (!m) return 1ll; return C(n%p,m%p)*lucas(n/p,m/p)%p;//Lucas } int main() { return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe7-bb-84-e5-90-88-e6-95-b0%2F</url>
    <content type="text"><![CDATA[组合数公式： $C_{m}^{n}=\frac{m!}{n!(m-n)!}$ 方法一：利用公式 $C_m^n=C_{m-1}^{n-1}+C_{m-1}^{n}$ 从m个元素里挑n个元素，针对第一个元素要么是n个里的要么不是，如果是的,那么就从剩下的m-1个里挑n-1个 就是c(m-1,n-1);如果第一个元素不是n里的，就从剩下的m-1个元素里挑n个，就是c(m-1,n)。 递归求法： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long comb(int m,int n) { if(n==0) return 1; if(n==1) return m; if(n&gt;m/2) return comb(m,m-n); if(n&gt;1) return (comb(m-1,n-1)+comb(m-1,n)); } int main() { int m,n; while(cin&gt;&gt;m&gt;&gt;n) cout&lt;&lt;comb(m,n)&lt;&lt;endl; return 0; } 方法二： 1、求取1到n的阶乘对 mod 取模的结果存入数组 JC 中； 2、求取 C(n,r) 时， 先利用“拓展欧几里得算法”或者“费马小定理+快速幂”求 JC[r]的逆元存入临时变量 x1 ; 3、然后计算 JC[n] ∗ x1 % mod 存入临时变量 x2;（x2 即为n!/r! %mod 的值） 4、求取JC[n - r] 的逆元存入临时变量 x3; 5、则可以得到 C(n,r)=x2∗x3%mod]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 35 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-35-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力扫即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } B. 最大化最小值，一看就可以二分。注意每个蛋糕都要有去处…所以要注意如果有一种蛋糕非常少的话也是要单独占一盘的…玄学二分居然没死循环，开心 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 说白了就是枚举找规律，会发现有1的时候，或者有俩2，或者3个都是3，又或者一个2配俩4是可以的，其他都是不行的 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int k,cnt[1505]={0},i; for(i=1;i&lt;=3;i++){ cin&gt;&gt;k;cnt[k]++; } if(cnt[1]||cnt[2]&gt;=2||cnt[3]==3||(cnt[2]==1&amp;&amp;cnt[4]==2)){ puts(&quot;YES&quot;); } else puts(&quot;NO&quot;); return 0; } D. 给出一个含有 n 个数的序列，让你求每次反转区间 [ l , r ] 后整个序列的逆序数是奇是偶。 首先有一个朴素的想法就是暴力枚举，当然就算用归并排序去计算逆序对也是会tle的… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int cnt; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } int main() { int n,i,j,a[1600],a1[1600],t[1600],m,l,r; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); cin&gt;&gt;m; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);cnt=0; reverse(a+l,a+r+1); memcpy(a1,a,sizeof(a)); mergesort(a1,1,n,t); //cout&lt;&lt;cnt&lt;&lt;endl; if(cnt&amp;1) puts(&quot;odd&quot;); else puts(&quot;even&quot;); } return 0; } 当将区间$ [ l , r ]$ 反转后，只有该区间内的逆序数产生了变化，其他的不变。具体变化是该区间之前是正序的变成了逆序，之前是逆序的变成了正序。如果我们知道反转前逆序数是奇是偶，再加上知道反转后逆序对相差是奇是偶就可以知道结果了。 设该区间长度为 len，则该区间共有 $len (len-1)/2$ 个数对，设反转后逆序的有 num 个，则正序的有 $len(len-1)/2 - num$ 个，反转前后逆序对相差 $num-( len(len-1)/2 - num )$ 个，化简得 $num 2 - len(len-1)/2$ 个，$num 2$ 一定为偶数，不影响奇偶性，所以只看 $len(len-1)/2 $的奇偶性就可以了。 判断奇偶可以用异或来做 #include&lt;cstdio&gt; int main() { int n,i,j,a[1505],m,l,r,x=0; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); for(i=1;i&lt;n;++i) for(j=i+1;j&lt;=n;++j) x^=a[i]&gt;a[j]; scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);i=r-l+1; x^=(i*(i-1)&gt;&gt;1)&amp;1; puts(x?&quot;odd&quot;:&quot;even&quot;); } return 0; } E. 对于给定的前k个，其实没什么好说的，就是模拟，看里面有对少个数能够直接放到b里面，扫完这k个之后，如果栈里还有那么肯定是那些缺乏小的数以致于无法放进b的，这时候我们为了能够把这些数顺利放进b，肯定是要逐步补齐栈顶项到b中已有项之间缺失的项的，这同时肯定也是字典序最大值。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; const int N=2e5+1; int n,k,a[N],t=1; stack&lt;int&gt;s; int main() { cin&gt;&gt;n&gt;&gt;k; s.push(n+1);//先置入一个n+1以防栈空re for(int i=0;i&lt;n;i++){ if(i&lt;k)cin&gt;&gt;a[i]; else a[i]=s.top()-1;//剩下的都是缺小项无法出栈的 s.push(a[i]); while(s.size()&amp;&amp;s.top()==t)s.pop(),t++; } if(s.size())puts(&quot;-1&quot;);//如果还有剩余说明原来的顺序有问题 else for(int i=0;i&lt;n;i++)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[复习一波，发现都快忘光了QAQ… 利用二分的思想，不断分割排序区间。 void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++]; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i];//这里要注意前面数组的下标 } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } 归并排序课用于计算逆序对，因为如果是非逆序的数，那么在mergearray的时候前面的肯定比后面的小，如果出现一个比后面大的，那么这个数后面的所有前面的数都一定比后面的数大。 int cnt=0; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1;//其实只有这里不同 } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim 游戏]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fnim-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[Nim游戏是组合游戏(Combinatorial Games)的一种，准确来说，属于“Impartial Combinatorial Games”（以下简称ICG）。满足以下条件的游戏是ICG（可能不太严谨）：1、有两名选手；2、两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动；3、对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； 4、如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。根据这个定义，很多日常的游戏并非ICG。例如象棋就不满足条件3，因为红方只能移动红子，黑方只能移动黑子，合法的移动集合取决于轮到哪名选手操作。 经典Nim游戏通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。 我们定义Position: P：表示当前局面下先手必败 N：表示当前局面下先手必胜 结论：(Bouton’s Theorem)： 对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position（后手必胜）当且仅当 a1^a2^…^an=0，其中^表示异或(xor)运算。 可以利用二进制来证明，详细证明过程：https://blog.csdn.net/Summer\_\_show\_/article/details/70185470 如果Nim游戏中的规则稍微变动一下,每次最多只能取K个,怎么处理? Ans：将每堆石子数mod (k+1). Nim的各种变形Moore’s Nimk n堆石子，每次从不超过k堆中取任意多个石子，最后不能取的人失败。 这是一个nim游戏的变形，也是有结论的。 结论为：把n堆石子的石子数用二进制表示，统计每个二进制位上1的个数，若每一位上1的个数mod(k+1)全部为0，则必败，否则必胜。 anti-nim(反Nim游戏) 正常的nim游戏是取走最后一颗的人获胜，而反nim游戏是取走最后一颗的人输。 一个状态为必胜态，当且仅当： 1）所有堆的石子个数为1，且NIM_sum=0 2）至少有一堆的石子个数大于1，且 NIM_sum≠0 例子：Bzoj1022 : https://www.lydsy.com/JudgeOnline/problem.php?id=1022 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int t,i,j,k,n; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; bool onlyone=true; int sum=0; while(n--){ scanf(&quot;%d&quot;,&amp;j); if(j!=1)onlyone=false; sum^=j; } if((onlyone&amp;&amp;!sum)||(!onlyone&amp;&amp;sum)){ puts(&quot;John&quot;); } else puts(&quot;Brother&quot;); } return 0; } 威佐夫博弈 两堆石子，每次可以从一堆或两堆中取任意数目的石子，从两堆中取得时候,从不同堆取的石子个数必须相同，先取完的获胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 奇异局势的3条性质： 1.任何自然数都包含在一个且仅有一个奇异局势中。 2.任意操作都可将奇异局势变为非奇异局势。 3.采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b）： 1.若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）； 2.如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局势； 3.如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab – ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）； 4.如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余的数量a – ak 即可； 5.如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – aj 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，（面对奇异局势）则后拿者取胜。 任给一个局势（a，b），判断它是不是奇异局势（先手负）： $a_k =[k\times \frac{（1+√5）}{2}]， b_k= a_k + k $ （k=0，1，2，…,n ，方括号表示向下取整函数) 其中k由bk-ak求得，如果两个数不符合这样的形式，则不是奇异局势 注意一定要满足a&lt;=b，不满足时对调a，b 例子：http://poj.org/problem?id=1067 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double t=(1+sqrt(5.0))/2;//系数 int a,b,k; while(cin&gt;&gt;a&gt;&gt;b){ if(a&gt;b)swap(a,b); k=b-a; if(a==(int)(k*t)){//计算a是否符合该形式 cout&lt;&lt;0&lt;&lt;endl; } else cout&lt;&lt;1&lt;&lt;endl; } return 0; } 巴什博奕 只有一堆石子共n个。每次从最少取1个，最多取m个，最后取光的人取胜。 如果$n=(m+1)* k+s (s!=0)$ 那么先手一定必胜，因为第一次取走s个，接下来无论对手怎么取，我们都能保证取到所有(m+1)倍数的点，那么循环下去一定能取到最后一个。(也就是说只要n不是m+1的倍数先手必胜) staircase nim 顾名思义就是在阶梯上进行，每层有若干个石子，每次可以选择任意层的任意个石子&gt;将其移动到该层的下一层。最后不能操作的人输。 （这个博弈的解释不是特别明白QAQ） 阶梯博弈经过转换可以变为Nim，把所有奇数阶梯看成N堆石子做nim。把石子从奇数堆移动到偶数堆可以理解为拿走石子，就相当于几个奇数堆的石子在做Nim。 结论：所有奇数阶梯（奇数堆）的石子的Nim sum如果不为0，先手胜，否则后手胜 （以下仅供参考，没太看懂） 假设我们是先手，所给的阶梯石子状态的奇数堆做Nim先手能必胜.我就按照能赢的步骤将奇数堆的石子移动到偶数堆.如果对手也是移动奇数堆，我们继续移动奇数堆.如果对手将偶数堆的石子移动到了奇数堆..那么我们紧接着将对手所移动的这么多石子从那个奇数堆移动到下面的偶数堆.两次操作后.相当于偶数堆的石子向下移动了几个。而奇数堆依然是原来的样子，即为必胜的状态。就算后手一直在移动偶数堆的石子到奇数堆，我们就一直跟着他将石子继续往下移，保持奇数堆不变。我可以跟着后手把偶数堆的石子最终移动到0，然后对手就不能移动这些石子了.所以整个过程.将偶数堆移动到奇数堆不会影响奇数堆做Nim博弈的过程..整个过程可以抽象为奇数堆的Nim博弈. 为什么是只对奇数堆做Nim就可以而不是偶数堆呢？因为如果是对偶数堆做Nim，对手移动奇数堆的石子到偶数堆，我们跟着移动这些石子到下一个奇数堆。那么最后是对手把这些石子移动到了0，我们不能继续跟着移动，就只能去破坏原有的Nim而导致胜负关系的不确定。所以只要对奇数堆做Nim判断即可知道胜负情况。 例子：http://poj.org/problem?id=1704 （ POJ1704） （可参考挑战程序设计竞赛P312） 本题的做法与上面描述的又不完全一致。我们把棋子按位置升序排列后（没有保证一定按升序给出），从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。 在同一对棋子中，如果对手移动前一个，你总能对后一个移动相同的步数，所以一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。于是我们只需要考虑同一对的两个棋子之间有多少空位。 这样一来就成了N堆取石子游戏了. #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,k; int s[1010]; int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;s[i]); sort(s+1, s+n+1); int ans; if(n%2 == 0) { ans = s[2]-s[1]-1; for(int i=4; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } else { ans = s[1]-1; for(int i=3; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Good Bye 2017]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-good-bye-2017%2F</url>
    <content type="text"><![CDATA[A. 模拟即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str;int cnt=0; cin&gt;&gt;str; for(auto a:str){ if(a==&apos;a&apos;||a==&apos;i&apos;||a==&apos;o&apos;||a==&apos;e&apos;||a==&apos;u&apos;||a==&apos;1&apos;||a==&apos;3&apos;||a==&apos;5&apos;||a==&apos;7&apos;||a==&apos;9&apos;) cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. 暴力枚举24种映射的情况即可….题目很简单，但是不是很好写 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; using namespace std; typedef pair&lt;int,int&gt;P; vector&lt;int&gt;per; void rotate(P*a,P*b) { for(int i=0;i&lt;4;i++) a[i]=b[per[i]]; } int main() { P mps[4]={ {0,1},{-1,0},{0,-1},{1,0}},mp[4]; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str; for(i=0;i&lt;4;i++)per.push_back(i); char mp1[55][55]; int x,y; for(i=1;i&lt;=n;i++){ cin&gt;&gt;mp1[i]+1; for(j=1;j&lt;=m;j++){ if(mp1[i][j]==&apos;S&apos;){ x=j,y=i;break; } } } cin&gt;&gt;str;int ans=0; for(int r=1;r&lt;=24;r++){ if(r&gt;1)next_permutation(per.begin(),per.end()); rotate(mp,mps); int x1=x,y1=y; for(auto a:str){ int p=a-&apos;0&apos;; x1+=mp[p].first;y1+=mp[p].second; if(x1&lt;1||x1&gt;m||y1&lt;1||y1&gt;n||mp1[y1][x1]==&apos;#&apos;)break; if(mp1[y1][x1]==&apos;E&apos;){ ans++;break; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 本来想着对于每个新加入的圆找出所有可能跟他冲突的圆进行计算的，但是边界不太好把握…后来发现这个数据范围…直接暴力枚举之前加入的所有圆与这圆冲突的可能即可… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int n,r,x[1005]={0},t,i,j;double y[1005]={0}; scanf(&quot;%d%d&quot;,&amp;n,&amp;r); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x[i]);y[i]=r; for(j=1;j&lt;i;j++) { t = x[i] - x[j], y[i] = max(y[i], y[j] + sqrt(4 * r * r - t * t)); } printf(&quot;%.10f &quot;,y[i]); } return 0; } F. 我们可以用绿色的点把整个线段分开，那么对于每一个区间（两端是绿色的点），有两种选择：1.两个绿色的点不连接，那么就需要把里面所有的红色点蓝色点都连接起来，长度是2 区间长度 2.连接绿色点，那么长度就是区间长度 3-长度最长的连接红点的边-长度最长的连接蓝点的边 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,x,pr,pb,pg,mr,mb,ans=0; char s[10]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%s&quot;,&amp;x,s); if(s[0]==&apos;R&apos;||s[0]==&apos;G&apos;){ if(pr){ ans+=x-pr; mr=max(mr,x-pr); } pr=x; } if(s[0]==&apos;B&apos;||s[0]==&apos;G&apos;){ if(pb){ ans+=x-pb; mb=max(mb,x-pb); } pb=x; } if(s[0]==&apos;G&apos;){ if(pg)ans+=min(0,x-pg-mr-mb); pg=x;mr=0;mb=0; } } printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #498 (Div. 3)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-498-div-3%2F</url>
    <content type="text"><![CDATA[A. 弱智题 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&amp;1)cout&lt;&lt;j&lt;&lt;&apos; &apos;; else cout&lt;&lt;j-1&lt;&lt;&apos; &apos;; } return 0; } B. 从大到小排序，前k大就是所求 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;set&gt; using namespace std; bool cmp(int x,int y) { return x&gt;y; } int main() { int n,k,i,j; int num[2005],num1[2005]; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);num1[i]=num[i]; } sort(num1+1,num1+1+n,cmp); map&lt;int,int&gt;mp1; int sum=0; for(i=1;i&lt;=k;i++)mp1[num1[i]]++,sum+=num1[i]; int pre=1; cout&lt;&lt;sum&lt;&lt;endl; for(i=1;i&lt;=n;i++){ if(mp1.count(num[i])){ k--; if(k)cout&lt;&lt;i-pre+1&lt;&lt;&apos; &apos;; else cout&lt;&lt;n-pre+1&lt;&lt;endl; pre=i+1;mp1[num[i]]--; if(mp1[num[i]]==0)mp1.erase(num[i]); } } return 0; } C. 前后求前缀和即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum[200005]; int main() { int n,i,j,k,d[200005]; cin&gt;&gt;n; map&lt;ll,int&gt;mp1; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;d[i]); sum[i]+=sum[i-1]+d[i]; mp1[sum[i]]=i; } ll ans=0,sum1=0; for(i=n;i;i--){ sum1+=d[i]; if(mp1.count(sum1)){ if(mp1[sum1]&gt;=i) break; else{ ans=sum1; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 注意只能换a中的字母！！ 分析一下可以发现a[i],a[n-i+1],b[i],b[n-i+1]这几个字母之间的位置是可以随便换的，因此只要枚举所有这样的字母组即可。 当4个字母全都不同的时候，a里面两个字母肯定要换； 当有两个相同时，另两个不同（也就是有3种字母），如果两个相同的在a，那么就要两个都换，否则的话都是换1个就够了。 当有3个相同时，换一个即可。 如果4个都相同或者两两相同，不用换。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; int main() { char a[100005],b[100005]; int i,j,k,n; cin&gt;&gt;n&gt;&gt;a+1&gt;&gt;b+1; int sum=0; for(i=1;i&lt;=n/2;i++){ map&lt;char,int&gt;mp1; mp1[a[i]]++;mp1[a[n-i+1]]++;mp1[b[i]]++;mp1[b[n-i+1]]++; if(mp1.size()==4){ sum+=2; } else if(mp1.size()==2){ if(mp1.begin()-&gt;second==2); else{ sum+=1; } } else if(mp1.size()==1); else{ if(a[i]==a[n-i+1])sum+=2; else sum+=1; } } if(n&amp;1){ if(a[n/2+1]!=b[n/2+1])sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; } E. 题目很长，但其实就是一个很简单的dfs。因为他的dfs顺序是固定的，所以我们会发现其实只要从根开始dfs一遍，并把结果保存起来即可，以后每次询问查询一下即可。完全模拟会tle，每个节点保存自己的子树则会mle，所以只能在根那里保存结果。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N=2e5+5; vector&lt;int&gt;G[N]; vector&lt;int&gt;ans; int child[N]; int pos[N]; int dfs(int x) { ans.push_back(x); pos[x]=ans.size()-1; child[x]++; for(auto a:G[x]){ child[x]+=dfs(a); } return child[x]; } int main() { int n,q,i,j,k,u; cin&gt;&gt;n&gt;&gt;q; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); for(i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;k); if(child[u]&lt;k){ printf(&quot;-1\n&quot;); } else{ printf(&quot;%d\n&quot;,ans[pos[u]+k-1]); } } return 0; } F. 有一个非常simple的dp做法，但是会mle，即使换成滚动数组也会tle… #include &lt;bits/stdc++.h&gt; using namespace std; long long n,m,k; map&lt;long long,long long&gt; a[25][25]; long long b[25][25]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) cin&gt;&gt;b[i][j]; a[1][1][b[1][1]]++; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { for (auto k:a[i-1][j]) { a[i][j][k.first^b[i][j]]+=k.second; } for (auto k:a[i][j-1]) { a[i][j][k.first^b[i][j]]+=k.second; } } cout&lt;&lt;a[n][m][k]; } 正解的话，是人为的划了一条线，即i+j==n+1，这是一条斜对角线，我们分别从（1，1）和（n，m）处开始搜索，如果能够到达中线，就做一个记录，然后统计答案。 #include &lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll num[25][25]; map&lt;ll,ll&gt;mp[25]; ll n,m,k; void dfs1(int i,int j,ll v) { v^=num[i][j]; if(i+j==n+1){ mp[i][v]++;return;//如果到达中线就不用再搜下去了 } if(i&lt;n)dfs1(i+1,j,v); if(j&lt;m)dfs1(i,j+1,v); } ll ans=0; void dfs2(int i,int j,ll v) { if(i+j==n+1) { ans += mp[i][v ^ k];return;//到达中线,我们希望遇到的中线处的值是v^k, // 因为在中线下半部分的xor和为v,v^k^v=k,满足题意 } v^=num[i][j]; if(i&gt;1)dfs2(i-1,j,v); if(j&gt;1)dfs2(i,j-1,v); } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf(&quot;%lld&quot;,&amp;num[i][j]); dfs1(1,1,0);dfs2(n,m,0); cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 47 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-47-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 按照题意模拟即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;deque&gt; using namespace std; int main() { deque&lt;int&gt;a; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; int c[1005]; for(i=1;i&lt;=n;i++)cin&gt;&gt;c[i]; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);a.push_back(j); } int cnt=0; for(i=1;i&lt;=n;i++){ if(!a.empty()&amp;&amp;a.front()&gt;=c[i]){ a.pop_front();cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. 首先我们注意到1是可以任意移动的，也就是说1可以移动到任何一个位置，而2是比较麻烦的，因此我们从前往后扫描，每扫描到一个2就记录一下当前扫描到的这段0 的数目，然后丢进vector里记录下来。注意：要记得特判没有2 的情形！ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string s; int num0(0), num1(0); vector &lt;int&gt; v; bool pd(false); int main() { cin &gt;&gt; s; for (auto i : s) { if (i == &apos;0&apos;)num0++;//统计0 else if (i == &apos;1&apos;)num1++;//统计1 else {//遇到2 v.push_back(num0); num0 = 0; } } for (auto i : v) {//2把连续的0分成了很多段 for (int j = 1; j &lt;= i; j++)cout &lt;&lt; 0; if (!pd) for (int j = 1; j &lt;= num1; j++)cout &lt;&lt; 1;//1可以全部移到第一个之前 cout &lt;&lt; 2; pd = true; } for (int j = 1; j &lt;= num0; j++)cout &lt;&lt; 0; if(!pd){//一定要特判没有2的情形 for(int i=1;i&lt;=num1;i++)cout&lt;&lt;1; } return 0; } C. 其实这题看懂之后似乎是挺简单的…?显然d如果是正的，我们 就希望dist之和最大，可以发现是放数列的两端最佳，否则的话就选在数列的中间可以使得dist之和最小。记得开longlong即可。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; int main() { ll n, m; ll ans=0, x, d; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; d; ans += x * n; if (d &gt; 0) { ans += d * n * (n - 1) / 2; } else { ans += ((n % 2 == 0) ? (n / 2 * n / 2 * d) : ((n + 1) / 2 * (n - 1) / 2 * d)); } } printf(&quot;%.20lf&quot;,(double)ans / n); return 0; } D. 要注意一点，就是构造的图必须是联通的。虽然题目范围看似很大，理论是暴力枚举复杂度1e10,但是m小哇，暴力从小到大枚举成对的互质的数，其实很快就够了，如果impossible的话只可能是n比较小m比较大的情况。然后注意m如果小于n-1的话那么这幅图怎么看都不可能的联通的（要求是每个点都必须在这个图里面，所以一个行之有效的办法就是每个电脑都跟1连接起来）； #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int gcd(int x,int y) { return y?gcd(y,x%y):x; } typedef pair&lt;int,int&gt;P; int main() { int n,m,i,j,k,cnt=0; cin&gt;&gt;n&gt;&gt;m; vector&lt;P&gt;ans; if(m&lt;n-1){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } for(i=1;i&lt;n;i++) for(j=i+1;j&lt;=n;j++){ if(gcd(i,j)==1){ m--;ans.push_back(P(i,j)); if(!m)goto step; } } if(m){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } step:cout&lt;&lt;&quot;Possible&quot;&lt;&lt;endl; for(auto a:ans) printf(&quot;%d %d\n&quot;,a.first,a.second); return 0; } E. 某人从x=0旅行至x=n，在上次休息过后走当前公里的疲劳值为ai，休息点的位置不确定，求疲劳值之和的数学期望。 对于某个位置x=i，疲劳值为ai的可能休息点情况数为2^(n-i)种，疲劳值为aj(j&lt;i)的可能休息点情况数为2^(n-i-1)种。处理过后发现对于某个疲劳值ai，其总的出现情况数为2^(n-i)+2^(n-i-1)* (n-i)。之后直接套公式即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int mod=998244353; long long a[1000005],b[1000005]; int main() { int n,i,j,k; cin&gt;&gt;n; b[0]=1; for(i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); b[i]=(b[i-1]&lt;&lt;1)%mod; } long long ans=0; for(i=1;i&lt;=n;i++){ ans+=a[i]*b[n-i]%mod; ans+=a[i]*b[n-i-1]%mod*(n-i)%mod;//注意多mod防止爆int } cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F20172018%2F</url>
    <content type="text"><![CDATA[过去的一年前几天考完了这学期的最后一科，那么，大一也就算是结束了吧，回想过去的一年，总想写点什么，却又不知道如何入手，那现在就纯当流水账随便写写吧。 去年，2017，是相当奇幻的，一场高考将一年横劈为二。刚考完那天下午拿出了尘封已久的iPad，打了一会wotb，但是似乎应了那句话——游戏还是考试前的好玩，考完之后变得有些索然无味起来。4天之后剁了个游戏本，然后开启了暑假的沉迷游戏之旅。不过后来开学后很快就后悔买了个如此厚重的游戏本，当然这是后话了。 暑假先是跟同学一起去了趟贵州，现在想想这趟旅程其实是有些令人失望的。贵州本身并不太好玩，花在路上的时间奇长无比。更重要的是高中的一群同学，似乎总有些说不清的隔阂感吧，也许是一群清北聚聚实在跟我这种裸考弱渣差别过大吧。而且感觉起来，高中同学总体还是比较奇特的，整个班级总是缺少些凝聚力，或许是大家都太有个性了，也可能是大家高中都忙，总而言之，并没有非常好的体验。 回来之后填了个志愿。我也不知道为什么我就想报计算机，也许是被某乎洗脑了吧，自己也看起来是有点兴趣。 记得当时还跟父母吵了一架，因为不知道选哪个学校。当时也不知道为何就选定了小破邮，不过现在想想哈深的计算机我还不够分来着，当时如果填了现在可能就在学机械了（摔）。现在想想似乎倒也不算什么错误的决定——小破邮虽破，但是偏远的沙河倒也能让人专心下来学习，而且说实话吧，基本上该有的设施也都算有了，更重要的是，小破邮的同学总体上感觉还是挺好的~总体而言学风良好，而且也有非常多在我看起来非常厉害的同学，让我感觉自己非常的蒟蒻QAQ。 后来的假期基本上就是打游戏，学架子鼓，踢足球，健身几样之间轮换。不得不说我还是挺难去坚持一些爱好的…现在除了偶尔去去健身房，其他几项基本都荒废了，虽说这一年来确实忙碌，但是难以持之以恒似乎也成为了我一贯以来的坏毛病吧。8月去了趟新疆，总体而言，景色是优美的，但是暑假浩浩荡荡的人流实在是令人难以提起任何游玩的兴致。而后又去西安搞了趟疯狂之旅，现在想想是有些后悔的，浪费钱，浪费时间。 打游戏的假期还是过得挺快的，一转眼就开学了。两周的军训令人印象深刻，大概是这辈子迄今为止过得最难受的两周了，生活质量奇差，而且毫无意义。用一句政治不正确的话来说，就是两周的参军劝退课，除了没拔草，部队里可以干的无聊事似乎都体验的差不多了。反正，个人是非常反感这种毫无意义的官僚性课程的。 回来以后就开学，不过国庆前基本上啥都没看，每天就是玩一玩，看一看，倒也悠哉悠哉。加了学生会的一个部门，现在想想这个还是挺有意义的…因为没进这部门的话，|没认识某菊苣的话，我可能已经被编程劝退了，更不会混进实验班了…也就没有很多故事了233…中间也没啥事，直到9.27——那一天，我突然开始研究了一波C Primer Plus，写了第一个C程序，啥内容不记得了，总之，感觉挺好玩的，也让我对这玩意儿突然感兴趣起来。现在想想，除了一开始的兴趣以外，大概也跟程序的反馈性有关吧——即时的输出，虽然只是控制台那个黑框框。以及后来的各种OJ，AC，WA，TLE，其实都令人刺激，不像那艹蛋的高数，至今都提不起什么兴趣。 后面大概就是上课，上课，其实印象都不是很深，因为第一个学期其实只有一件事令我感兴趣，那就是编程。当时花了大概一个月大致看了看C的基本语法，然后就开始对算法有了些兴趣——大概跟头几次机考的时候激动人心的排行榜也有点关系吧。总之期中之后，除了研究新算法写OJ，当时啥都不想干，连游戏都没碰过，导致我寒假把游戏本给卖了（笑）。不过平心而论，研究一个算法，试着用它去套一些简单模板题，获得一个个AC，真的是挺有意思的，让我大半个学期乐此不疲。第一学期怎么说呢，其实自我感觉还是挺认真的，可惜就是对课内的事情不太上心，最后成绩也不怎么好看，高数学得乱七八糟某种意义上也影响了第二学期的高数。当时想着第二学期一定要好好做人，不能忽视课内的东西，然而一连串的意外还是让这个设想落空了…事实上，这学期总体而言依然的挺糟糕的。 寒假过的其实不是很妙。回家前去了趟天津，其实并不好玩，不过一起去的小伙伴还是挺有意思的。回家之后实在是有点颓，本来想好好研究一波算法的，但是现在想想好像当时也没干什么，后来日子也就过去了。年后去了趟埃及，当时的日程安排的不是特别好，当然这个国家不一样的风情还是挺有意思的。总而言之，寒假延续了我一贯以来放假颓废的作风。 开学就是新生赛，最后结果还是ok的，毕竟一群OI菊苣们压阵，一个小白也就这样了吧。然后就是校赛的网络赛，第一次组队搞了一波，也算是认识了第一波队友吧。再后面就是实验班的选拔，不得不说这事还是挺糟心的，不知道是谁加的报名限制——智育前40%。反正就记得那周挺难受的，平心而论学院这么定其实也无可厚非，但我还是非常的郁闷。毕竟一个机考选拔，如果连参加的机会都没有的话，还是令人挺难以接受的。幸好后来好像并没有人记得有这么一回事，机考也顺利的参加了。不过那段时间大概状态不太好吧，加上内心忧郁，所以机考的的时候纯粹是靠罚时少把排名拉了上来。然后就是面试，忐忑地邓结果。当时面试的时候被老师问了一堆课内成绩的情况，感觉自己快凉了，幸好最后还是过了。校赛的话我们队感觉都不在状态，罚时爆炸混了个铜，不过当时想想，也算是混进实验班了，也不能太希望一切都很顺利吧。 不过，开学那会忙于准备各种赛，之后又是糟心的选拔，然后转班又是一片混乱，某种意义上也很大的影响了这学期后续的课程。特别是模电，转过去之后发现他们已经上完了，于是到最后我也没怎么学这玩意儿，期末也是不明不白混过去了。期末的半个月其实也努力了一下希望拯救一下课内，但其实最后也就那样了，积重难返。 应该说，这个班牛人还是很多的，比起来我其实啥都不行——代码不如OI党，课内成绩一塌糊涂，我也不知道说什么好了QAQ，希望可以在众多菊苣的刺激下以后做的更好吧…然后这半个学期也有幸遇到了几位挺好的同学，几位菊苣愿意搭理我这个蒟蒻，其实还是挺开心的，也算有些感谢吧…之前还有点担心会不会混成孤家寡人的感觉…. 流水账写了写，发现时间还是过得很快的。总体上来说，这一年还是挺忙的，每天都过得很快，也算是挺充实了。当然后来还是有点颓了，而且绩点应该算是挺糟糕了……一年换了两个班，认识了一大波新同学，还是蛮开心的。希望暑假的训练，以及后面的大二，可以吸取经验，过得更顺利一些吧，也争取混个更好的成绩。加油！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #456 (Div. 2) D.Fishes]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-456-div-2-d-fishes%2F</url>
    <content type="text"><![CDATA[显然，暴力模拟每个r* r的框覆盖是会tle的，我们不妨换一种思路，即计算每个cell被多少个框所覆盖。 可以发现，在位置x，y的cell的框覆盖数为： 因此，总的框覆盖数就是 注意到无论是怎么样的情况，位于(n+1)/2,(m+1)/2处的cell的框覆盖数一定是最大的之一，因此我们可以从这个cell开始bfs，但是这里的queueu采用有限队列，即以框覆盖数为优先值。最后注意一下重复的问题即可（写的时候用set判了一下重）。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;set&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt;P; struct cell{ int x,y;ll f; bool operator&lt;(const cell&amp;v)const{ return f&lt;v.f; } }; int n,m,r,k; ll cal(int x,int y) { return (ll)(min(n+1,x+r)-max(x,r))*(min(m+1,y+r)-max(y,r)); } bool ch(int x,int y) { if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return false; return true; } int main() { int i,j; int move1[4][2]={-1,0,1,0,0,-1,0,1}; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;k; priority_queue&lt;cell&gt;que; set&lt;P&gt;ck; ll sum=0; que.push(cell{(n+1)/2,(m+1)/2,cal((n+1)/2,(m+1)/2)}); ck.insert(P((n+1)/2,(m+1)/2)); while(!que.empty()){ k--; cell t=que.top();que.pop(); sum+=t.f; for(i=0;i&lt;4;i++){ int x1=t.x+move1[i][0],y1=t.y+move1[i][1]; if(ch(x1,y1)&amp;&amp;!ck.count(P(x1,y1))){ que.push(cell{x1,y1,cal(x1,y1)});ck.insert(P(x1,y1)); } } if(!k)break; } printf(&quot;%.10f\n&quot;,(double)sum/((ll)(n-r+1)*(m-r+1))); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Hello 2018]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-hello-2018%2F</url>
    <content type="text"><![CDATA[A. 2的幂次比较大的时候显然直接输出m就行了，比较小的时候暴力算一下就行。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { long long n,m; cin&gt;&gt;n&gt;&gt;m; if(n&gt;=63){ cout&lt;&lt;m&lt;&lt;endl; } else{ cout&lt;&lt;m%(1LL&lt;&lt;n)&lt;&lt;endl; } return 0; } B. dfs判断一下即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;G[1005]; bool dfs(int x) { if(G[x].empty()) return true; if(G[x].size()&amp;&amp;G[x].size()&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } int cnt=0; for(auto a:G[x]) if(dfs(a)) cnt++; if(cnt&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } return false; } int main() { int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; return 0; } C. 咋一看感觉是个完全背包，然而1e9的范围加上可以超过L，使得背包不太可能。 因为容量都是2的幂次，因此一个显然的优化就是，如果ci+1&gt;ci * 2，那么显然买i+1不如买两个i，因此可以把i+1给换掉。 做完这个替换之后，有一点显然的就是如果最终买的总容量不超过L的话，那么显然是买小容量的不如买大容量的。但是还有一个问题就是有可能买超出L的总容量会更划算，所以我们从大容量枚举到小容量，对于每个容量，我们都考虑如果最小的容量就是他的情况，并用此去更新答案。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;c; typedef long long ll; int main() { int n,i,j,k,l; cin&gt;&gt;n&gt;&gt;l; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;c.push_back(j); } for(i=0;i&lt;c.size()-1;i++){ c[i+1]=min(c[i+1],c[i]&lt;&lt;1); } ll sum=0,ans=1LL&lt;&lt;62; for(i=n-1;~i;i--){ int need=l/(1&lt;&lt;i); sum+=(ll)need*c[i]; l-=need*(1&lt;&lt;i); ans=min(ans,sum+(l?c[i]:0)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 这是一个比较复杂的排序问题。 首先我们将考试按a从大到小排序，a相同时按t从小到大排序。然后依次拿出每个考试，用一个大根堆维护我们选择的考试，大根堆根据每个考试的t排序。对于每个从序列中拿出的考试，如果它的门数==堆中的考试数，那么只有这个考试的t比堆顶的考试的t小的时候我们才有必要把他丢进去。如果拿出的考试的a&gt;=堆中门数+1，那么如果堆中总和+拿出的t&lt;=总时长，就直接丢进堆。否则把拿出的考试与堆顶考试中t比较小的放进去即可。最后堆中考试即为所求。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct test{ int id,a,t; bool operator&lt;(const test&amp;v)const{ return t&lt;v.t; } }T[200005]; bool cmp(test a,test b) { if(a.a==b.a) return a.t&lt;b.t; return a.a&gt;b.a; } int main() { int n,t,i,j,cnt=0; cin&gt;&gt;n&gt;&gt;t; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;T[i].a,&amp;T[i].t);T[i].id=i; } sort(T+1,T+1+n,cmp); priority_queue&lt;test&gt;que; for(i=1;i&lt;=n;i++){ if(T[i].a==que.size()){ if(!que.empty()){ if(que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } else if(T[i].a&gt;=que.size()+1){ if(cnt+T[i].t&lt;=t){ que.push(T[i]);cnt+=T[i].t; } else{ if(!que.empty()&amp;&amp;que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } } cout&lt;&lt;que.size()&lt;&lt;endl&lt;&lt;que.size()&lt;&lt;endl; while(!que.empty()){ cout&lt;&lt;que.top().id&lt;&lt;&apos; &apos;;que.pop(); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mash up占坑]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2Fmash-up-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Life 占坑]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2Flife-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 36 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-educational-codeforces-round-36-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 签到题不解释 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; bool cmp(int a,int b) { return a&gt;b; } int main() { int n,k,i,j; //cin&gt;&gt;n; vector&lt;int&gt;v; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(k%j==0)v.push_back(j); } sort(v.begin(),v.end(),cmp); cout&lt;&lt;k/v[0]&lt;&lt;endl; return 0; } B. 总共只有两种情况：先关左边再关右边，或者反过来，讨论一下特殊边界情形即可，签到*2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,pos,l,r,i,j,k; cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r; if(l==1&amp;&amp;r==n){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(l==1&amp;&amp;r!=n){ cout&lt;&lt;abs(pos-r)+1&lt;&lt;endl; } else if(l!=1&amp;&amp;r==n){ cout&lt;&lt;abs(pos-l)+1&lt;&lt;endl; } else{ int a=abs(pos-l)+1+abs(r-l)+1; int b=abs(pos-r)+1+abs(l-r)+1; cout&lt;&lt;min(a,b)&lt;&lt;endl; } return 0; } C. 显然我们是想求一个满足条件的字典序最大的排列，那么对于每一位，我们从可放置的最大数出发，找出在当前状况下后续能排出的最小序列，跟b剩下的位数比较，如果最小序列比b小，那么这一位就可以放最大的数。否则这一位就必须放比较小的数。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; int cnt[15]; string build(void) { string res; for(int i=0;i&lt;10;i++){ for(int j=1;j&lt;=cnt[i];j++) res+=char(i+&apos;0&apos;); } return res; } int main() { string a,b;int i,j,k; cin&gt;&gt;a&gt;&gt;b; int num[25]; for(i=0;i&lt;b.size();i++) num[i]=b[i]-&apos;0&apos;;//每位数字,便于比较 for(i=0;i&lt;a.size();i++)//统计每种数字的个数 cnt[a[i]-&apos;0&apos;]++; if(a.size()&lt;b.size()){//如果位数少直接输出最大排列 for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl;return 0; } string ans;bool ismall=false; for(i=0;i&lt;a.size();i++){ if(ismall)break; for(j=num[i];~j;j--){//寻找这一位最大的可能 if(cnt[j]){ cnt[j]--; if(j&lt;num[i]){//如果这一位已经比b小了,直接输出后续最大排列即可 ismall=true;ans+=char(j+&apos;0&apos;);break; } string minn=build();string bnow=b.substr(i+1);//寻找在当前情况下后续能排出的最小排列 if(minn&lt;=bnow){ ans+=char(j+&apos;0&apos;); break; } cnt[j]++; } } } cout&lt;&lt;ans; for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl; return 0; } D. 给定一幅有向图，问是否可以最多去掉一条边使得该有向图无环？ 题目的做法比较神奇。一开始的想法是先求一波强连通分量，然后特判一下强连通分量为1的情况，然而test56 GG了。 看到一种做法，即从1~n，每次以不同的起点开始dfs找环，判断图中是否可能存在只去掉一条边就无环的情况（当然要是本来就没环那就是废话）。 为什么从不同的点开始dfs结果会不一样？因为这道题中会有一种比较奇特的情形，有可能有多个环都依赖于一条有向边而存在，比如样例1（如图） 在这里会发现2-&gt;3的边是一条关键边，从3开始搜索时因为先到2，再开始搜索1，因此vis[2]=1而不会被1搜索到，于是cnt只有1.因此这就是“YES”。 看起来似乎还是挺奇妙的233 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[505]; int cnt; int vis[505]; void dfs(int x) { vis[x]=2;//正在当前搜索序列中的标记为2 for(auto a:G[x]){ if(vis[a]==2) cnt++;//每找到一个环cnt++ else if(!vis[a]) dfs(a); } vis[x]=1;//已经访问过但不是当前搜索序列中的标记为1 } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); } for(i=1;i&lt;=n;i++){ memset(vis,0,sizeof(vis));cnt=0; dfs(i); for(j=1;j&lt;=n&amp;&amp;cnt&lt;=1;j++) if(!vis[j]) dfs(j); if(cnt&lt;=1){//如果从这个点出发只找到一个环(关建边) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } E. 给定一个初始全为1的序列，不停地给出一个比较短的序列(l,r),将(l,r)范围内数全部变为1或0（根据k的值决定）。序列范围较大。 一眼看下去感觉线段树能搞，一看范围1e9…事实上这道题又是一个用map维护区间信息的典例…我们将连续的工作日区间按右端点为关键值插入map中，map的第二个键值就是区间的左端点。那么初始时有range[n]=1 对于每次询问，我们找出大于l的的最小的在map中的工作区间，把它与这次询问的区间相交的部分全部删去，然后依次类推直至map中的区间不与询问区间相交。如果k=2，那么答案加上r-l+1即可。为什么不讨论k=1？因为即使是k=1，询问的空间也可能是支离破碎的，并不容易统计，不如把他们全部删掉重置。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int main() { map&lt;int,int&gt;range;//标记周期 int n,i,j,k,q; cin&gt;&gt;n&gt;&gt;q; range[n]=1;int ans=n; for(i=1;i&lt;=q;i++){ int l,r,k; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); auto a=range.lower_bound(l);//找出大于等于询问区间的第一个map的右端点 while(a!=range.end()){ int cl=a-&gt;second,cr=a-&gt;first; if(cl&gt;r)break;//如果区间的左端点已经大于询问区间的右端点,显然没有交集了 ans-=(min(cr,r)-max(cl,l)+1);//除去询问区间的所有工作日 range.erase(a++);//删去重叠区间 if(cr&gt;r)range[cr]=r+1;//如果大区间被询问区间肢解了,加入小的未涉及区间 if(cl&lt;l)range[l-1]=cl; } if(k==2){ range[r]=l;ans+=r-l+1;//k=2时加入询问区间 } printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）Splay 平衡树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fsplay%2F</url>
    <content type="text"><![CDATA[您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 1.插入 xx 数 2.删除 xx 数(若有多个相同的数，因只删除一个) 3.查询 xx 数的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，因输4.出最小的排名) 5.查询排名为 xx 的数 6.求 xx 的前驱(前驱定义为小于 xx ，且最大的数) 7.求 xx 的后继(后继定义为大于 xx ，且最小的数) 洛谷P3369 不讲解，直接上代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int MAXN=1000000; int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN]; int nodecnt,root; void clear(int x)//清除(当这个点被删除之后) { ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0; } bool get(int x)//判断是父节点的左节点还是右节点 { return ch[f[x]][1]==x; } void update(int x)//更新当前点以下的元素个数(发生修改以后更新) { if (x){ size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; } } void rotate(int x)//旋转 { int old=f[x],oldf=f[old],whichx=get(x); ch[old][whichx]=ch[x][whichx^1]; f[ch[old][whichx]]=old; ch[x][whichx^1]=old; f[old]=x; f[x]=oldf; if (oldf) ch[oldf][ch[oldf][1]==old]=x; update(old); update(x); } void splay(int x)//splay,不停地rotate直到满足要求 { for (int fa;fa=f[x];rotate(x)) if (f[fa]) rotate((get(x)==get(fa))?fa:x); root=x; } void insert(int x)//插入 { if (root==0) { nodecnt++; ch[nodecnt][0] = ch[nodecnt][1] = f[nodecnt] = 0; root = nodecnt; size[nodecnt] = cnt[nodecnt] = 1; key[nodecnt] = x; return; } int now=root,fa=0; while(1){ if (x==key[now]){ cnt[now]++; update(now); update(fa); splay(now); break; } fa=now; now=ch[now][key[now]&lt;x]; if (now==0){ nodecnt++; ch[nodecnt][0]=ch[nodecnt][1]=0; f[nodecnt]=fa; size[nodecnt]=cnt[nodecnt]=1; ch[fa][key[fa]&lt;x]=nodecnt; key[nodecnt]=x; update(fa); splay(nodecnt); break; } } } int find(int x)//查询x的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，应输出最小的排名) { int now=root,ans=0; while(1){ if (x&lt;key[now]) now=ch[now][0]; else{ ans+=(ch[now][0]?size[ch[now][0]]:0); if (x==key[now]){ splay(now); return ans+1; } ans+=cnt[now]; now=ch[now][1]; } } } int findx(int x)//寻找排名为x的数 { int now=root; while(1){ if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else{ int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp; now=ch[now][1]; } } } int pre()//求 xx 的前驱(前驱定义为小于 xx ，且最大的数),注意这个数不一定在树中 { int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now; } //注意,查找某个数的前驱后驱时,要先把这个数插进树中,然后把这个数转到根节点(insert中已集成), //求x的前驱其实就是求x的左子树的最右边的一个结点，后继是求x的右子树的左边一个结点,求完后要删除这个点 int next1()//求 xx 的后继(后继定义为大于 xx ，且最小的数) { int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now; } void del(int x)//删除值为x的节点 { int whatever=find(x);//主要作用就是把x旋转到根节点...不能省略 if (cnt[root]&gt;1) { cnt[root]--; update(root); return; } if (!ch[root][0]&amp;&amp;!ch[root][1]) { clear(root); root = 0; return; } if (!ch[root][0]) { int oldroot = root; root = ch[root][1]; f[root] = 0; clear(oldroot); return; } else if (!ch[root][1]) { int oldroot = root; root = ch[root][0]; f[root] = 0; clear(oldroot); return; } int leftbig=pre(),oldroot=root; splay(leftbig); ch[root][1]=ch[oldroot][1]; f[ch[oldroot][1]]=root; clear(oldroot); update(root); } int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k); if(j==1){ insert(k); } else if(j==2){ del(k); } else if(j==3){ cout&lt;&lt;find(k)&lt;&lt;endl; } else if(j==4){ cout&lt;&lt;findx(k)&lt;&lt;endl; } else if(j==5){ insert(k);cout&lt;&lt;key[pre()]&lt;&lt;endl;del(k); } else if(j==6){ insert(k);cout&lt;&lt;key[next1()]&lt;&lt;endl;del(k); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2FUncategorized%2Ftest-1%2F</url>
    <content type="text"><![CDATA[testtesttest#include&lt;iostream&gt; int main() { std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; return 0; } hjsfkwhfkhfh fsdfggs hkjhka jhhhj njhkkjk $f^2+2f+4$ ~hjkahfh~ 中文测试 测试测试]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2FUncategorized%2Fe4-bd-a0-e5-a5-bd-e4-b8-96-e7-95-8c%2F</url>
    <content type="text"><![CDATA[Welcome to WordPress. This is your first post. Edit or delete it, then start writing!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
</search>
