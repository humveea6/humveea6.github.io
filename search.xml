<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Â∑¶ÂÄºÂºïÁî®‰∏éconstÈôêÂÆöÁ¨¶]]></title>
    <url>%2FCpp%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2FCpp%2F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%2Fconst%2F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8Econst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[ÂºïÁî® ËøôÈáåÁöÑÂºïÁî®ÊåáÂ∑¶ÂÄºÂºïÁî®ËÄå‰∏çÊòØC++11‰∏≠ÁöÑÂè≥ÂÄºÂºïÁî® ÂºïÁî®‰∏∫ÂØπË±°Ëµ∑‰∫Ü‰∏Ä‰∏™Âà´Âêç„ÄÇÊ≥®ÊÑèÔºöÂºïÁî®Âπ∂‰∏çÊòØÂØπË±°ÔºåÂÆÉÂè™ÊòØ‰∏∫‰∏Ä‰∏™Â∑≤ÁªèÂ≠òÂú®ÁöÑÂØπË±°ÊâÄËµ∑ÁöÑÂè¶Â§ñ‰∏Ä‰∏™ÂêçÂ≠ó„ÄÇ Âõ†‰∏∫ÂºïÁî®‰∏çÊòØ‰∏Ä‰∏™ÂØπË±°ÔºåÊâÄ‰ª•‰∏çËÉΩÂÆö‰πâÂºïÁî®ÁöÑÂºïÁî®ÔºÅ ‰∏∫ÂºïÁî®ËµãÂÄºÔºåÂÆûÈôÖ‰∏äÊòØÊääÂÄºËµãÁªô‰∫ÜÂºïÁî®ÁªëÂÆöÁöÑÂØπË±°ÔºåËé∑ÂèñÂºïÁî®ÁöÑÂÄºÔºåÂÖ∂ÂÆû‰πüÊòØËé∑Âèñ‰∫ÜÂºïÁî®ÁªëÂÆöÂØπË±°ÁöÑÂÄº„ÄÇ ÂºïÁî®ÁöÑÁ±ªÂûãÂøÖÈ°ªÂíåË¶ÅÁªëÂÆöÁöÑÂØπË±°‰∏•Ê†ºÂåπÈÖçÔºàÊØîÂ¶ÇintÁ±ªÂûãÁöÑÂºïÁî®‰∏çËÉΩÁªëÂÆöÂú®double‰∏äÔºâÔºå‰ΩÜÊòØÊúâ2‰∏™‰æãÂ§ñ„ÄÇËÄå‰∏îÂºïÁî®Âè™ËÉΩÁªëÂÆöÂú®ÂØπË±°‰∏äËÄå‰∏çËÉΩ‰∏éÂ≠óÈù¢ÂÄºÊàñËÄÖÊüê‰∏™Ë°®ËææÂºèÁöÑËÆ°ÁÆóÁªìÊûúÁªëÂÆöÂú®‰∏ÄËµ∑„ÄÇ Âú®ÂÆö‰πâÂºïÁî®Êó∂ÔºåÁ®ãÂ∫èÊääÂºïÁî®Ë∑üÂÆÉÁöÑÂàùÂßãÂÄºÁªëÂÆöÂú®‰∏ÄËµ∑ÔºàËÄå‰∏çÊòØÊã∑Ë¥ùÔºâÔºåÊó†Ê≥ï‰ª§ÂºïÁî®ÁªëÂÆöÂà∞Âè¶‰∏Ä‰∏™ÂØπË±°ÔºåÊâÄ‰ª•ÂºïÁî®ÂÆö‰πâÊó∂ÂøÖÈ°ªË¢´ÂàùÂßãÂåñ„ÄÇ constconstÂØπË±°‰∏ÄÊó¶ÂàõÈÄ†Â∞±‰∏çËÉΩÂÜçÊõ¥ÊîπÔºåÊâÄ‰ª•constÂØπË±°ÂøÖÈ°ªË¢´ÂàùÂßãÂåñÔºõ ÈªòËÆ§ÊÉÖÂÜµ‰∏ãconstÂØπË±°Ë¢´ËÆæÂÆö‰∏∫‰ªÖÂú®Êñá‰ª∂ÂÜÖÊúâÊïàÔºåÂΩìÂ§ö‰∏™Êñá‰ª∂ÂÜÖÂá∫Áé∞ÂêåÂêçÁöÑconstÂèòÈáèÊó∂Áõ∏ÂΩì‰∫éÂú®‰∏çÂêåÊñá‰ª∂‰∏≠ÂàÜÂà´ÂÆö‰πâ‰∫ÜÁã¨Á´ãÂèòÈáèÔºõÂ¶ÇÊûúË¶ÅÂú®Â§ö‰∏™Êñá‰ª∂‰∏≠‰ΩøÁî®Âêå‰∏Ä‰∏™constÂèòÈáèÔºåÈÇ£‰πàÂÆÉÁöÑÂ£∞Êòé‰∏éÂÆö‰πâÈÉΩÂ∫îËØ•Âä†‰∏äexternÂÖ≥ÈîÆÂ≠óÔºàÂ≠òÁñëÔºâÔºõ constÁöÑÂºïÁî®ÂèØ‰ª•ÊääÂºïÁî®ÁªëÂÆöÂà∞constÂØπË±°‰∏äÔºåÂ∞±ÂÉèÁªëÂÆöÂà∞ÂÖ∂‰ªñÂØπË±°‰∏ä‰∏ÄÊ†∑ÔºåÁß∞‰πã‰∏∫ÂØπÂ∏∏ÈáèÁöÑÂºïÁî®„ÄÇÂØπÂ∏∏ÈáèÁöÑÂºïÁî®Âπ∂‰∏çËÉΩ‰øÆÊîπÂÆÉÁªëÂÆöÁöÑÂØπË±°ÔºåÂêåÊó∂ÔºåÈùûÂ∏∏ÈáèÂºïÁî®‰πü‰∏çËÉΩÁªëÂÆöÂà∞Â∏∏ÈáèÂØπË±°‰∏äÔºõ‰æãÂ¶ÇÔºö123const int ci=1024;const int &amp;ri=ci;//Ê≠£Á°Æ,ÂºïÁî®ÂèäÂÖ∂ÂØπÂ∫îÂØπË±°ÈÉΩÊòØÂ∏∏Èáèint &amp;r2=ci;//ÈîôËØØ,ËØïÂõæÁî®‰∏Ä‰∏™ÈùûÂ∏∏ÈáèÂºïÁî®ÊåáÂêë‰∏Ä‰∏™Â∏∏ÈáèÂØπË±° ‚ÄúÂØπconstÁöÑÂºïÁî®‚ÄùÁÆÄÁß∞‰∏∫‚ÄúÂ∏∏ÈáèÂºïÁî®‚Äù„ÄÇ ÂºïÁî®ÁöÑÁ±ªÂûãÂøÖÈ°ªÂíåË¶ÅÁªëÂÆöÁöÑÂØπË±°‰∏•Ê†ºÂåπÈÖçÔºàÊØîÂ¶ÇintÁ±ªÂûãÁöÑÂºïÁî®‰∏çËÉΩÁªëÂÆöÂú®double‰∏äÔºâÔºå‰ΩÜÊòØÊúâ2‰∏™‰æãÂ§ñ„ÄÇ ÂÖ∂‰∏≠‰∏Ä‰∏™‰æãÂ§ñÂ∞±ÊòØÂú®ÂàùÂßãÂåñÂ∏∏ÈáèÂºïÁî®Êó∂ÂÖÅËÆ∏Áî®‰ªªÊÑèË°®ËææÂºè‰Ωú‰∏∫ÂàùÂßãÂÄºÔºåÂè™Ë¶ÅËØ•Ë°®ËææÂºèÁöÑÁªìÊûúËÉΩÂ§üËΩ¨Êç¢ÊàêÂºïÁî®ÁöÑÁ±ªÂûãÂç≥ÂèØ„ÄÇÂÖÅËÆ∏‰∏∫‰∏Ä‰∏™Â∏∏ÈáèÂºïÁî®ÁªëÂÆöÈùûÂ∏∏ÈáèÁöÑÂØπË±°ÔºåÂ≠óÈù¢ÂÄºÁîöËá≥‰∏Ä‰∏™‰∏ÄËà¨Ë°®ËææÂºè„ÄÇ‰æãÂ¶ÇÔºö12345int i=42;const int &amp;r1=i;//Ê≠£Á°Æconst int &amp;r2=42;//correctconst int &amp;r3=r1*2//correctint &amp;r4=r1*2;//ÈîôËØØÔºÅÈùûÂ∏∏ÈáèÂºïÁî®‰∏çÂÖÅËÆ∏Ëøô‰πàÊêûÔºÅ ÁîöËá≥ÂèØ‰ª•Ëøô‰πàÊêûÔºö123double a=1.22;const int &amp;ri=a;cout&lt;&lt;ri&lt;&lt;endl; ËøôÁßçÊÉÖÂÜµ‰∏ãriÂÖ∂ÂÆûÊòØÁªëÂÆö‰∫Ü‰∏Ä‰∏™Áî±aËΩ¨Êç¢ËÄåÊù•ÁöÑ‰∏¥Êó∂ÁöÑintÁ±ªÂûãÁöÑÂèòÈáè„ÄÇ]]></content>
      <categories>
        <category>CppÂü∫Êú¨ËØ≠Ê≥ï</category>
        <category>Cpp</category>
        <category>Â∑¶ÂÄºÂºïÁî®</category>
        <category>const</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>CppÂü∫Êú¨ËØ≠Ê≥ï</tag>
        <tag>Â∑¶ÂÄºÂºïÁî®</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CppÈòÖËØªÁ¨îËÆ∞-Á±ª]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FCPP%E7%B1%BB%2FCpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Á±ªÁöÑÂü∫Êú¨Ê¶ÇÂøµÈ¶ñÂÖàÊòØ‰∏ÄÊÆµËá™ÂÆö‰πâÁ±ªÁöÑ‰ª£Á†ÅÔºö123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;class Screen&#123;public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; string pr()const; Screen &amp;move(pos r,pos c); void move(pos r,pos c,int sit); Screen &amp;set(char); Screen &amp;set(pos,pos,char); Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125; const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; friend class window_mgr; //friend void window_mgr::clear(Screenindex);private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125;&#125;;Screen &amp;Screen::move(pos r,pos c)&#123; pos row=r*width; cursor=row+c; return *this;&#125;void Screen::move(pos r,pos c,int sit)&#123; pos row=r*width; cursor=row+c; //return *this;&#125;char Screen::get(pos r,pos c)const&#123; pos row=r*width; return contents[row+c];&#125;Screen &amp;Screen::set(char c)&#123; contents[cursor]=c; return *this;&#125;Screen &amp;Screen::set(pos r,pos col,char ch)&#123; contents[r*width+col]=ch; return *this;&#125;string Screen::pr() const &#123; return contents;&#125;class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;;void window_mgr::clear(window_mgr::Screenindex i)&#123; Screen &amp;s=screens[i]; s.contents.clear();&#125;window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s)&#123; screens.push_back(s); return screens.size()-1;&#125;int main()&#123; int x=10; Screen screen1; Screen screen2(10, 10, 'a');screen2.sit=3; cout&lt;&lt;screen1.sit&lt;&lt;endl; //screen1.move(2,3); screen1.move(2,3,1); screen1.move(3,4).sit=screen2.sit;// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; screen1.getH() &lt;&lt; endl;// cout&lt;&lt;screen1.sit&lt;&lt;endl; screen2.set(5,5,'d');// cout&lt;&lt;screen2.get(5,5)&lt;&lt;endl;// cout&lt;&lt;screen2.pr()&lt;&lt;endl; screen2 .display(cout); window_mgr w1; // w1.screens[0].display(cout); w1.clear(0); return 0;&#125; ÊàêÂëòÂáΩÊï∞ÔºàÁ±ª‰ººScreen1.set()ËøôÁßçÔºâÁöÑÂ£∞ÊòéÂøÖÈ°ªÂú®Á±ªÁöÑÂÜÖÈÉ®ÔºåÂÆö‰πâÂàôÂèØ‰ª•Âú®Á±ªÂÜÖÈÉ®‰πüÂèØ‰ª•Âú®Á±ªÂ§ñÈÉ®„ÄÇËÄåÊé•Âè£ÁªÑÊàêÈÉ®ÂàÜÁöÑÂáΩÊï∞ÊàñËÄÖËØ¥Âè™ÊòØ‰ΩøÁî®‰∫ÜÁ±ªÁöÑÂáΩÊï∞ÔºåÊØîÂ¶ÇËØ¥Áî®‰∏§‰∏™Á±ª‰Ωú‰∏∫Ëá™Â∑±ÁöÑÂèÇÊï∞ÁöÑÂáΩÊï∞ÔºåÂ£∞ÊòéÂíåÂÆö‰πâÈÉΩÂú®Á±ªÂ§ñÈÉ® thisÂÆû‰æãÂáΩÊï∞Ôºöstd::string isbn() const{return bookNo;} ÊàêÂëòÂáΩÊï∞ÈÄöËøáÂêç‰∏∫thisÁöÑÈöêÂºèÂèÇÊï∞Êù•ËÆøÈóÆË∞ÉÁî®ÂÆÉÁöÑÈÇ£‰∏™ÂØπË±°„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûúË∞ÉÁî®total.isbn()ÔºåÁºñËØëÂô®‰ºöÊäätotalÁöÑÂú∞ÂùÄ‰º†ÈÄíÁªôisbnÁöÑÈöêÂºèÂΩ¢ÂèÇthisÔºåÁõ∏ÂΩì‰∫éSales_data::isbn(&amp;total) thisÂΩ¢ÂèÇÊòØÈöêÂºèÂÆö‰πâÁöÑÔºå‰ªª‰ΩïËá™ÂÆö‰πâÂêç‰∏∫thisÁöÑÂèÇÊï∞ÊàñÂèòÈáèÁöÑË°å‰∏∫ÈÉΩÊòØÈùûÊ≥ïÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Âú®ÊàêÂëòÂáΩÊï∞‰ΩìÂÜÖÈÉ®‰ΩøÁî®thisÔºåËôΩÁÑ∂Ê≤°ÊúâÂøÖË¶Å„ÄÇ‰æãÔºöisbnËøòËÉΩÂ¶Ç‰∏ãÂÆö‰πâÔºöstd::string isbn() const{return this-&gt;bookNo;} isbnÂáΩÊï∞ÂèÇÊï∞ÂàóË°®ÂêéÁöÑconstÁöÑ‰ΩúÁî®ÊòØ‰øÆÊîπthisÊåáÈíàÁöÑÁ±ªÂûãÔºåÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåthisÁöÑÁ±ªÂûãÊòØÊåáÂêëÁ±ªÁ±ªÂûãÁöÑÈùûÂ∏∏ÈáèÁâàÊú¨ÁöÑÂ∏∏ÈáèÊåáÈíà„ÄÇËøôÂ∞±ÊÑèÂë≥ÁùÄÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÊàë‰ª¨‰∏çËÉΩÊääthisÁªëÂÆöÂú®‰∏Ä‰∏™Â∏∏ÈáèÂØπË±°‰∏ä„ÄÇ Á±ª‰ΩúÁî®ÂüüÂíåÊàêÂëòÂáΩÊï∞ÁºñËØëÂô®Â§ÑÁêÜÁ±ªÊó∂Ôºå È¶ñÂÖàÁºñËØëÊàêÂëòÂ£∞ÊòéÔºåÁÑ∂ÂêéÊâçËΩÆÂà∞ÊàêÂëòÂáΩÊï∞‰ΩìÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâÂõ†Ê≠§ÔºåÊàêÂëòÂáΩÊï∞‰ΩìÂèØ‰ª•ÈöèÊÑè‰ΩøÁî®Á±ª‰∏≠ÁöÑÂÖ∂‰ªñÊàêÂëòÂáΩÊï∞ËÄå‰∏çÂøÖÂú®ÊÑèËøô‰∫õÊàêÂëòÂá∫Áé∞ÁöÑÂÖàÂêéÈ°∫Â∫èÔºàÂç≥‰ΩøÂá∫Áé∞Âú®ÂáΩÊï∞Â£∞Êòé‰πãÂêé‰πüÊ≤°ÊúâÈóÆÈ¢òÔºâ„ÄÇ ‰ΩúÁî®ÂüüËøêÁÆóÁ¨¶ÔºöÁ±ª‰ºº‰∫éSales_data::avg_priceËøôÊ†∑ÁöÑÔºöÔºöÔºåËØ¥Êòé‰∫Ü‰ª•‰∏ã‰∫ãÂÆûÔºöÊúâ‰∏Ä‰∏™Âêç‰∏∫avg_priceÁöÑÂáΩÊï∞ÔºåÂπ∂‰∏îËØ•ÂáΩÊï∞Ë¢´Â£∞ÊòéÂú®Á±ªSales_dataÁöÑ‰ΩúÁî®ÂüüÂÜÖ„ÄÇ ÂÖ≥‰∫éÂáΩÊï∞ÂºïÁî®IOÁ±ªÂûã‰Ωú‰∏∫ÂèÇÊï∞IOÁ±ªÂ±û‰∫é‰∏çËÉΩË¢´Êã∑Ë¥ùÁöÑÁ±ªÂûãÔºåÂõ†Ê≠§Âè™ËÉΩÈÄöËøáÂºïÁî®Êù•‰º†ÈÄí‰ªñ‰ª¨„ÄÇ ÊûÑÈÄ†ÂáΩÊï∞ÊûÑÈÄ†ÂáΩÊï∞ÁöÑÂêçÁß∞‰∏éÁ±ªÁöÑÂêçÁß∞Áõ∏ÂêåÂè™Ë¶ÅÁ±ªÁöÑÂØπË±°Ë¢´ÂàõÈÄ†ÔºåÂ∞±‰ºöÊâßË°åÊûÑÈÄ†ÂáΩÊï∞„ÄÇÊ≥®ÊÑèÔºöÊûÑÈÄ†ÂáΩÊï∞Ê≤°ÊúâËøîÂõûÁ±ªÂûã‰∏Ä‰∏™Á±ªÂèØ‰ª•ÂåÖÂê´Â§ö‰∏™ÊûÑÈÄ†ÂáΩÊï∞ÔºåÂíåÂÖ∂‰ªñÈáçËΩΩÂáΩÊï∞Á±ª‰ºº„ÄÇ‰ΩÜÊòØÔºåÊûÑÈÄ†ÂáΩÊï∞‰∏çËÉΩË¢´Â£∞ÊòéÊàêconstÁöÑ„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™Á±ªÊ≤°ÊúâÊòæÂºèÂÆö‰πâÊûÑÈÄ†ÂáΩÊï∞ÔºåÈÇ£‰πàÁºñËØëÂô®Â∞±‰ºöÈöêÂºèÂú∞ÊåáÂÆö‰∏Ä‰∏™ÈªòËÆ§ÊûÑÈÄ†ÂáΩÊï∞ÔºàÂç≥ÂêàÊàêÁöÑÈªòËÆ§ÊûÑÈÄ†ÂáΩÊï∞ÔºâÔºå‰∏ÄËà¨Êù•ËØ¥ÔºåÂÆπÂô®ÈÉΩ‰∏∫Á©∫ÔºåÊï∞ÊçÆÈÉΩ‰∏∫0ÔºåboolÈÉΩ‰∏∫false„ÄÇÂú®C++11‰∏≠ÔºåÂ¶ÇÊûúÈúÄË¶ÅÈªòËÆ§Ë°å‰∏∫ÔºåÂèØ‰ª•Âú®ÂèÇÊï∞ÂàóË°®ÂêéÂÜô‰∏ä=defaultÊù•Ë¶ÅÊ±ÇÁºñËØëÂô®ÁîüÊàêÈªòËÆ§ÊûÑÈÄ†ÂáΩÊï∞ ÊûÑÈÄ†ÂáΩÊï∞‰∏æ‰æãÔºö12Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;Sales_data(const std::string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125; ÂÜíÂè∑‰∏éËä±Êã¨Âè∑‰πãÈó¥ÁöÑÈÉ®ÂàÜÁß∞‰∏∫ÊûÑÈÄ†ÂáΩÊï∞ÂàùÂßãÂÄºÂàóË°®ÔºåÂÆÉË¥üË¥£‰∏∫Êñ∞ÂàõÂª∫ÂØπË±°ÁöÑ‰∏Ä‰∏™ÊàñËÄÖÂá†‰∏™Êï∞ÊçÆÊàêÂëòËµãÂÄº„ÄÇÂ¶ÇÊûúÊúâÊï∞ÊçÆÊàêÂëòË¢´ÂàùÂßãÂåñÂàóË°®ÊâÄÂøΩÁï•ÔºåÈÇ£‰πàÂÆÉÂ∞ÜË¢´‰ª•‰∏éÈªòËÆ§ÊûÑÈÄ†ÂáΩÊï∞Áõ∏ÂêåÁöÑÊñπÂºèÈöêÂºèÂàùÂßãÂåñ„ÄÇ Ê≥®ÊÑèÔºö‰∏äÈù¢ÁöÑÂáΩÊï∞‰∏≠ÁöÑÂáΩÊï∞‰Ωì‰∏≠ËøòÂèØ‰ª•ÊâßË°åÂÖ∂‰ªñÁöÑ‰ªªÂä°ÊàñÁ©∫ÁΩÆ„ÄÇ ‰∏ÄËà¨Êù•ËØ¥ÔºåÂàùÂßãÂåñÂáΩÊï∞‰∏≠ÊàêÂëòÂàùÂßãÂåñÁöÑÈ°∫Â∫èÊ≤°‰ªÄ‰πàÂÖ≥Á≥ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊ∂âÂèäÂà∞Áî®‰∏Ä‰∏™ÊàêÂëòÂéªÂàùÂßãÂåñÂè¶‰∏Ä‰∏™ÊàêÂëòÊó∂ÔºåÂ∞±ÊúâÂÖ≥Á≥ª‰∫Ü„ÄÇÊØîÂ¶ÇËØ¥Ôºö123456class X&#123; int i; int j;public: X(int val):j(val),i(j)&#123;&#125;//ËøôÊòØÈîôËØØÁöÑÔºåÂõ†‰∏∫iÂú®j‰πãÂâçË¢´ÂàùÂßãÂåñ &#125;Ôºõ Âú®‰∏äÈù¢Ëøô‰∏™Á±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞‰∏≠ÔºåiÂÖàË¢´ÂàùÂßãÂåñÔºåjÊé•ÁùÄÊâçË¢´ÂàùÂßãÂåñÔºåÂõ†Ê≠§‰ºöÂá∫ÈîôÔºÅ Êã∑Ë¥ùÔºåËµãÂÄºÂíåÊûêÊûÑÈÄö‰øóÊù•ËØ¥Ôºå‰∏Ä‰∏™Á±ªÁöÑÂØπË±°ÂèØ‰ª•Áõ¥Êé•Ë¢´Ëµã‰∫àÂè¶‰∏Ä‰∏™ÂØπË±°ÁöÑÂÄºÔºå‰æãÂ¶Çtotal=trans,ÂÖ∂‰∏≠totalË∑ütransÈÉΩÊòØÁ±ªÂØπË±°„ÄÇ‰ΩÜÊòØÔºåÁÆ°ÁêÜÂä®ÊÄÅÂÜÖÂ≠òÁöÑÁ±ªÈÄöÂ∏∏‰∏çËÉΩËøô‰πàÂÅö„ÄÇ‰∏çËøá‰ΩøÁî®vectorË∑üstringÁöÑÁ±ªÂπ∂‰∏çÂèóÊ≠§ÂΩ±Âìç„ÄÇ ËÆøÈóÆÊéßÂà∂‰∏éÂ∞ÅË£ÖËÆøÈóÆËØ¥ÊòéÁ¨¶Ôºöpublic‰∏éprivateÂÆö‰πâÂú®private‰πãÂêéÁöÑÊàêÂëòÂèØ‰ª•Ë¢´Á±ªÁöÑÊàêÂëòÂáΩÊï∞‰ª•ÂèäÂèãÂÖÉËÆøÈóÆÔºå‰ΩÜ‰∏çËÉΩË¢´‰ΩøÁî®ËØ•Á±ªÁöÑÂáΩÊï∞ËÆøÈóÆ„ÄÇÊ≥®ÊÑèÔºåstructÈªòËÆ§‰∏∫publicÔºåclassÈªòËÆ§‰∏∫private ÂèãÂÖÉÁ±ªÂèØ‰ª•ÊääÂÖ∂‰ªñÁöÑÁ±ªÂÆö‰πâ‰∏∫ÂèãÂÖÉÔºå‰πüÂèØ‰ª•ÊääÂÖ∂‰ªñÁ±ªÁöÑÊàêÂëòÂáΩÊï∞ÂÆö‰πâ‰∏∫ÂèãÂÖÉÔºõÁ±ªÂèØ‰ª•ÂÖÅËÆ∏ÂÖ∂‰ªñÁ±ªÊàñËÄÖÂáΩÊï∞ËÆøÈóÆ‰ªñÁöÑprivateÊàêÂëòÔºåÂè™Ë¶ÅÁªôÂÖ∂‰ªñÁ±ªÊàñËÄÖÂáΩÊï∞Âä†‰∏äfriendÔºàÂèãÂÖÉÔºâÁöÑÂ£∞ÊòéÂç≥ÂèØ„ÄÇ ‰æãÂ¶ÇÔºö1234567891011121314151617181920212223242526272829class Screen&#123;public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; friend class window_mgr;//Â∞Üwindow_mgrÂ£∞Êòé‰∏∫ScreenÁöÑÂèãÂÖÉ //friend void window_mgr::clear(Screenindex);private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125;&#125;;class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;; ËøôÊ†∑‰∏ÄÊù•Ôºåwindow_mgrÂ∞±ÂèØ‰ª•ËÆøÈóÆScreenÁ±ªÁöÑÁßÅÊúâÊï∞ÊçÆÊàêÂëò‰∫Ü„ÄÇÂèãÂÖÉÂ£∞ÊòéÂè™ËÉΩÂá∫Áé∞Âú®Á±ªÁöÑÂÜÖÈÉ®Ôºå‰ΩÜÊòØÁ±ªÂÜÖÈÉ®Âá∫Áé∞ÁöÑÂÖ∑‰Ωì‰ΩçÁΩÆ‰∏çÈôêÂèãÂÖÉÁöÑÂ£∞Êòé‰ªÖ‰ªÖÊèê‰æõ‰∫Ü‰∏Ä‰∏™ËÆøÈóÆÊùÉÈôêÔºåË¶ÅÊÉ≥ÁúüÁöÑ‰ΩøÁî®Ëøô‰∏™ÂáΩÊï∞ÔºåÂú®Á±ªÁöÑÂ§ñÈÉ®ÈúÄË¶ÅÂÜç‰∏ìÈó®Â£∞Êòé‰∏ÄÊ¨°ÂèãÂÖÉÂÖ≥Á≥ª‰∏çÂÖ∑Êúâ‰º†ÈÄíÊÄßÂ¶ÇÊûúÂ∞Ü‰∏Ä‰∏™ÂÖ∂‰ªñÁ±ªÁöÑÊàêÂëòÂáΩÊï∞Â£∞Êòé‰∏∫ÂΩìÂâçÁ±ªÁöÑÂèãÂÖÉÂáΩÊï∞ÔºåÈÇ£‰πàËøô‰∏™ÂáΩÊï∞ÂøÖÈ°ªÂ∑≤ÁªèË¢´ÂÆö‰πâÔºõ‰ΩÜÊòØÂ¶ÇÊûúÊòØÂ∞ÜÂÖ∂‰ªñ‰∏Ä‰∏™Á±ªÂ£∞Êòé‰∏∫ÂèãÂÖÉÔºåÈÇ£‰πàËøô‰∏™Á±ªÂè™ÈúÄË¶ÅË¢´Â£∞ÊòéÂç≥ÂèØÂ¶ÇÊûúÊää‰∏ÄÁªÑÈáçËΩΩÂáΩÊï∞Â£∞Êòé‰∏∫ÂèãÂÖÉÔºåÈÇ£‰πàÊØè‰∏Ä‰∏™ÂáΩÊï∞ÈÉΩÂøÖÈ°ªÂ£∞Êòé‰∏ÄÊ¨°ÂèãÂÖÉÂáΩÊï∞ÂèØ‰ª•ÂÆö‰πâÂú®Á±ªÂÜÖÈÉ®Ôºå‰ΩÜÊòØÂøÖÈ°ªÂú®Á±ªÁöÑÂ§ñÈÉ®Â£∞Êòé‰ΩøÂæóÂáΩÊï∞ÂèØËßÅ Á±ªÁöÑÂÖ∂‰ªñÁâπÊÄßÔºàÁ±ªÊàêÂëòÔºâÈô§‰∫ÜÂÆö‰πâÊï∞ÊçÆÂíåÂáΩÊï∞ÊàêÂëò‰ª•Â§ñÔºåÁ±ªËøòÂèØ‰ª•Ëá™ÂÆö‰πâÊüêÁßçÁ±ªÂûãÂú®Á±ª‰∏≠ÁöÑÂà´ÂêçÔºåÁî±Á±ªÂÆö‰πâÁöÑÁ±ªÂûãÂêçÂ≠óÂíåÂÖ∂‰ªñÊàêÂëò‰∏ÄÊ†∑Â≠òÂú®ËÆøÈóÆÈôêÂà∂ÔºåÂèØ‰ª•ÊòØpublicÊàñËÄÖprivate‰∏≠ÁöÑ‰∏ÄÁßç„ÄÇ ÂíåÈùûÊàêÂëòÂáΩÊï∞‰∏ÄÊ†∑ÔºåÊàêÂëòÂáΩÊï∞‰πüÂèØ‰ª•Ë¢´ÈáçËΩΩÔºåÂè™Ë¶ÅÂáΩÊï∞‰πãÈó¥Âú®ÂèÇÊï∞Êï∞ÈáèÊàñËÄÖÁ±ªÂûã‰∏äÊúâÊâÄÂå∫Âà´Âç≥ÂèØ„ÄÇ Á±ªÊï∞ÊçÆÊàêÂëòÁöÑÂàùÂßãÂÄºÂèØ‰ª•ÁªôÁ±ªÁöÑÊï∞ÊçÆÊàêÂëòÊ∑ªÂä†‰∏Ä‰∏™ÈªòËÆ§ÁöÑÂàùÂßãÂÄº12345678class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;; ËøîÂõû*thisÁöÑÊàêÂëòÂáΩÊï∞12345Screen &amp;Screen::set(pos r,pos col,char ch)&#123; contents[r*width+col]=ch; return *this;&#125; ËøîÂõûÂºïÁî®ÁöÑÂáΩÊï∞ÊòØÂ∑¶ÂÄºÁöÑÔºåÊÑèÂë≥ÁùÄËøô‰∫õÂáΩÊï∞ËøîÂõûÁöÑÊòØÂØπË±°Êú¨Ë∫´ËÄå‰∏çÊòØÂØπË±°ÁöÑÂâØÊú¨ÔºõÂ¶ÇÊûúËøô‰∏™ÂáΩÊï∞ÊòØ‰∏çÊòØÂ∑¶ÂÄºÁöÑÔºåÈÇ£‰πàËøîÂõûÁöÑÊï∞ÊçÆÂè™ÊòØÂáΩÊï∞‰∏≠Ë∞ÉÁî®ÂØπË±°ÁöÑ‰∏Ä‰∏™copyÔºõ‰∏æ‰∏™‰æãÂ≠êÔºåÂ¶ÇÊûúÊúâËøô‰πà‰∏ÄÁ≥ªÂàóÊìç‰ΩúÔºömyscreen.move(4,0).set(&#39;#&#39;);Ëøô‰∫õÊìç‰Ωú‰ºöÂú®Âêå‰∏Ä‰∏™ÂØπË±°‰∏äÊâßË°åÔºåÂõ†‰∏∫move() Âíåset()ÂáΩÊï∞ÈÉΩÊòØÂ∑¶ÂÄºÁöÑÔºõ‰πüÂ∞±ÊòØËØ¥ÔºåËøô‰∏™ÂáΩÊï∞Á≠â‰ª∑‰∫émyscreen.move(4,0);myscreen.set(&#39;#&#39;); Â¶ÇÊûúmove() Âíåset()ÂáΩÊï∞‰∏çÊòØÂ∑¶ÂÄºÁöÑÔºåÈÇ£‰πà‰∏äËø∞ËØ≠Âè•Â∞Ü‰ºöÂèòÊàêÔºöScreen temp=myscreen.move(4,0);temp,set(&#39;#&#39;);‰πüÂ∞±ÊòØËØ¥ÔºåÁ¨¨2Ê≠•Âπ∂‰∏ç‰ºöÊîπÂèòÂéüÊù•myscreen‰∏≠ÁöÑcontentsÔºàÂÜÖÂÆπÔºâÔºõ Ê≥®ÊÑèÔºö‰∏Ä‰∏™constÊàêÂëòÂáΩÊï∞Â¶ÇÊûú‰ª•ÂºïÁî®ÁöÑÂΩ¢ÂºèËøîÂõû*thisÔºåÈÇ£‰πàÂÆÉÁöÑËøîÂõûÁ±ªÂûãÂ∞ÜÊòØÂ∏∏ÈáèÂºïÁî®Ôºå‰πüÂ∞±ÊòØ‰∏Ä‰∏™Â∏∏Èáè Âü∫‰∫éconstÁöÑÈáçËΩΩÈÄöËøáÂå∫ÂàÜÊàêÂëòÂáΩÊï∞ÊòØÂê¶ÊòØconstÁöÑÔºåÊàë‰ª¨‰πüÂèØ‰ª•ÂØπÂÖ∂ËøõË°åÈáçËΩΩ‰æãÂ¶ÇÔºö123456Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125;const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; ÂΩìÊàë‰ª¨Âú®Êüê‰∏™ÂØπË±°‰∏äË∞ÉÁî®displayÂáΩÊï∞Êó∂ÔºåËØ•ÂØπË±°ÊòØÂê¶ÊòØconstÂÜ≥ÂÆö‰∫ÜÂ∫îËØ•Ë∞ÉÁî®displayÁöÑÂì™‰∏™ÁâàÊú¨Ôºõ‰æãÂ¶ÇÔºö1234Screen myscreen(5,3);const Screen blank(5,3);myscreen.set('#').display(cout);//Ë∞ÉÁî®ÈùûÂ∏∏ÈáèÁâàÊú¨blank.display(cout);//Ë∞ÉÁî®Â∏∏ÈáèÁâàÊú¨ Á±ªÁ±ªÂûãÊ≥®ÊÑèÔºöÂç≥‰Ωø‰∏§‰∏™Á±ªÁöÑÊàêÂëòÂàóË°®ÂÆåÂÖ®‰∏ÄËá¥ÔºåÂÆÉ‰ª¨‰πüÊòØ‰∏çÂêåÁöÑÁ±ªÂûã„ÄÇÂØπ‰∫é‰∏Ä‰∏™Á±ªËÄåË®ÄÔºåÂÆÉÁöÑÊàêÂëòÂíåÂÖ∂‰ªñ‰ªª‰ΩïÁ±ªÁöÑÊàêÂëòÈÉΩÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑ„ÄÇ Á±ªÁöÑÂ£∞ÊòéÊàë‰ª¨ÂèØ‰ª•‰ªÖÂ£∞ÊòéÁ±ªËÄåÊöÇÊó∂‰∏çÂÆö‰πâÂÆÉÔºõËøôÂ∞±ÊòØÊâÄË∞ìÁöÑÂâçÂêëÂ£∞ÊòéÔºåÂú®Â£∞Êòé‰πãÂêéÂÆö‰πâ‰πãÂâçÁöÑÁ±ªÂûãË¢´Áß∞‰∏∫‰∏çÂÆåÂÖ®Á±ªÂûãÔºõ ‰∏çÂÆåÂÖ®Á±ªÂûãÂè™ËÉΩÂú®ÈùûÂ∏∏ÊúâÈôêÁöÑÂú∫ÊôØ‰∏ã‰ΩøÁî®ÔºöÂèØ‰ª•ÂÆö‰πâÊåáÂêëËøôÁßçÁ±ªÂûãÁöÑÊåáÈíàÂíåÂºïÁî®Ôºå‰πüÂèØ‰ª•Â£∞ÊòéÔºà‰ΩÜ‰∏çËÉΩÂÆö‰πâÔºâ‰ª•‰∏çÂÆåÂÖ®Á±ªÂûã‰Ωú‰∏∫ÂèÇÊï∞ÊàñËøîÂõûÁ±ªÂûãÁöÑÂáΩÊï∞Ôºõ ÂØπ‰∫é‰∏Ä‰∏™Á±ªËÄåË®ÄÔºåÊàë‰ª¨Âú®ÂàõÈÄ†ÂÆÉÁöÑÂØπË±°‰πãÂâçÂøÖÈ°ªÂ∞ÜÂÖ∂ÂÆö‰πâÔºà‰∏çÁÑ∂ÁºñËØëÂô®Âì™Áü•ÈÅìÊÄé‰πàÂàùÂßãÂåñ233Ôºâ„ÄÇ‰ΩÜÊòØ‰∏Ä‰∏™Á±ª‰∏ÄÊó¶ÂêçÂ≠óÂá∫Áé∞ÂêéÔºåÂÆÉÂ∞±Ë¢´ËÆ§‰∏∫ÊòØÂ£∞ÊòéËøá‰∫ÜÔºåÂõ†Ê≠§Á±ªÂÖÅËÆ∏ÂåÖÂê´ÊåáÂêëÂÆÉËá™Ë∫´Á±ªÂûãÁöÑÂºïÁî®ÊàñÊåáÈíà„ÄÇ Á±ªÁöÑ‰ΩúÁî®Âüü ÂØπ‰∫é‰∏ÄÊù°ÂáΩÊï∞ÂÆö‰πâÔºå‰∏ÄÊó¶ÈÅáÂà∞‰∫ÜÁ±ªÂêçÔºåÂÆö‰πâÁöÑÂâ©‰ΩôÈÉ®ÂàÜÂ∞±Âú®Á±ªÁöÑ‰ΩúÁî®Âüü‰πãÂÜÖ‰∫Ü„ÄÇÂõ†Ê≠§Âú®ÂèÇÊï∞ÂàóË°®ÂíåÂáΩÊï∞‰ΩìÂÜÖÂ∞±ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®ÊàêÂëòÂáΩÊï∞ËÄå‰∏çÂøÖÂÜçÊ¨°Â£∞Êòé‰∫ÜÔºõ ÂêåÊó∂ÔºåÂáΩÊï∞ÁöÑËøîÂõûÁ±ªÂûãÈÄöÂ∏∏Âá∫Áé∞Âú®ÂáΩÊï∞Âêç‰πãÂâçÔºåÂõ†Ê≠§Â¶ÇÊûúÊàêÂëòÂáΩÊï∞ÁöÑÂÆö‰πâÂú®Á±ªÁöÑÂ§ñÈÉ®Êó∂ÔºåËøîÂõûÁ±ªÂûãÂ∞±ÂøÖÈ°ªÊåáÊòéÂÆÉÊòØÂì™‰∏™Á±ªÁöÑÊàêÂëò‰æãÂ¶Ç:12345window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s)&#123; screens.push_back(s); return screens.size()-1;&#125; ÁºñËØëÂô®Â§ÑÁêÜÂÆåÁ±ª‰∏≠ÁöÑÂÖ®ÈÉ®Â£∞ÊòéÂêéÊâç‰ºöÂ§ÑÁêÜÊàêÂëòÂáΩÊï∞ÁöÑÂÆö‰πâÔºõÂõ†Ê≠§ÂáΩÊï∞ÂèØ‰ª•‰ΩøÁî®Á±ªÂÆö‰πâ‰∏≠ÁöÑ‰ªª‰ΩïÂêçÂ≠ó„ÄÇ ÊàêÂëòÂáΩÊï∞Êü•ÊâæÂêçÂ≠óÈááÂèñ‰ª•‰∏ãÊñπÂºèÔºö È¶ñÂÖàÔºåÂú®Á±ªÂÜÖÈÉ®ÊàêÂëòÂáΩÊï∞‰πãÂâçÊü•ÊâæËØ•ÂêçÂ≠óÁöÑÂ£∞ÊòéÔºõ ÂÖ∂Ê¨°ÔºåÂ¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåÂàôÂú®Á±ªÂÜÖÈÉ®ÁöÑÂÖ∂‰ªñÂú∞ÊñπÁªßÁª≠Êü•ÊâæÔºõ ÊúÄÂêéÔºåÂ¶ÇÊûúÊï¥‰∏™Á±ªÈÉΩÊ≤°ÊúâËøô‰∏™ÂêçÂ≠óÁöÑÂ£∞ÊòéÔºåÈÇ£‰πàÂú®ÊàêÂëòÂáΩÊï∞ÂÆö‰πâ‰πãÂâçÁöÑ‰ΩúÁî®ÂüüÂÜÖËøõË°åÊü•ÊâæÔºõ Â¶ÇÊûúÂú®ÊàêÂëòÂáΩÊï∞ÂÜÖÈúÄË¶ÅÁî®Âà∞Â§ñÂ±Ç‰ΩúÁî®ÂüüÂÜÖÁöÑÂêçÂ≠óÔºåÂèØ‰ª•ÊòæÊÄßÂú∞‰ΩøÁî®‰ΩúÁî®ÂüüËøêÁÆóÁ¨¶Êù•‰ΩìÁé∞Ôºõ ËÅöÂêàÁ±ªÂΩì‰∏Ä‰∏™Á±ªÊª°Ë∂≥‰∏ãÂàóÊù°‰ª∂Êó∂ÔºåÂÆÉÊòØËÅöÂêàÁöÑÔºö ÊâÄÊúâÊàêÂëòÈÉΩÊòØpublicÁöÑÔºõ Ê≤°ÊúâÂÆö‰πâ‰ªª‰ΩïÊûÑÈÄ†ÂáΩÊï∞Ôºõ Ê≤°ÊúâÁ±ªÂÜÖÂàùÂßãÂÄºÔºõ ËÅöÂêàÁ±ªÁöÑ‰∏ÄÂ§ßÁâπÁÇπÊòØÂèØ‰ª•Áî®‰∏Ä‰∏™Ëä±Êã¨Âè∑Êã¨Ëµ∑Êù•ÁöÑÊàêÂëòÂàùÂßãÂÄºÂàóË°®ËøõË°åÂàùÂßãÂåñÔºõ‰æãÂ¶ÇÔºö12345struct Data&#123; int ival;string s; &#125;; Data val=&#123;0,"Anna"&#125;; Ê≥®ÊÑèÔºöÂàùÂßãÂÄºÁöÑÈ°∫Â∫èÂøÖÈ°ª‰∏éÂ£∞ÊòéÈ°∫Â∫è‰∏ÄËá¥ Á±ªÁöÑÈùôÊÄÅÊàêÂëòÂú®Á±ªÁöÑÊàêÂëòÂ£∞Êòé‰πãÂâçÂä†‰∏ästatic‰ΩøÂæóÂÆÉÂèØ‰ª•‰∏éÁ±ªÂÖ≥ËÅîÂú®‰∏ÄËµ∑ÔºåÁß∞‰∏∫ÈùôÊÄÅÊàêÂëò„ÄÇÈùôÊÄÅÊàêÂëòÂèØ‰ª•ÊòØpublicÊàñËÄÖprivateÁöÑÔºåÁ±ªÂûãÂèØ‰ª•ÊòØÂ∏∏ÈáèÔºåÂºïÁî®ÔºåÊåáÈíàÔºåÁ±ªÁ±ªÂûãÁ≠â„ÄÇÁ±ªÁöÑÈùôÊÄÅÊàêÂëòÁã¨Á´ã‰∫é‰ªª‰ΩïÂØπË±°‰πãÂ§ñ„ÄÇ‰æãÂ¶ÇÔºö1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;public: void calculate()&#123;amount+=amount*interestrate;&#125; double rate()&#123;return interestrate;&#125; static void rate(double);private: std::string owner; double amount; static constexpr double interestrate=6; static double initrate();&#125;;//double Account::interestrate=5;//void Account::rate(double newrate1)//&#123;// interestrate=newrate1;//&#125;int main()&#123; Account a,b; //a.rate(6.04); cout&lt;&lt;a.rate()&lt;&lt;' '&lt;&lt;b.rate()&lt;&lt;endl; return 0;&#125; Âú®‰∏äÈù¢Ëøô‰∏™‰æãÂ≠ê‰∏≠ÔºåÊØè‰∏™AccountÂØπË±°ÈÉΩÊã•ÊúâËá™Â∑±ÁöÑ‰∏§‰∏™Êï∞ÊçÆÊàêÂëòownerÂíåamountÔºå‰ΩÜÊòØÂè™Â≠òÂú®‰∏Ä‰∏™interestRateÂπ∂‰∏îË¢´ÊâÄÊúâAccountÂØπË±°ÂÖ±‰∫´Ôºå‰πüÂ∞±ÊòØËØ¥ÔºåÂΩìËøô‰∏™ÂÄºÂèëÁîüÂèòÂåñÊó∂ÔºåÊâÄÊúâÂØπË±°‰∏≠ÁöÑinterestrateÁöÑÂÄºÈÉΩ‰ºöÂèòÂåñ„ÄÇ ÈùôÊÄÅÊàêÂëòÂáΩÊï∞‰∏çÂåÖÂê´thisÊåáÈíàÔºå‰πü‰∏çËÉΩË¢´Â£∞Êòé‰∏∫constÁöÑ„ÄÇ ËôΩÁÑ∂ÈùôÊÄÅÊàêÂëò‰∏çÂ±û‰∫é‰ªª‰Ωï‰∏Ä‰∏™ÂØπË±°Ôºå‰ΩÜÊòØ‰æùÁÑ∂ÂèØ‰ª•‰ΩøÁî®Á±ªÁöÑÂØπË±°„ÄÅÂºïÁî®ÂíåÊåáÈíàÊù•ËÆøÈóÆÈùôÊÄÅÊàêÂëò„ÄÇ ÂØπ‰∫éÈùôÊÄÅÊàêÂëòÂáΩÊï∞Ôºå‰πüÂèØ‰ª•Âú®Á±ªÁöÑÂ§ñÈÉ®ËøõË°åÂÆö‰πâÔºå‰ΩÜÊòØ‰∏çËÉΩÈáçÂ§çstaticÂÖ≥ÈîÆÂ≠óÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÂÖ≥ÈîÆÂ≠óÂè™ËÉΩÂá∫Áé∞Âú®Á±ªÂÜÖÈÉ®Â£∞ÊòéÁöÑÊó∂ÂÄô„ÄÇ Ê≥®ÊÑèÔºö‰∏ÄËà¨Êù•ËØ¥Ôºå‰∏çËÉΩÂú®Á±ªÂÜÖÈÉ®ÂàùÂßãÂåñÈùôÊÄÅÊàêÂëòÔºåÂøÖÈ°ªÂú®Á±ªÁöÑÂ§ñÈÉ®ÂÆö‰πâÂíåÂàùÂßãÂåñÊØè‰∏™ÈùôÊÄÅÊàêÂëòÔºåÂπ∂‰∏îÔºåÊØè‰∏™ÈùôÊÄÅÊï∞ÊçÆÊàêÂëòÂè™ËÉΩÂÆö‰πâ‰∏ÄÊ¨°„ÄÇÂΩìÁÑ∂ÔºåÂ¶ÇÊûúÈùôÊÄÅÊàêÂëòÊòØÂ≠óÈù¢ÂÄºÂ∏∏ÈáèÁ±ªÂûãÁöÑconstexprÔºåÈÇ£‰πàÊàë‰ª¨‰πêÊÑèÂú®Á±ªÂÜÖÈÉ®Êèê‰æõconstÊï¥Êï∞Á±ªÂûãÁöÑÂàùÂßãÂÄºÁªôÈùôÊÄÅÊàêÂëò ‰æãÂ¶Ç‰∏äÈù¢ÈÇ£‰∏™‰æãÂ≠ê‰∏≠ÔºåÂ¶ÇÊûúÂà†ÂéªinterestRateÂâçÈù¢ÁöÑconstexpr,ÈÇ£‰πàÂ∞±ÂøÖÈ°ªÂú®Á±ªÂ§ñÈÉ®ÂØπÂÖ∂ËøõË°åÂàùÂßãÂåñÔºåÂ¶Ç‰∏ãÔºö1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;public: void calculate()&#123;amount+=amount*interestrate;&#125; double rate()&#123;return interestrate;&#125; static void rate(double);private: std::string owner; double amount; static double interestrate;//Ê≥®ÊÑèÊ≠§Êó∂Â∞±‰∏çËÉΩÂú®Á±ªÂÜÖÈÉ®ÂàùÂßãÂåñ‰∫Ü static double initrate();&#125;;double Account::interestrate=5;void Account::rate(double newrate1)&#123; interestrate=newrate1;&#125;int main()&#123; Account a,b; //a.rate(6.04); cout&lt;&lt;a.rate()&lt;&lt;' '&lt;&lt;b.rate()&lt;&lt;endl; return 0;&#125; ÈùôÊÄÅÊàêÂëòËøòÊúâ‰∏Ä‰∏™Áî®Â§ÑÂ∞±ÊòØÂèØ‰ª•‰Ωú‰∏∫ÊàêÂëòÂáΩÊï∞ÁöÑÈªòËÆ§ÂÆûÂèÇ„ÄÇ]]></content>
      <categories>
        <category>Cpp</category>
        <category>CppËØ≠Ê≥ï</category>
        <category>CPPÁ±ª</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>CppËØ≠Ê≥ï</tag>
        <tag>CPPÁ±ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonÂü∫Êú¨ËØ≠Ê≥ï]]></title>
    <url>%2FPython%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Âü∫Êú¨ËØ≠Ê≥ï‰∏éËøêÁÆóÁ¨¶Ê≥®Èáä# Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûãintÂèØ‰ª•ÊòØ‰ªª‰ΩïÂ§ßÂ∞èÁöÑÊï¥Êï∞ ÂèòÈáèÂêçÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶ÂøÖÈ°ªÊòØÂ≠óÊØçÊàñ‰∏ãÂàíÁ∫øÔºõÂèòÈáèÂêçÂå∫ÂàÜÂ§ßÂ∞èÂÜôÔºõ ‰ΩøÁî®Âçï/ÂèåÂºïÂè∑ÊåáÂÆöÂ≠óÁ¨¶‰∏≤ÔºåÊâÄÊúâÂºïÂè∑ÂÜÖÁöÑÂ≠óÁ¨¶ÔºåÂåÖÊã¨Á©∫Ê†º‰∏éÂà∂Ë°®Á¨¶ÈÉΩÂ∞ÜÂéüÊ†∑‰øùÁïô„ÄÇ‰∏§ÁßçÂºïÂè∑Â∑•‰ΩúÊú∫Âà∂Áõ∏Âêå ËæìÂá∫Ê†ºÂºè‰∏âÂºïÂè∑Áî®‰∫éÊåáÂÆöÂ§öË°åÂ≠óÁ¨¶‰∏≤Ôºà&quot;&quot;&quot;Êàñ&#39;&#39;&#39;ÂùáÂèØ‰ª•Ôºâ‰æãÂ¶ÇÔºö123print('''this is the first lineand this is the secondhhahahah''') Â∞±‰ºöÂéüÊ†∑ËæìÂá∫3Ë°å ÊúâÊó∂ÂÄôÊàë‰ª¨‰ºöÊÉ≥Ë¶Å‰ªéÂÖ∂‰ªñ‰ø°ÊÅØ‰∏≠ÊûÑÂª∫Â≠óÁ¨¶‰∏≤„ÄÇËøôÊ≠£ÊòØ format() ÊñπÊ≥ïÂ§ßÊúâÁî®Ê≠¶‰πãÂú∞ÁöÑÂú∞Êñπ„ÄÇ‰æãÂ¶ÇÔºö1234age = 20name = 'Swaroop'print('&#123;&#125; was &#123;&#125; years old when he wrote this book'.format(name, age))print('Why is &#123;&#125; playing with that python?'.format(name)) Python ‰∏≠ format ÊñπÊ≥ïÊâÄÂÅöÁöÑ‰∫ãÊÉÖ‰æøÊòØÂ∞ÜÊØè‰∏™ÂèÇÊï∞ÂÄºÊõøÊç¢Ëá≥Ê†ºÂºèÊâÄÂú®ÁöÑ‰ΩçÁΩÆ„ÄÇËøô‰πã‰∏≠ÂèØ‰ª•Êúâ Êõ¥ËØ¶ÁªÜÁöÑÊ†ºÂºèÔºå‰æãÂ¶Ç:123456789# ÂØπ‰∫éÊµÆÁÇπÊï∞ '0.333' ‰øùÁïôÂ∞èÊï∞ÁÇπ(.)Âêé‰∏â‰Ωçprint('&#123;0:.3f&#125;'.format(1.0/3))# ÊàñËÄÖÁúÅÁï•Ëä±Êã¨Âè∑ÈáåÈù¢ÈÇ£‰∏™0‰πüÊòØÂèØ‰ª•ÁöÑprint('&#123;:.3f&#125;'.format(1.0/3))# ‰ΩøÁî®‰∏ãÂàíÁ∫øÂ°´ÂÖÖÊñáÊú¨ÔºåÂπ∂‰øùÊåÅÊñáÂ≠óÂ§Ñ‰∫é‰∏≠Èó¥‰ΩçÁΩÆ# ‰ΩøÁî® (^) ÂÆö‰πâ '___hello___'Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ 11print('&#123;0:_^11&#125;'.format('hello'))# Âü∫‰∫éÂÖ≥ÈîÆËØçËæìÂá∫ 'Swaroop wrote A Byte of Python'print('&#123;name&#125; wrote &#123;book&#125;'.format(name='Swaroop', book='A Byte of Python')) Áî±‰∫éÊàë‰ª¨Ê≠£Âú®ËÆ®ËÆ∫Ê†ºÂºèÈóÆÈ¢òÔºåÂ∞±Ë¶ÅÊ≥®ÊÑè print ÊÄªÊòØ‰ºö‰ª•‰∏Ä‰∏™‰∏çÂèØËßÅÁöÑ‚ÄúÊñ∞‰∏ÄË°å‚ÄùÂ≠óÁ¨¶( \n ) ÁªìÂ∞æÔºåÂõ†Ê≠§ÈáçÂ§çË∞ÉÁî® print Â∞Ü‰ºöÂú®Áõ∏‰∫íÁã¨Á´ãÁöÑ‰∏ÄË°å‰∏≠ÂàÜÂà´ÊâìÂç∞„ÄÇ‰∏∫Èò≤Ê≠¢ÊâìÂç∞ËøáÁ®ã‰∏≠Âá∫Áé∞Ëøô‰∏Ä Êç¢Ë°åÁ¨¶Ôºå‰Ω†ÂèØ‰ª•ÈÄöËøá end ÊåáÂÆöÂÖ∂Â∫î‰ª•Á©∫ÁôΩÁªìÂ∞æ:12print('a', end='')print('b', end=' ')#‰ª•Á©∫Ê†ºÁªìÂ∞æ ËΩ¨‰πâÂ∫èÂàó Â¶ÇÊûúÂ∏åÊúõÁîüÊàê‰∏Ä‰∏≤ÂåÖÂê´ÂçïÂºïÂè∑( ‚Äò )ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†Â∫îËØ•Â¶Ç‰ΩïÊåáÂÆöËøô‰∏≤Â≠óÁ¨¶‰∏≤? ‰æãÂ¶ÇÔºå‰Ω†ÊÉ≥Ë¶ÅÁöÑÂ≠óÁ¨¶‰∏≤ÊòØ ‚ÄúWhat‚Äôs your name?‚Äù „ÄÇ‰Ω†‰∏çËÉΩÊåáÂÆö ‚ÄòWhat‚Äôs your name?‚Äô ÔºåÂõ†‰∏∫Ëøô ‰ºö‰Ωø Python ÂØπ‰∫é‰ΩïÂ§ÑÊòØÂ≠óÁ¨¶‰∏≤ÁöÑÂºÄÂßã„ÄÅ‰ΩïÂ§ÑÂèàÊòØÁªìÊùüËÄåÊÑüÂà∞Âõ∞ÊÉë„ÄÇÊâÄ‰ª•Ôºå‰Ω†ÂøÖÈ°ªÊåáÂÆöËøô‰∏™ÂçïÂºïÂè∑‰∏ç‰ª£Ë°®Ëøô‰∏≤Â≠óÁ¨¶‰∏≤ÁöÑÁªìÂ∞æ„ÄÇËøôÂèØ‰ª•ÈÄöËøáËΩ¨‰πâÂ∫èÂàó(Escape Sequence) Êù•ÂÆûÁé∞„ÄÇ‰Ω†ÈÄöËøá\ Êù•ÊåáÂÆöÂçïÂºïÂè∑:Ë¶ÅÊ≥®ÊÑèÂÆÉÂèØÊòØÂèçÊñúÊù†„ÄÇÁé∞Âú®Ôºå‰Ω†ÂèØ‰ª•Â∞ÜÂ≠óÁ¨¶‰∏≤ÊåáÂÆö‰∏∫ ‚ÄòWhat\‚Äôs your name?‚Äô Âè¶‰∏ÄÁßçÊåáÂÆöËøô‰∏ÄÁâπÂà´ÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑÊñπÂºèÊòØËøôÊ†∑ÁöÑ: ‚ÄúWhat‚Äôs your name?‚Äù ÔºåÂ¶ÇËøô‰∏™‰æãÂ≠êËà¨‰ΩøÁî® ÂèåÂºïÂè∑„ÄÇÁ±ª‰ººÂú∞Ôºå ‰Ω†ÂøÖÈ°ªÂú®‰ΩøÁî®ÂèåÂºïÂè∑Êã¨Ëµ∑ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠ÂØπÂ≠óÁ¨¶‰∏≤ÂÜÖÁöÑÂèåÂºïÂè∑‰ΩøÁî®ËΩ¨‰πâÂ∫èÂàó„ÄÇ ÂêåÊ†∑Ôºå‰Ω†ÂøÖÈ°ª‰ΩøÁî®ËΩ¨‰πâÂ∫èÂàó \ Êù•ÊåáÂÆöÂèçÊñúÊù†Êú¨Ë∫´„ÄÇ Â¶ÇÊûú‰Ω†ÊÉ≥ÊåáÂÆö‰∏Ä‰∏≤ÂèåË°åÂ≠óÁ¨¶‰∏≤ËØ•ÊÄé‰πàÂäû?‰∏ÄÁßçÊñπÂºèÂç≥‰ΩøÁî®Â¶ÇÂâçÊâÄËø∞ÁöÑ‰∏âÂºïÂè∑Â≠óÁ¨¶‰∏≤ÔºåÊàñËÄÖ‰Ω† ÂèØ‰ª•‰ΩøÁî®‰∏Ä‰∏™Ë°®Á§∫Êñ∞‰∏ÄË°åÁöÑËΩ¨‰πâÂ∫èÂàó‚Äî‚Äî\n Êù•Ë°®Á§∫Êñ∞‰∏ÄË°åÁöÑÂºÄÂßã„ÄÇÔºà‰∏écppÁ±ª‰ººÔºâ Âú®‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰∏≠Ôºå‰∏Ä‰∏™ÊîæÁΩÆÂú®Êú´Â∞æÁöÑÂèçÊñúÊù†Ë°®Á§∫Â≠óÁ¨¶‰∏≤Â∞ÜÂú®‰∏ã‰∏ÄË°åÁªßÁª≠Ôºå‰ΩÜ‰∏ç‰ºöÊ∑ªÂä†Êñ∞ÁöÑ‰∏ÄË°å„ÄÇÊù•ÁúãÁúã‰æãÂ≠ê:12"This is the first sentence. \This is the second sentence." Áõ∏ÂΩì‰∫é&quot;This is the first sentence. This is the second sentence.&quot; Âü∫Á°ÄËØ≠Ê≥ïÊâÄË∞ìÁâ©ÁêÜË°å(Physical Line)ÊòØ‰Ω†Âú®ÁºñÂÜôÁ®ãÂ∫èÊó∂ ‰Ω†ÊâÄÁúãÂà∞ÁöÑÂÜÖÂÆπ„ÄÇÊâÄË∞ìÈÄªËæëË°å(Logical Line)ÊòØ Python ÊâÄÁúãÂà∞ ÁöÑÂçï‰∏™ËØ≠Âè•„ÄÇPython ‰ºöÂÅáÂÆöÊØè‰∏ÄÁâ©ÁêÜË°å‰ºöÂØπÂ∫î‰∏Ä‰∏™ÈÄªËæëË°å„ÄÇÂ¶ÇÊûú‰Ω†Â∏åÊúõÂú®‰∏ÄË°åÁâ©ÁêÜË°å‰∏≠ÊåáÂÆöÂ§öË°åÈÄªËæëË°åÔºåÈÇ£‰πà‰Ω†ÂøÖÈ°ªÈÄöËøá‰ΩøÁî®ÂàÜÂè∑( ; )Êù•ÊòéÁ°ÆË°®ÊòéÈÄªËæëË°åÊàñËØ≠Âè•ÁöÑÁªìÊùü„ÄÇ Á©∫ÁôΩÂå∫Âú® Python ‰∏≠ÂçÅÂàÜÈáçË¶Å„ÄÇÂÆûÈôÖ‰∏äÔºåÁ©∫ÁôΩÂå∫Âú®ÂêÑË°åÁöÑÂºÄÂ§¥ÈùûÂ∏∏ÈáçË¶Å„ÄÇËøôË¢´Áß∞‰Ωú Áº©Ëøõ (Indentation)„ÄÇÂú®ÈÄªËæëË°åÁöÑÂºÄÂ§¥Áïô‰∏ãÁ©∫ÁôΩÂå∫(‰ΩøÁî®Á©∫Ê†ºÊàñÂà∂Ë°®Á¨¶)Áî®‰ª•Á°ÆÂÆöÂêÑÈÄªËæëË°åÁöÑÁº© ËøõÁ∫ßÂà´ÔºåËÄåÂêéËÄÖÂèàÂèØÁî®‰∫éÁ°ÆÂÆöËØ≠Âè•ÁöÑÂàÜÁªÑ„ÄÇËøôÊÑèÂë≥ÁùÄÊîæÁΩÆÂú®‰∏ÄËµ∑ÁöÑËØ≠Âè•ÂøÖÈ°ªÊã•ÊúâÁõ∏ÂêåÁöÑÁº©Ëøõ„ÄÇÊØè‰∏ÄÁªÑËøôÊ†∑ÁöÑËØ≠Âè•Ë¢´Áß∞‰∏∫ Âùó(block)„ÄÇ AttentionÔºö‰ΩøÁî®Âõõ‰∏™Á©∫Ê†ºÊù•Áº©Ëøõ„ÄÇËøôÊòØÊù•Ëá™ Python ËØ≠Ë®ÄÂÆòÊñπÁöÑÂª∫ËÆÆ„ÄÇÂ•ΩÁöÑÁºñËæëÂô®‰ºöËá™Âä®‰∏∫‰Ω†ÂÆåÊàêËøô ‰∏ÄÂ∑•‰Ωú„ÄÇËØ∑Á°Æ‰øù‰Ω†Âú®Áº©Ëøõ‰∏≠‰ΩøÁî®Êï∞Èáè‰∏ÄËá¥ÁöÑÁ©∫Ê†ºÔºåÂê¶Âàô‰Ω†ÁöÑÁ®ãÂ∫èÂ∞Ü‰∏ç‰ºöËøêË°åÔºåÊàñÂºïÂèë‰∏ç ÊúüÊúõÁöÑË°å‰∏∫„ÄÇ ËøêÁÆóÁ¨¶‰∏é‰ºòÂÖàÁ∫ßÈúÄË¶ÅÊ≥®ÊÑèÁöÑËøêÁÆóÁ¨¶** (‰πòÊñπ)ËøîÂõû x ÁöÑ y Ê¨°Êñπ„ÄÇ3**4 ËæìÂá∫ 81 (Âç≥ 3 3 3* 3 )„ÄÇ /(Èô§)x Èô§‰ª• y13 / 3 ËæìÂá∫ 4.333333333333333 „ÄÇ // (Êï¥Èô§)x Èô§‰ª• y Âπ∂ÂØπÁªìÊûúÂêë‰∏ãÂèñÊï¥Ëá≥ÊúÄÊé•ËøëÁöÑÊï¥Êï∞„ÄÇ 13 // 3 ËæìÂá∫ 4 „ÄÇ-13 // 3 ËæìÂá∫ -5 „ÄÇ &lt; (Â∞è‰∫é) &gt; (Â§ß‰∫é)ËøîÂõû x ÊòØÂê¶Â∞è‰∫é y„ÄÇÊâÄÊúâÁöÑÊØîËæÉËøêÁÆóÁ¨¶ËøîÂõûÁöÑÁªìÊûúÂùá‰∏∫ True Êàñ False „ÄÇËØ∑Ê≥®ÊÑèËøô ‰∫õÂêçÁß∞‰πã‰∏≠ÁöÑÂ§ßÂÜôÂ≠óÊØç„ÄÇ5&lt;3 ËæìÂá∫ False Ôºå3&lt;6 ËæìÂá∫ True „ÄÇÊØîËæÉÂèØ‰ª•‰ªªÊÑèÁªÑÊàêÈìæÊé•: 3 &lt; 5 &lt; 7 ËøîÂõû True „ÄÇÂ¶ÇÊûú‰∏§‰∏™Êìç‰ΩúÊï∞Âùá‰∏∫Êï∞Â≠óÔºåÂÆÉ‰ª¨È¶ñÂÖàÂ∞Ü‰ºöË¢´ËΩ¨Êç¢Ëá≥‰∏ÄÁßçÂÖ±ÂêåÁöÑÁ±ªÂûã„ÄÇÂê¶ÂàôÔºåÂÆÉÂ∞ÜÊÄªÊòØËøîÂõû False „ÄÇ not (Â∏ÉÂ∞î‚ÄúÈùû‚Äù) ÂØπÂ∫îcppÁöÑÔºÅand (Â∏ÉÂ∞î‚Äú‰∏é‚Äù) ÂØπÂ∫îcppÁöÑ&amp;or (Â∏ÉÂ∞î‚ÄúÊàñ‚Äù) ÂØπÂ∫îcppÁöÑ| ÂÖ∂‰ΩôËøêÁÆóÁ¨¶‰∏écppÂü∫Êú¨‰∏ÄËá¥ ‰ºòÂÖàÁ∫ß‰ª•‰∏ãËøêÁÆóÁ¨¶‰ºòÂÖàÁ∫ßÁî±‰ΩéËá≥È´òÊéíÂ∫èlambda :Lambda Ë°®ËææÂºè if - else :Êù°‰ª∂Ë°®ËææÂºè or :Â∏ÉÂ∞î‚ÄúÊàñ‚Äùand:Â∏ÉÂ∞î‚Äú‰∏é‚Äùnot x :Â∏ÉÂ∞î‚ÄúÈùû‚Äùin, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == :ÊØîËæÉÔºåÂåÖÊã¨ÊàêÂëòËµÑÊ†ºÊµãËØï (Membership Tests)ÂíåË∫´‰ªΩÊµãËØï(Identity Tests)„ÄÇ| :Êåâ‰ΩçÊàñ^ :Êåâ‰ΩçÂºÇÊàñ&amp; :Êåâ‰Ωç‰∏é&lt;&lt;, &gt;&gt; :ÁßªÂä®+, -:Âä†‰∏éÂáè*, /, //, %:‰πò„ÄÅÈô§„ÄÅÊï¥Èô§„ÄÅÂèñ‰Ωô+x, -x, ~x :Ê≠£„ÄÅË¥ü„ÄÅÊåâ‰ΩçÂèñÂèç** :Ê±ÇÂπÇx[index], x[index:index], x(arguments...), x.attribute :‰∏ãÊ†á„ÄÅÂàáÁâá„ÄÅË∞ÉÁî®„ÄÅÂ±ûÊÄßÂºï Áî®(expressions...), [expressions...], {key: value...}{expressions...}:Ë°®Á§∫ÁªëÂÆöÊàñÂÖÉ ÁªÑ„ÄÅË°®Á§∫ÂàóË°®„ÄÅË°®Á§∫Â≠óÂÖ∏„ÄÅË°®Á§∫ÈõÜÂêà ÊéßÂà∂‰∏éÂæ™ÁéØIf‚Ä¶else‚Ä¶‰æãÂ≠êÂ¶Ç‰∏ãÔºåÊ≥®ÊÑèÁº©Ëøõ:123456789101112131415161718number = 23guess = int(input('Enter an integer : '))if guess == number: # Êñ∞Âùó‰ªéËøôÈáåÂºÄÂßã print('Congratulations, you guessed it.') print('(but you do not win any prizes!)') # Êñ∞ÂùóÂú®ËøôÈáåÁªìÊùüelif guess &lt; number: # Âè¶‰∏Ä‰ª£Á†ÅÂùó print('No, it is a little higher than that') # ‰Ω†ÂèØ‰ª•Âú®Ê≠§ÂÅö‰ªª‰Ωï‰Ω†Â∏åÊúõÂú®ËØ•‰ª£Á†ÅÂùóÂÜÖËøõË°åÁöÑ‰∫ãÊÉÖelse: print('No, it is a little lower than that') # ‰Ω†ÂøÖÈ°ªÈÄöËøáÁåúÊµã‰∏Ä‰∏™Â§ß‰∫é(&gt;)ËÆæÁΩÆÊï∞ÁöÑÊï∞Â≠óÊù•Âà∞ËææËøôÈáå„ÄÇ print('Done')# ËøôÊúÄÂêé‰∏ÄÂè•ËØ≠Âè•Â∞ÜÂú®# if ËØ≠Âè•ÊâßË°åÂÆåÊØïÂêéÊâßË°å„ÄÇ Python ‰∏≠‰∏çÂ≠òÂú® switch ËØ≠Âè•„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøá‰ΩøÁî® if..elif..else ËØ≠Âè•Êù•ÂÆûÁé∞ÂêåÊ†∑ÁöÑ‰∫ãÊÉÖ whileÂæ™ÁéØ1234567891011121314151617number = 23running = Truewhile running: guess = int(input('Enter an integer : ')) if guess == number: print('Congratulations, you guessed it.') # ËøôÂ∞ÜÂØºËá¥ while Âæ™ÁéØ‰∏≠Ê≠¢ running = False elif guess &lt; number: print('No, it is a little higher than that.') else: print('No, it is a little lower than that.')else: print('The while loop is over.') # Âú®ËøôÈáå‰Ω†ÂèØ‰ª•ÂÅö‰Ω†ÊÉ≥ÂÅöÁöÑ‰ªª‰Ωï‰∫ã print('Done') Ê≥®ÊÑèÔºö‰Ω†ÂèØ‰ª•Âú® while Âæ™ÁéØ‰∏≠‰ΩøÁî® else ‰ªéÂè•„ÄÇ forÂæ™ÁéØ1234for i in range(1, 5): print(i)else: print('The for loop is over') Ê≥®ÊÑèrangeÈáåÈù¢ÊòØÂâçÈó≠ÂêéÂºÄÁöÑÂå∫Èó¥ÔºÅ else ÈÉ®ÂàÜÊòØÂèØÈÄâÁöÑ„ÄÇÂΩìÂæ™ÁéØ‰∏≠ÂåÖÂê´‰ªñÊó∂ÔºåÂÆÉÊÄª‰ºöÂú® for Âæ™ÁéØÁªìÊùüÂêéÂºÄÂßãÊâß Ë°åÔºåÈô§ÈùûÁ®ãÂ∫èÈÅáÂà∞‰∫Ü break ËØ≠Âè•„ÄÇ Âú®ËøôÈáåÊàë‰ª¨ÊâÄË¶ÅÂÅöÁöÑ‰∫ãÊÉÖÊòØÊèê‰æõ‰∏§‰∏™Êï∞Â≠óÔºåËÄå range Â∞Ü‰ºöËøîÂõû‰∏Ä‰∏™Êï∞Â≠óÂ∫èÂàóÔºå‰ªéÁ¨¨‰∏Ä‰∏™Êï∞Â≠ó ÂºÄÂßãÔºåËá≥Á¨¨‰∫å‰∏™Êï∞Â≠óÁªìÊùü„ÄÇ‰∏æ‰∏™‰æãÂ≠êÔºå range(1,5) Â∞ÜËæìÂá∫Â∫èÂàó [1, 2, 3, 4] „ÄÇÂú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºårange Â∞Ü‰ºö‰ª• 1 ÈÄêÊ≠•ÈÄíÂ¢û„ÄÇÂ¶ÇÊûúÊàë‰ª¨Âêë range Êèê‰æõÁ¨¨‰∏â‰∏™Êï∞Â≠óÔºåÂàôËøô‰∏™Êï∞Â≠óÂ∞ÜÊàê‰∏∫ÈÄê Ê≠•ÈÄíÂ¢ûÁöÑÂä†Êï∞„ÄÇ ÂêåÊ†∑‰∏æ‰∏™‰æãÂ≠êÊù•ËØ¥Êòérange(1,5,2) Â∞Ü‰ºöËæìÂá∫ [1, 3] „ÄÇË¶ÅËÆ∞‰ΩèËøô‰∏ÄÂ∫èÂàóÊâ© Â±ïÁõ¥Âà∞Á¨¨‰∫å‰∏™Êï∞Â≠óÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÂÆÉ‰∏ç‰ºöÂåÖÊã¨Á¨¨‰∫å‰∏™Êï∞Â≠óÂú®ÂÜÖ„ÄÇ break123456while True: s = input('Enter something : ') if s == 'quit':break print('Length of the string is', len(s))print('Done') Êúâ‰∏ÄÁÇπÈúÄË¶ÅÂ∞§ÂÖ∂Ê≥®ÊÑèÔºåÂ¶ÇÊûú‰Ω† ‰∏≠Êñ≠ ‰∫Ü‰∏Ä‰∏™ for Êàñ while Âæ™ÁéØÔºå‰ªª‰ΩïÁõ∏Â∫îÂæ™ÁéØ‰∏≠ÁöÑ elseÂùóÈÉΩÂ∞Ü‰∏ç‰ºöË¢´ÊâßË°å„ÄÇ continuecontinue ËØ≠Âè•Áî®‰ª•ÂëäËØâ Python Ë∑≥ËøáÂΩìÂâçÂæ™ÁéØÂùó‰∏≠ÁöÑÂâ©‰ΩôËØ≠Âè•ÔºåÂπ∂ÁªßÁª≠ËØ•Âæ™ÁéØÁöÑ‰∏ã‰∏ÄÊ¨°Ëø≠‰ª£„ÄÇ123456789while True: s = input('Enter something : ') if s == 'quit': break if len(s) &lt; 3: print('Too small') continueprint('Input is of sufficient length')# Ëá™Ê≠§Â§ÑËµ∑ÁªßÁª≠ËøõË°åÂÖ∂ÂÆÉ‰ªª‰ΩïÂ§ÑÁêÜ ÂáΩÊï∞ÂáΩÊï∞ÂèØ‰ª•ÈÄöËøáÂÖ≥ÈîÆÂ≠ó def Êù•ÂÆö‰πâ„ÄÇËøô‰∏ÄÂÖ≥ÈîÆÂ≠óÂêéË∑ü‰∏Ä‰∏™ÂáΩÊï∞ÁöÑÊ†áËØÜÁ¨¶ÂêçÁß∞ÔºåÂÜçË∑ü‰∏ÄÂØπÂúÜÊã¨Âè∑ÔºåÂÖ∂‰∏≠ÂèØ‰ª•ÂåÖÊã¨‰∏Ä‰∫õÂèòÈáèÁöÑÂêçÁß∞ÔºåÂÜç‰ª•ÂÜíÂè∑ÁªìÂ∞æÔºåÁªìÊùüËøô‰∏ÄË°å„ÄÇÈöèÂêéËÄåÊù•ÁöÑËØ≠Âè•ÂùóÊòØÂáΩÊï∞ÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ12345678910111213def print_max(a, b): if a &gt; b: print(a, 'is maximum') elif a == b: print(a, 'is equal to', b) else:print(b, 'is maximum') # Áõ¥Êé•‰º†ÈÄíÂ≠óÈù¢ÂÄºprint_max(3, 4) x=5y=7# ‰ª•ÂèÇÊï∞ÁöÑÂΩ¢Âºè‰º†ÈÄíÂèòÈáèprint_max(x, y) globalËØ≠Âè•Â¶ÇÊûú‰Ω†ÊÉ≥Áªô‰∏Ä‰∏™Âú®Á®ãÂ∫èÈ°∂Â±ÇÁöÑÂèòÈáèËµãÂÄº(‰πüÂ∞±ÊòØËØ¥ÂÆÉ‰∏çÂ≠òÂú®‰∫é‰ªª‰Ωï‰ΩúÁî®Âüü‰∏≠ÔºåÊó†ËÆ∫ÊòØÂáΩÊï∞Ëøò ÊòØÁ±ª)ÔºåÈÇ£‰πà‰Ω†ÂøÖÈ°ªÂëäËØâ Python Ëøô‰∏ÄÂèòÈáèÂπ∂ÈùûÂ±ÄÈÉ®ÁöÑÔºåËÄåÊòØÂÖ®Â±Ä(Global)ÁöÑ„ÄÇÊàë‰ª¨ÈúÄË¶ÅÈÄö Ëøá global ËØ≠Âè•Êù•ÂÆåÊàêËøô‰ª∂‰∫ã„ÄÇÂõ†‰∏∫Âú®‰∏ç‰ΩøÁî® global ËØ≠Âè•ÁöÑÊÉÖÂÜµ‰∏ãÔºå‰∏çÂèØËÉΩ‰∏∫‰∏Ä‰∏™ÂÆö‰πâ‰∫é ÂáΩÊï∞‰πãÂ§ñÁöÑÂèòÈáèËµãÂÄº„ÄÇ ËØ¥‰∫∫ËØùÂ∞±ÊòØÔºåPythonÁöÑÂáΩÊï∞‰∏≠Â¶ÇÊûúÊÉ≥Áî®ÂáΩÊï∞Â§ñÈÉ®ÁöÑÂèòÈáèÁöÑËØùÔºåÂøÖÈ°ªÂú®ÂáΩÊï∞‰∏≠Â£∞ÊòéËøô‰∏™ÂèòÈáèÊòØglobalÁöÑÔºå‰∏çÁÑ∂‰ºöÂú®ÂáΩÊï∞ÂÜÖÂàõÂª∫‰∏Ä‰∏™ÂêåÂêçÁöÑÂ±ÄÈÉ®ÂèòÈáèÔºåÂπ∂‰∏îÂ±ÄÈÉ®ÂèòÈáè‰∏éÂ§ñÈÉ®ÂèòÈáèÂπ∂Ê≤°Êúâ‰ªÄ‰πàÂÖ≥Á≥ª„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÂÖ®Â±ÄÂèòÈáèÂÖ∂ÂÆûÂπ∂‰∏çÊòØÂæàÂ•ΩÁî®Ôºõ‰æãÂ≠êÔºö Â£∞ÊòéglobalÁöÑÊÉÖÂÜµÔºö123456789x=50def func(): global x x=10print('x is', x)x=2print('Changed global x to', x)func()print('Value of x is', x) ËæìÂá∫Ôºö123x is 50Changed global x to 2Value of x is 10 ‰∏çÂ£∞ÊòéglobalÁöÑÊÉÖÂÜµÔºö123456789x=50def func(): #global x x=10print('x is', x)x=2print('Changed global x to', x)func()print('Value of x is', x) ËæìÂá∫Ôºö123x is 50Changed global x to 2Value of x is 2 ÈªòËÆ§ÂèÇÊï∞ÂÄº ÂØπ‰∫é‰∏Ä‰∫õÂáΩÊï∞Êù•ËØ¥Ôºå‰Ω†ÂèØËÉΩ‰∏∫Â∏åÊúõ‰Ωø‰∏Ä‰∫õÂèÇÊï∞ÂèØÈÄâÂπ∂‰ΩøÁî®ÈªòËÆ§ÁöÑÂÄºÔºå‰ª•ÈÅøÂÖçÁî®Êà∑‰∏çÊÉ≥‰∏∫‰ªñ‰ª¨ Êèê‰æõÂÄºÁöÑÊÉÖÂÜµ„ÄÇÈªòËÆ§ÂèÇÊï∞ÂÄºÂèØ‰ª•ÊúâÊïàÂ∏ÆÂä©Ëß£ÂÜ≥Ëøô‰∏ÄÊÉÖÂÜµ„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøáÂú®ÂáΩÊï∞ÂÆö‰πâÊó∂ÈôÑÂä†‰∏Ä‰∏™ ËµãÂÄºËøêÁÆóÁ¨¶( = )Êù•‰∏∫ÂèÇÊï∞ÊåáÂÆöÈªòËÆ§ÂèÇÊï∞ÂÄº„ÄÇ Ë¶ÅÊ≥®ÊÑèÂà∞ÔºåÈªòËÆ§ÂèÇÊï∞ÂÄºÂ∫îËØ•ÊòØÂ∏∏Êï∞„ÄÇÊõ¥Á°ÆÂàáÂú∞ËØ¥ÔºåÈªòËÆ§ÂèÇÊï∞ÂÄºÂ∫îËØ•ÊòØ‰∏çÂèØÂèòÁöÑ‰æãÂ≠êÔºö1234def say(message, times=1): print(message * times)say('Hello')say('World', 5) ËæìÂá∫Ôºö123$ python function_default.pyHelloWorldWorldWorldWorldWorld Ê≥®ÊÑè! Âè™ÊúâÈÇ£‰∫õ‰Ωç‰∫éÂèÇÊï∞ÂàóË°®Êú´Â∞æÁöÑÂèÇÊï∞ÊâçËÉΩË¢´Ëµã‰∫àÈªòËÆ§ÂèÇÊï∞ÂÄºÔºåÊÑèÂç≥Âú®ÂáΩÊï∞ÁöÑÂèÇÊï∞ÂàóË°®‰∏≠Êã•ÊúâÈªòËÆ§ÂèÇÊï∞ÂÄºÁöÑÂèÇÊï∞‰∏çËÉΩ‰Ωç‰∫éÊ≤°ÊúâÈªòËÆ§ÂèÇÊï∞ÂÄºÁöÑÂèÇÊï∞‰πãÂâç„ÄÇËøôÊòØÂõ†‰∏∫ÂÄºÊòØÊåâÂèÇÊï∞ÊâÄÂ§ÑÁöÑ‰ΩçÁΩÆ‰æùÊ¨°ÂàÜÈÖçÁöÑ„ÄÇ‰∏æ‰æãÊù•ËØ¥Ôºådef func(a, b=5) ÊòØÊúâÊïàÁöÑÔºå ‰ΩÜ def func(a=5, b) ÊòØÊó†ÊïàÁöÑ„ÄÇ ÂÖ≥ÈîÆÂ≠óÂèÇÊï∞ Â¶ÇÊûú‰Ω†Êúâ‰∏Ä‰∫õÂÖ∑ÊúâËÆ∏Â§öÂèÇÊï∞ÁöÑÂáΩÊï∞ÔºåËÄå‰Ω†ÂèàÂ∏åÊúõÂè™ÂØπÂÖ∂‰∏≠ÁöÑ‰∏Ä‰∫õËøõË°åÊåáÂÆöÔºåÈÇ£‰πà‰Ω†ÂèØ‰ª•ÈÄöËøá ÂëΩÂêçÂÆÉ‰ª¨Êù•ÁªôËøô‰∫õÂèÇÊï∞ËµãÂÄº‚Äî‚ÄîËøôÂ∞±ÊòØÂÖ≥ÈîÆÂ≠óÂèÇÊï∞(Keyword Arguments)‚Äî‚ÄîÊàë‰ª¨‰ΩøÁî®ÂëΩÂêç(ÂÖ≥ÈîÆÂ≠ó)ËÄåÈùû‰ΩçÁΩÆ(‰∏ÄÁõ¥‰ª•Êù•Êàë‰ª¨ÊâÄ‰ΩøÁî®ÁöÑÊñπÂºè)Êù•ÊåáÂÆöÂáΩÊï∞‰∏≠ÁöÑÂèÇÊï∞„ÄÇ ËøôÊ†∑ÂÅöÊúâ‰∏§Â§ß‰ºòÁÇπ‚Äî‚ÄîÂÖ∂‰∏ÄÔºåÊàë‰ª¨‰∏çÂÜçÈúÄË¶ÅËÄÉËôëÂèÇÊï∞ÁöÑÈ°∫Â∫èÔºåÂáΩÊï∞ÁöÑ‰ΩøÁî®Â∞ÜÊõ¥Âä†ÂÆπÊòì„ÄÇÂÖ∂‰∫åÔºåÊàë‰ª¨ÂèØ‰ª•Âè™ÂØπÈÇ£‰∫õÊàë‰ª¨Â∏åÊúõËµãÙè∞ÄÁöÑÂèÇÊï∞‰ª•ËµãÂÄºÔºåÂè™Ë¶ÅÂÖ∂ÂÆÉÁöÑÂèÇÊï∞ÈÉΩÂÖ∑ÊúâÈªòËÆ§ÂèÇÊï∞ÂÄº„ÄÇ‰æãÂ≠êÔºö12345def func(a, b=5, c=10): print('a is', a, 'and b is', b, 'and c is', c)func(3, 7)func(25, c=24)func(c=50, a=100) ËæìÂá∫Ôºö1234$ python function_keyword.pya is 3 and b is 7 and c is 10a is 25 and b is 5 and c is 24a is 100 and b is 5 and c is 50]]></content>
      <categories>
        <category>Python</category>
        <category>PythonÂü∫Êú¨ËØ≠Ê≥ï</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonÂü∫Êú¨ËØ≠Ê≥ï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233]]></title>
    <url>%2Farticle%2F233%2F</url>
    <content type="text"><![CDATA[23323323312345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl; return 0;&#125; 2333 test ss s $233+34+A^3+A_5^4$ 2333 $A_5^4+A+23$ 233333333 ÂìàÂìàÂìà test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Farticle%2Ftest%2F</url>
    <content type="text"><![CDATA[233 test]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farticle%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[ËíüËíªÁöÑLinuxÈöèÁ¨î]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FLinux%2Fe8-92-9f-e8-92-bb-e7-9a-84linux-e9-9a-8f-e7-ac-94%2F</url>
    <content type="text"><![CDATA[ÊúÄËøëÁ™ÅÁÑ∂ÂºÄÂßãÁ†îÁ©∂‰∫Ü‰∏Ä‰∏ãLinuxÔºåÈöèÊâãËÆ∞ÂΩï‰∏Ä‰∏ã‰∏Ä‰∫õÁî®ËøáÁöÑÁúãËµ∑Êù•ÊØîËæÉÊúâÊÑèÊÄùÁöÑÂëΩ‰ª§ÂêßQAQ Êñá‰ª∂ÊµèËßà&amp;Â∏∏Áî®‰π±‰∏ÉÂÖ´Á≥üÁºñËØëÂëΩ‰ª§Ôºö g++ a+b.cpp -o a+b+c -std=c++11 a+b.cppÊòØcppÊñá‰ª∂ÂêçÔºåa+b+cÂàôÊòØÂèØÊâßË°åÊñá‰ª∂ÂêçÔºåÂêéÈù¢ÂàôÂèØ‰ª•ÈÄâÊã©ÁºñËØëÊ†áÂáÜ„ÄÇ ls ÊµèËßàÂΩìÂâçÊñá‰ª∂Â§π‰∏ãÁöÑÊâÄÊúâÊñá‰ª∂Ôºà‰∏çÂåÖÂê´ÈöêËóèÊñá‰ª∂ ls -a ÊòæÁ§∫ÊâÄÊúâÊñá‰ª∂ÔºàÂåÖÊã¨ÈöêËóèÊñá‰ª∂Ôºâ man ls manÂêéÈù¢Âä†‰∏úË•øÔºåÊòæÁ§∫ËØ•ÂëΩ‰ª§ÁöÑÂ∏ÆÂä©Ôºå‰∏ä‰∏ã/Á©∫Ê†ºÊµèËßàÔºåqÈÄÄÂá∫ cal ÊòæÁ§∫Êó•ÂéÜ„ÄÇcal 5 2018ÂèØÊòæÁ§∫ÊåáÂÆöÊúà‰ªΩ„ÄÇ Êñá‰ª∂ÊâìÂºÄ&amp;Êñ∞Âª∫&amp;Âà†Èô§ cd name ÊâìÂºÄÊñá‰ª∂ cd/cd ~ ÂõûÂà∞Ê†πÁõÆÂΩï cd .. ÂõûÂà∞‰∏ä‰∏ÄÁ∫ßÁõÆÂΩï pwd ÊòæÁ§∫ÂΩìÂâçË∑ØÂæÑ mkdir name Êñ∞Âª∫Êñá‰ª∂Â§π mkdir -p name/name/name ÊåâË∑ØÂæÑÂª∫Á´ãÂ§ö‰∏™Êñ∞Êñá‰ª∂Â§π rmdir name Âà†Èô§Ê≠§Êñá‰ª∂Â§πÔºàË¢´Âà†Èô§Êñá‰ª∂Â§πÂøÖÈ°ª‰∏∫Á©∫Ôºâ rm -r name Âπ≤ÁøªnameÁõÆÂΩï‰∏ãÊâÄÊúâÊñá‰ª∂ÔºàÂà†Â∫ìË∑ëË∑ØÔºüÔºâ Êñá‰ª∂Â§çÂà∂ÔºåÁßªÂä®ÔºåÂà†Èô§Êñá‰ª∂Â§çÂà∂ cp ~/testpdf.pdf ~/test Â∞ÜÊ†πÁõÆÂΩï‰∏ãÁöÑÊñá‰ª∂copyÂà∞Á©∫Ê†ºÂêéÁöÑÁõÆÂΩï‰∏≠Ôºå~/‰∏çÂ°´ÂàôÈªòËÆ§‰∏∫ÂΩìÂâçÁõÆÂΩï‰∏ãÁöÑÊñá‰ª∂ ÂèØ‰ª•Âú®Â§çÂà∂ÁöÑÂêåÊó∂ÂØπÂ§çÂà∂ÂêéÁöÑÊñá‰ª∂ËøõË°åÈáçÂëΩÂêçÔºö cp ~/testpdf.pdf ~/test/notest.pdf Â§çÂà∂ËøáÂéªÁöÑpdfÂêçÂ≠óÂ∞±Âèò‰∫Ü ÂèØ‰ª•Âä†‰∏ä-iÈÄâÈ°πÔºåËøôÊ†∑ÊúâÂêåÂêçÊñá‰ª∂Ë¶ÜÁõñÂâç‰ºöËØ¢ÈóÆÊòØÂê¶Ë¶ÜÁõñÔºö cp -i ~/testpdf.pdf ~/test Â¶ÇÊûúË¶ÅÂ§çÂà∂‰∏Ä‰∏™ÁõÆÂΩïÔºåÊàñËÄÖËØ¥ÊòØÊñá‰ª∂Â§πÔºåÈÇ£‰πàÈúÄË¶ÅÂä†‰∏äÊåá‰ª§ -r cp -r test1 test2 Â¶ÇÊûúË¶ÅÂº∫Âà∂ÊâßË°åÔºåËøòÂèØ‰ª•‰ΩøÁî®-fÊåá‰ª§ÔºõÂêåÊó∂ÔºåÂ§ö‰∏™Êåá‰ª§ÂèØ‰ª•Âè†Âä†‰ΩøÁî®Ôºå‰æãÂ¶ÇÔºö cp -rf test1 test2 Âº∫Âà∂Â§çÂà∂ÁõÆÂΩï Êñá‰ª∂Âà†Èô§‰ΩøÁî®Êåá‰ª§rm‰ª•ËææÂà∞ÁõÆÁöÑÔºåÂêåÊ†∑ÔºåÂà†Èô§ÁõÆÂΩïÈúÄË¶Å‰ΩøÁî®-rÔºåËøôÊòØÈÄíÂΩíÂà†Èô§ÂëΩ‰ª§Ôºõ rm -r test1 -iÂàô‰ºöÂú®Âà†Èô§ÂâçÁ°ÆËÆ§Ôºå-fË°®Á§∫Âº∫Âà∂ÊâßË°å„ÄÇÂêåÊó∂ÔºåËøòÂèØ‰ª•‰ΩøÁî®Êåá‰ª§ rm test* ÈÄöËøáÂä†‰∏ä ‚Äú* ‚Äù Êù•Âà†Èô§Ê≠§ÁõÆÂΩï‰∏ãÊâÄÊúâÊñá‰ª∂Âêç‰ª•test‰∏∫ÂâçÁºÄÁöÑÊñá‰ª∂Ôºõ Êñá‰ª∂ÁßªÂä®‰ΩøÁî®mvÊåá‰ª§Êù•ËææÊàêÁõÆÁöÑ„ÄÇmvÊåá‰ª§ÂèØ‰ª•ÁßªÂä®ÊôÆÈÄöÊñá‰ª∂ÂíåÁõÆÂΩïÔºåÂõ†Ê≠§‰∏çÂ≠òÂú®-r-f Âº∫Âà∂Ôºå-iÔºöÂ¶ÇÊûúÂ≠òÂú®ÂêåÂêçÊñá‰ª∂ÔºåËØ¢ÈóÆÊòØÂê¶Ë¶ÜÁõñÔºõ -uÔºöÂ¶ÇÊûúÁõÆÊ†áÊñá‰ª∂Â∑≤Â≠òÂú®Ôºå‰∏îÂΩìÂâçÊù•Ê∫êËæÉÊñ∞Êâç‰ºöÊõ¥Êñ∞ mv a+b ~/test/test2/ Â∞ÜÂΩìÂâçÁõÆÂΩï‰∏≠ÁöÑÂèØÊâßË°åÊñá‰ª∂a+bÁßªÂä®Âà∞ÊåáÂÆöÊñá‰ª∂Â§π‰∏≠Ôºõ mv a+b ~/test/test2/a+c ÁßªÂä®Êñá‰ª∂ÁöÑÂêåÊó∂ËøõË°åÂêçÁß∞ÂèòÊõ¥Ôºõ mv a+b a+c ~/test/ ÂêåÊó∂ÁßªÂä®Â§ö‰∏™Êñá‰ª∂ÔºõÊ≥®ÊÑèÊ≠§Êó∂ÊúÄÂêé‰∏Ä‰∏™‰∏ÄÂÆöÊòØÁõÆÂΩïÔºÅÔºÅÔºÅ]]></content>
      <categories>
        <category>‰π±Êêû</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>‰π±Êêû</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 18 (rated, Div. 1 + Div. 2)]]></title>
    <url>%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fmanthan-codefest-18-rated-div-1-div-2%2F</url>
    <content type="text"><![CDATA[1wÂπ¥Ê≤°Êõ¥Êñ∞‰∫ÜQAQ A. ÂÇªÈÄºÈ¢ò‰∫åËøõÂà∂ÂàÜËß£‰∏Ä‰∏ãÂç≥ÂèØ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=0;;i++){ if(n&lt;=(1&lt;&lt;i))break; n-=(1&lt;&lt;i); } cout&lt;&lt;i+1&lt;&lt;endl; return 0; } B. Êéí‰∏™Â∫èË¥™ÂøÉÊêûÊêûÂ∞±Ë°åÔºåËá™Â∑±zz‰∫ÜËøòwa‰∫Ü3Âèë‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { int num[200005],n,s,i,j,k; ll ans=0; cin&gt;&gt;n&gt;&gt;s; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); sort(num+1,num+1+n); int mid=(n+1)&gt;&gt;1; if(num[mid]==s){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(num[mid]&gt;s){ for(i=mid;i;i--){ if(num[i]&lt;=s)break; ans+=num[i]-s; } } else{ for(i=mid;i&lt;=n;i++){ if(num[i]&gt;=s)break; ans+=s-num[i]; //cout&lt;&lt;ans&lt;&lt;endl; } } //cout&lt;&lt;mid&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. Èô§ÈùûÁõ∏ÈÇª‰ΩçÁΩÆÂàöÂ•ΩË¶Å‰∫§Êç¢ÔºåÂê¶ÂàôÈÉΩÊ≤°Êúâ‰∫§Êç¢ÊÑè‰πâÔºåÈöè‰æøÊêûÊêûÂç≥ÂèØ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k;string str1,str2; int ans=0; cin&gt;&gt;n; cin&gt;&gt;str1&gt;&gt;str2; for(i=0;i&lt;str1.size();i++){ if(str1[i]!=str2[i]){ if(i&lt;str1.size()-1&amp;&amp;str1[i+1]!=str2[i+1]&amp;&amp;str1[i]!=str1[i+1]){ ans++;i++; } else{ ans++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. ÂÖ∂ÂÆûÂ∞±ÊòØ‰∏Ä‰∏™‰∫åÂèâÊ†ëÁöÑÂ±ÇÊ¨°ÈÅçÂéÜÔºå‰ΩÜÊòØËøòÊúâ‰∏ÄÁÇπË¶ÅÊ≥®ÊÑèÁöÑÂ∞±ÊòØÁà∂‰∫≤Â±ÇÁöÑÈÅçÂéÜÈ°∫Â∫èÂÜ≥ÂÆö‰∫Ü‰∏ã‰∏ÄÂ±ÇÁöÑÈÅçÂéÜÈ°∫Â∫èÔºåÊâÄ‰ª•Ëøô‰πüË¶ÅËÄÉËôë„ÄÇËß£ÂÜ≥ÊñπÊ°àÊòØÊØè‰∏™ÁÇπÂª∫‰∏Ä‰∏™mapËÆ∞ÂΩïËæπÔºåÁÑ∂ÂêéÊ£ÄÊµãÂ∫èÂàóÁöÑÊó∂ÂÄôÂºÑ‰∏§‰∏™ÊåáÈíàÔºå‰∏Ä‰∏™ÊåáÁ§∫ÂΩìÂâçËäÇÁÇπÔºåÂè¶‰∏Ä‰∏™ÊåáÁ§∫ÂΩìÂâçËäÇÁÇπÁöÑÂÑøÂ≠ê„ÄÇÂ¶ÇÊûúÊòØÈùûÊ≥ïÂ∫èÂàóÔºåÊúÄÂêéÁ¨¨‰∫å‰∏™ÊåáÈíàËÇØÂÆöÊ≤°Ê≥ïËµ∞ÂÆåÊâÄÊúâÁöÑËäÇÁÇπ„ÄÇÂêåÊó∂ËøòË¶ÅÊ≥®ÊÑèÁâπÂà§Ê†πËäÇÁÇπÊòØÂê¶‰∏∫1 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt;mp1[200005]; int main() { int n,i,j,k,x,y; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y);mp1[x][y]=1;mp1[y][x]=1; } int num[200005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); for(i=1,j=2;i&lt;=n;i++) while(mp1[num[i]][num[j]]) j++; if(j==n+1&amp;&amp;num[1]==1){//Ê≥®ÊÑèËøôÈáåÊòØj==n+1!! cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; //cout&lt;&lt;j&lt;&lt;endl; return 0; } E. ÈöæÁÇπÂú®‰∫éÊÄé‰πàÂéªÊ£ÄÊµã‰∏Ä‰∏™‰∫∫ÊòØÂê¶ÊúâËá≥Â∞ëk‰∏™ÊúãÂèãÔºåÂπ∂‰∏îËøô‰∫õÊúãÂèã‰πüÈÉΩÊúâËá≥Â∞ëk‰∏™ÂèØ‰ª•ÂéªÊóÖÊ∏∏ÁöÑÊúãÂèã‚Ä¶Ê†áÁÆóÂæàÁ≤æÂ¶ô‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; set&lt;int&gt;s,G[maxn]; int k,a[maxn],b[maxn],ans[maxn],n,m; void check(int x) { if(G[x].size()&lt;k&amp;&amp;s.erase(x)){//Â¶ÇÊûúËøô‰∏™‰∫∫ÁöÑÊúãÂèãÂ∞è‰∫ék,‰ªñËÇØÂÆöË¶ÅÊªöËõã,ÂêåÊó∂Âú®sÈáåÈù¢‰πüË¶ÅÂà†ÂéªÊ≠§‰∫∫ for(auto a:G[x]){ G[a].erase(x);check(a);//‰ªñÁöÑÊúãÂèã‰πüË¶Åcheck‰∏ÄÂèë } } } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); G[a[i]].insert(b[i]);G[b[i]].insert(a[i]);//Âª∫Á´ãÊúãÂèãÂÖ≥Á≥ª } for(i=1;i&lt;=n;i++)s.insert(i); for(i=1;i&lt;=n;i++)check(i);//Ê£ÄÊü•ÊØè‰∏Ä‰∏™‰∫∫ÁöÑÊúãÂèãÂÖ≥Á≥ª for(i=m;i;i--){ ans[i]=s.size();//Ê≠§Êó∂ÈõÜÂêà‰∏≠ÁöÑÊâÄÊúâ‰∫∫ÈÉΩÊª°Ë∂≥Ë¶ÅÊ±Ç G[a[i]].erase(b[i]);G[b[i]].erase(a[i]);//Âà†ÂéªËøôÂ§©ÊâçÊàê‰∏∫ÊúãÂèãÁöÑ‰∫∫ check(a[i]);check(b[i]); } for(i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]); return 0; }]]></content>
      <categories>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊÑèÁëûÊ≥ï‰πãÊóÖ‚Äî‚ÄîÂíïÂíïÂíïÁ≥ªÂàó]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%97%85%E6%B8%B8%2Fe6-84-8f-e7-91-9e-e6-b3-95-e4-b9-8b-e6-97-85-e5-92-95-e5-92-95-e5-92-95-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[8.26‰∏ÄÂ§ßÊó©5ÁÇπÈíüÂ∞±ÊªöÂéªÊú∫Âú∫‰∫ÜÔºåÈ£ûÊú∫ÂÄíÊòØÊ≤°Âª∂ËØØÔºå‰ΩÜÊòØÂçóËà™ÁöÑËøôÁè≠È£ûÊú∫ÁúüÂøÉ‰∏çÊï¢ÊÅ≠Áª¥‚Äî‚ÄîÈ¶ñÂÖàÈ£ûÊú∫Âú®ËøúÊú∫‰ΩçÔºåÂùêÊëÜÊ∏°ËΩ¶Ë∑ë‰∫ÜÂçäÂ§©ÔºåÁÑ∂ÂêéÂ§ßÊ¶ÇÊòØÈ£ûÊú∫ÊØîËæÉÈôàÊóßÁöÑÁºòÊïÖÂêßÔºåËøû‰∏™‰∫∫Â®±‰πêÁ≥ªÁªüÈÉΩÊ≤°ÊúâÔºåÊó†ËÅäÂæó‰∏çË°åÔºåË¶ÅÊòØÈ£ûÂõΩÈôÖÁ∫ø‰πòÂÆ¢‰º∞ËÆ°ËÉΩÊó†ËÅäÊ≠ª„ÄÇÈ§êÈ£üÂ∞±Êõ¥Âä†Êó†ËØ≠‰∫ÜÔºåÈù¢Êù°ÈùûÂ∏∏ÈöæÂêÉÔºåËøòÊØè‰∫∫Âèë‰∫ÜÂçä‰∏™Áï™ËñØ‚Ä¶ËØ¥Ëµ∑Êù•Áï™ËñØÂ•ΩÂÉèËøòÊòØÊúÄÂ•ΩÂêÉÁöÑ„ÄÇÂπ∏Â•ΩËà™Á®ã‰∏çÈïøÔºåÁù°‰∏ÄËßâ‰πüÂ∞±Âà∞‰∫Ü„ÄÇ‰∏çËøá‰∏ãÈôçÁöÑÊó∂ÂÄôÈ£ûË∂ä‰∫ÜÂπøÂ∑ûÂ∏ÇÂå∫ÂÄíÊòØÂ•ΩËØÑÔºåÁ¨¨‰∏ÄÊ¨°Â¶ÇÊ≠§ÂÆåÊï¥ÁöÑÂú®Á©∫‰∏≠‰øØÁû∞ÂπøÂ∑û‚Äî‚ÄîÊàëÁîöËá≥Ê∏ÖÊô∞Âú∞ÊãçÂà∞‰∫ÜÂ∞èËõÆËÖ∞„ÄÇ ÊªöÂõûÂÆ∂Â∞±12ÁÇπ‰∫ÜÔºåÁù°‰∫Ü‰∏ÄËßâËµ∑Êù•5ÁÇπ‰∫Ü‚Ä¶Êêû‰∫ÜÊêûÂêÉ‰∫Ü‰∏™È•≠ÂèàÊÑâÂø´Âú∞ÂéªÊú∫Âú∫‰∫ÜÔºåÊñ∞Ëà™Á´ôÊ•ºÁöÑÁ©∫Ë∞ÉÁúüÁöÑÂ•ΩÂÜ∑QAQ„ÄÇËà™Áè≠ÂÖ∂ÂÆûÊòØÂáåÊô®00Ôºö35ÁöÑ‚Ä¶ÁôªÊú∫ÁöÑÊó∂ÂÄôÂâçÈù¢Êúâ‰ø©ËõÆÂ∏ÖÁöÑÂ∞èÂì•Âì•Ôºå‰∏çËøá‰ºº‰πéÊòØ‰ø©ËµÑÊú¨‰∏ª‰πâÁöÑÂõΩÊ∞ëÔºå‰∏ÄÁõ¥Âú®ÂìáÂì©ÂìáÂï¶‰∏çÁü•ÈÅìËØ¥Âï•üòÇ ÊäïÂ•îËµÑÊú¨‰∏ª‰πâ~ ÁÑ∂ÂêéÔºåÂçóËà™‰∏çÂæó‰∏çÂÜçÂêêÊßΩ‰∏ÄÂèë‚Ä¶ËôΩÁÑ∂ËØ¥787‰∏ÄÊéí343‰πüÊòØËà™Á©∫ÂÖ¨Âè∏Â∏∏ÊÄÅ‰∫Ü‚Ä¶‰ΩÜÊòØÊÇ®Ëøô‰∏™ÂâçÂêéÈó¥Ë∑ùÊï¢‰∏çÊï¢ÂÜçÁ™Ñ‰∏ÄÁÇπÔºåÊÑüËßâÊàëTM‰∏ÄË∑ØËπ≤Âà∞‰∫ÜÁΩóÈ©¨‚Ä¶‰Ωú‰∏∫5Âπ¥ÁöÑËÄÅ787ÔºåWiFiËá™ÁÑ∂Ê≤°ÊúâÔºåÂ®±‰πêÁ≥ªÁªüÁöÑÂàÜËæ®Áéá‚Ä¶Â§ßÊ¶ÇÂè™ÊúâËÅîÊÉ≥ÁöÑÂûÉÂúæÊ≥õÁôΩtnÂ±èÊâçËÉΩ‰∏é‰πã‰∏ÄÊàò„ÄÇÈ£û‰∫Ü12‰∏™ÂçäÂ∞èÊó∂ÔºåÁúüÁöÑÊå∫Êº´ÈïøÁöÑ‚Ä¶ ÁΩóÈ©¨Êú∫Âú∫WiFiÁïåÈù¢ÂÄíÊòØÂ•ΩËØÑ‚Ä¶‰º∞ËÆ°‰πüÊòØ‰∏∫‰∫ÜËÆ®Â•Ω‰∏Ä‰∏ãÂêÑ‰ΩçÁàÜ‰π∞ÁöÑÈáë‰∏ªÂ§ßÂ¶àÂêß‚Ä¶ 8.27Âú®ÁΩóÈ©¨Êú∫Âú∫ËøáÊµ∑ÂÖ≥Èòü‰ºçÁúüÁöÑË∂ÖÁ∫ßÈïø‚Ä¶ÂàöÂ•ΩÊéíÂà∞‰∫Ü‰∏Ä‰∏™ÁâπÂà´‰∏•ËÇÉÁöÑÊµ∑ÂÖ≥Â§ßÂßêÊääÂÆàÁöÑÂÖ≥Âç°ÔºåÊàëÂâçÈù¢ÁöÑ‰∏Ä‰∏™Á©ÜÊñØÊûóÂ∞èÂßêÂßê‰ºº‰πéË¢´ÈÅ£Ëøî‰∫Ü‚Ä¶ËøòÂ•ΩÂêéÊù•Êç¢‰∫Ü‰∏™Â§ßÂèîÊù•ÂÆ°Ê†∏ÔºåËøôÂì•‰ª¨ÂÄíÊòØË¥ºÊùæÊï£Ôºå‰∏äÊù•‰∏ÄÁúã‰∏≠ÂõΩÊ∏∏ÂÆ¢Áõ¥Êé•Â∞±Ëøá‰∫Ü‚Ä¶ ÂâçÈù¢Ëøô‰∏™Â¶πÂ≠êË¢´ÈÅ£Ëøî‰∫ÜÔºåÂ∑¶ËæπÈÇ£‰∏™Â§ßÂ¶àÁúüÁöÑ‚Ä¶ ËÆ≤ÈÅìÁêÜÔºåÁΩóÈ©¨Êú∫Âú∫ÁªôÊàëÁöÑÊÑüËßâÂÖ∂ÂÆû‰πüÊå∫‰∏ÄËà¨ÁöÑÔºåË∑üÂåó‰∫¨ÁöÑt2‰∏Ä‰∏™Ê∞¥Âπ≥ÂêßÔºåÁï•Êóß„ÄÇ ÁÑ∂ÂêéÁ¨¨‰∏ÄÂ§©Â∞±ÂÖàÊªöÂéªÊ¢µËíÇÂÜà‰∫ÜÔºåÁúã‰∫ÜÁúãÂú£ÂΩºÂæóÂ§ßÊïôÂ†ÇÔºåÈáåÈù¢ÂêÑÁßç‰ªÄ‰πàÂêçÁîªÈõïÂ°ëÔºåÂüã‰∫ÜÂêÑÁßçÂêç‰∫∫‚Ä¶‰∏çËøáÂØπ‰∫éÂØπËâ∫ÊúØ‰∏ÄÁ™ç‰∏çÈÄöÁöÑÊàëÊù•ËØ¥ÔºåÊÑüËßâÈÉΩÊòØ‰∏ÄÂ†ÜÁü≥ËÜèÂÉèÔºåÁúã‰∏çÂá∫‰ªÄ‰πàÂ§ßÂå∫Âà´‚Ä¶ÂÄíÊòØÂ§ñÈù¢ÁöÑÁëûÂ£´Èõá‰Ω£ÂÖµËõÆÊúâÊÑèÊÄùÔºåÊÑüËßâÂÉèÂä®Áâ©Âõ≠ÈáåÁöÑÂä®Áâ©Ë¢´‰∫∫ÁñØÁãÇÊãçÁÖßÔºö-D Êé•ÁùÄÂ∞±ÊªöÂéª‰∫ÜÊñóÂÖΩÂú∫Ë∑üËÆ∏ÊÑøÊ±†ËΩ¨‰∫ÜËΩ¨ÔºåÊÑüËßâËøòË°åÔºåÂ∞±ÊòØ‰∫∫Áï•Â§öÔºàË∞ÅËØ¥Âè™Êúâ‰∏≠ÂõΩ‰∫∫Â§öÊù•ÁùÄÔºåËµÑÊú¨‰∏ª‰πâ‰∏ÄÊ†∑‰∫∫Êå§‰∫∫‚Ä¶)ÂêÉ‰∫Ü‰∏™ÊâÄË∞ìÊÑèÂ§ßÂà©Èõ™Á≥ïÔºå‰∏™‰∫∫ÊÑüËßâÂπ∂Ê≤°ÊúâÈ∫¶ÂΩìÂä≥ÁöÑÊñ∞Âú∞Â•ΩÂêÉÔºàÂë∏ ‰∏çËøáÔºåÁΩóÈ©¨ËÄÅÂª∫Á≠ëÁöÑ‰øùÊä§ËøòÊòØÊôÆÈÅçÊØîÂõΩÂÜÖÂ•Ω‚Ä¶Ëøô‰∏™‰∏çÂæó‰∏çÊâøËÆ§ ‰ºº‰πéËøòÊòØË∑®ÂõΩÂ§ßÂÖ¨Âè∏È∫¶Áà∏Áà∏ÁöÑ‰∏úË•øÊúÄÂ•ΩÂêÉÔºö-D ÁÑ∂ÂêéÂ∞±ÊªöÂõûÈÖíÂ∫óÂï¶ÔºåÂêÉ‰∫Ü‰∏™È∫¶Áà∏Áà∏Ôºå8ÁÇπÂ∞±Áù°ÁùÄ‰∫ÜÔºà‰∫éÊòØÁ¨¨‰∫åÂ§©4ÁÇπÂ∞±ÈÜí‰∫ÜÔºâ 8.288.31‰ªäÂ§©Êó©‰∏äÂú®ÁêâÊ£ÆÊπñÊ∏∏‰∫Ü‰∏Ä‰ºöËàπÔºå‰ΩÜÊòØÈõæÂ§™Â§ßÊÑüËßâÂï•ÈÉΩÁúã‰∏çËßÅÔºåÊúÄÊúâÊÑèÊÄùÁöÑ‰ºº‰πéÊòØÊπñÈáåËøòËÉΩÊ≠£Â∏∏Ë°åÈ©∂ÁöÑÊòéËΩÆËí∏Ê±ΩËàπ„ÄÇÊé•ÁùÄÂ∞±ÊòØÂú®Âç¢Â°ûÊÅ©ÔºàÁêâÊ£ÆÔºâÁöÑËá™Áî±Ê¥ªÂä®Êó∂Èó¥‰∫Ü„ÄÇËÄÉËôëÂà∞ÂØπÊâãË°®ÊØ´Êó†ÂÖ¥Ë∂£ÔºàÂÖ∂ÂÆûÊòØ‰π∞‰∏çËµ∑ÔºâÔºåÂèàÊÅ∞Â•ΩÂèëÁé∞ÈôÑËøëÊúâ‰∏Ä‰∏™The Swiss Museum of Transport,‰∫éÊòØÂ∞±ÂæàÂºÄÂøÉÁöÑÂùê‰∫Ü4Á´ôÂÖ¨‰∫§ËøáÂéªÁúã„ÄÇ‰π∞Á•®ÁöÑÊó∂ÂÄôÂèëÁé∞Ê≤°ÊúâË∂≥Â§üÁöÑÁ°¨Â∏ÅÔºå‰∏äËΩ¶Ë∑üÂè∏Êú∫ËÅä‰∫ÜÂçäÂ§©‰πüÊ≤°ÊúâËß£ÂÜ≥ÈóÆÈ¢òÔºå‰∫éÊòØÊúÄÂêéÂ∞±ÈÄÉ‰∫Ü‰∏ÄÊ≥¢Á•®„ÄÇ‰∏çÂæó‰∏çËØ¥ËµÑÊú¨‰∏ª‰πâÁöÑÂÖ¨‰∫§ÂùêËµ∑Êù•ËøòÊòØÊå∫ËàíÊúçÁöÑÔºåËÄå‰∏îËΩ¶‰∏ä‰∫∫Ë¥ºÂ•ΩÔºåËøò‰∏ªÂä®ÈóÆÊàëÊòØ‰∏çÊòØÂéªÂçöÁâ©È¶ÜÔºàÂ§ßÊ¶ÇÊòØËÑ∏‰∏äÂÜôÁùÄ‚ÄúÊ∏∏ÂÆ¢‚Äù‰∏§Â≠óÔºüÔºâ ÂçöÁâ©È¶ÜË∑ü‰∏≠ÂõΩÁöÑÁõ∏ÊØîÂÖ∂ÂÆûÂπ∂‰∏çÊòØÂæàÂ§ßÔºå‰ΩÜÊòØÁª¥Êä§ÂæóÈùûÂ∏∏Â•ΩÔºåÂ±ïÂìÅ‰øùÂÖªÂæó‰πüÈùûÂ∏∏Ê£íÔºåÊõ¥ÈáçË¶ÅÁöÑÊòØÔºå]]></content>
      <categories>
        <category>ÁîüÊ¥ª</category>
        <category>ÊóÖÊ∏∏</category>
      </categories>
      <tags>
        <tag>ÁîüÊ¥ª</tag>
        <tag>ÊóÖÊ∏∏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 10]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E8%B5%9B%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-multi-university-training-contest-10%2F</url>
    <content type="text"><![CDATA[HDU6426~6437 GËÄÉËôë‰ΩøÁî®ÂÆπÊñ•ÂéüÁêÜËøõË°åËÆ°Êï∞. ÂåÖÂê´Ëá≥Â∞ë‰∏Ä‰∏™ÂΩ¢Â¶Ç $[i, i + 1] $Êàñ $[n, 1] $ËøôÊ†∑ÁöÑÂ≠ê‰∏≤ÁöÑÁéØÊéíÂàó‰∏™Êï∞ÊòØ $\binom{n}{1} (n - 2)! $‰∏™; ÂèØ‰ª•Êé®Âπø‰∏∫ÂåÖÂê´Ëá≥Â∞ë$ k (0 \leq k &lt; n)$‰∏™ÁöÑÁéØÊéíÂàó‰∏™Êï∞ÊòØ $\binom{n}{k} (n - k - 1)!$, ÂêåÊó∂Ê≥®ÊÑèÂà∞ÂåÖÂê´ $n$ ‰∏™ÁöÑÁéØÊéíÂàó‰∏™Êï∞‰∏ÄÂÆöÊòØ 1‰∏™. ÊâÄ‰ª•ÊúÄÁªàÁ≠îÊ°àÂ∞±ÊòØ$ (-1)^n + \sum_{k = 0}^{n - 1} (-1)^k \binom{n}{k} (n - k - 1)!$ ÊàñËÄÖÔºåÁõ¥Êé•Êö¥ÂäõÊâìË°®ÊâæÂá∫ÂâçÂá†È°πÔºåÊé®ÂÖ¨ÂºèÊàñËÄÖÈù¢ÂêëOEISÁºñÁ®ãÔºåÂæóÂá∫ÂÖ¨ÂºèÔºö $a_n=(n-2)\times a_{n-1}+(n-1)\times a_{n-2}-(-1)^n$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=998244353; ll f[100005]; int main() { f[1]=1;f[2]=0;f[3]=1;f[4]=1; int i,j; for(i=5;i&lt;=100000;i++){ f[i]=((i-2)*f[i-1]%mod+(i-1)*f[i-2]%mod-(i&amp;1?-1:1))%mod; } int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; cout&lt;&lt;f[n]&lt;&lt;endl; } return 0; } Hprintf(‚Äú%.0f\n‚Äù, pow(2, n)); #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 10000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } int main() { int t,i,j,k; cin&gt;&gt;t; while(t--){ int n;cin&gt;&gt;n; bign ans=1; for(i=1;i&lt;=n;i++){ ans=ans*2; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } I.‰ª§ $a=i-j$, ÂÖàÊûö‰∏æ$ i$ ÂÜçÊûö‰∏æ $a$ $ \sum_{i=1}^n \sum_{j=1}^{i-1} [\gcd(i+j,i-j)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i-a,a)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i,a)=1]$ Âç≥ÂØπ‰∫éÊØè‰∏™ $i$, Ê±ÇÊúâÂ§öÂ∞ë‰∏™Â∞è‰∫éÂÆÉÁöÑ $a$ Êª°Ë∂≥$ \gcd(i,a)=1 $‰∏î$ a $ÊòØÂ•áÊï∞. ÂΩì $i$ ÊòØÂ•áÊï∞Êó∂, Á≠îÊ°à‰∏∫$ \frac{\varphi(i)}{2}.$ ÔºàÊ≠§Êó∂ÔºåÊâÄÊ±ÇÂ∞±ÊòØ$(n,1),(n,3),(n,5)‚Ä¶(n,n)$‰∏≠$\gcd$‰∏∫1ÁöÑ‰∏™Êï∞Ôºå‰πüÂ∞±ÊòØÊ±Ç $(n,n-1),(n,n-3),‚Ä¶(n,n-n)$,Âç≥$(n,2),(n,4),(n,6)‚Ä¶(n,n-1)$,ÊâÄ‰ª•Êúâ $\sum(1,3,‚Ä¶,n)=\frac{1}{2}\sum(1,2,‚Ä¶n)[gcd(n,i)=1]=\frac{phi(n)}{2}$ ÂΩì $i$ ÊòØÂÅ∂Êï∞Êó∂, Á≠îÊ°à‰∏∫$\varphi(i).$ (ÊòæÁÑ∂aÊòØÂÅ∂Êï∞ÁöÑÊó∂ÂÄôgcd‰∏ç‰ºöÊòØ1ÔºåÊâÄ‰ª•Áõ¥Êé•Ê±ÇÊ¨ßÊãâÂáΩÊï∞Âç≥ÂèØ) Ê≥®ÊÑè $i=1$ Êó∂, Á≠îÊ°à‰∏∫ 0. ËÆ∞‰∏™ÂâçÁºÄÂíåÂ∞±Â•Ω‰∫Ü, Â§çÊùÇÂ∫¶‰∏∫ $O(N+T)$. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e7+10; vector&lt;int&gt;prime; bool isnotprime[maxn+50]; long long phi[maxn+50]; void check(void) { int i,j,k; for(i=2;i&lt;=maxn;i++){ if(!isnotprime[i]){ prime.push_back(i);//[ptop++]=i; phi[i]=i-1; } for(j=0;j&lt;prime.size();j++){ int pi=prime[j]*i; if(pi&gt;maxn)break; isnotprime[pi]=true; if(i%prime[j]==0){ phi[pi]=prime[j]*phi[i]; break; } phi[pi]=(prime[j]-1)*phi[i]; } } for(i=1;i&lt;=maxn;i++) { if(i&amp;1)phi[i]&gt;&gt;=1; phi[i] += phi[i - 1]; } } int main() { int t,i,j; check(); cin&gt;&gt;t; while(t--){ int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,phi[n]); } return 0; } J.K ‰∏çÂ§ß‰∫é 5, ‰ªÖÊòØÂ∏∏Êï∞Á∫ßÂà´, ÊâÄ‰ª•ÂèØ‰ª•Êêû‰∫ãÊÉÖ Êàë‰ª¨ÂèëÁé∞ $|x_{MW}[i]-x_{SW}[i]| = max(x_{MW}[i]-x_{SW}[i],x_{SW}[i]-x_{MW}[i])$ ‰πüÂ∞±ÊòØËØ¥ÂØπ‰∫éÊØè‰∏Ä‰∏™Áª¥Â∫¶Âè™Êúâ‰∏§ÁßçÈÄâÊã©, ÂêåÊó∂$ 2^K \le 32$ ‰πü‰∏çÂ§ß, ÊâÄ‰ª•ÂèØ‰ª•Êûö‰∏æÊØè‰∏ÄÁª¥ÁöÑÂ§ßÂ∞èÊÉÖÂÜµ, ÂàÜÂà´Âèñ‰∏ªÊ≠¶Âô®‰∏éÂâØÊ≠¶Âô®ÁöÑÊúÄÂ§ßÂÄºÂ∞±Â•Ω‰∫Ü, Â§çÊùÇÂ∫¶ $O(2^Kn).$ ÂÖ∑‰ΩìÊù•ËØ¥ÔºåÂØπ‰∫éÊØè‰∏Ä‰∏™Ê≠¶Âô®ÔºåÊûö‰∏æ‰ªñÁöÑÊØè‰∏Ä‰∏™xÂâçÈù¢Âèñ+/-Âè∑ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊõ¥Êñ∞$num[j]$Êï∞ÁªÑÔºå‰πüÂ∞±ÊòØËÆ∞ÂΩïÂú®‰∏ÄÁßç+/-ÂèñÂÄºÁä∂ÂÜµ‰∏ãÁöÑÊúÄÂ§ßÂÄºÔºåÁÑ∂ÂêéÊàë‰ª¨Êûö‰∏æ‰∏ªÂâØÊ≠¶Âô®ÁöÑnumÊï∞ÁªÑÔºåÂΩìÁÑ∂Êûö‰∏æÁöÑÊó∂ÂÄôË¶ÅÁ°Æ‰øù‰∏ªÊ≠¶Âô®ÁöÑÂèñÂÄºÁä∂ÂÜµ‰∏éÂâØÊ≠¶Âô®ÂàöÂ•ΩÊòØÂèñÂèçÁöÑÁä∂ÊÄÅÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Ê±ÇÂá∫ÊúÄÂ§ßÂÄº„ÄÇÂΩìÁÑ∂‰ºöÂá∫Áé∞‰∏Ä‰∫õÊ≠£Ë¥üÂè∑‰∏çÁîöÊ≠£Á°ÆÁöÑÊÉÖÂÜµÔºåÂèØÊòØËøô‰∫õÊÉÖÂÜµÊòæÁÑ∂‰∏ç‰ºöÊòØÊúÄ‰ºòËß£ÔºåÊâÄ‰ª•‰∏çÂøÖÊãÖÂøÉ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=-(1ll&lt;&lt;60); const int maxn=100005; int S[maxn],s[maxn],X[maxn][6],x[maxn][6]; ll numm[60],numn[60]; int main() { int t,i,j,n,m,k; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=0;i&lt;(1&lt;&lt;5);i++) numm[i]=numn[i]=INF; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;S[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;X[i][j]); for(;j&lt;=5;j++) X[i][j]=0; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;s[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;x[i][j]); for(;j&lt;=5;j++) x[i][j]=0; } for(i=1;i&lt;=n;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=S[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?X[i][a+1]:-X[i][a+1]; } numm[j]=max(numm[j],temp); } } for(i=1;i&lt;=m;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=s[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?x[i][a+1]:-x[i][a+1]; } numn[j]=max(numn[j],temp); } } ll ans=0; for(i=0;i&lt;(1&lt;&lt;5);i++){ int pos=((1&lt;&lt;5)-1)&amp;(~i); ans=max(ans,numm[i]+numn[pos]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } L.Âíã‰∏ÄÁúã‰ª•‰∏∫ÊòØdpÔºåÂêéÊù•ÂèëÁé∞ÊòØÁΩëÁªúÊµÅ‚Ä¶ËøôÈáåÈúÄË¶ÅÊúÄÂ§ßÁöÑÊª°ÊÑèÂÄºÔºåËÄåÊàë‰ª¨ÁöÑÊ®°ÊùøÊòØÊúÄÂ∞èË¥πÁî®ÊµÅÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊª°ÊÑèÂÄºÈÉΩÂºÑÊàêË¥üÁöÑÔºåËøôÊ†∑Ê±ÇÂá∫Êù•‰ª•ÂêéÂèñ‰∏™Áõ∏ÂèçÊï∞Â∞±ÊòØÊª°ÊÑèÂÄº‰∫Ü‚Ä¶ ËÄÉËôëÂà∞ÊØè‰∏™videoÂè™ËÉΩË¢´‰∏Ä‰∏™‰∫∫ÁúãÔºåÂõ†Ê≠§ÊòæÁÑ∂Ë¶ÅÊãÜÁÇπÔºåÊµÅÈáè1Ë¥πÁî®0ÔºåÁÑ∂Âêé‰∏∫‰∫ÜÈôêÂà∂ÊÄªÊµÅÈáè‰πüÂ∞±ÊòØ‰∫∫Êï∞ÔºåËµ∑ÁÇπÂêëËôöÊãüËµ∑ÁÇπËøûËæπ,ÈôêÂà∂ÊÄªÊµÅÈáèk„ÄÇ‰∏∫‰∫Ü‰øùËØÅÊúÄÂ§ßÊµÅÔºåÔºàÊúâÁöÑ‰∫∫ÂèØ‰ª•Ê≤°videoÁúãÔºâÔºåËôöÊãüËµ∑ÁÇπÂêëÁªàÁÇπËøûËæπ,ÊµÅÈáèkË¥πÁî®0ÔºåÁ°Æ‰øùÊúÄÂ§ßÊµÅÈáèÔºàÂõ†‰∏∫videoË¥πÁî®‰∏∫Ë¥üÔºåÂèØÊµÅÁöÑÊÉÖÂÜµ‰∏ãÊòæÁÑ∂Êõ¥‰ºòÔºâ„ÄÇÁÑ∂ÂêéËµ∑ÁÇπÂêëÊØè‰∏™ÁÇπvideoÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπËøûËæπÔºå‰ª•ÂèäÊØè‰∏™videoÁöÑÁ¨¨‰∫å‰∏™ÁÇπÂêëÁªàÁÇπËøûËæπ„ÄÇÂØπ‰∫éÊØè‰∏™videoÔºåÊûö‰∏æÊâÄÊúâÁöÑvideoÔºå‰∏ã‰∏™videoÁöÑËµ∑ÂßãÊó∂Èó¥Êôö‰∫éÂΩìÂâçvideoÁöÑÁªìÊùüÊó∂Èó¥ÊâçÂèØ‰ª•ËøûËæπÔºåÊµÅÈáè1ÔºåË¥πÁî®‰∏∫‰∏ã‰∏™videoÁöÑwÔºåÂπ∂‰∏îË¶ÅËÄÉËôëÁ±ªÂûãÂ∏¶Êù•ÁöÑÊÉ©ÁΩöÂÄº„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=550; struct edge{ int to,cap,cost,rev;//ÁªàÁÇπ,ÂÆπÈáè,Ë¥πÁî®,ÂèçÂêëËæπ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//ÊúÄÁü≠Ë∑Ø‰∏≠ÂâçÈ©±ËäÇÁÇπÂíåÂØπÂ∫îÁöÑËæπ, // Â∞èÂøÉcostÁàÜint,Â§öÁªÑÊï∞ÊçÆÊó∂ËÆ∞ÂæóÊ∏ÖÈõ∂ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//Ê≥®ÊÑèÂèçÂêëËæπÁöÑÂä†Ê≥ï!!-costÂíåcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//Â∞èÂøÉÁàÜintÁöÑÊÉÖÂÜµ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//ÂÖ®ÊúÄÁü≠Ë∑Ø‰∏≠ÁöÑÊúÄÂ∞èÊµÅÈáèÈôêÂà∂Â∞±ÊòØÊú¨Ê¨°ÊÄªÁöÑÊµÅÈáèÈôêÂà∂ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//Êõ¥Êñ∞Ë∑ØÂæÑ‰ø°ÊÅØ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } struct movie{ int s,t,w,op; }M[250]; int main() { int t,i,j,k,n,m,w,W; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;W; for(i=0;i&lt;=520;i++)G[i].clear(); for(i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;M[i].s,&amp;M[i].t,&amp;M[i].w,&amp;M[i].op); int s1=505,s2=506,t=510; add(s1,s2,k,0);//Ëµ∑ÁÇπÂêëËôöÊãüËµ∑ÁÇπËøûËæπ,ÈôêÂà∂ÊÄªÊµÅÈáè add(s2,t,k,0);//ËôöÊãüËµ∑ÁÇπÂêëÁªàÁÇπËøûËæπ,Á°Æ‰øùÊúÄÂ§ßÊµÅÈáè flow=cost=0; for(i=1;i&lt;=m;i++) add(i+200,t,1,0);//ÊØè‰∏™videoÂêëÁªàÁÇπËøûËæπ for(i=1;i&lt;=m;i++){ add(s2,i,1,-M[i].w);//Ëµ∑ÁÇπÂêëÊØè‰∏™videoËøûËæπ add(i,i+200,1,0);//ÊØè‰∏™videoÊãÜÊàê‰∏§‰∏™ÁÇπ for(j=1;j&lt;=m;j++){ if(i==j)continue; if(M[i].t&lt;=M[j].s){//‰∏ã‰∏™videoÁöÑËµ∑ÂßãÊó∂Èó¥Êôö‰∫éÂΩìÂâçvideoÁöÑÁªìÊùüÊó∂Èó¥ÊâçÂèØ‰ª•ËøûËæπ if(M[i].op!=M[j].op){//Á±ªÂûã‰∏çÂêåÁõ¥Êé•Ëøû add(i+200,j,1,-M[j].w); } else{//ÂáèÂéªÊÉ©ÁΩöÂÄº add(i+200,j,1,-(M[j].w-W)); } } } } mincostmaxflow(s1,t); cout&lt;&lt;-cost&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúËµõ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
        <tag>ÁΩëÁªúËµõ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 34 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-34-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.Êï∞ÊçÆËåÉÂõ¥ÈÇ£‰πàÂ∞èÁõ¥Êé•Êö¥ÂäõÊûö‰∏æÂïä #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x; cin&gt;&gt;n; while(n--){ cin&gt;&gt;x; for(i=0;3*i&lt;=x;i++){ if((x-i*3)%7==0){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;&apos;\n&apos;;break; } } if(3*i&gt;x) puts(&quot;NO&quot;); } return 0; } B.Âº±Êô∫* 2 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int h1,a1,c1,h2,a2,cnt=0; vector&lt;int&gt;ans; cin&gt;&gt;h1&gt;&gt;a1&gt;&gt;c1&gt;&gt;h2&gt;&gt;a2; while(h2&gt;0){ cnt++; if(h2-a1&lt;=0){ ans.push_back(1);break; } else{ if(h1-a2&lt;=0){ ans.push_back(0);h1=h1-a2+c1; } else { ans.push_back(1);h1-=a2;h2-=a1; } } } cout&lt;&lt;cnt&lt;&lt;endl; for(auto a:ans) if(a) puts(&quot;STRIKE&quot;); else puts(&quot;HEAL&quot;); return 0; } C.‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåÁÑ∂ÂêéÁª¥Êä§‰∏Ä‰∏™Â§ßÊ†πÂ†ÜÔºåÊØèÊ¨°Â¶ÇÊûúÂ†ÜÈ°∂ÁöÑÁÆ±Â≠êËÉΩÊîæ‰∏ãÂΩìÂâçÁÆ±Â≠êÔºåÂ∞±ÊääÂΩìÂâçÁÆ±Â≠ê‰∏¢ËøõÂéªÂπ∂Êõ¥Êñ∞ÁÆ±Â≠êÂ§ßÂ∞èÔºåÂê¶ÂàôËøô‰∏™ÁÆ±Â≠êÂ∞±ÂæóÂçïÁã¨Êîæ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,box[5005]; priority_queue&lt;int&gt;que; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;box[i]; sort(box+1,box+1+n); for(i=n;i;i--){ if(que.empty()||que.top()&lt;=box[i]){ que.push(box[i]); } else{ que.pop();que.push(box[i]); } } cout&lt;&lt;que.size()&lt;&lt;endl; return 0; } D.ÂÖ∂ÂÆûÊàëÁöÑÊÉ≥Ê≥ïÂæàÁÆÄÂçïÔºöÈ¶ñÂÖàÊêû‰∏™mapÁªüËÆ°ÊØè‰∏™Êï∞ÁöÑÂá∫Áé∞Ê¨°Êï∞ÔºåÂÜçÊêû‰∏™ÂêéÁºÄÂíå„ÄÇÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÔºåÂØπ‰∫éÊØè‰∏™Êï∞ÔºåÂÖàÂú®mapÈáåÂØπËøô‰∏™Êï∞‚ÄìÔºåÁÑ∂ÂêéÁúãÁúãÂú®Ëøô‰∏™Êï∞-1~Ëøô‰∏™Êï∞+1ÁöÑËåÉÂõ¥ÂÜÖËøòÊúâÂ§öÂ∞ë‰∏™Êï∞ÔºàÁî®mapÊü•ËØ¢ÔºâÔºåÁÑ∂ÂêéÂ§ÑÁêÜ‰∏Ä‰∏ãÂêéÁºÄÂíåÂ∞±Ë°å‰∫Ü„ÄÇÁÑ∂ËÄåËøô‰∏™‰∏áÊÅ∂ÁöÑÈ¢òÁõÆÂç°long long‚Ä¶‰∫éÊòØÊàëÂ∞±ÊäÑ‰∫Ü‰∏™400Ë°åÁöÑÈ´òÁ≤æÂ∫¶Ê®°Êùø‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //ÊúÄÂ§ßÈïøÂ∫¶ÔºåÂèØ‰ª•‰øÆÊîπ using namespace std; class bign { public: int len, s[MAX_L];//Êï∞ÁöÑÈïøÂ∫¶ÔºåËÆ∞ÂΩïÊï∞ÁªÑ //ÊûÑÈÄ†ÂáΩÊï∞ bign(); bign(const char *); bign(int); bool sign;//Á¨¶Âè∑ 1Ê≠£Êï∞ 0Ë¥üÊï∞ string toStr() const;//ËΩ¨Âåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰∏ªË¶ÅÊòØ‰æø‰∫éËæìÂá∫ friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//ÈáçËΩΩËæìÂÖ•ÊµÅ friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//ÈáçËΩΩËæìÂá∫ÊµÅ //ÈáçËΩΩÂ§çÂà∂ bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //ÈáçËΩΩÂêÑÁßçÊØîËæÉ bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //ÈáçËΩΩÂõõÂàôËøêÁÆó bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //ÂõõÂàôËøêÁÆóÁöÑË°çÁîüËøêÁÆó bign operator%(const bign &amp;) const;//ÂèñÊ®°Ôºà‰ΩôÊï∞Ôºâ bign factorial() const;//Èò∂‰πò bign Sqrt() const;//Êï¥Êï∞ÂºÄÊ†πÔºàÂêë‰∏ãÂèñÊï¥Ôºâ bign pow(const bign &amp;) const;//Ê¨°Êñπ //‰∏Ä‰∫õ‰π±‰π±ÁöÑÂáΩÊï∞ void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005]; int main() { int n,i,j,k,num[200005]; bign ans=0; cin&gt;&gt;n; map&lt;int,int&gt;mp1; for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;num[i]),mp1[num[i]]++; for(i=n;i;i--){ sum[i]=num[i];sum[i]+=sum[i+1]; } for(i=1;i&lt;=n;i++){ mp1[num[i]]--; int tot=n-i; if(mp1[num[i]]==0)mp1.erase(num[i]); bign temp;temp=num[i]; sum[i]-=temp; if(mp1.count(num[i]-1)){ temp=(ll)mp1[num[i]-1]*(num[i]-1); sum[i]-=temp; tot-=mp1[num[i]-1]; } if(mp1.count(num[i])){ temp=(ll)mp1[num[i]]*(num[i]); sum[i]-=temp; tot-=mp1[num[i]]; } if(mp1.count(num[i]+1)){ temp=(ll)mp1[num[i]+1]*(num[i]+1); sum[i]-=temp; tot-=mp1[num[i]+1]; } temp=(ll)tot*num[i]; ans-=temp;ans+=sum[i]; } //ans*=-1; cout&lt;&lt;ans&lt;&lt;endl; return 0; } ÁÑ∂ÂêéÊàëÁúãÊèê‰∫§ËÆ∞ÂΩïÁöÑÊó∂ÂÄôÂèëÁé∞‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÂæóÂ§öÁöÑÂÅöÊ≥ï‚Ä¶ÂÖ∂ÂÆû‰πüÂèØËÉΩÊòØÂõ†‰∏∫Êãølong double‰ª£Êõø‰∫ÜÈ´òÁ≤æÂ∫¶ÊâÄ‰ª•ÊòæÂæóÊØîËæÉÁÆÄÂçï„ÄÇ È¶ñÂÖà‰ªéÂâçÂæÄÂêéÊâ´ÔºåÂØπ‰∫éÊØè‰∏Ä‰ΩçÊï∞a[i]ÔºåÊàë‰ª¨Êãøa[i]* iÂáèÂéªÂâçÁºÄÂíåÂ∞±ÊòØÊ≤°ÊúâÁõ∏Âáè‰∏∫0Êù°‰ª∂‰∏ãÁöÑÁ≠îÊ°àÔºåÁÑ∂ÂêéÂØπ‰∫éÈÇ£‰∫õÁªùÂØπÂÄºÁõ∏Â∑Æ1 ÁöÑÊï∞ÔºåÊàë‰ª¨ÂÖàÊãø‰∏Ä‰∏™map cntÁªüËÆ°ËøÑ‰ªä‰∏∫Ê≠¢ÂêÑ‰∏™Êï∞ÁöÑÂá∫Áé∞Ê¨°Êï∞ÔºåÁÑ∂ÂêéÂä†‰∏äcnt[a[i]+1]-cnt[a[i]-1]Âç≥ÂèØ„ÄÇlong doubleÂ±ÖÁÑ∂ËÉΩÊêûËøáÂéª‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt; cnt; int main() { int n; long double ans=0,sum=0,num; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++){ scanf(&quot;%Lf&quot;,&amp;num); ans+=num*i-sum+cnt[(int)num+1]-cnt[(int)num-1]; sum+=num; cnt[(int)num]++; } printf(&quot;%.0Lf&quot;,ans+0.000000001); return 0; } E. ÁªôÂÆö‰∏ÄÂ†ÜÂ≠óÁ¨¶‰∏≤ÔºåÈóÆËÉΩ‰∏çËÉΩÊûÑÈÄ†‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰ΩøÂæóÊâÄÊúâÁöÑÂ≠óÁ¨¶‰∏≤Âú®‰∫§Êç¢Ëá™Â∑±ÁöÑÊüê‰∏§‰∏™Â≠óÁ¨¶‰πãÂêéÈÉΩ‰∏éÊûÑÈÄ†Âá∫Êù•ÁöÑÂ≠óÁ¨¶‰∏ÄÊ®°‰∏ÄÊ†∑„ÄÇ È¶ñÂÖàÔºåÂ¶ÇÊûúÊâÄÊúâÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂæóÈÉΩ‰∏ÄÊ†∑ÔºåÈÇ£Èöè‰æøÊç¢‰∏§‰∏™Â≠óÊØçÁöÑ‰ΩçÁΩÆËæìÂá∫Âç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÊàë‰ª¨ÊâæÂà∞‰∏§‰∏™‰∏çÂêåÁöÑÂ≠óÁ¨¶‰∏≤ÔºàÁ¨¨‰∏Ä‰∏™‰∏çÂ¶®Â∞±ÊòØËæìÂÖ•ÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÔºâÔºåÁÑ∂ÂêéÊää‰ªñ‰ª¨ÊâÄÊúâ‰∏çÁõ∏ÂêåÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÈÉΩ‰øùÂ≠òÂú®diffÊï∞ÁªÑÈáå„ÄÇÂ¶ÇÊûúdiffÁöÑsize&gt;4ÔºåÈÇ£‰πàÊòæÁÑ∂ÔºåÊó†Ëß£ÔºàÊØè‰∏™Â≠óÁ¨¶‰∏≤ÊúÄÂ§ö‰∫§Êç¢2‰∏™Â≠óÁ¨¶Ôºå‰∏çÂèØËÉΩ‰ΩøÂæó5‰∏™‰ª•‰∏ä‰∏çÂêåÁöÑ‰ΩçÁΩÆÂèòÂæóÁõ∏ÂêåÔºâ„ÄÇ ÁÑ∂ÂêéÔºåÂØπ‰∫éÊØè‰∏™‰∏çÂêåÁöÑ‰∏ãÊ†áÔºåÊàë‰ª¨ÈÉΩÂ∞ùËØïÊãøÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰∏≠‰∏çÂêå‰ΩçÁΩÆÁöÑÂ≠óÁ¨¶Âéª‰∏é‰πã‰∫§Êç¢ÔºåÁúãÁúãÊç¢ÂÆåÁöÑÂ≠óÁ¨¶‰∏≤ËÉΩ‰∏çËÉΩÊòØÁ≠îÊ°à„ÄÇ Â¶Ç‰ΩïÊ£ÄÊü•‰∏Ä‰∏™‰∫§Êç¢ÂÆåÁöÑÂ≠óÁ¨¶‰∏≤ÊòØ‰∏çÊòØÁ≠îÊ°àÂë¢Ôºü ÂØπ‰∫éÊâÄÊúâÁöÑÂ≠óÁ¨¶‰∏≤ÔºàÂΩìÁÑ∂Ëá™Â∑±Ë∑üËá™Â∑±Èô§Â§ñÔºâÔºåÊàë‰ª¨ÈÉΩÁªüËÆ°‰∏çÂêåÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÂπ∂‰øùÂ≠òÂú®difÊï∞ÁªÑ‰∏≠ÔºåÂ¶ÇÊûúÊúâ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑdifÊï∞ÁªÑÁöÑsize!=0&amp;&amp;size!=2ÔºåÊòæÁÑ∂Ëøô‰∏™Êç¢ÂÆåÁöÑÂ≠óÁ¨¶‰∏≤ÊòØ‰∏çËÉΩÊàê‰∏∫Á≠îÊ°àÁöÑ„ÄÇÂ¶ÇÊûúsize=0ÔºåÈÇ£‰πàÈÇ£‰∏™Â≠óÁ¨¶‰∏≤Â¶ÇÊûúÊâÄÊúâÁöÑÂ≠óÁ¨¶ÈÉΩÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑÔºå‰πü‰∏çË°åÔºàÂõ†‰∏∫ÊØè‰∏™Â≠óÁ¨¶‰∏≤ÈÉΩË¶Å‰∫§Êç¢‰∏§‰∏™Â≠óÁ¨¶ÔºåÂÖ®ÈÉ®‰∏çÂêåÁöÑËØùÊç¢ÂÆåÂ∞±‰∏çÂèØËÉΩÊª°Ë∂≥ÂΩìÂâçÁ≠îÊ°à‰∫ÜÔºâ„ÄÇÂ¶ÇÊûúsize=2ÔºåÈÇ£‰πàÈÇ£‰∏™Â≠óÁ¨¶‰∏≤‰∫§Êç¢ÂÆåËøô‰ø©‰ΩçÁΩÆ‰πãÂêéÂøÖÈ°ª‰∏éÂΩìÂâçÁ≠îÊ°à‰∏ÄÊ†∑„ÄÇ Êâ´ÂÆåÊâÄÊúâÂèØËÉΩ‰ª•ÂêéÔºåÂ¶ÇÊûúËøòÊ≤°ÊúâÊâæÂà∞Á≠îÊ°àÔºåËæìÂá∫-1Âç≥ÂèØ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; bool check(string str) { int cnt[30]={0}; for(auto a:str) cnt[a-&apos;a&apos;]++; for(int i=0;i&lt;26;i++) if(cnt[i]&gt;=2) return true; return false; } int main() { set&lt;string&gt;s; int k,n,i,j,a,b,len; cin&gt;&gt;n&gt;&gt;len; string str[2505],str1,str2; for(i=1;i&lt;=n;i++){ cin&gt;&gt;str[i];s.insert(str[i]); } if(s.size()==1){ swap(str[1][0],str[1][1]); cout&lt;&lt;str[1]&lt;&lt;endl;return 0; } str1=str[1]; for(i=2;i&lt;=n;i++) if(str[i]!=str[1]) { str2 = str[i];break; } vector&lt;int&gt;diff; for(i=0;i&lt;len;i++) if(str1[i]!=str2[i]) diff.push_back(i); if(diff.size()&gt;4){ puts(&quot;-1&quot;);return 0; } for(auto a:diff){ for(i=0;i&lt;len;i++){ if(i==a)continue; bool isok=true; string str3=str1;swap(str3[i],str3[a]); for(j=2;j&lt;=n;j++){ vector&lt;int&gt;dif; for(k=0;k&lt;len;k++){ if(str3[k]!=str[j][k]) dif.push_back(k); } if(dif.size()!=0&amp;&amp;dif.size()!=2){ isok=false; break; } if(dif.empty()){ if(!check(str[j])){ isok=false;break; } } else{ string str4=str[j];swap(str4[dif[0]],str4[dif[1]]); if(str4!=str3){ isok=false;break; } } } if(isok){ cout&lt;&lt;str3&lt;&lt;endl;return 0; } } } puts(&quot;-1&quot;); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 49 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-49-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.Â∞èÂøÉÂ§ÑÁêÜz‰∏éaÁöÑÈóÆÈ¢òÔºå‰ª•ÂèäÊ≥®ÊÑèÊØè‰∏™Â≠óÊØçÈÉΩÂøÖÈ°ªÂèëÁîüÂèòÂåñÂç≥ÂèØ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { string str1,str2; int n,i,j,k; int t; cin&gt;&gt;t; while(t--){ bool isok=true; cin&gt;&gt;n&gt;&gt;str1;str2=str1;reverse(str2.begin(),str2.end()); for(i=0;i&lt;str1.size();i++){ if(abs((int)(str1[i]-str2[i]))==1||abs((int)(str1[i]-str2[i]))&gt;2){ isok=false;break; } } if(isok)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } B.Ê≥®ÊÑèn‰∏∫Â•áÊï∞ÁöÑÊó∂ÂÄôÈúÄË¶ÅÁâπÂà´ËÆ®ËÆ∫,ÊØè‰∏§Ë°å‰∏∫‰∏ÄÁªÑÂàöÂ•Ωn‰∏™Êï∞ÔºåÁÑ∂ÂêéÂèØËÉΩÂ§ö‰∏ÄË°åÂæóÂçïÁã¨ËÆ®ËÆ∫‰∏Ä‰∏ã„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n, q, x, y; cin &gt;&gt; n &gt;&gt; q; int i,j,k; for (i = 1; i &lt;= q; i++) { cin &gt;&gt; x &gt;&gt; y; ll ans = 0; if ((x + y) &amp;1) { ans += (n * n - 1) / 2 + 1; } if (n &amp;1) { ans += (x - 1) / 2 * n; if ((x + y) % 2 == 1) ans += (x - 1) % 2 * (n / 2); else ans += (x - 1) % 2 * (n / 2 + 1); ans += (y + 1) / 2; } else if (n % 2 == 0) { ans += (x - 1) * n / 2; ans += (y + 1) / 2; } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } C.Ê≥®ÊÑèÂà∞ÂèñÂà∞ÁöÑÊúÄÂ∞èÂÄºÁöÑÁªÑÂêàËÇØÂÆöÊòØÈÇ£‰∫õÊØîËæÉÁõ∏ÈÇªÈïøÂ∫¶ÁöÑÊú®Ê£çÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•Â∞ÜÊú®Ê£çÊéíÂ∫èÔºåÁÑ∂ÂêéÊö¥ÂäõÊûö‰∏æÁõ∏ÈÇªÈïøÂ∫¶‰∏îÊ†πÊï∞&gt;=2ÁöÑÊú®Ê£ç„ÄÇ #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 50; long double minnum; int num[maxn]; int main() { int i,j,k, t, n; int q1, q2, P1, P2; cin&gt;&gt;t; while(t--){ minnum = 1ll &lt;&lt; 60;P1 = P2 = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); } sort(num + 1, num + n + 1); for (i = 1; i &lt;= n; i++) { if (P1 == num[i]) { if (P2 != 0) { long double x(P1), y(P2); long double temp = (x + x + y + y)*(x + x + y + y) / (x*y); if (temp &lt; minnum) { q1 = P2; q2 = P1; minnum = temp; } } P2 = P1;P1 = 0; } else { P1 = num[i]; } } printf(&quot;%d %d %d %d\n&quot;,q1,q1,q2,q2); //cout &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; endl; } return 0; } D.ÊØè‰∏™ÊàøÈó¥ÈÉΩÊúâÂá∫Â∫¶‚Ä¶ÊâÄ‰ª•ÊúÄÂêéÊØè‰∏™ÊàøÈó¥ÈÉΩÂèØ‰ª•ÂΩíÁªì‰∫éÊüê‰∏™ËøûÈÄöÂàÜÈáè‰πã‰∏≠ÔºåÊ±ÇÂá∫Ëøô‰∏™ËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÊúÄÂ∞èÁöÑcÂ∞±ÊòØËøô‰∏™ËøûÈÄöÂàÜÈáèÁöÑÁ≠îÊ°àÔºå‰ΩÜÊòØËøòË¶ÅÊ≥®ÊÑèÈÇ£‰∫õa[i]=iÁöÑÁÇπÔºåËøôÁßçÊàøÈó¥‰∏ÄÂÆöË¶ÅÂú®Ëá™Â∑±ÈÇ£ÈáåÊîæ‰∏Ä‰∏™„ÄÇË∑ëË∑ëtarjanÂ∞±ÂÆå‰∫Ü„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; int dfn[maxn],low[maxn],scccnt=0,sccindex=0,belong[maxn]; bool instack[maxn]; stack&lt;int&gt;sta; vector&lt;int&gt;G[maxn]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v); } } int outdegree[maxn],c[maxn]; int minn[maxn],size1[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i]); long long ans=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);outdegree[i]++; if(j==i)ans+=c[i]; } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) size1[belong[i]]++; memset(minn,0x3f,sizeof(minn)); for(i=1;i&lt;=n;i++){ if(size1[belong[i]]&lt;=1)continue; minn[belong[i]]=min(minn[belong[i]],c[i]); } for(i=1;i&lt;=n;i++){ if(minn[i]!=0x3f3f3f3f) ans+=minn[i]; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. È¢òÊÑèÂ§ßÊ¶ÇÊòØÊûÑÈÄ†‰∏Ä‰∏™n* nÁöÑÁü©ÈòµÔºåË¶ÅÊ±ÇÊª°Ë∂≥Áõ∏ÈÇªË°å‰∏éÁõ∏ÈÇªÂàó‰πãÈó¥Ë¶Å‰πàÂÆåÂÖ®Áõ∏ÂêåÔºåË¶Å‰πàÂÆåÂÖ®Áõ∏Âèç„ÄÇ‰∏î‰∏çÂ≠òÂú®Èù¢ÁßØÂ§ß‰∫éÁ≠â‰∫ékÁöÑÂ≠êÁü©ÈòµÈ¢úËâ≤ÂÆåÂÖ®Áõ∏Âêå„ÄÇ È¶ñÂÖàÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™‰∫ãÂÆûÔºö‰∏ÄÊó¶Á¨¨‰∏ÄË°åÁ¨¨‰∏ÄÂàóÁ°ÆÂÆö‰∫ÜÔºåÈÇ£‰πàÊï¥‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°à‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÈÇ£‰πàÊàë‰ª¨Â∞±ÂèØ‰ª•ËÆæÊ≥ïÂéªÊ±ÇÁ¨¨‰∏ÄË°åÁöÑÊüìËâ≤ÊñπÊ°àÔºàÁ¨¨‰∏ÄÂàóË∑üÁ¨¨‰∏ÄË°åÊòØ‰∏ÄÊ†∑ÁöÑÔºâ ËøôÂèØ‰ª•Áî®dpÊù•Ê±Ç #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 510; const int mod = 998244353; ll f[maxn][maxn][2];//‰ΩçÁΩÆÔºåËøûÁª≠Êï∞ÈáèÔºåÈ¢úËâ≤Ôºõ ll num[maxn]; int main() { //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, k,i,j,q; cin &gt;&gt; n &gt;&gt; k; for (q = 1; q &lt;= n; q++) { memset(f, 0, sizeof(f)); f[1][1][0] = f[1][1][1] = 1; for (i = 2; i &lt;= n; i++) {//‰ΩçÁΩÆ for (j = 1; j &lt;= min(i,q); j++) {//ËøûÁª≠Êï∞Èáè f[i][1][1] += f[i - 1][j][0];//ËøûÁª≠ÈïøÂ∫¶‰∏∫1,ÈÇ£‰πàÂâç‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÈ¢úËâ≤‰∏ÄÂÆö‰∏éËøô‰∏™‰ΩçÁΩÆ‰∏çÂêå f[i][1][0] += f[i - 1][j][1]; f[i][j][1] += f[i - 1][j - 1][1];//‰∏éÂâç‰∏Ä‰∏™‰ΩçÁΩÆÈ¢úËâ≤Áõ∏Âêå f[i][j][0] += f[i - 1][j - 1][0]; f[i][1][0] %= mod; f[i][1][1] %= mod; f[i][j][0] %= mod; f[i][j][1] %= mod; } } for (i = 1; i &lt;= q; i++) { num[q] += f[n][i][0] + f[n][i][1]; num[q] %= mod; } } for (i = n; i &gt;= 2; i--) { num[i] = num[i] - num[i - 1] + mod;//ÂáèÂéª‰∏çÊòØËøô‰∏™ÈïøÂ∫¶ÁöÑ Êï∞Èáè num[i] %= mod; } ll ans = 0; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { if (i*j &gt;= k)break;//Â¶ÇÊûúËøô‰∏™Áü©ÂΩ¢ÁöÑÈù¢ÁßØÂ§ß‰∫éÁ≠â‰∫ék ans += num[i] * num[j]; ans %= mod; } } if (ans % 2 == 1)ans = (ans + mod) / 2;//Á≠îÊ°àÊòØË¶ÅÈô§‰ª•2ÁöÑ(ÈáçÂ§ç), // ‰ΩÜÊòØÊ®°Êï∞ÊòØÂ•áÊï∞‰∏î‰πãÂâçÂ§öÊ¨°ÂèñÊ®°,Âõ†Ê≠§Â¶ÇÊûúÁ≠îÊ°àÊòØÂ•áÊï∞,Â∫îËØ•ÂèòÊàêÂÅ∂Êï∞ÂÜçÈô§‰ª•2 else ans /= 2; cout &lt;&lt; ans &lt;&lt; endl; return 0; } F. Êúân‰∏™ËÄÉËØïÔºåÊØè‰∏™ËÄÉËØïÊúâ‰∏§‰∏™ÂèØ‰ª•ÈÄöËøáÁöÑÊó•ÊúüÔºåÊØèÂ§©Âè™ËÉΩÈÄöËøá‰∏Ä‰∏™ËÄÉËØïÔºåÈóÆÂ¶Ç‰ΩïÂÆâÊéíÂèØ‰ª•Â∞ΩÊó©ÂÆåÊàêÊâÄÊúâËÄÉËØï„ÄÇ Êö¥Âäõ‰∫åÂàÜÁΩëÁªúÊµÅÊòØÊ≤°ÈîôÁöÑÔºå‰ΩÜÊòØ‰ºöt„ÄÇ‰ΩÜÊòØÂèØ‰ª•‰ªé‰∏≠ÂæóÂà∞ÂêØÂèëÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ËÄÉËØïÁöÑ‰∏§Â§©ÔºåÂÖàÈÄâÊã©ÈÇ£‰∏™ÊØîËæÉÂ∞èÁöÑÂ§©ÔºåÁÑ∂Âêé‰ªéÊØîËæÉÂ∞èÁöÑÂ§©ÂêëÊØîËæÉÂ§ßÁöÑÂ§©Ëøû‰∏ÄÊù°ËæπÔºåË°®Á§∫ÈÄâÊã©ÁöÑËøô‰∏ÄÂ§©‰πüÂèØ‰ª•Êç¢ÊàêÊØîËæÉÂ§ßÁöÑÈÇ£‰∏ÄÂ§©„ÄÇÂ¶ÇÊûúÊüê‰∏™ËÄÉËØïÂç≥‰ΩøËΩ¨Áßª‰∫Ü‰ª•Âêé‰πüÊ≤°Ê≥ïÂÆåÊàêÁöÑËØùÔºåÂ∞±ÊòØÊ≤°ÊúâÂèØË°åËß£‰∫Ü„ÄÇ‰ª£Á†Å‰∏≠Âà©Áî®‰∫ÜÁ±ª‰ººÂπ∂Êü•ÈõÜÁöÑÊñπÂºèÊù•Áª¥Êä§ËΩ¨ÁßªÔºõ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+50; struct e{ int x,y; }G[maxn]; bool cmp1(e a,e b) { return a.x&lt;b.x; } bool cmp2(e a,e b) { return a.y&lt;b.y; } int anotherchoice[maxn*2]; int find(int x) { return x==anotherchoice[x]?x:anotherchoice[x]=find(anotherchoice[x]); } int main() { int cnt=0,i,j,k,n; cin&gt;&gt;n; int ys[maxn*2]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;G[i].x,&amp;G[i].y);ys[++cnt]=G[i].x;ys[++cnt]=G[i].y; } sort(ys+1,ys+1+cnt); cnt=unique(ys+1,ys+1+cnt)-ys;int pos; sort(G+1,G+n+1,cmp1);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].x==ys[i])G[pos++].x=i; sort(G+1,G+n+1,cmp2);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].y==ys[i])G[pos++].y=i;//Á¶ªÊï£Âåñ,ÂêåÊó∂‰øùËØÅÂéüÂ§ßÂ∞èÂÖ≥Á≥ª‰∏ç‰ºöÊîπÂèò for(i=1;i&lt;=cnt;i++)anotherchoice[i]=i;//ÂºÄÂßãÁöÑÊó∂ÂÄôÊØè‰∏™Êó•ÊúüÁöÑÈÄâÊã©ÈÉΩÂè™ÊúâËá™Â∑± int ans=0; for(i=1;i&lt;=n;i++){ int ch1,ch2; ch1=find(G[i].x);ch2=find(G[i].y); if(!ch1&amp;&amp;!ch2){//Â¶ÇÊûúËøô‰∏™ËÄÉËØïÁöÑ‰∏§‰∏™Êó•ÊúüÈÉΩÊ≤°ÊúâÈÄâÊã©‰∫Ü,ÈÇ£‰πàÊòæÁÑ∂Êó†Ê≥ïÂÆåÊàê puts(&quot;-1&quot;);return 0; } else if(ch1==ch2||!ch1||!ch2){//Â¶ÇÊûúËøô‰∏™ËÄÉËØïÂè™Êúâ‰∏Ä‰∏™ÂèØÁî®ÁöÑÊó•Êúü,ÈÇ£‰πàÊòæÁÑ∂Âè™ËÉΩÂîØ‰∏ÄÈÄâÊã© ans=max(ans,max(ch1,ch2));anotherchoice[ch1]=anotherchoice[ch2]=0; } else{//ËÄÉËØïÊúâ‰∏§‰∏™ÈÄâÊã©,ÈÇ£‰πàÂÖàÈÄâÈÇ£‰∏™Êó•ÊúüÊØîËæÉÂ∞èÁöÑ,ÂêåÊó∂Ê†áËÆ∞‰∏Ä‰∏ãÊó•ÊúüÊØîËæÉÂ∞èÁöÑÈÇ£È¢òËøòÊúâ‰∏Ä‰∏™Êó•ÊúüÊØîËæÉÂ§ßÁöÑÈÄâÊã© ans=max(ans,min(ch1,ch2));anotherchoice[min(ch1,ch2)]=max(ch1,ch2); } } cout&lt;&lt;ys[ans]&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÂø´ÈÄüËØªÂÖ•]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e8-af-bb-e5-85-a5%2F</url>
    <content type="text"><![CDATA[‰∏éscanfÔºåcinÂÜ≤Á™ÅÔºàËæìÂá∫Ê≤°ÈóÆÈ¢òÔºâÔºåÂèØËøîÂõûEOF„ÄÇ const int BufferSize=1&lt;&lt;16; char buffer[BufferSize],*fronthead,*fronttail; inline char GET_CHAR(){ if(fronthead==fronttail){ int l=fread(buffer,1,BufferSize,stdin); fronttail=(fronthead=buffer)+l; if(fronthead==fronttail)return EOF; } return *fronthead++; } inline int READ(){ int x=0,f=1;char c=GET_CHAR(); for(;!isdigit(c);c=GET_CHAR()){ if(c==EOF)return EOF; if(c==&apos;-&apos;)f=-1; } for(;isdigit(c);c=GET_CHAR())x=(((x&lt;&lt;2)+x)&lt;&lt;1)+c-&apos;0&apos;; return x*f; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #5]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-5%2F</url>
    <content type="text"><![CDATA[A.Gym - 101606L Lizard LoungeÂÖ∂ÂÆûÂ∞±ÊòØÁÆóÂá∫ÂêÑ‰∏™ÁÇπ‰Ωç‰∫éÂì™Êù°Áõ¥Á∫ø‰∏äÔºåÁÑ∂ÂêéÂØπÊØèÊù°Áõ¥Á∫øÁÆóÁÆóLISÁöÑÈóÆÈ¢ò‚Ä¶ÔºàÂ∞±ÊòØÊääÂêå‰∏ÄÊù°Áõ¥Á∫ø‰∏äÁöÑËú•Ëú¥‰∏¢Âà∞‰∏ÄËµ∑„ÄÇÊàë‰ª¨Áî®ÊñúÁéáÊù•Âà§Êñ≠‰ªñ‰ª¨ÊòØ‰∏çÊòØÂú®Âêå‰∏ÄÊù°Áõ¥Á∫ø‰∏ä„ÄÇ‰πãÂêéË¶ÅÊää‰ªñ‰ª¨ÊåâÁÖßÂú®ÊàøÈó¥ÈáåÁöÑÊ¨°Â∫èÊù•ÊéíÂ∫èÔºå‰πüÂ∞±ÊòØÊåâÂà∞ÊòæÁ§∫Âô®ÁöÑË∑ùÁ¶ªÊù•ÊéíÂ∫è„ÄÇÔºâ‰ΩÜÊòØÂÜôËµ∑Êù•ÊúâÂùëÔºåÈ¶ñÂÖàÊñúÁéáÁõ∏ÂêåÁöÑÁÇπÂèØËÉΩÂú®txÔºåtyÁöÑ‰∏§‰æßÔºå‰ªñ‰ª¨ÊòØ‰∫í‰∏çÂΩ±ÂìçÁöÑ„ÄÇÂÖ∂Ê¨°ÔºåÁõ¥Êé•ÁÆóÊñúÁéá‰ºöÊúâÁ≤æÂ∫¶ÈóÆÈ¢ò„ÄÇÊúÄÂêéÔºåÁÆóÂÆåÊñúÁéá‰ª•ÂêéÁÇπÁöÑÊéíÂ∫è‰πüË¶ÅÊ≥®ÊÑè„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;P; const int maxn=1e6+10; map&lt;P,int&gt; mp1; vector&lt;P&gt;G[maxn]; int cnt=0; int gcd(int a,int b) { return b?gcd(b,a%b):a; } ll lenth(int x,int y) { return (ll)x*x+(ll)y*y; } void sit(int x, int y, int h) { ll d = lenth(x, y); if (x == 0) y /= abs(y); else if (y == 0) x /= abs(x); else { int z = gcd(abs(x), abs(y)); x /= z, y /= z; } if (mp1.count(P(x, y)) == 0) mp1[P(x, y)] = ++cnt; G[mp1[P(x, y)]].push_back(P(d, h)); } int main() { int tx, ty, n, i, j, k, x, y, h; cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; n; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;h); x -= tx;y -= ty; sit(x, y, h); } int ans = 0; int f[maxn], a[maxn]; for (i = 1; i &lt;= cnt; i++) { sort(G[i].begin(), G[i].end()); int len = G[i].size(); for (j = 0; j &lt; len; j++) a[j] = G[i][j].second, f[j + 1] = 1 &lt;&lt; 30; for (j = 0; j &lt; len; j++) { *lower_bound(f + 1, f + 1 + len, a[j]) = a[j]; } ans += lower_bound(f + 1, f + 1 + len, 1 &lt;&lt; 30) - f - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } B.CodeForces - 977DÂ¶ÇÊûú‰∏Ä‰∏™Êï∞ÊòØÂè¶‰∏Ä‰∏™Êï∞ÁöÑ‰∏§ÂÄçÔºåÊàñËÄÖÊòØÂè¶‰∏Ä‰∏™Êï∞Èô§‰ª•3ÁöÑÁªìÊûúÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰ªéÈÇ£‰∏™Êï∞Âºï‰∏ÄÊù°ËæπÊåáÂêëËøô‰∏™Êï∞ÔºåÂ∞ÜÈóÆÈ¢òËΩ¨‰∏∫‰∏Ä‰∏™ÊúâÂêëÂõæÊãìÊâëÊéíÂ∫èÁöÑÈóÆÈ¢òÂç≥ÂèØËß£ÂÜ≥‰∫Ü„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { vector&lt;int&gt;G[105];int indegree[105]={0}; int n,i,j,k; cin&gt;&gt;n; ll num[105]; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;num[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ if(i==j)continue; if(num[j]==num[i]*2||(num[i]%3==0&amp;&amp;num[j]==num[i]/3)){ G[i].push_back(j);indegree[j]++; } } queue&lt;int&gt;que; for(i=1;i&lt;=n;i++)if(indegree[i]==0)que.push(i); int cnt=0; while(!que.empty()){ i=que.front();que.pop(); cout &lt;&lt; num[i] &lt;&lt; &apos; &apos;; for (j = 0; j &lt; G[i].size(); j++) { k = G[i][j]; indegree[k]--; if(!indegree[k])que.push(k); } } return 0; } D.CodeForces - 959DÈ¶ñÂÖàÔºå‰∏çÁÆ°b‰∏≠ÁöÑÊï∞Â≠óÊÄé‰πàÊîæÔºåË¶Å‰ΩøÂæób‰∏≠ÁöÑÊï∞‰∏§‰∏§‰∫íË¥®ÔºåÈÇ£‰πàÊØèÊ¨°ÂæÄbÈáåÈù¢‰∏¢‰∏Ä‰∏™Êï∞ÔºåËøô‰∏™Êï∞ÁöÑÁ∫¶Êï∞ÁöÑÊâÄÊúâÂÄçÊï∞ÈÉΩÂøÖÈ°ª‰ªéÂèØÈÄâÈõÜÈáåÊªöËõã„ÄÇÂõ†‰∏∫bÁöÑÂ≠óÂÖ∏Â∫èÂøÖÈ°ªÂ§ß‰∫éa‰∏îÊúÄÂ∞èÔºåÊâÄ‰ª•Â¶ÇÊûúÊúâ‰∏Ä‰∏™‰ΩçÁΩÆbÊØîaÂ§ßÔºåÈÇ£‰πàÂêéÈù¢ÁöÑ‰ΩçÁΩÆ‰∏≠Â∞ΩÈáèÊîæÊúÄÂ∞èÁöÑÂèØÊîæÁöÑÊï∞Âç≥ÂèØ„ÄÇÂü∫‰∫éËøôÁßçËÄÉËôëÔºåÊàë‰ª¨È¶ñÂÖà‰ΩøÁî®Á±ª‰ººÂüÉÊ∞èÁ≠õÁöÑÊñπÊ≥ïÈ¢ÑÂ§ÑÁêÜÂá∫ÊâÄÊúâÊï∞ÁöÑÁ∫¶Êï∞ÔºåÁÑ∂ÂêéÊØèÊ¨°ÂÖàÊü•ÊâæÂ§ß‰∫éÁ≠â‰∫éaÁöÑÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÂèØÈÄâÊï∞ÔºåÁÑ∂ÂêéÊääËøô‰∏™Êï∞ÁöÑÊâÄÊ¨≤Á∫¶Êï∞ÁöÑÂÄçÊï∞Âπ≤Êéâ„ÄÇÂ¶ÇÊûúËøô‰∏™Êï∞&gt;a,ÈÇ£‰πàGGÔºåÂêéÈù¢Âè™Ë¶ÅÊîæÊúÄÂ∞èÁöÑÂèØÊîæÁöÑÊï∞Âç≥ÂèØ #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e6+5; bool isnot[N],erase1[N]; set&lt;int&gt;s; vector&lt;int&gt;G[N]; void getys(void) { for(int i=2;i&lt;N;i++){ //if(isnot[i])continue; if(!isnot[i]) { for (int j = i; j &lt; N; j += i) { isnot[j] = true; G[j].push_back(i); } } s.insert(i); } } int main() { int n,i,j,k; cin&gt;&gt;n; getys();bool islarge=false; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d&quot;,&amp;a);b=*s.begin(); if(!islarge) { b = *s.lower_bound(a); if(b!=a)islarge=true; } cout&lt;&lt;b&lt;&lt;&apos; &apos;; for(int j:G[b]){ if(erase1[j])continue; for(k=j;k&lt;N;k+=j){ if(!erase1[k]){ s.erase(k);erase1[k]=true; } } } } return 0; } E.CodeForces - 931BÁ≠æÂà∞ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,a,b,cnt,i,j; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(i=0;;i++){ if(!(n&gt;&gt;i))break; } cnt=i-1;int cnt1=0; while(a!=b){ a=(a+1)&gt;&gt;1;b=(b+1)&gt;&gt;1;cnt1++; } if(cnt1==cnt)cout&lt;&lt;&quot;Final!&quot;&lt;&lt;endl; else cout&lt;&lt;cnt1&lt;&lt;endl; return 0; } F.CodeForces - 731F‰∏Ä‰∏™ÂâçÁºÄÂíåsum[i]ËÆ∞ÂΩïÂ∞è‰∫éÁ≠â‰∫éIÁöÑ‰∏™Êï∞ÔºåÂ∞ÜÂ∫èÂàóÊéíÂ∫èÔºåÂéªÈáç„ÄÇÊûö‰∏æÊØè‰∏Ä‰∏™Êï∞‰∏∫‚ÄúÂü∫Êï∞‚ÄùÔºåÂà§Êñ≠‰ªñ[nÂÄç‚Äî-(n+1) )ÂÄçÔºàÂ∑¶Èó≠Âè≥ÂºÄÔºån‰ªé1ÂºÄÂßãÔºâ‰πãÈó¥Êï∞ÁöÑ‰∏™Êï∞ÔºåËøô‰∫õÊï∞ÊòØË¶ÅÂèòÊàên* Âü∫Êï∞ÁöÑ„ÄÇËÆ∞ÂΩïÂíåÔºåËÆ∞ÂΩïÊúÄÂ§ßÂÄº„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sum[200005],a[200005]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum[a[i]]++; } sort(a+1,a+1+n); int cnt=unique(a+1,a+1+n)-a-1; for(i=1;i&lt;=200000;i++) sum[i]+=sum[i-1];//ËÆ∞ÂæóÂèòÊàêÂâçÁºÄÂíå ll ans=0; for(i=1;i&lt;=cnt;i++){ ll val=0; for(j=1;a[i]*j&lt;=200000;j++){ int t1=a[i]*j,t2=a[i]*(j+1)&gt;200000?200000:a[i]*(j+1)-1;//Ê≥®ÊÑèÂå∫Èó¥ÁöÑÈóÆÈ¢ò int tot=sum[t2]-sum[t1-1]; val+=(ll)tot*t1; } ans=max(ans,val); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } G.CodeForces - 570DÈ¢òÁõÆÁöÑÊú¥Á¥†ÂÜôÊ≥ïËøòÊòØÂæàÂ•ΩÂÜôÁöÑ‚Ä¶‰ΩÜÊòØÊï∞ÊçÆËßÑÊ®°ËøáÂ§ßÂØºËá¥ÂøÖtÊó†Áñë‚Ä¶ ‰∫éÊòØÊàë‰ª¨ÊÉ≥Âà∞‰∫ÜÁ¶ªÁ∫øÂ§ÑÁêÜÔºå‰∏ÄÊ¨°dfs‚Ä¶ ‰ΩÜÊòØ‰æùÁÑ∂‰∏çÂ•ΩÂÅöÔºåËøôÈáåÊàë‰ª¨Â§ÑÁêÜÁöÑÂÅöÊ≥ïÊòØÂà©Áî®ÂºÇÊàñ‚Ä¶ÊØèÊ¨°ÊêúÁ¥¢Âà∞‰∏Ä‰∏™ÁÇπÁöÑÊó∂ÂÄôÂÖàÊääÂêÑ‰∏™Á≠îÊ°àË¶ÅÈóÆÁöÑÊ∑±Â∫¶ÁöÑÂ≠óÊØçÊÉÖÂÜµÁªô‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂ÂêéÊêúÁ¥¢Ëøô‰∏™ËäÇÁÇπ‰∏ãÈù¢Â≠êÊ†ëÂêÑ‰∏™Ê∑±Â∫¶ÁöÑÂ≠óÊØçÊÉÖÂÜµÔºåÊúÄÂêéÂÜçÁªôÊØè‰∏™Á≠îÊ°àÂºÇÊàñ‰∏Ä‰∏ãÔºåÂ∞±ÂèØ‰ª•ÂæóÂá∫Ëøô‰∏™ËäÇÁÇπ‰∏ãÈù¢ÁöÑÊÉÖÂÜµ‚Ä¶.emm,ÊÑüËßâ‰∏çÂ§™Â•ΩÊèèËø∞ÔºåÊÄª‰πãËøòÊòØÊå∫Â∑ßÂ¶ôÁöÑ‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500005; char node[maxn]; vector&lt;int&gt;G[maxn],query[maxn]; int dep[maxn],ans[maxn],tardep[maxn]; void dfs(int x,int depth) { for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//È¶ñÂÖàÂÖàÊääËøô‰∏™Ê∑±Â∫¶ÁöÑÂ≠óÊØç‰∏™Êï∞ÊÉÖÂÜµ‰øùÂ≠òËµ∑Êù• for (auto b:G[x]) dfs(b, depth + 1);//ÁÑ∂ÂêéÁªüËÆ°Âú®ÂΩìÂâçËäÇÁÇπ‰∏ãÂêÑ‰∏™Ê∑±Â∫¶ÁöÑÂ≠óÊØçÊÉÖÂÜµ,Âπ∂Êõ¥Êñ∞depÊï∞ÁªÑ dep[depth] ^= (1 &lt;&lt; (int) (node[x] - &apos;a&apos;)); for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//Êñ∞ÁöÑdepÊï∞ÁªÑÂºÇÊàñÊóßÁöÑdepÊï∞ÁªÑ,Â∞±ÂèØ‰ª•ÂæóÂá∫ÂΩìÂâçËäÇÁÇπÁöÑÂ≠êÊ†ë‰∏≠ÂêÑ‰∏™Ê∑±Â∫¶ÁöÑÂ≠óÊØçÊÉÖÂÜµ } bool check(int x) { int cnt=0; while(x){ cnt++;x-=x&amp;-x; } if(cnt&gt;1)return false; return true; } int main() { int n, m,i,j; cin&gt;&gt;n&gt;&gt;m; for (i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); G[j].push_back(i);//‰øùÂ≠òÊ†ë } scanf(&quot;%s&quot;, node + 1); for (i = 1; i &lt;= m; i++) { int v,h; scanf(&quot;%d%d&quot;, &amp;v, &amp;h); query[v].push_back(i);//Á¶ªÁ∫øÂ§ÑÁêÜÈóÆËØ¢ tardep[i] = h;//‰øùÂ≠òÈóÆËØ¢Ê∑±Â∫¶ } dfs(1, 1); for (i = 1; i &lt;= m; i++) { if(!check(ans[i]))//Â¶ÇÊûúansÁöÑ‰∫åËøõÂà∂Ë°®Á§∫‰∏≠ÊúâË∂ÖËøá‰∏Ä‰∏™‰ΩçÁΩÆÊòØ1 printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #4]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-4%2F</url>
    <content type="text"><![CDATA[A.CodeForces 791DÈ¶ñÂÖàÔºåÂÖàËÄÉËôë‰∏Ä‰∏™ÈóÆÈ¢òÔºöÂ¶Ç‰ΩïËÆ°ÁÆó‰∏ÄÊ£µÊ†ë‰∏≠ÊâÄÊúâÁÇπÂØπ‰πãÈó¥ÁöÑË∑ùÁ¶ªÂíå„ÄÇÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúËøô‰∏™ÁÇπÁöÑÂ≠êÊ†ëÁöÑÂ§ßÂ∞è‰∏∫$s$ÁöÑËØùÔºåÈÇ£‰πàËøô‰∏™ÁÇπ‰∏éÂÖ∂Á•ñÂÖà‰πãÈó¥ÁöÑÈÇ£Êù°ËæπÂú®ËÆ°ÁÆóÊÄªÂíåÁöÑËøáÁ®ã‰∏≠‰∏ÄÂÆö‰ºöË¢´ËÆ°ÁÆó$(n-s)\times s$Ê¨°Ôºàn‰∏∫ÊÄªÁöÑËäÇÁÇπÊï∞Ôºâ„ÄÇ‰ΩÜÊòØÁõÆÂâçÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÔºåÂ∞±ÊòØÊØèÊ¨°Âè™ËÉΩËµ∞kÊ≠•ÔºåÊØîÂ¶ÇËØ¥k=4ÔºåËÄåË∑ùÁ¶ª‰∏∫10ÔºåÈÇ£Â∞±ÈúÄË¶Å3Ê≠•ÔºåÊ≠§Êó∂Â¶ÇÊûúÁõ¥Êé•Ê±ÇÂá∫ÊÄªÁöÑË∑ùÁ¶ª‰πãÂíåÂéªÈô§‰ª•kÔºåÁ≠îÊ°àËÇØÂÆöÊòØÈîôËØØÁöÑ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âú®dfsÂà∞ÊØè‰∏™ËäÇÁÇπÁöÑÊó∂ÂÄôÔºåËøòË¶ÅËÆ°ÁÆó‰ªñÁöÑÂêÑ‰∏™Â≠êËäÇÁÇπ‰πãÈó¥ÁöÑË∑ùÁ¶ªÔºåÁÑ∂ÂêéÊääÊâÄÊúâmod kÊúâ‰ΩôÊï∞ÁöÑË∑ùÁ¶ª‰∏ékÁöÑÂÄçÊï∞ÁöÑÂ∑ÆÂÄºÈÉΩÁªôË°•‰∏ä„ÄÇÊúÄÂêéË∑ùÁ¶ªÊÄªÂíåÈô§‰ª•kÂç≥ÂèØ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5 + 50; ll n,k,ans=0,size[maxn][5],cntsub[maxn];//size‰ª£Ë°®ËäÇÁÇπxÁöÑË∑ùÁ¶ªÂÆÉÁöÑË∑ùÁ¶ª‰∏∫iÁöÑÂ≠êËäÇÁÇπÁöÑ‰∏™Êï∞,cntÂàô‰∏∫ËäÇÁÇπÊÉ≥ÁöÑÂ≠êÊ†ë‰∏™Êï∞Âíå vector&lt;int&gt;G[maxn]; void dfs(ll x,ll fa,ll sit)//x‰∏∫ËäÇÁÇπID,fa‰∏∫ËäÇÁÇπÁ•ñÂÖà,sit‰∏∫ÂΩìÂâçËäÇÁÇπÂà∞È°∂ÁÇπÁöÑË∑ùÁ¶ªmod k { cntsub[x] = size[x][sit % k] = 1; ll i, j; for (auto a : G[x]) { if (a == fa)continue; dfs(a, x, sit + 1); for (i = 0; i &lt; k; i++) {//Êûö‰∏æÂà∞Â≠êËäÇÁÇπÁöÑË∑ùÁ¶ª for (j = 0; j &lt; k; j++) { ll t = (k - (i + j - 2 * (sit % k)) % k) % k; ans += t * size[x][i] * size[a][j]; } } for (i = 0; i &lt; k; i++)size[x][i] += size[a][i]; cntsub[x] += cntsub[a]; } ans += cntsub[x] * (n - cntsub[x]);//x‰∏éÁ•ñÂÖàËøûËæπË¢´ËÆ°ÁÆóÁöÑÊ¨°Êï∞ } int main() { int i, j, u, v; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, 0, 0); cout &lt;&lt; ans / k &lt;&lt; endl; return 0; } B.CodeForces - 2BÊ±ÇÁü©ÈòµË∑ØÂæÑ‰∏äÊï∞Â≠óÁöÑÁßØÊú´Â∞æÊúÄÂ∞ëÁöÑ0‰∏™Êï∞„ÄÇÈÇ£‰πàÂÖ∂ÂÆûÂ∞±ÊòØÁªüËÆ°Ë∑ØÂæÑ‰∏äÊúÄÂ∞ëÁöÑ2‰∏™Êï∞‰∏é5‰∏™Êï∞ÔºåÂèñÂÖ∂‰∏≠ÊØîËæÉÂ∞èÁöÑÂç≥ÂèØ„ÄÇÊúâ‰∏™ÈóÆÈ¢òÂ∞±ÊòØË∑ØÂæÑ‰∏≠Â¶ÇÊûúÊúâ0ÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÁâπÂà§Á≠îÊ°àÂà∞Â∫ïÊòØ1ËøòÊòØ0‰∫Ü„ÄÇË∑ØÂæÑËæìÂá∫ÁöÑÊó∂ÂÄôÁ®çÂæÆË¶ÅÁÇπÂ∞èÊäÄÂ∑ßÔºåÊ≤°‰∫Ü„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int get2(int x) { int cnt=0; while(x&amp;&amp;x%2==0){ cnt++;x/=2; } return cnt; } int get5(int x) { int cnt=0; while(x&amp;&amp;x%5==0){ cnt++;x/=5; } return cnt; } int num[1005][1005]; typedef pair&lt;int,char&gt;P; P dp2[1005][1005],dp5[1005][1005]; int main() { int i,j,k,n; cin&gt;&gt;n; memset(dp2,0x3f, sizeof(dp2));memset(dp5,0x3f,sizeof(dp5)); int move1[2][2]={1,0,0,1}; bool haszero=false;int zerox,zeroy; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) { scanf(&quot;%d&quot;, &amp;num[i][j]); if(!num[i][j]){ haszero=true;zerox=i,zeroy=j; } } if(num[1][1]) { dp2[1][1].first = get2(num[1][1]), dp5[1][1].first = get5(num[1][1]); } else{ dp2[1][1].first=dp5[1][1].first=1; } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ //if(i==1&amp;&amp;j==1)continue; for(k=0;k&lt;2;k++){ int a=i+move1[k][0],b=j+move1[k][1]; if(num[a][b]==0){ dp2[a][b].first=0;dp5[a][b].first=0; } else { if (dp2[a][b].first &gt; dp2[i][j].first + get2(num[a][b])) { dp2[a][b].first = dp2[i][j].first + get2(num[a][b]); if (k)dp2[a][b].second = &apos;R&apos;; else dp2[a][b].second = &apos;D&apos;; } if (dp5[a][b].first &gt; dp5[i][j].first + get5(num[a][b])) { dp5[a][b].first = dp5[i][j].first + get5(num[a][b]); if (k)dp5[a][b].second = &apos;R&apos;; else dp5[a][b].second = &apos;D&apos;; } } } } int ans=1&lt;&lt;30; int sit=0; //cout&lt;&lt;dp2[n][n].first&lt;&lt;&apos; &apos;&lt;&lt;dp5[n][n].first&lt;&lt;endl; if(haszero&amp;&amp;dp2[n][n].first&gt;1&amp;&amp;dp5[n][n].first&gt;1){ ans=1;sit=1; } else{ if(dp2[n][n].first&gt;dp5[n][n].first){ ans=dp5[n][n].first;sit=3; } else{ ans=dp2[n][n].first;sit=2; } } cout&lt;&lt;ans&lt;&lt;endl; vector&lt;char&gt;way; if(sit==1){ for(i=1;i&lt;zerox;i++)way.push_back(&apos;D&apos;); for(j=1;j&lt;n;j++)way.push_back(&apos;R&apos;); for(i=zerox;i&lt;n;i++)way.push_back(&apos;D&apos;); } else if(sit==2){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp2[i][j].second); if(dp2[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } else if(sit==3){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp5[i][j].second); if(dp5[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } for(auto a:way) cout&lt;&lt;a; return 0; } C.CodeForces - 527AÁ≠æÂà∞ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll ans=0; void cal(ll x,ll y) { if(!y)return; ans+=x/y;x%=y; cal(y,x); } int main() { ll a,b; cin&gt;&gt;a&gt;&gt;b; cal(a,b); cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.CodeForces - 785B‰∏ªË¶ÅËÄÉÂØüËã±ËØ≠ÈòÖËØªÁêÜËß£ËÉΩÂäõÔºåÊ≥®ÊÑèÂÖà‰∏äÂì™‰∏™ËØæÁ®ãÊòØ‰∏çÁ°ÆÂÆöÁöÑ„ÄÇÂÇªÈÄºÈ¢ò* 2 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,ans,i,j,a,b,amin=0,amax=1&lt;&lt;30,bmin=0,bmax=1&lt;&lt;30; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); amin = max(amin, a); amax = min(amax, b); } cin&gt;&gt;m; for(i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); bmin = max(bmin, a); bmax = min(bmax, b); } ans=max(amin-bmax,bmin-amax); cout&lt;&lt;(ans&gt;=0?ans:0)&lt;&lt;endl; return 0; } F.CodeForces - 57CÈ¶ñÂÖàÔºåÊ≥®ÊÑèÂà∞‰∏ÄÁÇπÔºöÊØè‰∏Ä‰∏™‰∏ç‰∏ãÈôçÊï∞ÂàóÂèçËøáÊù•Â∞±ÊòØ‰∏Ä‰∏™‰∏ç‰∏äÂçáÊï∞ÂàóÔºåÂõ†Ê≠§Êàë‰ª¨Âè™Ë¶ÅËÆ°ÁÆóÂá∫‰∏ç‰∏ãÈôçÊï∞ÂàóÁöÑ‰∏™Êï∞Ôºå‰πò2ÔºåÂáèÂéªnÔºàÊâÄÊúâÊï∞Â≠óÁõ∏ÂêåÁöÑÊï∞Âàó‰∏™Êï∞ÔºâÔºåÂ∞±ÊòØÁ≠îÊ°à‰∫Ü„ÄÇ ÁÑ∂ÂêéÔºåÁ¨¨‰∏Ä‰ΩçËÇØÂÆöÊòØË¶ÅÊîæ‰∏Ä‰∏™Êï∞ÁöÑÔºåÊàë‰ª¨Âßë‰∏î‰∏çÁÆ°„ÄÇÈÇ£‰πàÂú®ÂêéÈù¢ÁöÑn-1‰∏™‰ΩçÁΩÆ‰∏äÔºåÊàë‰ª¨ÂèØ‰ª•‰ªªÊÑèÂèñËã•Âπ≤‰∏™‚Äú‰∏äÂçáÁÇπ‚ÄùÔºå‰πüÂ∞±ÊòØËøô‰∏™ÁÇπÊîæÁöÑÊï∞ÊØîÂâçÈù¢ÁöÑÊï∞Ë¶ÅÊù•ÁöÑÂ§ßÔºåÁõ∏ÈÇª‚Äú‰∏äÂçáÁÇπ‚Äù‰πãÈó¥ÁöÑÊï∞Â≠óÁöÑÂÄºÊòØÁõ∏ÂêåÁöÑ„ÄÇÂú®n-1‰∏™‰ΩçÁΩÆ‰∏≠ÈÄâk‰∏™‰∏äÂçáÁÇπÔºåÊñπÊ°àÊï∞ÊòØ$C_{n-1}^{k}$,ÁÑ∂ÂêéÔºåÈÄâÂÆök‰∏™‰∏äÂçáÁÇπÔºåÈÇ£‰πàÊàë‰ª¨Ëøô‰∏™Êï∞Âàó‰∏≠Â∞±ÈúÄË¶Åk+1‰∏™‰∏çÂêåÁöÑÊï∞ÔºàËøòËÆ∞ÂæóÁ¨¨‰∏Ä‰Ωç‰πàÔºüÔºâÔºå‰ºöÂèëÁé∞Ôºå‰ªªÊÑèÈÄâÊã©1~n‰∏≠ÁöÑk+1‰∏™Êï∞Ôºå‰ªñÈÉΩÂØπÂ∫îÁùÄÂîØ‰∏ÄÁöÑ‰∏ÄÁßçÊéíÂàóÊñπÊ°àÔºåÊâÄ‰ª•ÔºåÊÄªÁöÑÁ≠îÊ°àÂ∞±ÊòØ$\sum_{i=0}^{n-1}C_{n-1}^{i}\times C_n^{i+1}$,ÁÆóÁÆóÁªÑÂêàÊï∞ÁÆóÁÆóÈÄÜÂÖÉÂ∞±ok‰∫Ü„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; const int maxn=1e5+10; ll c1[maxn],inv[maxn],jc[maxn],c2[maxn]; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int i,j,k,n; cin&gt;&gt;n; jc[1]=1;inv[1]=1,inv[0]=1; for(i=2;i&lt;=n;i++) jc[i]=jc[i-1]*i%mod,inv[i]=pow(jc[i],mod-2,mod); for(i=1;i&lt;=n;i++) { c1[i] = (jc[n - 1] * inv[i] % mod * inv[n - 1 - i]) % mod; c2[i] = (jc[n] * inv[i] % mod * inv[n - i]) % mod; } c1[0]=1;c2[0]=1; ll ans=0; for(i=0;i&lt;n;i++) ans=(ans+c1[i]*c2[i+1])%mod; ans=(ans+ans-n)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } I.HackerRank - game-with-cellsÂÇªÈÄºÈ¢ò* 3 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; if(n&amp;1)n=n/2+1; else n&gt;&gt;=1; if(m&amp;1)m=m/2+1; else m&gt;&gt;=1; cout&lt;&lt;n*m&lt;&lt;endl; return 0; } J.CodeForces - 145C ÁªôÂá∫‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫nÁöÑÂ∫èÂàóaiÔºåÈóÆÂÖ∂ÈïøÂ∫¶‰∏∫kÁöÑÂ≠êÂ∫èÂàó‰∏≠ÔºåÂêå‰∏Ä‰∏™Âπ∏ËøêÊï∞Â≠óËá≥Â§öÂá∫Áé∞‰∏ÄÊ¨°ÁöÑÂ≠êÂ∫èÂàó‰∏™Êï∞ÔºåÂπ∏ËøêÊï∞Â≠óÂç≥‰∏∫ÂÖ®ÈÉ®Áî±4Âíå7ÁªÑÊàêÁöÑÊï∞Â≠ó ÂÅáËÆæÊúâ$res$‰∏™‰∏çÂêåÁöÑÂπ∏ËøêÊï∞Â≠óÔºåÊúâ$sum$‰∏™ÈùûÂπ∏ËøêÊï∞Â≠óÔºåÁ¨¨$i$‰∏™Âπ∏ËøêÊï∞Â≠óÂú®ÂéüÂ∫èÂàó‰∏≠Âá∫Áé∞‰∫Ü$num[i]$Ê¨°ÔºåÁî®$dp[i][j]$Ë°®Á§∫‰ªéÂâç$i$‰∏™Âπ∏ËøêÊï∞Â≠ó‰∏≠ÈÄâ$j$‰∏™ÁöÑÊñπÊ°àÊï∞ÔºåÈÇ£‰πàÊòìÂæóËΩ¨ÁßªÊñπÁ®ã$dp[i][j]=dp[i‚àí1][j]+num[i]‚ãÖdp[i‚àí1][j‚àí1]$Ôºå‰πãÂêéÊûö‰∏æÂ≠êÂ∫èÂàó‰∏≠ÈùûÂπ∏ËøêÊï∞Â≠ó‰∏™Êï∞Âç≥ÂèØÂæóÂà∞Á≠îÊ°à$ans=\sum_{i=0}^{min(k,sum)}C_{sum}^{i}\times dp[res][k-i]$„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+10; const int mod=1e9+7; ll fac[maxn],dp[3000][3000]; bool islucky(int v)//Âà§Êñ≠ÊòØÂê¶lucky number { while (v) { if (v % 10 != 4 &amp;&amp; v % 10 != 7) return false; v /= 10; } return true; } ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } ll C(ll v, ll u) { if (v &lt; u) return 0; ll x = (fac[u] * fac[v - u]) % mod; return (fac[v] * pow(x, mod - 2,mod)) % mod; } int main() { int i, j, n, k,sum=0;ll ans=0; cin&gt;&gt;n&gt;&gt;k; map&lt;int,int&gt;mp1; fac[0] = 1; for (i = 1; i &lt;= n; i++) fac[i] = (fac[i - 1] * i) % mod; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); if (islucky(j)) mp1[j]++;//ÁªüËÆ°Âπ∏ËøêÊï∞‰∏™Êï∞ else sum++; } dp[0][0] = 1;i = 1; for (auto it = mp1.begin(); it != mp1.end(); it++, i++) for (j = 0; j &lt; i; j++) { dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod; dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j] * it-&gt;second) % mod; } int cnt = mp1.size(); for (i = 0; i &lt;= cnt &amp;&amp; i &lt;= k; i++) ans = (ans + (dp[cnt][i] * C(sum, k - i)) % mod) % mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } K.CodeForces - 691BÈöæÁÇπÂú®‰∫éÂ¶Ç‰ΩïÊâæÂá∫ÊâÄÊúâÂØπÁß∞ÁöÑÂ≠óÁ¨¶ÔºåÂÇªÈÄºÈ¢ò* 4 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(char x, char y) { if (x == &apos;A&apos; &amp;&amp; y == &apos;A&apos;||x == &apos;H&apos; &amp;&amp; y == &apos;H&apos;||x == &apos;I&apos; &amp;&amp; y == &apos;I&apos;||x == &apos;M&apos; &amp;&amp; y == &apos;M&apos;||x == &apos;O&apos; &amp;&amp; y == &apos;O&apos;) return true; if (x == &apos;T&apos; &amp;&amp; y == &apos;T&apos;||x == &apos;U&apos; &amp;&amp; y == &apos;U&apos;||x == &apos;V&apos; &amp;&amp; y == &apos;V&apos;||x == &apos;W&apos; &amp;&amp; y == &apos;W&apos;||x == &apos;X&apos; &amp;&amp; y == &apos;X&apos;) return true; if (x == &apos;Y&apos; &amp;&amp; y == &apos;Y&apos;||x == &apos;v&apos; &amp;&amp; y == &apos;v&apos;||x == &apos;w&apos; &amp;&amp; y == &apos;w&apos;||x == &apos;x&apos; &amp;&amp; y == &apos;x&apos;||x == &apos;o&apos; &amp;&amp; y == &apos;o&apos;) return true; if (x == &apos;p&apos; &amp;&amp; y == &apos;q&apos;||x == &apos;q&apos; &amp;&amp; y == &apos;p&apos;||x == &apos;b&apos; &amp;&amp; y == &apos;d&apos;||x==&apos;d&apos;&amp;&amp;y==&apos;b&apos;) return true; return false; } int main() { string str1,str2; cin&gt;&gt;str1;str2=str1; reverse(str2.begin(),str2.end()); for(int i=0;i&lt;str1.size();i++){ if(!check(str1[i],str2[i])){ cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâTarjan]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2FTarjan%2Fe6-a8-a1-e6-9d-bf-ef-bc-89tarjan%2F</url>
    <content type="text"><![CDATA[Ë¶ÅÊ≥®ÊÑèÁöÑÂ∞±ÊòØÈÇ£‰∫õÂçïÁã¨ÁöÑÁÇπÊØè‰∏™ÁÇπÈÉΩ‰ºöË¢´ÂΩìÂÅöËá™Ë∫´‰∏Ä‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÔºå‰πüÂ∞±ÊòØÊúâ‰∏çÂ∞ëÁöÑÂº∫ËøûÈÄöÂàÜÈáèÈáåÈù¢ÂèØËÉΩÂè™Êúâ‰∏Ä‰∏™ÂÖÉÁ¥†‚Ä¶‚Ä¶ int dfn[105],low[105],scccnt=0,sccindex=0,belong[105]; bool instack[105]; stack&lt;int&gt;sta; vector&lt;int&gt;G[105]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i;//ÁêÜËÆ∫‰∏äÁî®c++11ÁöÑÁâπÊÄß‰ºöÊØîG[v].size()Âø´‰∏Ä‰∫õ; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v);//‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèËøôÈáåÂπ∂‰∏çÊòØË¶ÅÊääÊï¥‰∏™Ê†àÊ∏ÖÁ©∫,Âè™ÊòØË¶ÅÊääÂ±û‰∫éÂΩìÂâçËÅîÈÄöÂàÜÈáèÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ê∏ÖÁ©∫ } } ‰∏ªÂáΩÊï∞‰∏≠Ë∞ÉÁî®Ôºö int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ while(cin&gt;&gt;j&amp;&amp;j) G[i].push_back(j); } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b7-af-e5-be-84-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[ÂØπ‰∫é‰∏Ä‰∏™ÁªôÂÆöÁöÑÊúâÂêëÊó†ÁéØÂõæÔºàDAGÔºâÔºåÊ±ÇÂÖ∂ÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñ„ÄÇÈ¢òÁõÆÂèØÂèÇËßÅÊ¥õË∞∑P2764„ÄÇ „ÄêÈóÆÈ¢òÂàÜÊûê„Äë ÊúâÂêëÊó†ÁéØÂõæÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñÔºåÂèØ‰ª•ËΩ¨ÂåñÊàê‰∫åÂàÜÂõæÊúÄÂ§ßÂåπÈÖçÈóÆÈ¢òÔºå‰ªéËÄåÁî®ÊúÄÂ§ßÊµÅËß£ÂÜ≥„ÄÇ „ÄêÂª∫Ê®°ÊñπÊ≥ï„Äë ÊûÑÈÄ†‰∫åÂàÜÂõæÔºåÊääÂéüÂõæÊØè‰∏™È°∂ÁÇπiÊãÜÂàÜÊàê‰∫åÂàÜÂõæXÔºåYÈõÜÂêà‰∏≠ÁöÑ‰∏§‰∏™È°∂ÁÇπXiÂíåYi„ÄÇÂØπ‰∫éÂéüÂõæ‰∏≠Â≠òÂú®ÁöÑÊØèÊù°Ëæπ(i,j)ÔºåÂú®‰∫åÂàÜÂõæ‰∏≠ËøûÊé•Ëæπ(Xi,Yj)„ÄÇÁÑ∂ÂêéÊää‰∫åÂàÜÂõæÊúÄÂ§ßÂåπÈÖçÊ®°ÂûãËΩ¨Âåñ‰∏∫ÁΩëÁªúÊµÅÊ®°ÂûãÔºåÊ±ÇÁΩëÁªúÊúÄÂ§ßÊµÅ„ÄÇ ÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñÁöÑÊù°Êï∞ÔºåÂ∞±ÊòØÂéüÂõæÈ°∂ÁÇπÊï∞ÔºåÂáèÂéª‰∫åÂàÜÂõæÊúÄÂ§ßÂåπÈÖçÊï∞„ÄÇÊ≤øÁùÄÂåπÈÖçËæπÊü•ÊâæÔºåÂ∞±ÊòØ‰∏Ä‰∏™Ë∑ØÂæÑ‰∏äÁöÑÁÇπÔºåËæìÂá∫ÊâÄÊúâË∑ØÂæÑÂç≥ÂèØ„ÄÇ „ÄêÂª∫Ê®°ÂàÜÊûê„Äë ÂØπ‰∫é‰∏Ä‰∏™Ë∑ØÂæÑË¶ÜÁõñÔºåÊúâÂ¶Ç‰∏ãÊÄßË¥®Ôºö 1„ÄÅÊØè‰∏™È°∂ÁÇπÂ±û‰∫é‰∏îÂè™Â±û‰∫é‰∏Ä‰∏™Ë∑ØÂæÑ„ÄÇ 2„ÄÅË∑ØÂæÑ‰∏äÈô§ÁªàÁÇπÂ§ñÔºå‰ªéÊØè‰∏™È°∂ÁÇπÂá∫ÂèëÂè™Êúâ‰∏ÄÊù°ËæπÊåáÂêëË∑ØÂæÑ‰∏äÁöÑÂè¶‰∏ÄÈ°∂ÁÇπ„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™È°∂ÁÇπÁêÜËß£Êàê‰∏§‰∏™È°∂ÁÇπÔºå‰∏Ä‰∏™ÊòØÂá∫ÂèëÔºå‰∏Ä‰∏™ÊòØÁõÆÊ†áÔºåÂª∫Á´ã‰∫åÂàÜÂõæÊ®°Âûã„ÄÇËØ•‰∫åÂàÜÂõæÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÂåπÈÖçÊñπÊ°àÔºåÈÉΩÂØπÂ∫î‰∫Ü‰∏Ä‰∏™Ë∑ØÂæÑË¶ÜÁõñÊñπÊ°à„ÄÇÂ¶ÇÊûúÂåπÈÖçÊï∞‰∏∫0ÔºåÈÇ£‰πàÊòæÁÑ∂Ë∑ØÂæÑÊï∞=È°∂ÁÇπÊï∞„ÄÇÊØèÂ¢ûÂä†‰∏ÄÊù°ÂåπÈÖçËæπÔºåÈÇ£‰πàË∑ØÂæÑË¶ÜÁõñÊï∞Â∞±ÂáèÂ∞ë‰∏Ä‰∏™ÔºåÊâÄ‰ª•Ë∑ØÂæÑÊï∞=È°∂ÁÇπÊï∞ - ÂåπÈÖçÊï∞„ÄÇË¶ÅÊÉ≥‰ΩøË∑ØÂæÑÊï∞ÊúÄÂ∞ëÔºåÂàôÂ∫îÊúÄÂ§ßÂåñÂåπÈÖçÊï∞ÔºåÊâÄ‰ª•Ë¶ÅÊ±Ç‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç„ÄÇÊ≥®ÊÑèÔºåÊ≠§Âª∫Ê®°ÊñπÊ≥ïÊ±ÇÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñ‰ªÖÈÄÇÁî®‰∫éÊúâÂêëÊó†ÁéØÂõæÔºåÂ¶ÇÊûúÊúâÁéØÊàñÊòØÊó†ÂêëÂõæÔºåÈÇ£‰πàÊúâÂèØËÉΩÊ±ÇÂá∫ÁöÑ‰∏Ä‰∫õÁéØË¶ÜÁõñÔºåËÄå‰∏çÊòØË∑ØÂæÑË¶ÜÁõñ„ÄÇ Ê¥õË∞∑È¢òÁõÆÂèÇËÄÉ‰ª£Á†ÅÔºö // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; struct edge { int to, cap, rev; }; vector&lt;edge&gt;G[500]; int level[500], iter[500]; int n, m; void addedge(int from, int to, int cap) { edge e; e.to = to; e.cap = cap; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.rev = G[from].size() - 1;//‰∏ÄÂÆöË¶ÅÂ∞èÂøÉÂèçÂêëËæπÁöÑcap‰∏∫0ÔºÅÔºÅÔºÅ G[to].push_back(e); } void bfs(int s) { memset(level, -1, sizeof(level));//ÊØèÊ¨°bfsÁöÑÊó∂ÂÄôÊûÑÂõæÈÉΩ‰∏çÂêåÔºåË¶Åmemset queue&lt;int&gt;que; level[s] = 0; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;level[e.to] &lt; 0) { level[e.to] = level[t] + 1; que.push(e.to); } } } } int dfs(int v, int t, int f) { if (v == t) return f; for (int &amp;i = iter[v]; i &lt; G[v].size(); i++) {//Âõ†‰∏∫ÊØèÊ¨°dfsÁöÑÊó∂ÂÄôÂ¶ÇÊûúÊâæÂà∞Ëß£Â∞±return‰∫ÜÔºåÊâÄ‰ª•ÊúâÂøÖË¶ÅËÆ∞ÂΩï‰∏äÊ¨°Ëøô‰∏™ÁÇπÊêúÂà∞Âì™‰∫Ü edge &amp;e = G[v][i]; if (e.cap&amp;&amp;level[e.to] &gt; level[v]) { int d = dfs(e.to, t, min(f, e.cap)); if (d) { e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } return 0; } int maxflow(int s, int t) { int flow = 0; for (;;) { bfs(s); if (level[t] &lt; 0)//ËØ¥ÊòéÊ≠§Êó∂Â∑≤Áªè‰∏çÂ≠òÂú®Ê≤°ÊúâÊêúËøáÁöÑË∑Ø‰∫Ü return flow; memset(iter, 0, sizeof(iter)); int f; while (f = dfs(s, t, 1 &lt;&lt; 30))//Ë¶ÅÊêúÂÆåÂΩìÊúüÁä∂ÂÜµ‰∏ãÁöÑÊâÄÊúâÂèØËÉΩ flow += f; } } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m ; for (i = 1; i &lt;= m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); addedge(a, b+150, 1); } for (i = 1; i &lt;= n; i++) { addedge(0, i, 1); addedge(i+150, 400, 1); } int ans = n - maxflow(0, 400); bool vis[500]; memset(vis, 0, sizeof(vis)); for (i = 1; i &lt;= n; i++) { if (!vis[i]) { cout &lt;&lt; i; int k = i; for (;;) { bool find = false; for (j = 0; j &lt; G[k].size(); j++) { if (G[k][j].cap == 0&amp;&amp;G[k][j].to&gt;150) { cout &lt;&lt; &quot; &quot; &lt;&lt; G[k][j].to-150; k = G[k][j].to - 150; vis[k] = true; find = true; break; } } if (!find)break; } cout &lt;&lt; endl; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúÄÂ∞èÁîüÊàêÊ†ë]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[KruskalÊúÄÈáçË¶ÅÁöÑËøòÊòØËÆ∞ÂæóÂπ∂Êü•ÈõÜË¶ÅÂàùÂßãÂåñÔºÅÔºÅ // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=1e6,M=1e6; int par[N]; struct edge{ int from,to,len; bool operator&lt;(const edge&amp;v)const{ return len&lt;v.len; } }G[M]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } bool unite(int x,int y) { x=find(x);y=find(y); if(x==y)return false; par[x]=y;return true; } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)par[i]=i; for(i=1;i&lt;=m;i++){ cin&gt;&gt;G[i].from&gt;&gt;G[i].to&gt;&gt;G[i].len; } sort(G+1,G+1+m); int cnt=0,ans=0; for(i=1;i&lt;=m;i++){ if(unite(G[i].from,G[i].to)) cnt++,ans+=G[i].len; if(cnt==n-1)break; } if(cnt&lt;n-1)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; return 0; } PrimÁÆóÊ≥ïË∑üDijkstraÂæàÂÉè Ôºå‰ΩÜÊòØË¶ÅÁâπÂà´Ê≥®ÊÑè‰∏§ÁÇπÔºö 1.ÊúÄÂ•Ω‰ΩøÁî®‰∏Ä‰∏™È¢ùÂ§ñÁöÑÊï∞ÁªÑÊù•‰øùËØÅÊØè‰∏™ÁÇπÂè™Ë¢´ËÆøÈóÆ‰∏ÄÊ¨°ÔºåÂê¶ÂàôÁöÑËØùÂ∫îËØ•‰øùËØÅÂú®35Ë°åÂ§Ñ‰ΩøÁî®e.dis&gt;=dis[e.num]ËÄå‰∏ç‰ªÖÊòØ&gt;ÔºåÂê¶Âàô‰ºöÈÄ†Êàê‰∏Ä‰∫õÁõ∏Á≠âÁöÑÈ¢ùÂ§ñÁõ∏Âä†„ÄÇ 2.40Ë°åÁöÑÂú∞ÊñπË¶ÅÊ≥®ÊÑè‰∏éDijkstraÁöÑÂå∫Âà´ÔºÅÔºÅ‰∏çÊòØÂä†ËÄåÊòØÁõ¥Êé•Êç¢ÔºÅÔºÅÔºÅ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); G[b].push_back(edge{a,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[1]=0; priority_queue&lt;d&gt;que;que.push(d{1,0}); int ans=0; while(!que.empty()){ d t=que.top();que.pop(); if(vis[t.num])continue;//Â¶ÇÊûú‰∏çÁî®È¢ùÂ§ñÊï∞ÁªÑËøôÈáåË¶ÅÊ≥®ÊÑè ans+=t.dis;vis[t.num]=true; for(i=0;i&lt;G[t.num].size();i++){ edge e=G[t.num][i]; if(dis[e.to]&gt;e.cost){ dis[e.to]=e.cost;//Ê≥®ÊÑèËøôÈáå‰∏éDijkstraÁöÑÂå∫Âà´ que.push(d{e.to,dis[e.to]}); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÊúÄÂ∞èÁîüÊàêÊ†ë</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
        <tag>ÊúÄÂ∞èÁîüÊàêÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâSPFA]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89spfa%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; bool inque[maxn]; int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; int dis[maxn]; for(i=1;i&lt;=n;i++)dis[i]=(1&lt;&lt;31)-1; dis[s]=0; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } queue&lt;int&gt;que;que.push(s);//inque[s]=true; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâDijkstra]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89dijkstra%2F</url>
    <content type="text"><![CDATA[Ëá™ÂÆö‰πâÁªìÊûÑ‰Ωì#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{//ËÆ∞ÂΩïÂêÑÁßçË¢´ÊùæÂºõÂêéÁöÑÁÇπ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[s]=0; priority_queue&lt;d&gt;que; que.push(d{s,0}); while(!que.empty()){ d e=que.top();que.pop(); if(e.dis&gt;dis[e.num])continue;//ËøôÈáå‰πüÂèØ‰ª•Âà©Áî®‰∏Ä‰∏™È¢ùÂ§ñÁöÑÊï∞ÁªÑÊù•‰øùËØÅÊØè‰∏™ÁÇπÂè™Ë¢´ËÆø //ÈóÆ‰∏ÄÊ¨°ÔºåÊàñËÄÖËØ¥ÊúÄÁü≠Ë∑ùÁ¶ªÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÁÇπ‰∏çÂÜçË¢´Êõ¥Êîπ for(int i=0;i&lt;G[e.num].size();i++){ edge eg=G[e.num][i]; if(dis[eg.to]&gt;dis[e.num]+eg.cost){ dis[eg.to]=dis[e.num]+eg.cost; que.push(d{eg.to,dis[eg.to]}); } } } return 0; } using pair#include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; using namespace std; const int maxn=1e5+5; typedef struct { int to, cost; }Edge; vector&lt;Edge&gt;edge[maxn]; typedef pair&lt;int, int&gt;P; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;q;//‰ªéÂ∞èÂà∞Â§ßÁöÑ‰ºòÂÖàÈòüÂàó int book[maxn], dis[maxn]; int main(void) { int n, m, s, i, j; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); fill(dis, dis + n+1, 2147483647); dis[s] = 0; for (i = 1; i &lt;= m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge temp; temp.to = b; temp.cost = c; edge[a].push_back(temp); } P p; p.first = 0; p.second = s; q.push(p); while (!q.empty()) { P p = q.top(); q.pop(); if (book[p.second] == 1) continue; book[p.second] = 1; for (i = 0; i &lt; edge[p.second].size(); i++) { Edge temp = edge[p.second][i]; if (dis[temp.to] &gt; dis[p.second] + temp.cost) { dis[temp.to] = dis[p.second] + temp.cost; P p1; p1.first = dis[temp.to]; p1.second = temp.to; q.push(p1); } } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâFloydÁÆóÊ≥ïÔºàÂ§öÊ∫êÊúÄÁü≠Ë∑ØÔºâ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89floyd-e7-ae-97-e6-b3-95-ef-bc-88-e5-a4-9a-e6-ba-90-e6-9c-80-e7-9f-ad-e8-b7-af-ef-bc-89%2F</url>
    <content type="text"><![CDATA[ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÂ∞±ÊòØÂõ†‰∏∫ÊØèÊ¨°ÊòØÊãø‰∏Ä‰∏™ÁÇπÂá∫Êù•ËÄÉËôëËÉΩÂê¶ÊääÂà´ÁöÑË∑ØÂèòÁü≠ÔºåÊâÄ‰ª•k‰∏ÄÂÆöÊòØÊúÄÂ§ñÂ±ÇÂæ™ÁéØ„ÄÇ‰ª•ÂèäË¶ÅËÆ∞ÂæóÂàùÂßãÂåñ‰∏∫Êó†Á©∑Â§ßÊàñÊó†Á©∑Â∞è„ÄÇ ÂèØ‰ª•ÈÄöËøáÊ£ÄÊü•ÊòØÂê¶Êúâdis[i][i]&lt;0Êù•Âà§ÂÆöÊòØÂê¶ÊúâË¥üÁéØÂ≠òÂú® int dis[105][105]; memset(dis,0x7f,sizeof(dis)); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;dis[i][j]; for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÂπ∂Êü•ÈõÜ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-b9-b6-e6-9f-a5-e9-9b-86%2F</url>
    <content type="text"><![CDATA[‰∏§‰ª∂‰∫ãÔºöËÆ∞ÂæóÂàùÂßãÂåñparÔºå‰ª•ÂèäÔºåË∑ØÂæÑÂéãÁº©Âà´ÂÜôÈîô‰∫Ü‚Ä¶ int par[1005];//ËÆ∞ÂæóÂàùÂßãÂåñÔºÅ int find(int x) { return par[x]==x?x:par[x]=find(par[x]);//ÂêéÈù¢Ëøô‰∏ÄÂùó‰∏çË¶ÅÊºè‰∫Üpar[x],Âê¶ÂàôÂ∞±ÊòØ‰∏çÂ∏¶Ë∑ØÂæÑÂéãÁº©! } bool unite(int x,int y) { x=find(x),y=find(y); if(x==y)return false; par[x]=y; return true; } ÊåâÁß©ÂêàÂπ∂Ôºö int find(int x) { if (x == par[x]) return x; else return par[x] = find(par[x]);//ÂêéÈù¢Ëøô‰∏ÄÂùó‰∏çË¶ÅÊºè‰∫Üpar[x]!!!Âê¶ÂàôÂ∞±ÊòØ‰∏çÂ∏¶Ë∑ØÂæÑÂéãÁº©(ÊúâÊó∂ÂÄôÊúâÁî®Ôºâ } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) { par[x] = y; } else { par[y] = x; if (rank[x] == rank[y]) rank[x]++; } } ‰∏ÄÂÆöË¶ÅÂä†‰∏äÔºö for(i=1;i&lt;=n;i++){ par[i]=i; }!!!!!!]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âπ∂Êü•ÈõÜ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âπ∂Êü•ÈõÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâSGÂáΩÊï∞Â∞èÁªì]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89sg-e5-87-bd-e6-95-b0-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[ËØ¥ÊòØÂ∞èÁªìÔºåÂÖ∂ÂÆûÊàëÂπ∂Ê≤°ÊúâÊÄé‰πàÂºÑÊáÇQAQÔºåÁÆÄÂçïÂÜôÂÜôÊ¶ÇÂøµË∑üÊùøÂ≠êÂêß‚Ä¶ Sprague-GrundyÂáΩÊï∞ÁªôÂÆö‰∏Ä‰∏™ÊúâÂêëÊó†ÁéØÂõæÂíå‰∏Ä‰∏™Ëµ∑ÂßãÈ°∂ÁÇπ‰∏äÁöÑ‰∏ÄÊûöÊ£ãÂ≠êÔºå‰∏§ÂêçÈÄâÊâã‰∫§ÊõøÁöÑÂ∞ÜËøôÊûöÊ£ãÂ≠êÊ≤øÊúâÂêëËæπËøõË°åÁßªÂä®ÔºåÊó†Ê≥ïÁßªÂä®ËÄÖÂà§Ë¥ü„ÄÇ‰∫ãÂÆû‰∏äÔºåËøô‰∏™Ê∏∏ÊàèÂèØ‰ª•ËÆ§‰∏∫ÊòØÊâÄÊúâImpartial Combinatorial GamesÁöÑÊäΩË±°Ê®°Âûã„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå‰ªª‰Ωï‰∏Ä‰∏™ICGÈÉΩÂèØ‰ª•ÈÄöËøáÊääÊØè‰∏™Â±ÄÈù¢ÁúãÊàê‰∏Ä‰∏™È°∂ÁÇπÔºåÂØπÊØè‰∏™Â±ÄÈù¢ÂíåÂÆÉÁöÑÂ≠êÂ±ÄÈù¢Ëøû‰∏ÄÊù°ÊúâÂêëËæπÊù•ÊäΩË±°ÊàêËøô‰∏™‚ÄúÊúâÂêëÂõæÊ∏∏Êàè‚Äù„ÄÇ Âü∫Êú¨Ê¶ÇÂøµ‰∏ãÈù¢Êàë‰ª¨Â∞±Âú®ÊúâÂêëÊó†ÁéØÂõæÁöÑÈ°∂ÁÇπ‰∏äÂÆö‰πâSprague-GarundyÂáΩÊï∞„ÄÇ È¶ñÂÖàÂÆö‰πâ$mex$(minimal excludant)ËøêÁÆóÔºåËøôÊòØÊñΩÂä†‰∫é‰∏Ä‰∏™ÈõÜÂêàÁöÑËøêÁÆóÔºåË°®Á§∫ÊúÄÂ∞èÁöÑ‰∏çÂ±û‰∫éËøô‰∏™ÈõÜÂêàÁöÑÈùûË¥üÊï¥Êï∞„ÄÇ‰æãÂ¶Ç$mex[0,1,2,4]=3,mex[2,3,5]=0,mex[]=0$„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁªôÂÆöÁöÑÊúâÂêëÊó†ÁéØÂõæÔºåÂÆö‰πâÂÖ≥‰∫éÂõæÁöÑÊØè‰∏™È°∂ÁÇπÁöÑSprague-GarundyÂáΩÊï∞$g$Â¶Ç‰∏ãÔºö$g(x)=mex[ g(y) | yÊòØxÁöÑÂêéÁªß ]$„ÄÇ SGÂáΩÊï∞ÁöÑÊÄßË¥®È¶ñÂÖàÔºåÊâÄÊúâÁöÑterminal positionÊâÄÂØπÂ∫îÁöÑÈ°∂ÁÇπÔºå‰πüÂ∞±ÊòØÊ≤°ÊúâÂá∫ËæπÁöÑÈ°∂ÁÇπÔºåÂÖ∂SGÂÄº‰∏∫0ÔºåÂõ†‰∏∫ÂÆÉÁöÑÂêéÁªßÈõÜÂêàÊòØÁ©∫ÈõÜ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™g(x)=0ÁöÑÈ°∂ÁÇπxÔºåÂÆÉÁöÑÊâÄÊúâÂêéÁªßyÈÉΩÊª°Ë∂≥g(y)!=0„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™g(x)!=0ÁöÑÈ°∂ÁÇπÔºåÂøÖÂÆöÂ≠òÂú®‰∏Ä‰∏™ÂêéÁªßyÊª°Ë∂≥g(y)=0„ÄÇ P ‰ª•‰∏äËøô‰∏âÂè•ËØùË°®ÊòéÔºåÈ°∂ÁÇπxÊâÄ‰ª£Ë°®ÁöÑpostionÊòØP-positionÂΩì‰∏î‰ªÖÂΩìg(x)=0ÔºàË∑üP-positioin/N-positionÁöÑÂÆö‰πâÁöÑÈÇ£‰∏âÂè•ËØùÊòØÂÆåÂÖ®ÂØπÂ∫îÁöÑÔºâ„ÄÇÊàë‰ª¨ÈÄöËøáËÆ°ÁÆóÊúâÂêëÊó†ÁéØÂõæÁöÑÊØè‰∏™È°∂ÁÇπÁöÑSGÂÄºÔºåÂ∞±ÂèØ‰ª•ÂØπÊØèÁßçÂ±ÄÈù¢ÊâæÂà∞ÂøÖËÉúÁ≠ñÁï•‰∫Ü„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÂÆö‰πâÊúâÂêëÂõæÊ∏∏ÊàèÁöÑÂíå(Sum of Graph Games)ÔºöËÆæG1„ÄÅG2„ÄÅ‚Ä¶‚Ä¶„ÄÅGnÊòØn‰∏™ÊúâÂêëÂõæÊ∏∏ÊàèÔºåÂÆö‰πâÊ∏∏ÊàèGÊòØG1„ÄÅG2„ÄÅ‚Ä¶‚Ä¶„ÄÅGnÁöÑÂíå(Sum)ÔºåÊ∏∏ÊàèGÁöÑÁßªÂä®ËßÑÂàôÊòØÔºö‰ªªÈÄâ‰∏Ä‰∏™Â≠êÊ∏∏ÊàèGiÂπ∂ÁßªÂä®‰∏äÈù¢ÁöÑÊ£ãÂ≠ê„ÄÇSprague-Grundy TheoremÂ∞±ÊòØÔºög(G)=g(G1)^g(G2)^‚Ä¶^g(Gn)„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÊ∏∏ÊàèÁöÑÂíåÁöÑSGÂáΩÊï∞ÂÄºÊòØÂÆÉÁöÑÊâÄÊúâÂ≠êÊ∏∏ÊàèÁöÑSGÂáΩÊï∞ÂÄºÁöÑÂºÇÊàñ„ÄÇ ÂÜçËÄÉËôë‰∏Ä‰∏™ÊÄßË¥®Ôºö‰ªª‰Ωï‰∏Ä‰∏™ICGÈÉΩÂèØ‰ª•ÊäΩË±°Êàê‰∏Ä‰∏™ÊúâÂêëÂõæÊ∏∏Êàè„ÄÇÊâÄ‰ª•‚ÄúSGÂáΩÊï∞‚ÄùÂíå‚ÄúÊ∏∏ÊàèÁöÑÂíå‚ÄùÁöÑÊ¶ÇÂøµÂ∞±‰∏çÊòØÂ±ÄÈôê‰∫éÊúâÂêëÂõæÊ∏∏Êàè„ÄÇÊàë‰ª¨ÁªôÊØè‰∏™ICGÁöÑÊØè‰∏™positionÂÆö‰πâSGÂÄºÔºå‰πüÂèØ‰ª•ÂÆö‰πân‰∏™ICGÁöÑÂíå„ÄÇÊâÄ‰ª•ËØ¥ÂΩìÊàë‰ª¨Èù¢ÂØπÁî±n‰∏™Ê∏∏ÊàèÁªÑÂêàÊàêÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÊó∂ÔºåÂè™ÈúÄÂØπ‰∫éÊØè‰∏™Ê∏∏ÊàèÊâæÂá∫Ê±ÇÂÆÉÁöÑÊØè‰∏™Â±ÄÈù¢ÁöÑSGÂÄºÁöÑÊñπÊ≥ïÔºåÂ∞±ÂèØ‰ª•ÊääËøô‰∫õSGÂÄºÂÖ®ÈÉ®ÁúãÊàêNimÁöÑÁü≥Â≠êÂ†ÜÔºåÁÑ∂Âêé‰æùÁÖßÊâæNimÁöÑÂøÖËÉúÁ≠ñÁï•ÁöÑÊñπÊ≥ïÊù•ÊâæËøô‰∏™Ê∏∏ÊàèÁöÑÂøÖËÉúÁ≠ñÁï•‰∫ÜÔºÅÔºàNimÂÖ∂ÂÆûÂ∞±ÊòØn‰∏™‰ªé‰∏ÄÂ†Ü‰∏≠ÊãøÁü≥Â≠êÁöÑÊ∏∏ÊàèÊ±ÇSGÁöÑÂèòÂûãÔºåÊÄªSG=n‰∏™sgÁöÑÂºÇÊàñÔºâ„ÄÇ Ê®°Êùø1.ÊääÂéüÊ∏∏ÊàèÂàÜËß£ÊàêÂ§ö‰∏™Áã¨Á´ãÁöÑÂ≠êÊ∏∏ÊàèÔºåÂàôÂéüÊ∏∏ÊàèÁöÑSGÂáΩÊï∞ÂÄºÊòØÂÆÉÁöÑÊâÄÊúâÂ≠êÊ∏∏ÊàèÁöÑSGÂáΩÊï∞ÂÄºÁöÑÂºÇÊàñ„ÄÇÂç≥$sg(G)=sg(G1)\oplus sg(G2)\oplus ‚Ä¶\oplus sg(Gn)$„ÄÇ 2.ÂàÜÂà´ËÄÉËôëÊ≤°‰∏Ä‰∏™Â≠êÊ∏∏ÊàèÔºåËÆ°ÁÆóÂÖ∂SGÂÄº„ÄÇ1.ÂèØÈÄâÊ≠•Êï∞‰∏∫1~mÁöÑËøûÁª≠Êï¥Êï∞ÔºåÁõ¥Êé•ÂèñÊ®°Âç≥ÂèØÔºå$SG(x) = x \ mod\ (m+1)$; 2.ÂèØÈÄâÊ≠•Êï∞‰∏∫‰ªªÊÑèÊ≠•Ôºå$SG(x) = x$; 3.ÂèØÈÄâÊ≠•Êï∞‰∏∫‰∏ÄÁ≥ªÂàó‰∏çËøûÁª≠ÁöÑÊï∞ÔºåÁî®Ê®°ÊùøËÆ°ÁÆó„ÄÇ Ê®°Êùø1ÔºöÊâìË°® #include&lt;bits/stdc++.h&gt; using namespace std; //f[]ÔºöÂèØ‰ª•ÂèñËµ∞ÁöÑÁü≥Â≠ê‰∏™Êï∞ //sg[]:0~nÁöÑSGÂáΩÊï∞ÂÄº //Mex[]:mex{} int f[N],sg[N],Mex[N]; void getSG(int n) { int i, j; memset(sg, 0, sizeof(sg)); for (i = 1; i &lt;= n; i++) { memset(Mex, 0, sizeof(Mex)); for (j = 1; f[j] &lt;= i; j++) Mex[sg[i - f[j]]] = 1; for (j = 0; j &lt;= n; j++) //Ê±Çmes{}‰∏≠Êú™Âá∫Áé∞ÁöÑÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞ { if (Mex[j] == 0) { sg[i] = j; break; } } } } Ê®°Êùø2Ôºödfs //Ê≥®ÊÑè SÊï∞ÁªÑË¶ÅÊåâ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫è SGÂáΩÊï∞Ë¶ÅÂàùÂßãÂåñ‰∏∫-1 ÂØπ‰∫éÊØè‰∏™ÈõÜÂêàÂè™ÈúÄÂàùÂßãÂåñ1ÈÅç //nÊòØÈõÜÂêàsÁöÑÂ§ßÂ∞è S[i]ÊòØÂÆö‰πâÁöÑÁâπÊÆäÂèñÊ≥ïËßÑÂàôÁöÑÊï∞ÁªÑ int s[110],sg[10010],n; int SG_dfs(int x) { int i; if(sg[x]!=-1) return sg[x]; bool vis[110];//boolÊï∞ÁªÑ‰∏ÄÂÆöË¶ÅÊîæÂú®ÈáåÈù¢ memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) { if(x&gt;=s[i]) { SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; } } int e; for(i=0;;i++) if(!vis[i]) { e=i; break; } return sg[x]=e; } ‰∏ÄËà¨DFSÂè™Âú®ÊâìË°®Ëß£ÂÜ≥‰∏ç‰∫ÜÁöÑÊÉÖÂÜµ‰∏ãÁî®ÔºåÈ¶ñÈÄâÊâìË°®È¢ÑÂ§ÑÁêÜ„ÄÇ ËøòÊúâ‰∏ÄÁßçdfsÔºåÈ¢òÁõÆÁªôÂá∫ÁöÑ‰∏çÊòØÁßªÂä®Ê¨°Êï∞ÔºåËÄåÊòØÂèØ‰ª•ÁßªÂä®ÁöÑÊìç‰ΩúÔºåÁ±ª‰ºº‰∫éÁªôÂÆö‰∏ÄÂπÖÊúâÂêëÂõæÔºåÁü•ÈÅì‰∏ã‰∏ÄÊ≠•ÊúâÂì™‰∫õÊìç‰ΩúÊòØÂèØÈÄâÁöÑÔºàÂèÇËßÅHDU1524Ôºâ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[1005]; int sg[1005]; int dfs(int x) { if(sg[x]!=-1) return sg[x]; bool vis[1005]={false}; for(int i=0;i&lt;G[x].size();i++){ vis[dfs(G[x][i])]=true; } for(int i=0;;i++) if(!vis[i]) return sg[x]=i; } int main() { int n,i,j,k,x,m; while(cin&gt;&gt;n){ for(i=0;i&lt;=1000;i++)G[i].clear(); memset(sg,-1,sizeof(sg)); for(i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;x); while(x--){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);//Âä†Ëæπ,‰∏ã‰∏ÄÊ≠•ÂèØ‰ª•ÂÅöÁöÑÊìç‰Ωú } } while(scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m){ int ans=0; for(i=0;i&lt;m;i++){ scanf(&quot;%d&quot;,&amp;j); if(sg[j]!=-1) ans^=sg[j]; else ans^=dfs(j); } if(ans)puts(&quot;WIN&quot;); else puts(&quot;LOSE&quot;); } } return 0; } 3.ËÆ°ÁÆó$sg(G)=sg(G1)\oplus sg(G2)\oplus ‚Ä¶\oplus sg(Gn)$ÔºåËã•$sg(G)=0$,Âç≥P-Position,Âç≥ÂÖàÊâãÊØîË¥•„ÄÇ]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂçöÂºàËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>ÂçöÂºàËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #450 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-450-div-2%2F</url>
    <content type="text"><![CDATA[A.Âº±Êô∫È¢ò #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x,y,cnt[2]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&lt;0)cnt[0]++; else cnt[1]++; } if(cnt[0]&lt;=1||cnt[1]&lt;=1){ puts(&quot;Yes&quot;); } else puts(&quot;No&quot;); return 0; } B.È¶ñÂÖàË¶ÅÁü•ÈÅì‰∏Ä‰∏™ÁªìËÆ∫ÔºöÂØπ‰∫é$a/b$,‰ªñÁöÑÂ∞èÊï∞ÈÉ®ÂàÜÁöÑÂæ™ÁéØËäÇÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá$b$ÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊ£ÄÊü•Â∞èÊï∞ÁÇπÂêéÁöÑÊúÄÂ§ö$b$‰ΩçÂ∞±ÂèØ‰ª•Áü•ÈÅì$c$ÊòØÂê¶ÊúâÂá∫Áé∞Ëøá‰∫Ü„ÄÇÁÑ∂ÂêéÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂ∞èÊï∞ÁÇπÂêéÁöÑ‰ΩçÊï∞‰∫Ü„ÄÇËøô‰∏™ÂèØ‰ª•Áî®ÈïøÈô§Ê≥ïÊù•ÂÅöÔºåÂÖ∑‰ΩìÊÄùÊÉ≥ÂÖ∂ÂÆûÂ∞±ÊòØ‰∏çÊñ≠ÊääË¢´Èô§Êï∞‰πò10ÁÑ∂ÂêéÈô§‰ª•Èô§Êï∞Ëé∑Âæó‰∏ã‰∏Ä‰ΩçÂ∞èÊï∞‰ΩçÔºàÁõ∏ÂΩì‰∫é‰∏çÊñ≠Âú∞Â∞ÜÂ∞èÊï∞ÁÇπÂè≥Áßª‰∏Ä‰ΩçÔºâÔºåÂÜôÂÜôÂ∞±ÊòéÁôΩ‰∫Ü„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c,i,j,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=1;i&lt;=b;i++){ if(a*10/b==c){ cout&lt;&lt;i&lt;&lt;endl;return 0; } a=a*10%b; } cout&lt;&lt;-1&lt;&lt;endl; return 0; } C.ÂÖ∂ÂÆûÂæàÂÆπÊòìÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÁöÑÊÉ≥Ê≥ïÔºåÂ∞±ÊòØ‰ªéÂâçÂæÄÂêéÊâ´‰∏ÄÈÅçÔºåÂØπ‰∫éÊØè‰∏™Êï∞ÔºåÂ¶ÇÊûúÂâçÈù¢ÊÅ∞Â•ΩÊúâ‰∏Ä‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫éÂΩìÂâçÊï∞ÔºåÈÇ£‰πàÈÇ£‰∏™Êï∞ÁöÑ‚ÄúÂà†Èô§ÂÄº‚ÄùÂ∞±Â∫îËØ•+1ÔºåÁÑ∂ÂêéÊâæÂá∫‚ÄùÂà†Èô§ÂÄº‚ÄúÊúÄÂ§ßÁöÑÊï∞Âç≥ÂèØ„ÄÇ‰ΩÜÊòØËøòÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÂ∞±ÊòØÊØè‰∏™Êï∞ÂêåÊó∂ÂèØËÉΩÊú¨Ë∫´‰πüÊòØ‰∏Ä‰∏™‚Äùrecord‚ÄùÔºåÊâÄ‰ª•ÂØπ‰∫éÊØè‰∏™Êï∞ÔºåÂ¶ÇÊûú‰ªñÊòØ‚Äùrecord‚ÄùÔºåÈÇ£‰πà‰ªñÁöÑÂà†Èô§ÂÄºÂ∞±ÊòØ1ÔºåÁÑ∂ÂêéÊØèÊ¨°ÊâæÂà∞‰∏Ä‰∏™ÂêéÈù¢ÁöÑÊï∞Ë¶ÅÂà†Èô§Ëøô‰∏™Êï∞ÔºåÈÇ£‰πà‰ªñÁöÑÂà†Èô§ÂÄºÂ∞±-1ÔºåÊúÄÂêéÊâæÂá∫Âà†Èô§ÂÄºÊúÄÂ∞èÁöÑÊï∞Âç≥ÂèØÔºàÂàùÂßãÂà†Èô§ÂÄºÈÉΩ‰∏∫0Ôºâ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k,maxn=0,ans=0,premaxn=0; cin&gt;&gt;n; int num[100005],pos[100005]={0}; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]&gt;maxn){ pos[i]=1; premaxn=maxn;maxn=num[i];k=i; } else if(num[i]&gt;premaxn){ pos[k]--;premaxn=num[i]; } } int minn=2; for(i=1;i&lt;=n;i++){ if(pos[i]&lt;minn){ ans=num[i];minn=pos[i]; } else if(pos[i]==minn){ ans=min(ans,num[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.È¶ñÂÖàÔºåÂ¶ÇÊûúx‰∏çËÉΩÊï¥Èô§yÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•Áõ¥Êé•ÊªöËõã‰∫Ü„ÄÇ ‰ª§$f(t)$Ë°®Á§∫Ëã•Âπ≤‰∏™Êï∞Âíå‰∏∫$t$Ôºå$gcd$‰∏∫1„ÄÇÈÇ£‰πàÁ≠îÊ°àÂ∞±ÊòØ$f(\frac{y}{x})$. ‰ª§$g(t)$Ë°®Á§∫Ëã•Âπ≤‰∏™Êï∞Âíå‰∏∫$t$,ÈÇ£‰πàÊòæÁÑ∂Êúâ$g(t)=2^{t-1}$:ÊÉ≥Ë±°‰∏Ä‰∏ãÔºåÊäätÂàÜÊàêt‰∏™1ÔºåÈÇ£‰πàÁõ∏ÈÇªÁöÑ1‰πãÈó¥ÂàÜÂºÄ‰∏éÂê¶ÈÉΩÊòØ‰∏çÂêåÁöÑÔºàÊú¨È¢òÁöÑÂ∫èÂàóÊòØÊúâÂ∫èÁöÑÔºâ„ÄÇ Ê≥®ÊÑèÂà∞Êúâ$g(t)=\sum_{i=1}^{t_i}f(\frac{t}{t_i})$($t_i$ÊòØ$t$ÁöÑÁ∫¶Êï∞)Ôºå ÊâÄ‰ª•Êúâ$f(t)=g(t)-\sum_{i=2}^{sz}f(\frac{t}{t_i})$. ‰∫éÊòØÂÖàÊääyÈô§‰ª•xÔºåÁÑ∂ÂêéÊ±ÇÂá∫yÁöÑÊâÄÊúâÁ∫¶Êï∞Ôºå‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÂêéÔºå‰ªéÂ§ßÂà∞Â∞èÊûö‰∏æÊØè‰∏™Á∫¶Êï∞ÔºåÂØπ‰∫éÊØè‰∏™Á∫¶Êï∞ÔºåÊàë‰ª¨ÂèØ‰ª•ÂÖàÁÆóÂá∫‰ªñÁöÑ$g(i)$,ÁÑ∂ÂêéÊûö‰∏æÊâÄÊúâÊØî‰ªñÂ§ßÁöÑÁ∫¶Êï∞ÔºåÂ¶ÇÊûúÊüê‰∏™Á∫¶Êï∞ËÉΩÊï¥Èô§‰ªñÔºåÈÇ£‰πàÈÇ£‰∏™Á∫¶Êï∞ÂØπÂ∫îÁöÑ$f(i)$Â∞±Â∫îËØ•Ë¢´ÂáèÂéª„ÄÇÊúÄÂêéËæìÂá∫$f(1)$Âç≥ÂèØ„ÄÇ‰ª•ÂèäÔºåÊ≥®ÊÑèÂèñÊ®°ÁöÑÈóÆÈ¢òÔºåË¶ÅÁî®Âø´ÈÄüÂπÇ&amp;Â∞èÂøÉË¥üÊï∞„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; typedef long long ll; ll mod_pow(ll x,ll y) { ll res=1; while(y){ if(y&amp;1){ res=res*x%mod; } y&gt;&gt;=1;x=x*x%mod; } return res; } ll f[100000]; int main() { int x,y,i,j,k; cin&gt;&gt;x&gt;&gt;y; if(y%x){ puts(&quot;0&quot;);return 0; } y/=x;vector&lt;int&gt;ys; for(i=1;i*i&lt;=y;i++){ if(y%i==0){ ys.push_back(i); if(i*i!=y) ys.push_back(y/i); } } sort(ys.begin(),ys.end()); for(i=ys.size()-1;~i;i--){ f[i]=mod_pow(2,y/ys[i]-1); for(j=ys.size()-1;j&gt;i;j--) if(ys[j]%ys[i]==0) f[i]=(f[i]-f[j]+mod)%mod; } cout&lt;&lt;(f[0]+mod)%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #502ÔºàDiv. 1 + Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-502-ef-bc-88div-1-div-2%2F</url>
    <content type="text"><![CDATA[A.Á≠æÂà∞ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct mark{ int id,sum; bool operator&lt;(const mark&amp;v)const{ if(sum==v.sum) return id&lt;v.id; return sum&gt;v.sum; } }G[1005]; int main() { int n,i,j,k,a,b,c,d; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;G[i].sum+=a+b+c+d;G[i].id=i; } sort(G+1,G+1+n); for(i=1;i&lt;=n;i++){ if(G[i].id==1){ cout&lt;&lt;i&lt;&lt;endl;return 0; } } } B.È¶ñÂÖàÔºåÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™‰∫ãÂÆûÔºöÁ¨¨‰∫å‰∏™‰∏≤ÁöÑÊüê‰∏™‰ΩçÁΩÆÂ¶ÇÊûúÊòØ1ÔºåÈÇ£‰πàÁ¨¨‰∏Ä‰∏™‰∏≤ÊòØ‰ªÄ‰πàÊòØ‰∏çÈáçË¶ÅÁöÑÔºåÂõ†‰∏∫Êç¢ÂÆåËøòÊòØ1.Âê¶ÂàôÔºåÁ¨¨‰∏Ä‰∏™‰∏≤Â¶ÇÊûúÊòØ0ÔºåÊàë‰ª¨Â∞±Á†îÁ©∂ÊúâÂ§öÂ∞ë‰∏™1ÂèØ‰ª•Êç¢„ÄÇ‰ΩÜÊòØËøôÊ†∑Â∞±‰ºöÂ∏¶Êù•‰∏Ä‰∏™ÈáçÂ§çÁöÑÈóÆÈ¢òÔºåÂØπÊ≠§ÔºåÊàë‰ª¨ÂèØ‰ª•ÂÅö‰∏Ä‰∏™È¢ÑÂ§ÑÁêÜÔºåÂØπ‰∫éÊØè‰∏™1ÔºåÁõ∏ÂΩì‰∫éË¶ÅÊç¢0ÔºåËÄåÁõ∏Â∫îÂâçÈù¢ÁöÑ0ÁöÑ‰ΩçÁΩÆÂøÖÁÑ∂Ë¶ÅÊç¢1ÔºåÈÇ£‰πàÊàë‰ª¨Â∞±ÂèØ‰ª•ÁªüËÆ°‰∏Ä‰∏ãËøô‰∏™ÈáçÂ§çÁöÑÈóÆÈ¢ò„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string str1,str2;int n,i,j,k,cnt[2]={0},cnt1[2]={0}; cin&gt;&gt;n&gt;&gt;str1&gt;&gt;str2; for(auto a:str1)cnt[a-&apos;0&apos;]++; long long ans=0; for(i=0;i&lt;n;i++){ if(str2[i]==&apos;0&apos;){ if(str1[i]==&apos;1&apos;){ ans+=cnt[0];ans-=cnt1[1];cnt1[0]++; } else{ ans+=cnt[1];ans-=cnt1[0];cnt1[1]++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C.‰∏çÂ§™‰ºöËØÅÊòé‚Ä¶Âà©Áî®‰∫Ü‰∏ÄÁÇπÁ±ª‰ººÂàÜÂùóÁöÑÊÄùÊÉ≥ÔºåÂèçÊ≠£Âπ≥ÊñπÂàÜÂâ≤ËÇØÂÆöÊòØÂØπÁöÑ‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,pos; cin&gt;&gt;n;pos=n; int len=sqrt(n); while(pos&gt;=len){ for(i=pos-len+1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; pos-=len; } for(i=1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; } D.ÊØîËµõÁöÑÊó∂ÂÄôÊÄªËßâÂæóÊòØÂª∫Ê†ëÔºåÁÑ∂ÂêéÂ∞±tÂæóÊÄÄÁñë‰∫∫Áîü‰∫Ü‚Ä¶ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; struct node{ int son[2]; int cnt=0; bool tag; }ch[1&lt;&lt;14];//Êï∞ÁªÑÂ§ßÂ∞èÁî±ÊâÄË¶ÅÊèíÂÖ•Â≠óÁ¨¶ÁöÑÊÄªÈïøÂ∫¶ÂÜ≥ÂÆö void insert(char*str,int n) { int now=0; ch[now].tag=true; for(int i=0;i&lt;n;i++){ int c=str[i]-&apos;0&apos;; now=ch[now].son[c]; ch[now].tag=true; } ch[now].cnt++; ch[now].tag=true; } int w[15],k;int cnt,n; void query(string str,int id,int quan,int ceng) { if(!ch[id].tag)return; if(ceng) { if ((id &amp; 1) != str[ceng - 1] - &apos;0&apos;) quan += w[ceng]; if (quan &gt; k)return; if (ceng == n) { cnt += ch[id].cnt; return; } } query(str,id&lt;&lt;1|1,quan,ceng+1); query(str,(id&lt;&lt;1)+2,quan,ceng+1); } int main() { int i,j; for(i=0;i&lt;(1&lt;&lt;12);i++){ //ch[i].cnt++; ch[i].son[0]=i&lt;&lt;1|1;ch[i].son[1]=(i&lt;&lt;1)+2; } int m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;=m;i++){ char str[15];scanf(&quot;%s&quot;,str); insert(str,n); } while(q--){ string str;cin&gt;&gt;str&gt;&gt;k; cnt=0; query(str,0,0,0); printf(&quot;%d\n&quot;,cnt); } return 0; } Ê≠£Ëß£ÊòØÂà©Áî®Á±ª‰ººbitsetÁöÑÊÄùÊÉ≥ÔºåÂõ†‰∏∫‰∏§‰∏≤Áõ∏‰∏éÂè™ÂèØËÉΩÊòØ0~2^12ÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•È¢ÑÂ§ÑÁêÜÊâÄÊúâÁöÑÊÉÖÂÜµÔºåÊää‰ªñ‰ª¨ËΩ¨10ËøõÂà∂Ë°®Á§∫ÔºåÁÑ∂ÂêéÊü•ËØ¢ÁöÑÊó∂ÂÄôÂ∞±ÊòØ$O(1)$ÁöÑ‰∫Ü. Êúâ‰∏ÄÁÇπË¶ÅÊ≥®ÊÑèÁöÑÂ∞±ÊòØÂõ†‰∏∫‰∏§‰∏™‰∏≤ÈÉΩÊòØ0ÊàñËÄÖÈÉΩÊòØ1 ÁöÑÊó∂ÂÄôÊùÉÂÄºÈÉΩÊòØÊúâÊïàÁöÑÔºå‰∏∫‰∫ÜÊñπ‰æøÁªüËÆ°ÔºåÊàë‰ª¨ÂèØ‰ª•ÊääsetÈáåÈù¢ÁöÑ‰∏≤ÂÖ®ÈÉ®ÂèñÂèçÔºåÁÑ∂ÂêéÊü•ËØ¢ÁöÑÊó∂ÂÄô‰∏§‰∏™‰∏≤ÂºÇÊàñ‰∏Ä‰∏ãÔºåÊòØ1ÁöÑ‰ΩçÁΩÆÂ∞±ÊòØÊùÉÂÄºÊúâÊïàÁöÑ‰ΩçÁΩÆ‰∫Ü„ÄÇans[i][j]‰ª£Ë°®Ê®°Âºè‰∏≤‰∏∫iÁöÑÊó∂ÂÄô‰∏§‰∏≤Áõ∏‰∏é‰∏∫jÁöÑÊÉÖÂÜµÊï∞„ÄÇ ‰ª•ÂèäÔºåstring‰ºötle #include&lt;bits/stdc++.h&gt; using namespace std; int w[5000],s[5000],ans[5000][105],f[5000];//sÊòØÂ∞ÜÂ≠óÁ¨¶‰∏≤ËΩ¨Âåñ‰∏∫Êï∞Â≠ó‰∏≤,ansÂ≠òÁ≠îÊ°à,fÈ¢ÑÂ§ÑÁêÜ int main() { int n,m,q; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;w[n - i]);//Ê≥®ÊÑèËøôÈáåÂ±ÇÁ∫ßË¶ÅÂÄíÁùÄÊù•,‰∏çÁÑ∂Ê≤°Ê≥ï‰ªéÂâçÂæÄÂêéÂåπÈÖç for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j))//f[i]‰ª£Ë°®‰∏§‰∏™Êï∞Áõ∏‰∏éÁ≠â‰∫éiÊó∂ÁöÑÊùÉÂÄº f[i] += w[j]; for (int i = 1; i &lt;= m; i++) { char ss[15];scanf(&quot;%s&quot;,ss); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + 1 - (ss[j] - &apos;0&apos;);//Ê≥®ÊÑèËøôÈáåÊòØ‰∏éÂéüÊï∞ÂèñÂèçÁöÑ!!! //a=a*2+(ss[j]-&apos;0&apos;); s[a]++;//ÁªüËÆ°‰∏≤‰∏™Êï∞ } for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; (1 &lt;&lt; n); j++) if (f[i ^ j] &lt;= 100)//È¢òÊÑè:k&lt;=100ÊâçÊúâÊïà ans[i][f[i ^ j]] += s[j];//ans[i][j]ÁªüËÆ°Ê®°Âºè‰∏≤‰∏∫iÊó∂Áõ∏‰∏éÁ≠îÊ°à‰∏∫jÁöÑ‰∏™Êï∞ //ans[i][f[i&amp;j]]+=s[j]; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 1; j &lt;= 100; j++) ans[i][j] += ans[i][j - 1];//Âõ†‰∏∫&lt;=jÈÉΩÂèØ‰ª•,ÊâÄ‰ª•,Ë¶ÅÂä†ÊàêÂâçÁºÄÂíå for (int i = 1; i &lt;= q; i++) { char ss[15];scanf(&quot;%s&quot;,ss);int k;scanf(&quot;%d&quot;,&amp;k); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + (ss[j] - &apos;0&apos;); printf(&quot;%d\n&quot;, ans[a][k]); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training ÁΩëÁªúÊµÅ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F%E5%9B%BE%E8%AE%BA%2F2018-bupt-summer-training-e7-bd-91-e7-bb-9c-e6-b5-81%2F</url>
    <content type="text"><![CDATA[A - Drainage Ditches POJ - 1273ÊùøÂ≠êÈ¢òÔºåÊ≤°‰ªÄ‰πàÂ•ΩËØ¥ÁöÑ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[210]; int level[205],iter[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ for(i=1;i&lt;=200;i++)G[i].clear(); for(i=1;i&lt;=n;i++){ int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);addedge(a,b,c); } cout&lt;&lt;maxflow(1,m)&lt;&lt;endl; } return 0; } C - Reactor Cooling ZOJ - 2314Êó†Ê∫êÊ±áÂèØË°åÊµÅÊ®°ÊùøÈ¢ò #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//ËÆ∞ÂΩïËæπÁöÑid } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//Â≠òÁ≠îÊ°à for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//ÂèçÂêëËæπÊàñËÄÖËøûÂêëÈôÑÂä†Ê±áÁÇπÁöÑËæπÊó†ËßÜ as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//ËøôÊù°ËæπÁöÑÂèçÂêëËæπÁöÑÂÆπÈáè+ËøôÊù°ËæπÁöÑ‰∏ãÁïå } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } D - Number HYSBZ - 3275Ê≥®ÊÑèÈ¢òÁõÆÊù°‰ª∂ÊòØÂêåÊó∂Êª°Ë∂≥‰∏§‰∏™Êù°‰ª∂ÁöÑÊï∞Êâç‰∏çËÉΩ‰∏ÄËµ∑ÈÄâ„ÄÇÂØπ‰∫éÊØè‰∏™ÁÇπaÔºåÊàë‰ª¨ÊãÜÊàê$a_x$Âíå$a_y$,Ê∫êÁÇπËøûÊé•$a_x$,ÂÆπÈáè‰∏∫Êï∞ÂÄºÔºå$a_y$ËøûÊé•Ê±áÁÇπÔºåÂÆπÈáè‰∏∫Êï∞ÂÄº„ÄÇÂ¶ÇÊûú‰∏§‰∏™Êï∞aÔºåb‰∏çËÉΩÂêåÊó∂ÈÄâÔºåÈÇ£‰πàÊàë‰ª¨Â∞±Â∞Ü$a_x$ËøûÊé•$b_y$,$b_x$ ËøûÊé•$a_y$,ÂÆπÈáè‰∏∫INF„ÄÇÈÇ£‰πàÁ≠îÊ°àÂ∞±ÊòØÊâÄÊúâÊï∞ÁöÑÂíå-maxflow/2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//ËÆ∞ÂΩïËæπÁöÑid } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//Â≠òÁ≠îÊ°à for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//ÂèçÂêëËæπÊàñËÄÖËøûÂêëÈôÑÂä†Ê±áÁÇπÁöÑËæπÊó†ËßÜ as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//ËøôÊù°ËæπÁöÑÂèçÂêëËæπÁöÑÂÆπÈáè+ËøôÊù°ËæπÁöÑ‰∏ãÁïå } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } E - ËΩØ‰ª∂ÂºÄÂèë HYSBZ - 1221ÈùûÂ∏∏Á±ª‰ººÈ§êÂ∑æËÆ°ÂàíÈóÆÈ¢ò„ÄÇÂîØ‰∏ÄÁöÑ‰∏çÂêåÂ∞±ÊòØÊ¥óÁöÑÊó∂Èó¥ÔºåÁ¨¨iÂ§©ÁöÑÊØõÂ∑æÂú®i+1Â§©ÊâçÂºÄÂßãÊ¥óÔºåÊâÄ‰ª•Âú®Á¨¨i+k+1Â§©ÊâçÊ¥óÂ•ΩÔºåÂÖ∂‰ªñÂ∞±Ê≤°‰ªÄ‰πàÂå∫Âà´‰∫Ü„ÄÇ ÂÖ≥‰∫éÊûÑÂõæÔºö ËøôÊòØ‰∏ÄÈÅìÊúÄÂ∞èË¥πÁî®ÔºàË¥πÁî®ÊåáÂçï‰ª∑ÔºâÊúÄÂ§ßÊµÅÁöÑÈ¢òÁõÆ„ÄÇ È¶ñÂÖàÔºåÊàë‰ª¨ÊãÜÁÇπÔºåÂ∞Ü‰∏ÄÂ§©ÊãÜÊàêÊôö‰∏äÂíåÊó©‰∏äÔºåÊØèÂ§©Êôö‰∏ä‰ºöÂèóÂà∞ËÑèÈ§êÂ∑æÔºàÊù•Ê∫êÔºöÂΩìÂ§©Êó©‰∏äÁî®ÂÆåÁöÑÈ§êÂ∑æÔºåÂú®ËøôÈÅìÈ¢ò‰∏≠ÂèØÁêÜËß£‰∏∫‰ªéÂéüÁÇπËé∑ÂæóÔºâÔºåÊØèÂ§©Êó©‰∏äÂèàÊúâÂπ≤ÂáÄÁöÑÈ§êÂ∑æÔºàÊù•Ê∫êÔºöË¥≠‰π∞„ÄÅÂø´Ê¥óÂ∫ó„ÄÅÊÖ¢Ê¥óÂ∫óÔºâ„ÄÇÔºàÊú¨È¢ò‰∏≠ÂØπÂ∫î‰∏§ÁßçÊ∏ÖÊ¥óÊñπÂºèÔºåÂÖ∂ÂÆûÂ∞±ÊòØÊç¢‰∫Ü‰∏™ÂêçÂ≠óËÄåÂ∑≤Ôºâ 1.‰ªéÂéüÁÇπÂêëÊØè‰∏ÄÂ§©Êôö‰∏äËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫ÂΩìÂ§©ÊâÄÁî®È§êÂ∑æxÔºåË¥πÁî®‰∏∫0ÁöÑËæπÔºåË°®Á§∫ÊØèÂ§©Êôö‰∏ä‰ªéËµ∑ÁÇπËé∑ÂæóxÊù°ËÑèÈ§êÂ∑æ„ÄÇ 2.‰ªéÊØè‰∏ÄÂ§©Êó©‰∏äÂêëÊ±áÁÇπËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫ÂΩìÂ§©ÊâÄÁî®È§êÂ∑æxÔºåË¥πÁî®‰∏∫0ÁöÑËæπÔºåÊØèÂ§©ÁôΩÂ§©,Ë°®Á§∫ÂêëÊ±áÁÇπÊèê‰æõxÊù°Âπ≤ÂáÄÁöÑÈ§êÂ∑æ,ÊµÅÊª°Êó∂Ë°®Á§∫Á¨¨iÂ§©ÁöÑÈ§êÂ∑æÂ§üÁî® „ÄÇ 3.‰ªéÊØè‰∏ÄÂ§©Êôö‰∏äÂêëÁ¨¨‰∫åÂ§©Êôö‰∏äËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫INFÔºåË¥πÁî®‰∏∫0ÁöÑËæπÔºåË°®Á§∫ÊØèÂ§©Êôö‰∏äÂèØ‰ª•Â∞ÜËÑèÈ§êÂ∑æÁïôÂà∞Á¨¨‰∫åÂ§©Êôö‰∏äÔºàÊ≥®ÊÑè‰∏çÊòØÊó©‰∏äÔºåÂõ†‰∏∫ËÑèÈ§êÂ∑æÂú®Êó©‰∏ä‰∏çÂèØ‰ª•‰ΩøÁî®Ôºâ„ÄÇ 4.‰ªéÊØè‰∏ÄÂ§©Êôö‰∏äÂêëËøô‰∏ÄÂ§©+Âø´Ê¥óÊâÄÁî®Â§©Êï∞t1ÁöÑÈÇ£‰∏ÄÂ§©Êó©‰∏äËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫INFÔºåË¥πÁî®‰∏∫Âø´Ê¥óÊâÄÁî®Èí±Êï∞ÁöÑËæπÔºåË°®Á§∫ÊØèÂ§©Êôö‰∏äÂèØ‰ª•ÈÄÅÂéªÂø´Ê¥óÈÉ®,Âú®Âú∞i+t1Â§©Êó©‰∏äÊî∂Âà∞È§êÂ∑æ „ÄÇ 5.ÂêåÁêÜÔºå‰ªéÊØè‰∏ÄÂ§©Êôö‰∏äÂêëËøô‰∏ÄÂ§©+ÊÖ¢Ê¥óÊâÄÁî®Â§©Êï∞t2ÁöÑÈÇ£‰∏ÄÂ§©Êó©‰∏äËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫INFÔºåË¥πÁî®‰∏∫ÊÖ¢Ê¥óÊâÄÁî®Èí±Êï∞ÁöÑËæπÔºåË°®Á§∫ÊØèÂ§©Êôö‰∏äÂèØ‰ª•ÈÄÅÂéªÊÖ¢Ê¥óÈÉ®,Âú®Âú∞i+t2Â§©Êó©‰∏äÊî∂Âà∞È§êÂ∑æ „ÄÇ 6.‰ªéËµ∑ÁÇπÂêëÊØè‰∏ÄÂ§©Êó©‰∏äËøû‰∏ÄÊù°ÊµÅÈáè‰∏∫INFÔºåË¥πÁî®‰∏∫Ë¥≠‰π∞È§êÂ∑æÊâÄÁî®Èí±Êï∞ÁöÑËæπÔºåË°®Á§∫ÊØèÂ§©Êó©‰∏äÂèØ‰ª•Ë¥≠‰π∞È§êÂ∑æ „ÄÇ Ê≥®ÊÑèÔºå‰ª•‰∏ä6ÁÇπÈúÄË¶ÅÂª∫ÂèçÂêëËæπÔºÅ3~6ÁÇπÈúÄË¶ÅÂÅöÂà§Êñ≠ÔºàÂç≥ËøûÂêëÁöÑËæπÂøÖÈ°ª&lt;=nÔºâ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,cost,rev;//ÁªàÁÇπ,ÂÆπÈáè,Ë¥πÁî®,ÂèçÂêëËæπ }; vector&lt;edge&gt;G[5010]; int dis[5010],prevv[5010],preve[5010],n,m,s,t,flow=0,cost=0;//ÊúÄÁü≠Ë∑Ø‰∏≠ÂâçÈ©±ËäÇÁÇπÂíåÂØπÂ∫îÁöÑËæπ bool inque[5010]; const int INF=1&lt;&lt;30; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//Ê≥®ÊÑèÂèçÂêëËæπÁöÑÂä†Ê≥ï!!-costÂíåcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f) return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//ÂÖ®ÊúÄÁü≠Ë∑Ø‰∏≠ÁöÑÊúÄÂ∞èÊµÅÈáèÈôêÂà∂Â∞±ÊòØÊú¨Ê¨°ÊÄªÁöÑÊµÅÈáèÈôêÂà∂ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//Êõ¥Êñ∞Ë∑ØÂæÑ‰ø°ÊÅØ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int n,a,b,f,fa,fb,i,j,k; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;fa&gt;&gt;fb; int peo[1005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;peo[i]); for(i=1;i&lt;=n;i++) add(0,i,peo[i],0); for(i=1;i&lt;=n;i++) add(i+n,2005,peo[i],0); for(i=1;i&lt;n;i++) add(i,i+1,INF,0); for(i=1;i+a+1&lt;=n;i++) add(i,i+a+n+1,INF,fa); for(i=1;i+b+1&lt;=n;i++) add(i,i+b+n+1,INF,fb); for(i=1;i&lt;=n;i++) add(0,i+n,INF,f); mincostmaxflow(0,2005); cout&lt;&lt;cost&lt;&lt;endl; return 0; } F - ‰øÆËΩ¶ HYSBZ - 1070È¢òÁõÆÁöÑÈöæÁÇπÂú®‰∫éÊÄé‰πàÂéªËÆ°ÁÆóÊÄªÁöÑÁ≠âÂæÖÊó∂Èó¥„ÄÇÊñπÊ≥ïÊòØÊää‰øÆËΩ¶‰∫∫ÂëòÊãÜÊàên‰∏™ÁÇπÔºåÊØè‰∏™‰∫∫ÁöÑÁ¨¨i‰∏™ÁÇπÂàÜÂà´Ë°®Á§∫Ëøô‰∏™‰∫∫Âú®ÂÄíÊï∞Á¨¨i‰∏™ÂØπÊüêËæÜËΩ¶ËøõË°å‰øÆÁêÜÔºåÈÇ£‰πàÁ≠âÂæÖ‰øÆÁöÑËΩ¶ËøûÂêëËøô‰∏™ÁÇπÁöÑËæπÂ∞±Â∫îËØ•ÊòØ ‰øÆËΩ¶Êó∂Èó¥* iÔºåÂõ†‰∏∫ËøòÊúâi‰∏™‰∫∫Âú®Á≠âËøô‰∏™‰øÆËΩ¶Â∏àÂÇÖ„ÄÇÁÑ∂ÂêéË∑ëÊúÄÂ∞èË¥πÁî®ÊµÅÂç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,cost,rev;//ÁªàÁÇπ,ÂÆπÈáè,Ë¥πÁî®,ÂèçÂêëËæπ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//ÊúÄÁü≠Ë∑Ø‰∏≠ÂâçÈ©±ËäÇÁÇπÂíåÂØπÂ∫îÁöÑËæπ, // Â∞èÂøÉcostÁàÜint,Â§öÁªÑÊï∞ÊçÆÊó∂ËÆ∞ÂæóÊ∏ÖÈõ∂ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//Ê≥®ÊÑèÂèçÂêëËæπÁöÑÂä†Ê≥ï!!-costÂíåcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//Â∞èÂøÉÁàÜintÁöÑÊÉÖÂÜµ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//ÂÖ®ÊúÄÁü≠Ë∑Ø‰∏≠ÁöÑÊúÄÂ∞èÊµÅÈáèÈôêÂà∂Â∞±ÊòØÊú¨Ê¨°ÊÄªÁöÑÊµÅÈáèÈôêÂà∂ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//Êõ¥Êñ∞Ë∑ØÂæÑ‰ø°ÊÅØ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int m,n,i,j,k,a,b; cin&gt;&gt;m&gt;&gt;n; for(i=1;i&lt;=n;i++) add(0,n*m+i,1,0); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ cin&gt;&gt;a; for(k=1;k&lt;=n;k++){ add(n*m+i,(j-1)*n+k,1,a*k); } } for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) add((i-1)*n+j,900,1,0); mincostmaxflow(0,900); printf(&quot;%.2f\n&quot;,(double)cost/n); return 0; } G - Firing POJ - 2987ÊúÄÂ§ßÊùÉÈó≠ÂêàÂõæÁöÑÊ®°ÊùøÈ¢ò #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } long long maxflow(int s,int t){ long long flow=0;//Â∞èÂøÉÁàÜint for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//Ê≥®ÊÑèÂ¶ÇÊûúÁàÜintËøôÈáåÂàùÂßãÊúÄÂ§ßÂÄºË¶ÅÊõ¥ÊîπÊúÄÂ§ßÂÄº flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; } H - Being a Hero HDU - 3251Ê∑ªÂä†Ê±áÁÇπTÔºåÂéüÂõæ‰∏äÁöÑÂçïÂêëËæπ‰æùÊ¨°Âª∫ËæπÔºåÂÆπÈáè‰∏∫Ëä±Ë¥πÔºåÂÖÅËÆ∏ÈÄâÊã©ÁöÑf‰∏™ÁÇπÂêëÊ±áÁÇπTËøûËæπÔºåÂÆπÈáè‰∏∫ÁÇπ‰∏äÊùÉÂÄº„ÄÇË∑ë‰∏ÄÈÅçÊúÄÂ∞èÂâ≤ÂæóÂà∞Ëä±Ë¥πÂÄºcostÔºåÁÑ∂ÂêéÁî®ÊÄªÁöÑËÉΩËé∑ÂæóÂà©Ê∂¶ÔºàÂ∞±ÊòØf‰∏™ÁÇπÁöÑÊùÉÂÄº‰πãÂíåÔºâÂáèÂéªcost ‰ªéÊ∫êÁÇπSÂú®ÊÆãÁïôÁΩëÁªú‰∏≠dfsÈÅçÂéÜËÉΩËµ∞Âà∞ÁöÑÁÇπÔºåÈÇ£‰πàËøô‰∫õÁÇπÂ∞±ÊòØÂ±û‰∫éSÈõÜÔºåÂÖ∂‰ªñÂâ©‰∏ãÁöÑÁÇπÂ∞±Â±û‰∫éTÈõÜ‰∫ÜÔºå ÁÑ∂ÂêéÂà§Êñ≠ËæπÁöÑ‰∏§‰∏™ÁÇπÊâÄÂ±ûÁöÑÈõÜÂêàÔºåÂ¶ÇÊûúÂ±û‰∫é‰∏çÂêåÁöÑÈõÜÂêàÈÇ£‰πàËøôÊù°ËæπÂ∞±ÊòØÂâ≤Ëæπ„ÄÇ ÂØπ‰∫éÂéüÂõæ‰∏äÁöÑËæπÂ¶ÇÊûúË¢´Ââ≤Âà∞ÔºåÈÇ£‰πàËøôÊù°ËæπÂ∞±ÊòØË¶ÅÁ†¥ÂùèÁöÑÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑèÁöÑÊòØ‰∏ÄÂÆöË¶ÅÊ†áËÆ∞ÊØèÊù°ËæπÊòØ‰∏çÊòØÂéüÂõæ‰∏≠ÁöÑËæπÔºåÂê¶ÂàôÂæàÂèØËÉΩÂèçÂêëËæπ‰ºöË¢´ËØØÂà§‰∏∫Ââ≤ËæπÔºÅÔºÅÔºÅ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,rev,id; bool iscor; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap,int id) { G[from].push_back(edge{to,cap,(int)G[to].size(),id,true}); G[to].push_back(edge{from,0,(int)G[from].size()-1,id,false});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0;//Â∞èÂøÉÁàÜint for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//Ê≥®ÊÑèÂ¶ÇÊûúÁàÜintËøôÈáåÂàùÂßãÊúÄÂ§ßÂÄºË¶ÅÊõ¥ÊîπÊúÄÂ§ßÂÄº flow+=f; } } bool vis[1005]; void dfs(int x) { vis[x]=true; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]){ dfs(G[x][i].to); } } } int main() { int t,i,j,k,n,m,f; cin&gt;&gt;t;int case1=0; while(t--){ case1++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;f; for(i=1;i&lt;=1001;i++)G[i].clear(); //int ava[1005]={0}; for(i=1;i&lt;=m;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w,i);//ËøûËæπ } long long sum=0; while(f--){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w);sum+=w;//ava[u]=1; addedge(u,1001,w,0);//1001‰∏∫Ê±áÁÇπ } printf(&quot;Case %d: &quot;,case1); cout&lt;&lt;sum-maxflow(1,1001)&lt;&lt;endl; memset(vis,0,sizeof(vis)); dfs(1); vector&lt;int&gt;road;//Á†¥ÂùèÁöÑËæπ for(i=1;i&lt;=n;i++){ for(j=0;j&lt;G[i].size();j++){ edge e=G[i][j]; if(vis[i]&amp;&amp;!vis[e.to]&amp;&amp;e.id&amp;&amp;e.iscor){ road.push_back(e.id); } } } cout&lt;&lt;road.size(); //sort(road.begin(),road.end()); for(i=0;i&lt;road.size();i++) cout&lt;&lt;&apos; &apos;&lt;&lt;road[i]; cout&lt;&lt;endl; } return 0; } I - ÂøóÊÑøËÄÖÊãõÂãü HYSBZ - 1061Ê∫êÁÇπËøûÁ¨¨‰∏ÄÂ§©ÔºåÊúÄÂêé‰∏ÄÂ§©Ôºàn+1ÔºâËøûÊ±áÁÇπÔºåÂÆπÈáè‰∏∫INFË¥πÁî®‰∏∫0 ËøôÊ†∑Ë∑ëÁΩëÁªúÊµÅÊòØÊ≤øÊó∂Èó¥ÊµÅÁöÑÔºàÂ∞±ÊòØ‰æùÊ¨°Ëß£ÂÜ≥ÊØè‰∏ÄÂ§©ÁöÑÈóÆÈ¢òÔºâ ÁÑ∂ÂêéÊØè‰∏ÄÂ§©ÂêëÂêé‰∏ÄÂ§©Ëøû‰∏ÄÊù°ÂÆπÈáè‰∏∫INF-a[i]ÔºåË¥πÁî®‰∏∫0ÁöÑËæπÔºàËøôÂÖ∂ÂÆûÊòØÊú¨È¢òÁ≤æÈ´ìÔºâ ‰∏∫‰ªÄ‰πàÂÆπÈáè‰∏∫INF-a[i]ÔºüËøôÂ∞±Áõ∏ÂΩì‰∫éÂ∞ë‰∫Üa[i]ÔºåÂæóÁî®Â∏¶ÊùÉËæπ‰πüÂ∞±ÊòØÊãõÊù•ÁöÑÂøóÊÑøËÄÖË°•ÂÖ®INF ËøôÂ∞±ÊòØÂøóÊÑøËÄÖËøûÁª≠Âπ≤Êó∂Ê≤øËøôÊù°ËæπË∑ëÔºåÂõ†‰∏∫ËøûÁª≠Âπ≤‰∏çËä±Èí±ÔºåÊâÄ‰ª•‰ºòÂÖàÈÄâËøôÁßçËæπ ÁÑ∂ÂêéÂ∞ÜÊØè‰∏ÄÁ±ªÂøóÊÑøËÄÖs[i]‰∏ét[i]+1Ëøû‰∏ÄÊù°ÂÆπÈáè‰∏∫INFËä±Ë¥π‰∏∫c[i]ÁöÑËæπÔºåÂΩìËøûÁª≠Âπ≤ÁöÑ‰∫∫‰∏çÂ§üÊó∂ÔºåÂ∞±ÂæóÂÖÖÈí±‰ΩøÂä≤ÂæÄÈáåÂ°û‰∫∫ÔºåË°•ÂÖ®INF„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int INF = (1 &lt;&lt; 31) - 1; struct edge { int to, cap, cost, rev; }; vector&lt;edge&gt;G[2010]; int dis[2010], prevv[2010], preve[2010], n, m, flow = 0, cost = 0; bool inque[2010]; void add(int from, int to, int cap, int cost) { edge e; e.to = to; e.cap = cap; e.cost = cost; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.cost = -cost; e.rev = G[from].size() - 1;//-cost! G[to].push_back(e); } bool Spfa(int s, int t) { fill(dis, dis + 2000, 1 &lt;&lt; 30); memset(inque, 0, sizeof(inque)); queue&lt;int&gt;que; dis[s] = 0; inque[s] = true; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); inque[t] = false; for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;dis[e.to] &gt; dis[t] + e.cost) { dis[e.to] = dis[t] + e.cost; prevv[e.to] = t; preve[e.to] = i;//‰∏Ä‰∏™Ëæπ‰∏Ä‰∏™ÁÇπ‰∏çË¶ÅÊ∑∑Ê∑ÜÔºÅ if (!inque[e.to]) { que.push(e.to); inque[e.to] = true; } } } } if (dis[t] == 1 &lt;&lt; 30)//Â¶ÇÊûúÂ∑≤ÁªèÊó†Ê≥ïÂ¢ûÂπøÔºåËøîÂõû return false; int d = 1 &lt;&lt; 30; for (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);//Ê≠§Ê¨°ÂèØÂ¢ûÂπøÂÆπÈáèÊòØÂÖ®Ë∑ØÂæÑ‰∏≠ÂÆπÈáèÊúÄÂ∞èÁöÑÈÇ£‰∏™ flow += d; cost += d * dis[t];//disÊòØË∑ØÂæÑ‰∏≠Âçï‰ΩçË¥πÁî®Âíå for (int v = t; v != s; v = prevv[v]) {//Êõ¥ÊîπÂÆπÈáè edge &amp;e = G[prevv[v]][preve[v]]; e.cap -= d; G[v][e.rev].cap += d;//vÊàñËÄÖe.toÈÉΩÂèØ‰ª• } return true; } void mincostmaxflow(int s, int t) { while (Spfa(s, t)&amp;&amp;flow&lt;INF); } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m; add(0, 1, INF, 0); add(n + 1, 1500, INF, 0); for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); add(i, i + 1, INF - j, 0); } for (i = 1; i &lt;= m; i++) { int s, t, c; scanf(&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;c); add(s, t + 1, INF, c); } mincostmaxflow(0, 1500); cout &lt;&lt; cost &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúâ‰∏ä‰∏ãÁïåÁöÑÁΩëÁªúÊµÅ ÊÄªÁªì]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-9c-89-e4-b8-8a-e4-b8-8b-e7-95-8c-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b5-81-e5-81-9a-e6-b3-95-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[Êó†Ê∫êÊ±áÂèØË°åÊµÅÂª∫ÂõæÊñπÊ≥ïÂ∞ÜÊúâ‰∏ä‰∏ãÁïåÁöÑÁΩëÁªúÊµÅÂõæËΩ¨ÂåñÊàêÊôÆÈÄöÁöÑÁΩëÁªúÊµÅÂõæ È¶ñÂÖàÂª∫Á´ãÈôÑÂä†Ê∫êÁÇπssÂíåÈôÑÂä†Ê±áÁÇπtt ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑËæπx-&gt;yÔºåËã•ÈôêÂà∂‰∏∫[b,c]ÔºåÈÇ£‰πàËøûËæπx-&gt;yÔºåÊµÅÈáè‰∏∫c-b ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑÊüê‰∏Ä‰∏™ÁÇπiÔºåËÆ∞d(i)‰∏∫ÊµÅÂÖ•Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíåÂáèÂéªÊµÅÂá∫Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíå Ôºà‰∏äÈù¢Âú®ËøûÊØè‰∏ÄÊù°ËæπÁöÑÊó∂ÂÄôÂª∫‰∏Ä‰∏™curÊï∞ÁªÑËÆ∞‰∏Ä‰∏ãËæìÂÖ•ËæìÂá∫Âç≥ÂèØÔºâ Ëã•d(i)&gt;0ÔºåÈÇ£‰πàËøûËæπss-&gt;iÔºåÊµÅÈáè‰∏∫d(i) ÔºåÂêåÊó∂ÊúüÊúõÁöÑÊµÅÈáèÂÄºsum+=dÔºài) Ëã•d(i)&lt;0ÔºåÈÇ£‰πàËøûËæπi-&gt;ttÔºåÊµÅÈáè‰∏∫-d(i) Ê±ÇËß£ÊñπÊ≥ï Âú®Êñ∞Âõæ‰∏äË∑ëssÂà∞ttÁöÑÊúÄÂ§ßÊµÅ Ëã•Êñ∞ÂõæÊª°ÊµÅÔºàÊµÅÈáèÁ≠â‰∫ésumÔºâÔºåÈÇ£‰πà‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÁßçÂèØË°åÊµÅ Ê≠§Êó∂ÔºåÂéüÂõæ‰∏≠ÊØè‰∏ÄÊù°ËæπÁöÑÊµÅÈáèÂ∫î‰∏∫Êñ∞Âõæ‰∏≠ÂØπÂ∫îÁöÑËæπÁöÑÊµÅÈáè+ËøôÊù°ËæπÁöÑÊµÅÈáè‰∏ãÁïå EXÔºöLOJ115 ËøôÊòØ‰∏ÄÈÅìÊ®°ÊùøÈ¢ò„ÄÇ n‰∏™ÁÇπÔºåmÊù°ËæπÔºåÊØèÊù°Ëæπ eÊúâ‰∏Ä‰∏™ÊµÅÈáè‰∏ãÁïå $lower(e) $ ÂíåÊµÅÈáè‰∏äÁïå $upper(e)$ÔºåÊ±Ç‰∏ÄÁßçÂèØË°åÊñπÊ°à‰ΩøÂæóÂú®ÊâÄÊúâÁÇπÊª°Ë∂≥ÊµÅÈáèÂπ≥Ë°°Êù°‰ª∂ÁöÑÂâçÊèê‰∏ãÔºåÊâÄÊúâËæπÊª°Ë∂≥ÊµÅÈáèÈôêÂà∂„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[310]; int level[305],iter[305],cur[305],lower[30500]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,flow; bool operator&lt;(const ans&amp;a)const{ return id&lt;a.id; } }; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int s,t,l,u; scanf(&quot;%d%d%d%d&quot;,&amp;s,&amp;t,&amp;lower[i],&amp;u); cur[s]-=lower[i];cur[t]+=lower[i]; addedge(s,t,u-lower[i]);G[s].back().id=i; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]); sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,250,-cur[i]); } } int flow=maxflow(0,250); if(flow!=sum){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return 0; } vector&lt;ans&gt;as; for(i=1;i&lt;=n;i++){ for(auto a:G[i]){ if(!a.id)continue; as.push_back(ans{a.id,lower[a.id]+G[a.to][a.rev].cap}); } } sort(as.begin(),as.end()); cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(auto a:as){ cout&lt;&lt;a.flow&lt;&lt;endl; } return 0; } ÊúâÊ∫êÊ±áÂèØË°åÊµÅÂª∫ÂõæÊñπÊ≥ïÂú®ÂéüÂõæ‰∏≠Ê∑ªÂä†‰∏ÄÊù°Ëæπt-&gt;sÔºåÊµÅÈáè‰∏∫inf Âç≥ËÆ©Ê∫êÁÇπÂíåÊ±áÁÇπ‰πüÊª°Ë∂≥ÊµÅÈáèÂπ≥Ë°°Êù°‰ª∂ ËøôÊ†∑Â∞±ÊîπÈÄ†Êàê‰∫ÜÊó†Ê∫êÊ±áÁöÑÁΩëÁªúÊµÅÂõæÔºåÂÖ∂‰ΩôÂª∫ÂõæÊñπÊ≥ï‰∏éÊó†Ê∫êÊ±áÂèØË°åÊµÅÁõ∏Âêå„ÄÇ ÊúâÊ∫êÊ±áÊúâ‰∏ä‰∏ãÁïåÊúÄÂ§ßÊµÅÂª∫ÂõæÊñπÊ≥ïÂ∞ÜÊúâ‰∏ä‰∏ãÁïåÁöÑÁΩëÁªúÊµÅÂõæËΩ¨ÂåñÊàêÊôÆÈÄöÁöÑÁΩëÁªúÊµÅÂõæ È¶ñÂÖàÂª∫Á´ãÈôÑÂä†Ê∫êÁÇπssÂíåÈôÑÂä†Ê±áÁÇπtt ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑËæπx-&gt;yÔºåËã•ÈôêÂà∂‰∏∫[b,c]ÔºåÈÇ£‰πàËøûËæπx-&gt;yÔºåÊµÅÈáè‰∏∫c-b ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑÊüê‰∏Ä‰∏™ÁÇπiÔºåËÆ∞d(i)‰∏∫ÊµÅÂÖ•Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíåÂáèÂéªÊµÅÂá∫Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíå Ëã•d(i)&gt;0ÔºåÈÇ£‰πàËøûËæπss-&gt;iÔºåÊµÅÈáè‰∏∫d(i) Ëã•d(i)&lt;0ÔºåÈÇ£‰πàËøûËæπi-&gt;ttÔºåÊµÅÈáè‰∏∫-d(i) Ôºà‰ª•‰∏ä‰∏éÊó†Ê∫êÊ±áÂèØË°åÊµÅÁõ∏ÂêåÔºâ Âú®ÂéüÂõæ‰∏≠Ê∑ªÂä†‰∏ÄÊù°Ëæπt-&gt;sÔºåÊµÅÈáè‰∏∫inf Âç≥ËÆ©Ê∫êÁÇπÂíåÊ±áÁÇπ‰πüÊª°Ë∂≥ÊµÅÈáèÂπ≥Ë°°Êù°‰ª∂ ËøôÊ†∑Â∞±ÊîπÈÄ†Êàê‰∫ÜÊó†Ê∫êÊ±áÁöÑÁΩëÁªúÊµÅÂõæ Ôºà‰ª•‰∏ä‰∏éÊúâÊ∫êÊ±áÂèØË°åÊµÅÁõ∏ÂêåÔºâ Âú®Êñ∞Âõæ‰∏äË∑ëssÂà∞ttÁöÑÊúÄÂ§ßÊµÅ Ëã•Êñ∞ÂõæÊª°ÊµÅÔºåÈÇ£‰πà‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÁßçÂèØË°åÊµÅ ËÆ∞Ê≠§Êó∂$‚àëf(s,i)=sum1$ ÔºåÂç≥Ê≠§Êó∂t-&gt;sÁöÑÊúÄÂ§ßÊµÅÔºå‰πüÂ∞±ÊòØÊ±ÇÂèçÂêëËæπs-&gt;tÁöÑÊµÅÈáè Â∞Üt-&gt;sËøôÊù°ËæπÊãÜÊéâÔºåÂú®Êñ∞Âõæ‰∏äË∑ësÂà∞tÁöÑÊúÄÂ§ßÊµÅ ËÆ∞Ê≠§Êó∂$‚àëf(s,i)=sum2 $ÔºåÂç≥maxflowÔºàsÔºåtÔºâ ÊúÄÁªàÁ≠îÊ°àÂç≥‰∏∫sum1+sum2 EX:LOJ116 ËøôÊòØ‰∏ÄÈÅìÊ®°ÊùøÈ¢ò„ÄÇ n‰∏™ÁÇπÔºåmÊù°ËæπÔºåÊØèÊù°Ëæπ eÊúâ‰∏Ä‰∏™ÊµÅÈáè‰∏ãÁïå$ lower(e) $ÂíåÊµÅÈáè‰∏äÁïå $upper(e) $ÔºåÁªôÂÆöÊ∫êÁÇπ s‰∏éÊ±áÁÇπ tÔºåÊ±ÇÊ∫êÁÇπÂà∞Ê±áÁÇπÁöÑÊúÄÂ§ßÊµÅ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; bool tag; }; vector&lt;edge&gt;G[410]; int level[405],iter[405],cur[405],lower[10005]; void addedge(int from,int to,int cap,int s) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! if(from==s)G[from].back().tag=true; } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,t,up; scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;t,&amp;lower[i],&amp;up); addedge(from,t,up-lower[i],s);cur[from]-=lower[i];cur[t]+=lower[i]; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i],s);sum+=cur[i]; } else{ addedge(i,250,-cur[i],s); } } addedge(t,s,(1&lt;&lt;31)-1,s); int flow=maxflow(0,250); if(sum!=flow){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } int ans=G[s].back().cap; G[s].pop_back();G[t].pop_back(); ans+=maxflow(s,t); cout&lt;&lt;ans&lt;&lt;endl; return 0; } ÊúâÊ∫êÊ±áÊúâ‰∏ä‰∏ãÁïåÊúÄÂ∞èÊµÅÂª∫ÂõæÊñπÊ≥ïÂ∞ÜÊúâ‰∏ä‰∏ãÁïåÁöÑÁΩëÁªúÊµÅÂõæËΩ¨ÂåñÊàêÊôÆÈÄöÁöÑÁΩëÁªúÊµÅÂõæ È¶ñÂÖàÂª∫Á´ãÈôÑÂä†Ê∫êÁÇπssÂíåÈôÑÂä†Ê±áÁÇπtt ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑËæπx-&gt;yÔºåËã•ÈôêÂà∂‰∏∫[b,c]ÔºåÈÇ£‰πàËøûËæπx-&gt;yÔºåÊµÅÈáè‰∏∫c-b ÂØπ‰∫éÂéüÂõæ‰∏≠ÁöÑÊüê‰∏Ä‰∏™ÁÇπiÔºåËÆ∞d(i)‰∏∫ÊµÅÂÖ•Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíåÂáèÂéªÊµÅÂá∫Ëøô‰∏™ÁÇπÁöÑÊâÄÊúâËæπÁöÑ‰∏ãÁïåÂíå Ëã•d(i)&gt;0ÔºåÈÇ£‰πàËøûËæπss-&gt;iÔºåÊµÅÈáè‰∏∫d(i) Ëã•d(i)&lt;0ÔºåÈÇ£‰πàËøûËæπi-&gt;ttÔºåÊµÅÈáè‰∏∫-d(i) Ôºà‰ª•‰∏ä‰∏éÊó†Ê∫êÊ±áÂèØË°åÊµÅÁõ∏Âêå) Ê±Çres=ss-&gt;ttÊúÄÂ§ßÊµÅ ËøûËæπt-&gt;s,inf Ê±Çres+=ss-&gt;ttÊúÄÂ§ßÊµÅ Â¶ÇÊûúresÔºÅ=sum‰πüÂ∞±ÊòØÊúüÊúõ‰∏≠ÁöÑÊª°ÊµÅÔºåÈÇ£‰πàÂ∞±Ê≤°ÊúâÂèØË°åËß£„ÄÇ ÈúÄË¶ÅÊ†ºÂ§ñÊ≥®ÊÑèÊúÄÂ∞èÊµÅÂà§Êñ≠ÊòØÂê¶ÊúâÂèØË°åËß£ÁöÑ‰ΩçÁΩÆ‰∏éÊó∂Êú∫‰∏éÂè¶Â§ñÂá†Áßç‰∏ä‰∏ãÁïåÁΩëÁªúÊµÅÁöÑ‰∏çÂêåÔºÅÔºÅÔºÅ Âê¶ÂàôÔºåËæìÂá∫G[s].back().cap‰πüÂ∞±ÊòØ‰ªétÂà∞s infËæπÁöÑÂÆûÈôÖÊµÅÈáèÔºåÂç≥‰∏∫ÊâÄÊ±Ç„ÄÇ EX:LOJ117 n ‰∏™ÁÇπÔºåmÊù°ËæπÔºåÊØèÊù°Ëæπ eÊúâ‰∏Ä‰∏™ÊµÅÈáè‰∏ãÁïå $lower(e) $ÂíåÊµÅÈáè‰∏äÁïå $upper(e)$ÔºåÁªôÂÆöÊ∫êÁÇπ s‰∏éÊ±áÁÇπ tÔºåÊ±ÇÊ∫êÁÇπÂà∞Ê±áÁÇπÁöÑÊúÄÂ∞èÊµÅ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; struct edge{ int to;ll cap;int rev; }; vector&lt;edge&gt;G[50210]; int level[50205],iter[50205],low[125050];ll cur[50205]; void addedge(int from,int to,ll cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } ll dfs(int v,int t,ll f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ ll d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } ll maxflow(int s,int t){ ll flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); ll f; while(f=dfs(s,t,0x7f7f7f7f7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,to,up;scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;to,&amp;low[i],&amp;up); cur[from]-=low[i];cur[to]+=low[i];addedge(from,to,up-low[i]); } ll sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]);sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,50050,-cur[i]); } } ll flow=maxflow(0,50050); addedge(t,s,(1LL&lt;&lt;63)-1); flow+=maxflow(0,50050); if(flow!=sum){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } cout&lt;&lt;G[s].back().cap&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #452 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-452-div-2%2F</url>
    <content type="text"><![CDATA[A.#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,cnt[3]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);cnt[j]++; } //cout&lt;&lt;min(cnt[1],cnt[2])&lt;&lt;endl; if(cnt[1]&lt;=cnt[2]){ cout&lt;&lt;cnt[1]&lt;&lt;endl; } else{ if(cnt[1]-cnt[2]&lt;3) cout&lt;&lt;cnt[2]&lt;&lt;endl; else cout&lt;&lt;cnt[2]+(cnt[1]-cnt[2])/3&lt;&lt;endl; } return 0; } B.Â∞±ÊòØÊâìË°®Êö¥Âäõ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int init[15]={31,31,28,31,30,31,30,31,31,30,31,30,31},days[5][50]; int i,j,n,tar[30],k; for(i=1;i&lt;=4;i++) for(j=1;j&lt;=36;j++){ days[i][j]=init[j%12]; } days[1][2]=29;days[2][14]=29;days[3][26]=29; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;tar[i]); bool isok=false; for(i=1;i&lt;=4;i++){ for(j=1;j&lt;=36-n+1;j++){ for(k=1;k&lt;=n;k++){ if(tar[k]!=days[i][j+k-1]) break; } if(k&gt;n){ isok=true;break; } } } if(isok){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } C.Â¶ÇÊûúÊï∞Â≠ó‰∏çÊòØ1~nÁöÑËØù‰ºº‰πéÊòØ‰∏Ä‰∏™npÈóÆÈ¢ò‚Ä¶ÂΩìÁÑ∂ËøôÈáåÊòØËøûÁª≠ÁöÑÔºåÂõ†Ê≠§ÂÖ∂ÂÆûÊòØÊúâËßÑÂæãÂèØÂæ™ÁöÑ„ÄÇËÆ®ËÆ∫nÊ®°4ÁöÑ‰ΩôÊï∞ÔºåÁÑ∂ÂêéÂ∞±‰ºöÂèëÁé∞ÂΩì‰ΩôÊï∞‰∏∫0Êàñ2ÁöÑÊó∂ÂÄôÈÉΩÊòØÂèØ‰ª•ÊûÑÈÄ†Âá∫Êù•Â∑Æ‰∏∫0ÁöÑÔºåÂÖ∂‰ªñÂ∞±Âè™ËÉΩÂ∑Æ‰∏∫1‰∫Ü„ÄÇ ÊûÑÈÄ†Êàø‰∏ªË¶ÅÊÄùÊÉ≥Â∞±ÊòØÈ¶ñ‰ΩçÈÖçÂØπÔºåÂõ†‰∏∫ËøôÊ†∑ÈÖçÂá∫Êù•ÁöÑÊØèÂØπÁöÑÂíåÈÉΩÊòØÁõ∏Á≠âÁöÑ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; vector&lt;int&gt;ans; cin&gt;&gt;n; int y=n%4; if(y==0){ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; } else if(y==1){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2+1&lt;&lt;&apos; &apos;&lt;&lt;1; for(i=2;i&lt;=n/4+1;i++) cout&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+2; } else if(y==2){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; cout&lt;&lt;n/2&lt;&lt;endl; } else{ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;endl; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; for(i=n-n/4;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; } return 0; } D.È¶ñÂÖàÔºåÂ¶ÇÊûúÂú®ËåÉÂõ¥ÂÜÖÊúÄÂ§ßÁöÑ‰∏§‰∏™Êï∞Âä†Ëµ∑Êù•ÊÅ∞Â•ΩÊòØ9999‚Ä¶99ÁöÑÂΩ¢ÂºèÁöÑËØùÔºåÈÇ£‰πàÂπ∂‰∏çÈúÄË¶ÅÂÜçËÆ®ËÆ∫‰∫ÜÔºåÁ≠îÊ°àÂ∞±ÊòØ1.Âê¶ÂàôÊâÄÊ±ÇÁöÑ9ÁöÑ‰ΩçÊï∞Â∞±ÊòØÊúÄÂ§ß‰∏§‰∏™Êï∞ÁöÑÂíåÁöÑ‰ΩçÊï∞-1Ôºõ ÁÑ∂ÂêéÊàë‰ª¨Â∞±ËØïÁùÄÂú®ÁõÆÊ†á‰∏™Êï∞ÁöÑ9ÂâçÈù¢‰æùÊ¨°Â°´‰∏ä0~8ÔºåÁúãÁúãÊúâÂ§öÂ∞ëÁßçÊñπÂºèËÉΩÂä†Ëµ∑Êù•Á≠â‰∫éÊàë‰ª¨ÂΩìÂâçÊûÑÈÄ†ÁöÑÂíå„ÄÇÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÂΩìÂíåpÊØîËæÉÂ∞èÁöÑÊó∂ÂÄôÔºåÊñπÂºèÂ∞±ÊòØp/2Ôºå‰ΩÜÊòØÂíåÊØîËæÉÂ§ßÁöÑÊó∂ÂÄôÂ∞±ÊòØn-p/2‚Ä¶ ‰ª•ÂèäÔºåÂ¶ÇÊûún&lt;5ÁöÑÊó∂ÂÄôÂπ∂‰∏çËÉΩÊûÑÈÄ†Âá∫9ÔºåÈÇ£Â∞±Ë¶ÅÁâπÂà§‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,i,j,k; cin&gt;&gt;n; ll maxn=n+n-1; int cnt=0; ll t=maxn; while(t){ cnt++;t/=10; } if(maxn==(ll)pow(10,cnt)-1){ cout&lt;&lt;1&lt;&lt;endl;return 0; } ll ans=0,nine=pow(10,cnt-1)-1;//ans1=n-n/2; for(i=0;i&lt;9;i++){ ll p=(ll)pow(10,cnt-1)*i+nine; if(p&gt;maxn)break; //ans+=((ll)pow(10,cnt-1)*i+nine)/2; ans+=min(n-p/2,p/2); } cout&lt;&lt;(n&lt;5?n*(n-1)/2:ans)&lt;&lt;endl; return 0; } E.È¢òÁõÆÂÅöÊ≥ïÂ∞±ÊòØÊ®°ÊãüÔºåÂÖ≥ÈîÆÂú®‰∫éÂà†Âéª‰∏Ä‰∏™Âå∫Èó¥‰πãÂêéÔºå‰ªñÂ∑¶Âè≥ÁöÑÂå∫Èó¥ÂèØËÉΩ‰ºöÂõ†‰∏∫Êï∞Â≠óÁõ∏ÂêåËÄåÈÄ†ÊàêÂêàÂπ∂„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºåÊàë‰ª¨Áî®‰∏§‰∏™setÔºå‰∏§‰∏™set‰∏≠ÈÉΩÂ≠òÊîæpairÔºåÁ¨¨‰∏Ä‰∏™setÁöÑÁ¨¨‰∏ÄÂÖÉÂ≠òÊîæËøûÁª≠Êï∞Â≠óÁöÑÈïøÂ∫¶*-1ÔºåÁ¨¨‰∫åÂÖÉÂàôÂ≠òÊîæËøûÁª≠Êï∞Â≠óÁöÑËµ∑Âßã‰ΩçÁΩÆ„ÄÇÁ¨¨‰∫å‰∏™setÁöÑÁ¨¨‰∏ÄÂÖÉÂ≠òÊîæËøûÁª≠Êï∞Â≠óÁöÑËµ∑Âßã‰ΩçÁΩÆÔºåÁ¨¨‰∫åÂÖÉÂ≠òÊîæËøûÁª≠Êï∞Â≠óÁöÑÈïøÂ∫¶„ÄÇ ÁÑ∂ÂêéÊØèÊ¨°Êàë‰ª¨ÊääÁ¨¨‰∏Ä‰∏™set‰∏≠ÁöÑÁ¨¨‰∏Ä‰∏™pairÊâæÂá∫Êù•Ôºå‰ªñÂ∞±ÊòØË¶ÅË¢´Âà†Èô§ÁöÑÔºåÁÑ∂ÂêéÊàë‰ª¨Áî®lowerboundÂú®Á¨¨‰∫å‰∏™set‰∏≠ÊâæÂá∫‰ªñÂâçÂêéÁöÑ‰∏§‰∏™pairÔºåÁúãÁúã‰ªñ‰ª¨ÊòØÂê¶ÈúÄË¶ÅÂêàÂπ∂Âç≥ÂèØ„ÄÇÂ∞èÂøÉsetËÆøÈóÆÈùûÊ≥ï‰ΩçÁΩÆ‚Ä¶ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k; set&lt;P&gt;len,seg; //int pre=0,sum=0; cin&gt;&gt;n;int num[200005]={0},sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i]; if(num[i]!=num[i-1]){ if(i&gt;1){ len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); } sum=1; } else sum++; } len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); int ans=0; while(!len.empty()){ ans++; P p=*len.begin();len.erase(len.begin()); auto a=seg.lower_bound(P(p.second,0)); if(seg.size()&gt;=3&amp;&amp;a!=seg.begin()&amp;&amp;a!=--seg.end()){ auto b=a,c=a;b--,c++; if(num[b-&gt;first]==num[c-&gt;first]){ len.erase(P((b-&gt;second)*-1,b-&gt;first)); len.erase(P((c-&gt;second)*-1,c-&gt;first)); len.insert(P((b-&gt;second+c-&gt;second)*-1,b-&gt;first)); seg.insert(P(b-&gt;first,b-&gt;second+c-&gt;second)); seg.erase(b);seg.erase(c); } } seg.erase(a); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } F.ÂÖ∂ÂÆûÂÅöÊ≥ï‰πüÊå∫Êö¥ÂäõÁöÑ‚Ä¶Êàë‰ª¨Âª∫‰∏ÄÂ†ÜsetÔºåÊØè‰∏™ÈáåÈù¢ÈÉΩÂ≠òËøô‰∏™Â≠óÁ¨¶Âá∫Áé∞ÊâÄÊúâ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÂØπ‰∫éÊØèÊ¨°ËØ¢ÈóÆÔºåÊàë‰ª¨ÊâæÂá∫lÔºårÂú®ÂéüÂ≠óÁ¨¶‰∏≤‰∏≠ÁöÑ‰ΩçÁΩÆÔºåËøô‰∏™ÂèØ‰ª•Á±ª‰ººÊ†ëÁä∂Êï∞ÁªÑÂéªÁª¥Êä§‰∏Ä‰∏ãÔºå‰ΩÜÊòØÊúâÁÇπ‰∏çÂêåÔºåÈúÄË¶ÅÂ•ΩÂ•ΩÁêÜËß£‰∏Ä‰∏ã‚Ä¶ÁÑ∂ÂêéÂéªËøô‰∏™Â≠óÁ¨¶ÂØπÂ∫îÁöÑsetÈáåÈù¢lowerbound‰∏Ä‰∏ãÊâæÂá∫lÔºårÂØπÂ∫îÂéü‰ΩçÁΩÆÂå∫Èó¥ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâËøô‰∫õ‰ΩçÁΩÆÁÑ∂ÂêéÊ†áËÆ∞‰∏Ä‰∏ã‚Ä¶ÊúÄÂêé‰ªéÂâçÂæÄÂêéÔºåÂ¶ÇÊûúÊ≤°ÊúâË¢´Ê†áËÆ∞ËøáÂ∞±ËæìÂá∫Âç≥ÂèØ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e5+10; int bit[maxn],A; void add(int pos,int x) { while(pos&lt;=A){ bit[pos]+=x; pos+=pos&amp;-pos; } } int find(int x) { int s=0,j=A&gt;&gt;1; for(;j;j&gt;&gt;=1) if(x&gt;bit[s+j]) x-=bit[s+j],s+=j; return s+1; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str;cin&gt;&gt;str; set&lt;int&gt;s[150]; for(i=0;i&lt;str.size();i++) s[str[i]].insert(i+1); for(A=1;A&lt;n;A&lt;&lt;=1); for(i=1;i&lt;=n;i++)add(i,1); while(m--){ int l,r;char c[5];scanf(&quot;%d%d%s&quot;,&amp;l,&amp;r,c); l=find(l),r=find(r); //add() for(auto a=s[c[0]].lower_bound(l);a!=s[c[0]].end()&amp;&amp;(*a)&lt;=r;){ vis[*a]=true; add(*a,-1);s[c[0]].erase(a++); } } for(i=1;i&lt;=n;i++) if(!vis[i]) cout&lt;&lt;str[i-1]; cout&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâSTË°®]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FRMQ%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89st-e8-a1-a8%2F</url>
    <content type="text"><![CDATA[Ê¶ÇÂøµSTË°®Â∞±ÊòØ‰∏Ä‰∏™Áî®Êù•Ëß£ÂÜ≥rmqÔºàÂå∫Èó¥ÊúÄÂÄºÔºâÈóÆÈ¢òÁöÑÁÆóÊ≥ï. STË°®‰∏çÊîØÊåÅÂú®Á∫ø‰øÆÊîπ È¢ÑÂ§ÑÁêÜÊó∂Èó¥Â§çÊùÇÂ∫¶$O(nlogn)$ÔºåÊü•ËØ¢Êó∂Èó¥$O(1)$ ÁÆóÊ≥ïËØ¶Ëß£ÔºàÊ±ÇÊúÄÂ∞èÂÄºÔºâÔºöÁî®$mn[i][j]$Ë°®Á§∫‰ªé$i$Âà∞$i+2^j-1$ÁöÑÊúÄÂ∞èÂÄºÔºàÈïøÂ∫¶ÊòæÁÑ∂‰∏∫$2^i$Ôºâ„ÄÇ ‰ªªÊÑè‰∏ÄÊÆµÁöÑÊúÄÂ∞èÂÄºÊòæÁÑ∂Á≠â‰∫éminÔºàÂâçÂçäÊÆµÊúÄÂ∞èÂÄºÔºåÂêéÂçäÊÆµÊúÄÂ∞èÂÄºÔºâ„ÄÇ ÈÇ£‰πà$mn[i][j]$Â¶Ç‰ΩïÁî®ÂÖ∂‰ªñÁä∂ÊÄÅÊù•ÁªßÊâøÂë¢Ôºü $i$Âà∞$i+2^j-1$ÁöÑÈïøÂ∫¶‰∏∫$2^j$ÔºåÈÇ£‰πà‰∏ÄÂçäÁöÑÈïøÂ∫¶Â∞±Á≠â‰∫é$2^{j-1}$„ÄÇ ÈÇ£‰πàÂâçÂçäÊÆµÁöÑÁä∂ÊÄÅË°®Á§∫‰∏∫$mn[i][j-1]$„ÄÇ ÂêéÂçäÊÆµÁöÑÈïøÂ∫¶‰πü‰∏∫$2^{j-1}$ÔºåËµ∑Âßã‰ΩçÁΩÆ‰∏∫$i+2^{(j-1)}$„ÄÇ ÈÇ£‰πàÂêéÂçäÊÆµÁöÑÁä∂ÊÄÅË°®Á§∫‰∏∫$mn[i+2^{j-1}][j-1]$„ÄÇ ÊâÄ‰ª•Ôºö $mn[i][j]=min(mn[i][j-1],mn[i+2^{j-1}][j-1]$„ÄÇ Ê®°ÊùøÊ≥®ÊÑè‰øÆÊîπÊï∞ÁªÑÂ§ßÂ∞èÔºÅ (Ê¥õË∞∑P3865) #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=100010; int a[MAXN],dp[MAXN][50];//Á¨¨‰∫å‰∏™Êã¨Âè∑ÂÜÖË¶ÅÊ†πÊçÆÊúÄÂ§ßÊï∞ÊçÆËåÉÂõ¥ÊîπÊàê2ÁöÑÂπÇÊ¨°ËÉΩÂ§ß‰∫éÊúÄÂ§ßÁöÑÊï∞ÊçÆ //int Min(int x,int y)//ÊúâÊó∂ÂÄôÂèØ‰ª•Áî®‰∫éËá™ÂÆö‰πâ‰∏Ä‰∫õÁâπÊÆäÁ±ªÂûãÁöÑÊØîËæÉ //{ // return a[x]&lt;=a[y]?x:y; //} void st_init(int n)//n‰∏∫ÂéüÂßãÊï∞ÁªÑÁöÑÈïøÂ∫¶ { for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); //dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } int query(int l,int r) { int k = log2(r - l + 1); return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); //return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); st_init(n); int l,r; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%dn&quot;,query(l,r)); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #3]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-3%2F</url>
    <content type="text"><![CDATA[A.HackerRank array-partitionÈ¶ñÂÖàÊ≥®ÊÑèÂà∞‰∏ÄÁÇπÔºåÂ¶ÇÊûúÊúâ‰∏§‰∏™Êï∞aÔºåbÔºå$gcd(a,b)\geq 1$,ÈÇ£‰πàaÔºåbÊòæÁÑ∂ÊòØË¶ÅÊîæÂú®‰∏ÄÁªÑÁöÑ„ÄÇËÄÉËôëÂà∞Êï∞ÁªÑ‰∏≠ÁöÑÊï∞Â≠óËøáÂ§öÔºåÂõ†Ê≠§Êàë‰ª¨Âπ∂‰∏çËÉΩËøõË°å‰∏§‰∏§ÁöÑÊûö‰∏æÔºå‰ΩÜÊòØÊï∞ÊçÆÁöÑËåÉÂõ¥ÈÉΩÈùûÂ∏∏ÊúâÈôê„ÄÇÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•ËÄÉËôëÊûö‰∏æÊâÄÊúâÁöÑË¥®Êï∞ÔºåÁÑ∂ÂêéÊûö‰∏æË¥®Êï∞ÁöÑÂÄçÊï∞ÔºåÂ¶ÇÊûúÂêå‰∏Ä‰∏™Ë¥®Êï∞Â≠òÂú®‰∏Ä‰∫õÂÄçÊï∞ÊòØÊï∞ÁªÑ‰∏≠ÁöÑÊï∞ÁöÑËØùÔºåÂ∞±ÊääËøô‰∫õÊï∞ÈÉΩÂêàÂπ∂Ëµ∑Êù•ÔºàÊòæÁÑ∂Áî®Âπ∂Êü•ÈõÜÊïàÁéáÊúÄÈ´òÔºâ„ÄÇÁÑ∂ÂêéÊúÄÂêéÊ±ÇÂá∫ËøûÈÄöÂùóÁöÑÊï∞Èáèk„ÄÇÊ≥®ÊÑèÔºåÂõ†‰∏∫Êï∞Â≠ó1ÁöÑÁâπÊÆäÊÄßÔºåÊâÄ‰ª•ÊØè‰∏™1ÈÉΩÂèØ‰ª•ÁÆó‰∏Ä‰∏™ÂçïÁã¨ÁöÑËøûÈÄöÂùóÔºåËøô‰∏™Ë¶ÅÈ¢ùÂ§ñÁªüËÆ°„ÄÇÈÇ£‰πàÊñπÊ°àÊï∞Â∞±ÊòØ$2^k-2$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; bool notprime[1000005]; vector&lt;int&gt;prime; void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(notprime[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++) notprime[j*i]=true; } } ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } bool s[1000005]; int par[1000005]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } void unite(int x,int y) { x=find(x),y=find(y); if(x==y) return; par[x]=y; } int main() { int t,i,j,k; checkprime(1000000); cin&gt;&gt;t; int num[100005]; while(t--){ int n;cin&gt;&gt;n; int num1=0; int maxn=0; memset(s,0,sizeof(s)); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);s[num[i]]=true; if(num[i]==1)num1++;maxn=max(maxn,num[i]); } for(i=1;i&lt;=maxn;i++)par[i]=i; for(auto a:prime){ int t=0; for(i=1;i*a&lt;=maxn;i++){ if(s[i*a]){ if(!t)t=i*a; else unite(t,i*a); } } } int cnt=1;find(num[1]);set&lt;int&gt;s; for(i=1;i&lt;=n;i++) s.insert(find(num[i])); cnt=s.size(); if(num1&gt;1)cnt+=num1-1; ll ans=mod_pow(2,cnt,mod); ans=(ans-2+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } B.CodeChef - F2NDMAXËøôÈÅìÈ¢òÂÖ∂ÂÆûÊòØ‰∏ÄÂπÖÂõæ‚Ä¶ËÆæÊÉ≥‰∏Ä‰∏ãÔºåÂØπ‰∫é‰∏§‰∏™Êï∞aÔºåbÔºåÂ¶ÇÊûú$a&gt;b$,ÈÇ£‰πà‰ªéaËøûËæπÊåáÂêëbÔºåÈÇ£‰πàÂΩìÊª°Ë∂≥È¢òÊÑèÁöÑËØ¢ÈóÆÂÆåÊàêÂêéÔºåÊàë‰ª¨‰∏ÄÂÆöËÉΩÂæóÂà∞‰∏ÄÂπÖÂõæÔºåÂÖ∂‰∏≠Âè™Êúâ‰∏Ä‰∏™ÁÇπÂÖ•Â∫¶‰∏∫0ÔºåÂç≥ÊúÄÂ§ßÁöÑÈÇ£‰∏™ÁÇπÔºåÈÇ£‰πàÁ¨¨‰∫åÂ§ßÁöÑÁÇπÂ∫îÂΩìÂ∞±ÊòØÂÆÉÁöÑ‰∏Ä‰∏™Áõ¥Êé•ÁöÑÂÑøÂ≠ê„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂÖàÁªüËÆ°ÊâÄÊúâÂÖ•Â∫¶‰∏∫0ÁöÑÁÇπÔºåÂØπ‰∫éËøôcnt‰∏™ÁÇπÔºåÊàë‰ª¨Ëá≥Â∞ëË¶ÅËØ¢ÈóÆcnt-1Ê¨°ÊâçËÉΩÊòéÁ°ÆÂÖ∂‰∏≠ÊúÄÂ§ßÁöÑÊï∞ÔºåÁÑ∂Âêé‰∏∫‰∫Ü‰ΩøÊÄªÊ¨°Êï∞ÊúÄÂ∞ëÔºåÊàë‰ª¨ÊääËøô‰∫õÂÖ•Â∫¶‰∏∫0ÁöÑÁÇπÁöÑÂÑøÂ≠ê‰∏≠ÂΩìÂâçÂÖ•Â∫¶‰∏∫1ÁöÑÊï∞Èáè‰∏¢Ëøõ‰∏Ä‰∏™Â∞èÊ†πÂ†ÜÔºåÁÑ∂ÂêéÊØèÊ¨°ËØ¢ÈóÆÈÉΩÂ∫îÂΩìÊâæÂá∫Â†ÜÈ°∂ÊúÄÂ§ßÁöÑ‰∏§‰∏™Êï∞aÔºåbÔºåÈÇ£‰πàËá≥Â∞ëË¶ÅËØ¢ÈóÆmax(a,b)+1Ê¨°ÊâçËÉΩÊâæÂá∫ÂêàÂπ∂Ëøô‰∏§ÁªÑ‰πãÂêéÁ¨¨‰∫åÂ§ßÁöÑÊï∞„ÄÇÔºà‰ºº‰πéÊúâÁÇπÊ∑∑‰π±ÔºüÔºâ #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn=3e5+5; int indegree[maxn], outdegree[maxn]; int main() { int t; cin &gt;&gt; t; int n,m,i,j,k; while(t--){ cin &gt;&gt; n &gt;&gt; m; memset(indegree, 0, sizeof(indegree));memset(outdegree, 0, sizeof(outdegree)); vector&lt;int&gt; adj[maxn]; while(m--) { int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adj[u].push_back(v); indegree[v]++; } for(i=1; i&lt;=n; i++) for(auto j : adj[i]) outdegree[i]+=(indegree[j]==1); int cnt=0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; for(i=1; i&lt;=n; i++) { cnt+=indegree[i]==0?1:0; if(!indegree[i]) que.push(outdegree[i]); } cnt--; while(que.size()&gt;1) { int a=que.top();que.pop(); int b=que.top();que.pop(); que.push(max(a, b)+1); } cout &lt;&lt; cnt+que.top()-1 &lt;&lt; endl; } return 0; } J.CodeChef - RINÈ¶ñÂÖàÔºåÊàë‰ª¨ÊääÂàÜÊï∞ËøõË°åËΩ¨ÂåñÔºåÂæóÂà∞ÁöÑÂàÜÊï∞ÂèòÊàê100-ÂæóÂà∞ÁöÑÂàÜÊï∞Ôºå‰πüÂ∞±ÊòØ‰∫èÊçüÁöÑÂàÜÊï∞„ÄÇÂ¶ÇÊûúÂàÜÊï∞ÊòØ-1ÈÇ£‰πà‰∫èÊçüÊó†ÈôêÂ§ß„ÄÇÈÇ£‰πàÊàë‰ª¨ÁöÑÈóÆÈ¢òÂÖ∂ÂÆûÂ∞±ÂèòÊàê‰∫ÜÂ¶Ç‰ΩïÈÄâÊã©‰ΩøÂæó‰∫èÊçüÂ∞ΩÂèØËÉΩÁöÑÂ∞è„ÄÇÊàë‰ª¨ÊääÊØè‰∏™ËØæÁöÑÊØè‰∏™Â≠¶ÊúüÈÉΩÂª∫ÊàêÁÇπÔºå‰ªéÊ∫êÁÇπÂêëÊâÄÊúâËØæÁöÑÁ¨¨‰∏ÄÂ≠¶ÊúüËøûÊùÉÂÄº‰∏∫ËØ•‰∫èÊçüÁöÑËØæÔºå‰ªéÁ¨¨‰∏ÄÂ≠¶ÊúüÂêëÁ¨¨‰∫åÂ≠¶ÊúüËøûÁ¨¨‰∫åÂ≠¶Êúü‰∫èÊçüÁöÑËØæ‚Ä¶‰æùÊ¨°Á±ªÊé®ÔºåÊúÄÂêé‰∏ÄÂ≠¶ÊúüÂêëÊ±áÁÇπËøûÂÆπÈáèÊó†Á©∑ÁöÑËæπ„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûú‰∏çËÄÉËôëÂâçÁΩÆËØæÁ®ãÁöÑË¶ÅÊ±ÇÔºåÊàë‰ª¨Áé∞Âú®ÁöÑÈóÆÈ¢òÂÖ∂ÂÆûÂ∞±ÊòØÂú®Ê±ÇÂõæÁöÑÊúÄÂ∞èÂâ≤„ÄÇ ËÄÉËôëÂà∞ÂâçÁΩÆËØæÁ®ãÔºåÂÅáËÆæaÊòØbÁöÑÂâçÁΩÆËØæÁ®ãÔºåÈÇ£‰πàÂØπ‰∫éaÁöÑÊØè‰∏™Â≠¶ÊúüÔºåÊàë‰ª¨ÈÉΩÂêëbÁöÑ‰∏ã‰∏ÄÂ≠¶ÊúüËøû‰∏ÄÊù°Êó†ÈôêÁöÑËæπÁ°Æ‰øùbÁöÑÂâ≤‰∏ç‰ºöÂèëÁîüÂú®a‰πãÂâç„ÄÇÊ≥®ÊÑèÁöÑÊòØbÁöÑÁ¨¨‰∏ÄÂ≠¶ÊúüÁöÑËÇØÂÆö‰∏çËÉΩÈÄâÁöÑÔºåÂõ†Ê≠§‰ªéÊ∫êÁÇπÂêëËØ•Â≠¶ÊúüËøûÊùÉÂÄºINFÁöÑËæπ„ÄÇ Á≠îÊ°àÂ∞±ÊòØ$(n* 100-maxflow)/n$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e4+50; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0;//Â∞èÂøÉÁàÜint for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//Ê≥®ÊÑèÂ¶ÇÊûúÁàÜintËøôÈáåÂàùÂßãÊúÄÂ§ßÂÄºË¶ÅÊõ¥ÊîπÊúÄÂ§ßÂÄº flow+=f; } } int main() { int n,m,k,i,j; int x[105][105]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ int mar; scanf(&quot;%d&quot;,&amp;mar); if(mar==-1)x[i][j]=1&lt;&lt;30; else x[i][j]=100-mar; } for(i=1;i&lt;=n;i++){ addedge(0,(i-1)*m+1,x[i][1]); for(j=2;j&lt;=m;j++){ addedge((i-1)*m+j-1,(i-1)*m+j,x[i][j]); } addedge((i-1)*m+m,10005,1&lt;&lt;30); } while(k--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(i=1;i&lt;m;i++) addedge((a-1)*m+i,(b-1)*m+i+1,1&lt;&lt;30); addedge(0,(b-1)*m+1,1&lt;&lt;30); //addedge((a-1)*m+m,10005,1&lt;&lt;30); } double ans=n*100-maxflow(0,10005); printf(&quot;%.2f\n&quot;,ans/n); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 48 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-48-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.ÊòéÊòæÁ≠æÂà∞ÔºåÈöè‰æøÂÜô #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; ll pre=0; long long sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;sum+=j; ll d=sum/m;;cout&lt;&lt;d-pre&lt;&lt;&apos; &apos;; pre=d; } return 0; } B.Ê≠£Ëß£Â∫îËØ•ÊòØÊÉ≥ËÆ©‰Ω†È¢ÑÂ§ÑÁêÜÂ≠óÁ¨¶‰∏≤ÂåπÈÖçÔºåÁÑ∂ÂêéÊêû‰∏™ÂâçÁºÄÂíåÂéªÂØπ‰ªòÊØè‰∏™ËØ¢ÈóÆ„ÄÇÁÑ∂ËÄå‰∏≤ÂÆûÂú®Â§™Áü≠‰∫Ü‰ª•Ëá≥‰∫éÂØπ‰∫éÊØèÊ¨°ËØ¢ÈóÆÊö¥ÂäõkmpÂ∞±ÂèØ‰ª•ËΩªÊùæËøá„ÄÇ Êö¥ÂäõkmpÔºö #include&lt;bits/stdc++.h&gt; using namespace std; int next1[1000005]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); while(q--) { int cnt=0; int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); string str3=str1.substr(l-1,r-l+1); int i = 0, j = 0; while (i &lt; str3.size()) { if (j == -1 || str3[i] == str2[j]) { if (j == str2.size() - 1) { cnt++;j = next1[j]; continue; } i++;j++; } else { while (j &gt;= 0 &amp;&amp; str2[j] != str3[i]) j = next1[j]; } } printf(&quot;%d\n&quot;,cnt); } return 0; } È¢ÑÂ§ÑÁêÜÂâçÁºÄÂíåÁâàÔºö(Êï∞ÊçÆÊúâÂùëÔºå‰∏ç‰øùËØÅl&gt;=1) #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; int next1[1050]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int sum[1050]; int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); int i=0,j=0; while(i&lt;str1.size()){ if(j==-1||str1[i]==str2[j]){ if(j==str2.size()-1){ sum[i-str2.size()+2]++; j=next1[j];continue; } i++;j++; } else{ while(j&gt;=0&amp;&amp;str2[j]!=str1[i]) j=next1[j]; } } for(i=1;i&lt;=1000;i++)sum[i]+=sum[i-1]; int len=str2.size(); while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(r-len+1&gt;=l&amp;&amp;l&gt;=1) printf(&quot;%d\n&quot;,sum[r-len+1]-sum[l-1]); else printf(&quot;0\n&quot;); } return 0; } C.ÂÖ∂ÂÆûÂ∞±ÊòØ‰∏Ä‰∏™Â§çÊùÇÁâàÁöÑÂâçÁºÄÂíåÈóÆÈ¢ò„ÄÇÊàë‰ª¨‰ºöÂèëÁé∞ÂÖ∂ÂÆûËµ∞ÁöÑÊñπÊ≥ïÂ∞±ÊòØÊ†∑‰æãÈáåÁöÑÈÇ£‰∏§ÁßçÔºåÂΩìÁÑ∂Á¨¨‰∏ÄÁßçÂèØ‰ª•ÂÖàËµ∞‰∏ãÈù¢ÂÜçËµ∞‰∏äÈù¢„ÄÇÊúÄÂêéÁöÑÁªìÊûú‰∏ÄÂÆöÊòØÂÖàËµ∞Á¨¨‰∫åÁßçÁÑ∂ÂêéËµ∞Á¨¨‰∏ÄÁßç‰∏≠ÁöÑ‰∏ÄÁßç„ÄÇÈÇ£‰πàÊàë‰ª¨Â∞±ÂèØ‰ª•È¢ÑÂ§ÑÁêÜÊØèÁßçËµ∞Ê≥ïÁöÑÂâçÁºÄÂíå„ÄÇÁ¨¨‰∫åÁßçÊòæÁÑ∂‰ªéÂ∑¶ÂæÄÂè≥ÈÄíÊé®Ëµ∞Âà∞ÊØè‰∏™‰ΩçÁΩÆÁöÑÂâçÁºÄÂíåÂç≥ÂèØ„ÄÇËÄåÁ¨¨‰∏ÄÁßçÂàôË¶ÅÂàÜ‰∏ä‰∏ãËÆ®ËÆ∫ÔºåÂπ∂‰∏î‰ªé‰∏çÂêåÁöÑÂàóÂºÄÂßãÁ¨¨‰∏ÄÁßçÔºå‰ªñÂêéÈù¢ÁöÑÂâçÁºÄÂíåËøòË¶ÅÂä†‰∏äËµ∞Á¨¨‰∫åÁßçÁöÑÊó∂ÂÄôÊâÄÂ∏¶Êù•ÁöÑÁ≥ªÊï∞(sum3). sum1ÊòØÁ¨¨‰∫åÁßçÁöÑÂâçÁºÄÂíåÔºåsum2Ôºåsum4ÊòØÁ¨¨‰∏ÄÁßçÁöÑ‰∏§ÁßçÂâçÁºÄÂíå„ÄÇ ÊúÄÂêéÊûö‰∏æÊØè‰∏™‰ΩçÁΩÆ‰∏∫Á¨¨‰∫åÔºåÁ¨¨‰∏ÄÁßçÁöÑÂàÜÁïåÁÇπÊ±ÇÊúÄÂÄºÂç≥ÂèØ„ÄÇ Ê≥®ÊÑèÔºöÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÁ≥ªÊï∞ÊòØ0‰∏çÊòØ1ÔºÅ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+5; ll sum1[maxn],sum2[maxn],a[maxn],b[maxn],sum3[maxn],sum4[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]); for(i=1;i&lt;=n;i++){ //ll t=0; if(i&amp;1){ sum1[i]=(i*2-2)*a[i]+(i*2-1)*b[i]; } else{ sum1[i]=(i*2-2)*b[i]+(i*2-1)*a[i]; } sum1[i]+=sum1[i-1]; } for(i=n;~i;i--){ sum3[i]+=a[i]+b[i]; sum3[i]+=sum3[i+1]; } for(i=n;i;i--){ sum2[i]+=sum2[i+1]+sum3[i+1]; sum2[i]+=b[i]*((n-i+1)*2-1); sum4[i]+=sum4[i+1]+sum3[i+1]; sum4[i]+=a[i]*((n-i+1)*2-1); } ll ans=0; // for(i=1;i&lt;=n;i++) // cout&lt;&lt;sum2[i]&lt;&lt;&apos; &apos;&lt;&lt;sum4[i]&lt;&lt;endl; for(i=0;i&lt;=n;i++){ ll t=sum1[i]; if(i&amp;1){ t+=sum4[i+1]+sum3[i+1]*(i)*2; } else t+=sum2[i+1]+sum3[i+1]*i*2; ans=max(ans,t); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.ÂÖ∂ÂÆûÂè™Ë¶Å$a_1\oplus a_2\oplus ‚Ä¶a_n=b_1\oplus b_2\oplus‚Ä¶b_n$Â∞±ÊòØ‰∏ÄÂÆöÂèØ‰ª•ÁöÑ„ÄÇ ÁÑ∂ÂêéÈô§‰∫ÜÊúÄÂêé‰∏ÄÂàóÂèäÊúÄÂêé‰∏ÄË°å‰πãÂ§ñÁöÑÊâÄÊúâ‰ΩçÁΩÆÂÖ∂ÂÆûÈÉΩÂèØ‰ª•Èöè‰æøÊîæ„ÄÇÊ†πÊçÆÊîæÁöÑÊÉÖÂÜµÊé®ÊúÄÂêé‰∏ÄË°åÊúÄÂêé‰∏ÄÂàóÂç≥ÂèØ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int ma[105][105]; int a[105],b[106]; int main() { int n,m,i,j,k,sum1=0,sum2=0; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum1^=a[i]; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;b[i]);sum2^=b[i]; } if(sum1!=sum2){ puts(&quot;NO&quot;);return 0; } for(i=1;i&lt;n;i++){ for(j=1;j&lt;m;j++){ ma[i][j]=1; } if((m-1)&amp;1) sum1=1; else sum1=0; ma[i][m]=a[i]^sum1; } for(i=1;i&lt;=m;i++){ sum1=0; for(j=1;j&lt;n;j++) sum1^=ma[j][i]; ma[j][i]=b[i]^sum1; } puts(&quot;YES&quot;); for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,ma[i][j],j==m?&apos;\n&apos;:&apos; &apos;); } //cout&lt;&lt;(4^2^15)&lt;&lt;&apos; &apos;&lt;&lt;(2^15)&lt;&lt;endl; return 0; } E.ÂØπ‰∫éÊØè‰∏™ÁÇπÔºåÊàë‰ª¨ËøûÊé•ÂÆÉ‰∏éa,b. Ëøô‰∏§Êù°Á∫ø‰∏éxËΩ¥ÁöÑ‰∫§ÁÇπÂèØ‰ª•ÊûÑÊàê‰∏ÄÊù°Á∫øÊÆµlenÔºåÈÇ£‰πàÔºåËøô‰∏™ÁÇπÂú®shade‰∏≠ÁöÑÊó∂ÈïøÂ∞±ÊòØÔºö |len‰∏≠Ê†ÖÊ†èÁöÑÈïøÂ∫¶|* |abÁöÑÈïøÂ∫¶|/|lenÁöÑÈïøÂ∫¶| ËÆ°ÁÆó‰∏≠Áî®lowerboundÊâæÁõ∏‰∫§ÁÇπÔºåÁÑ∂ÂêéÁî®Áõ∏‰ºº‰∏âËßíÂΩ¢Ê±ÇËß£„ÄÇ ‰ª£Á†Å‰∏≠Áî® |Âè≥Á´ØÁÇπÁöÑÊ†ÖÊ†èÂâçÁºÄÂíå|-|Â∑¶Á´ØÁÇπÁöÑÊ†ÖÊ†èÂâçÁºÄÂíå| Ê±ÇËß£Ê†ÖÊ†èÈïøÂ∫¶„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;double&gt;v; const int maxn=2e5+5; double s[maxn]; int main() { double sy,a,b,l[maxn],r[maxn]; int n,i,j,k,q; scanf(&quot;%lf%lf%lf&quot;,&amp;sy,&amp;a,&amp;b); cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf&quot;,&amp;l[i],&amp;r[i]);s[i]+=s[i-1]+r[i]-l[i];//s‰∏∫È¢ÑÂ§ÑÁêÜÁöÑÊ†ÖÊ†èÈïøÁöÑÂâçÁºÄÂíå v.push_back(l[i]);v.push_back(r[i]); } cin&gt;&gt;q; while(q--){ double x,y;scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); double pos=a-sy/(y-sy)*(x-a);//Âà©Áî®Áõ∏‰ºº‰∏âËßíÂΩ¢Ê±ÇÁ∫ø‰∏éxËΩ¥ÁöÑ‰∫§ÁÇπ int p=lower_bound(v.begin(),v.end(),pos)-v.begin();//Ê±Ç‰∫§ÁÇπËêΩÂú®Âì™‰∏™‰ΩçÁΩÆ double ans=-s[p/2];//Â∑¶Á´ØÁÇπÂâçÁºÄÂíå,Ë¶ÅÂáèÂéªÊâÄ‰ª•Â∏¶Ë¥üÂè∑ if(p&amp;1)ans-=pos-v[p-1];//Â¶ÇÊûú‰∫§ÁÇπÂú®Âú®Ê†ÖÊ†è‰∏≠Èó¥,ÈÇ£‰πàËøô‰∏™Ê†ÖÊ†èÂú®‰∫§ÁÇπÂ∑¶ËæπÁöÑ‰∏ÄÈÉ®ÂàÜ‰πüÊòØË¶ÅÂáèÂéªÁöÑ pos=b-sy/(y-sy)*(x-b); p=lower_bound(v.begin(),v.end(),pos)-v.begin(); ans+=s[p/2]; if(p&amp;1)ans+=pos-v[p-1];//ÂêåÁêÜÁÆóÂè≥Á´ØÁÇπ ans=ans/y*(y-sy); printf(&quot;%.7f\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúÄÂ§ßÊùÉÈó≠ÂêàÂõæ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-9d-83-e9-97-ad-e5-90-88-e5-9b-be%2F</url>
    <content type="text"><![CDATA[ÊâÄË∞ìÈó≠ÂêàÂõæÔºåÊåáÁöÑÊòØÂõæ‰∏≠ÊØè‰∏™ÁÇπÁöÑÂêéÁª≠ÈÉΩÂú®Âõæ‰∏≠„ÄÇÊúÄÂ§ßÊùÉÈó≠ÂêàÂõæÔºåÊåáÁöÑÊòØÁÇπÁöÑÊùÉÂÄº‰πãÂíåÊúÄÂ§ßÁöÑÈó≠ÂêàÂõæ„ÄÇ ÊúÄÂ§ßÊùÉÈó≠ÂêàÂõæÁöÑÊ±ÇËß£ÊñπÊ≥ï1.ÂÖàÊûÑÈÄ†ÁΩëÁªúÊµÅNÔºåÊ∑ªÂä†Ê∫êÁÇπsÔºå‰ªésÂà∞Ê≠£ÊùÉÂÄºÁÇπÂÅö‰∏ÄÊù°ËæπÔºåÂÆπÈáè‰∏∫ÁÇπÁöÑÊùÉÂÄº„ÄÇ 2.Ê∑ªÂä†Ê±áÁÇπtÔºå‰ªéË¥üÊùÉÂÄºÁÇπÂà∞tÂÅö‰∏ÄÊù°ËæπÔºåÂÆπÈáè‰∏∫ÁÇπÁöÑÊùÉÂÄºÁöÑÁªùÂØπÂÄº„ÄÇ 3.ÂéüÊù•ÁöÑËæπÁöÑÂÆπÈáèÁªüÁªüËÆæ‰∏∫Êó†Á©∑Â§ß 4.Ê±ÇËß£ÊúÄÂ∞èÂâ≤ÔºåÊúÄÂ§ßÊùÉ=Ê≠£ÊùÉÂÄº‰πãÂíå-ÊúÄÂ∞èÂâ≤ÊùÉÂÄº 5.ÊúÄÂ∞èÂâ≤ÊâÄ‰∫ßÁîüÁöÑ‰∏§‰∏™ÈõÜÂêà‰∏≠ÔºåÂÖ∂Ê∫êÁÇπSÊâÄÂú®ÈõÜÂêà(Èô§ÂéªS)‰∏∫ÊúÄÂ§ßÊùÉÈó≠ÂêàÂõæ„ÄÇÔºà‰πüÂ∞±ÊòØPOJ2987ÊâÄÊ±ÇÁöÑË£ÅÂëòÔºâ EX:POJ2987 ÂÖ¨Âè∏ÂÆòÂÉöÊàêÈ£éÔºåÁõòÊ†πÈîôËäÇÔºåÂäûÂÆû‰∫ãÁöÑÁ†ÅÂÜúÊ≤°Âá†‰∏™„ÄÇËÄÅÊùøÂÜ≥ÂÆöÂ§ßË£ÅÂëòÔºåÊØèÂºÄÈô§‰∏Ä‰∏™‰∫∫ÔºåÂêåÊó∂Ë¶ÅÂ∞ÜÂÖ∂‰∏ãÂ±û‰∏ÄÂπ∂ÂºÄÈô§ÔºåÂ¶ÇÊûúËØ•‰∏ãÂ±ûËøòÊúâ‰∏ãÂ±ûÔºåÁÖßÊñ©‰∏çËØØ„ÄÇÁªôÂá∫ÊØè‰∏™‰∫∫ÁöÑË¥°ÁåÆÂÄºÔºàÂèØ‰∏∫Ë¥üÔºâÂíå‰ªéÂ±ûÂÖ≥Á≥ªÔºåÊ±ÇÊúÄÂ∞èË£ÅÂëòÊï∞ÂèäÊúÄÂ§ßË¥°ÁåÆÂÄºÂíå„ÄÇ Ê®°ÊùøÈ¢òÔºåËÆ∞ÂæóÂºÄlonglongÂç≥ÂèØ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } long long maxflow(int s,int t){ long long flow=0;//Â∞èÂøÉÁàÜint for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//Ê≥®ÊÑèÂ¶ÇÊûúÁàÜintËøôÈáåÂàùÂßãÊúÄÂ§ßÂÄºË¶ÅÊõ¥ÊîπÊúÄÂ§ßÂÄº flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúÄÂ∞èË¥πÁî®ÊµÅ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b4-b9-e7-94-a8-e6-b5-81%2F</url>
    <content type="text"><![CDATA[ÊúÄÂ§ßÊµÅ+SPFA #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,cost,rev;//ÁªàÁÇπ,ÂÆπÈáè,Ë¥πÁî®,ÂèçÂêëËæπ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//ÊúÄÁü≠Ë∑Ø‰∏≠ÂâçÈ©±ËäÇÁÇπÂíåÂØπÂ∫îÁöÑËæπ, // Â∞èÂøÉcostÁàÜint,Â§öÁªÑÊï∞ÊçÆÊó∂ËÆ∞ÂæóÊ∏ÖÈõ∂ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//Ê≥®ÊÑèÂèçÂêëËæπÁöÑÂä†Ê≥ï!!-costÂíåcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//Â∞èÂøÉÁàÜintÁöÑÊÉÖÂÜµ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//ÂÖ®ÊúÄÁü≠Ë∑Ø‰∏≠ÁöÑÊúÄÂ∞èÊµÅÈáèÈôêÂà∂Â∞±ÊòØÊú¨Ê¨°ÊÄªÁöÑÊµÅÈáèÈôêÂà∂ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//Êõ¥Êñ∞Ë∑ØÂæÑ‰ø°ÊÅØ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int a,b,c,d; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); add(a,b,c,d); } mincostmaxflow(s,t); cout&lt;&lt;flow&lt;&lt;&apos; &apos;&lt;&lt;cost&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊúÄÂ§ßÊµÅ‰∏é‰∫åÂàÜÂõæÁöÑ‰∏Ä‰∫õÁªìËÆ∫]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-b5-81-e4-b8-8e-e4-ba-8c-e5-88-86-e5-9b-be-e7-9a-84-e4-b8-80-e4-ba-9b-e7-bb-93-e8-ae-ba%2F</url>
    <content type="text"><![CDATA[ÂåπÈÖçÔºåËæπË¶ÜÁõñÔºåÁã¨Á´ãÈõÜÂêàÈ°∂ÁÇπË¶ÜÁõñÊ¶ÇÂøµÔºö$V$ÔºöÂÖ®ÈõÜ ÂåπÈÖç‚Äî‚ÄîÂú®Âõæ‰∏≠‰∏§‰∏§Ê≤°ÊúâÂÖ¨ÂÖ±È°∂ÁÇπÁöÑËæπÁöÑÈõÜÂêà Ê≥®ÊÑèÔºåÂõæ‰∏≠ÁöÑÂåπÈÖçÊúâÂæàÂ§öÔºå‰∏ÄÊù°Ëæπ‰πüÂèØ‰ª•ÁÆó‰∏Ä‰∏™ÂåπÈÖç„ÄÇ‰ΩÜÊòØÊúÄÂ§ßÂåπÈÖçÂç¥ÊòØÂèØ‰ª•Á°ÆÂÆöÁöÑ„ÄÇÊúÄÂ§ßÂåπÈÖç‰πüÂ∞±ÊòØË¶ÅËÆ©ÈÄâÂá∫Â∞ΩÂèØËÉΩÂ§öÁöÑËæπ‰ΩøÂæóÂÆÉ‰ª¨‰∏§‰∏§‰πãÈó¥ÈÉΩÊ≤°Êúâ‰∫§ÁÇπÔºàÁ´ØÁÇπÔºâ„ÄÇ ËæπË¶ÜÁõñ‚Äî‚ÄîÂõæ‰∏≠ÁöÑ‰ªªÊÑèÈ°∂ÁÇπÈÉΩËá≥Â∞ëÊòØÈõÜÂêà$F$‰∏≠ÊüêÊù°ËæπÁöÑÁöÑÁ´ØÁÇπÔºåÊª°Ë∂≥ËøôÊ†∑Êù°‰ª∂ÁöÑÈõÜÂêàÁöÑÊúÄÂ∞ëÁöÑËæπÁöÑÈõÜÂêà$F$Áß∞‰∏∫ÊúÄÂ∞èËæπË¶ÜÁõñ Áã¨Á´ãÈõÜ‚Äî‚ÄîÂú®Âõæ‰∏≠‰∏§‰∏§‰∏çÁõ∏ËøûÁöÑÈ°∂ÁÇπÈõÜÂêà ÊØîÂ¶Ç‰∏ÄÊù°Ëæπ$S$ÁöÑÈ°∂ÁÇπÊòØ$S_a,S_b$,ÈÇ£‰πàËøô‰∏§‰∏™ÁÇπÂ∞±‰∏çËÉΩÂêåÊó∂Âú®‰∏Ä‰∏™Áã¨Á´ãÈõÜ‰∏≠„ÄÇ‰∫ãÂÆû‰∏äÔºåÁã¨Á´ãÈõÜ‰∏≠ÁöÑ‰ªªÊÑè‰∏§‰∏™ÁÇπ‰πãÈó¥ÈÉΩ‰∏çÂ≠òÂú®ÊúâËæπ‰πãÈó¥Áõ∏Ëøû„ÄÇ È°∂ÁÇπË¶ÜÁõñ‚Äî‚ÄîÂõæ‰∏≠ÁöÑ‰ªªÊÑèËæπÈÉΩËá≥Â∞ëÊúâ‰∏Ä‰∏™Á´ØÁÇπÂ±û‰∫éÈõÜÂêà$S$ÁöÑÈõÜÂêàÂè´ÂÅöÈ°∂ÁÇπË¶ÜÁõñ ÁªìËÆ∫(a)ÂØπ‰∫é‰∏çÂ≠òÂú®Â≠§Á´ãÁÇπÁöÑÂõæÔºå|ÊúÄÂ§ßÂåπÈÖç|+|ÊúÄÂ∞èËæπË¶ÜÁõñ|=|$V$|ÔºàËæπÁöÑÂÖ®ÈõÜÔºâÔºàÂç≥‰ªªÊÑè‰∏Ä‰∏™È°∂ÁÇπÈÉΩËá≥Â∞ëÂú®ÊüêÊù°Ëæπ‰∏≠Ôºâ ÔºàbÔºâ|ÊúÄÂ§ßÁã¨Á´ãÈõÜ|+|ÊúÄÂ∞èÈ°∂ÁÇπË¶ÜÁõñ|=|$V$|ÔºàÁÇπÁöÑÂÖ®ÈõÜÔºâ ÔºàcÔºâÂú®‰∫åÂàÜÂõæ‰∏≠ÔºåÊúâÔºö|ÊúÄÂ§ßÂåπÈÖç|=|ÊúÄÂ∞èÈ°∂ÁÇπË¶ÜÁõñ|ÔºàÂèØÁî®‰∫éÊ±ÇËß£‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÁã¨Á´ãÈõÜÂíåÊúÄÂ∞èÈ°∂ÁÇπË¶ÜÁõñÔºâ ÔºàdÔºâ|ÂõæÁöÑÊúÄÂ§ßÊµÅ|=|ÂõæÁöÑÊúÄÂ∞èÂâ≤|ÔºàÂõæÊúâÊ∫êÊ±áÔºâ]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÁΩëÁªúÊµÅÊúÄÂ§ßÊµÅ(Dinic)]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-bd-91-e7-bb-9c-e6-b5-81-e6-9c-80-e5-a4-a7-e6-b5-81dinic%2F</url>
    <content type="text"><![CDATA[Ê®°ÊùøÁªìËÆ∫ÔºöÂõæÁöÑÊúÄÂ∞èÂâ≤=ÂõæÁöÑÊúÄÂ§ßÊµÅÔºàÊúÄÂ§ßÊµÅÊúÄÂ∞èÂâ≤ÂÆöÁêÜÔºâÔºàÂõæÊòØÊúâÊ∫êÊ±áÁöÑÔºâ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//ÂèçÂêëÂÆπÈáè‰∏∫0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//Ê≥®ÊÑè‰º†ÂºïÁî®! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//‰∏çË¶ÅÊºè‰∫ÜËøô‰∏™,ÂæàÂ§öÊó∂ÂÄôÂèØËÉΩÊòØÊó†Ê≥ïÂ¢ûÂπøÁöÑ } int maxflow(int s,int t){ int flow=0;//Â∞èÂøÉÁàÜint for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//Ê≥®ÊÑèÂ¶ÇÊûúÁàÜintËøôÈáåÂàùÂßãÊúÄÂ§ßÂÄºË¶ÅÊõ¥ÊîπÊúÄÂ§ßÂÄº flow+=f; } } int main() { return 0; }]]></content>
      <categories>
        <category>ÁΩëÁªúÊµÅ</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂõæËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÂõæËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÂêéÁºÄÊï∞ÁªÑ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-90-8e-e7-bc-80-e6-95-b0-e7-bb-84%2F</url>
    <content type="text"><![CDATA[ÂÆö‰πâÂ≠óÁ¨¶‰∏≤$s$ËøûÁª≠ÁöÑ‰∏ÄÊÆµÂ≠óÁ¨¶ÁªÑÊàêÁöÑ‰∏≤Âè´ÂÅöÂ≠óÁ¨¶‰∏≤ÔºåÊõ¥Âπø‰πâÂú∞Ôºå‰ªª‰Ωï‰∏Ä‰∏™Áî±ÂèØÊØîËæÉÂ§ßÂ∞èÁöÑÂÖÉÁ¥†ÁªÑÊàêÁöÑÊï∞ÁªÑÈÉΩÂèØÁß∞‰∏∫Â≠óÁ¨¶‰∏≤„ÄÇÂ≠óÁ¨¶‰∏≤ÁöÑ‰∏ãÊ†á‰ªé 1ÂºÄÂßãÔºåÈïøÂ∫¶‰∏∫$length(s)$ „ÄÇ ÂêéÁºÄÔºö $suffix(i)$Ë°®Á§∫Â≠óÁ¨¶‰∏≤$s$‰ªéÁ¨¨$i$‰∏™‰ΩçÁΩÆÂºÄÂßãÁöÑÂêéÁºÄÔºåÂç≥Áî± $s[i]-s[n] $ÁªÑÊàêÁöÑÂ≠ê‰∏≤„ÄÇ Â≠óÁ¨¶‰∏≤ÁöÑÊØîËæÉÔºö ‰∏§‰∏™Â≠óÁ¨¶‰∏≤Â§ßÂ∞èÁöÑÊØîËæÉÔºå‰ªéÈ¶ñ‰ΩçÂºÄÂßãÔºå‰∏Ä‰Ωç‰∏Ä‰ΩçÂú∞ÊåâÁÖß ASCII Á†ÅÊØîËæÉÔºåÂ¶ÇÊûú‰ªéÊüê‰ΩçÁΩÆÂºÄÂßã‰∏çÁõ∏ÂêåÔºåÂàôËÆ§‰∏∫ËØ•‰ΩçÁΩÆÂ§ÑÂ≠óÁ¨¶ ASCII Á†ÅÂ∞èÁöÑÂ≠óÁ¨¶‰∏≤Â∞èÔºõ Â¶ÇÊûú‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊØîËæÉÂÆå‰∫ÜÊúÄÂêé‰∏Ä‰ΩçÔºåËÄåÂè¶‰∏Ä‰∏™Ê≤°ÊúâÔºåÂàôËÆ§‰∏∫ÂâçËÄÖÔºàÈïøÂ∫¶Â∞èÁöÑÔºâÂ∞èÔºõ Â¶ÇÊûú‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶Áõ∏ÂêåÂπ∂‰∏îÊâÄÊúâ‰ΩçÁΩÆ‰∏äÁöÑÂ≠óÁ¨¶ÂùáÁõ∏ÂêåÔºåÂàôËÆ§‰∏∫‰∏§‰∏™Â≠óÁ¨¶‰∏≤Áõ∏Á≠â„ÄÇ Ê≥®ÊÑèÔºåÂêå‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑ‰∏§‰∏™ÂêéÁºÄÊòØ‰∏çÂèØËÉΩÁõ∏Á≠âÁöÑÔºåÂõ†‰∏∫Êó†Ê≥ïÊª°Ë∂≥Áõ∏Á≠âÁöÑÂøÖË¶ÅÊù°‰ª∂ÈïøÂ∫¶Áõ∏Âêå„ÄÇ ÂêéÁºÄÊï∞ÁªÑÔºö $sa$ÊòØ‰∏Ä‰∏™‰∏ÄÁª¥Êï∞ÁªÑÔºå‰øùÂ≠ò‰∫ÜÂØπÂ≠óÁ¨¶‰∏≤$s$ÁöÑÊâÄÊúâÂêéÁºÄÊéíÂ∫èÂêéÁöÑÁªìÊûú„ÄÇ Ë°®Á§∫Á¨¨$i$Â∞èÁöÑÂêéÁºÄÂú®Âéü‰∏≤‰∏≠ÁöÑËµ∑Âßã‰ΩçÁΩÆ„ÄÇ ÂêçÊ¨°Êï∞ÁªÑÔºö $rank$ÊòØ‰∏Ä‰∏™‰∏ÄÁª¥Êï∞ÁªÑÔºåÊåâËµ∑Âßã‰ΩçÁΩÆ‰øùÂ≠ò‰∫ÜÊØè‰∏™ÂêéÁºÄÂú® $sa$‰∏≠ÁöÑÊéíÂêç„ÄÇ Ë°®Á§∫$suffix(i)$ÁöÑÊéíÂêçÔºåÂç≥ $rank[sa[i]]=i$ÔºàÁ¨¨$i$Â∞èÁöÑÂêéÁºÄÁöÑÊéíÂêç‰∏∫$i$Ôºâ„ÄÇ È´òÂ∫¶Êï∞ÁªÑÔºö ÊòØ‰∏Ä‰∏™‰∏ÄÁª¥Êï∞ÁªÑÔºå‰øùÂ≠ò‰∫ÜÁõ∏ÈÇª‰∏§‰∏™ÂêéÁºÄÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄÔºàLongest Common PrefixÔºåLCPÔºâÈïøÂ∫¶„ÄÇ $height[i]=LCP(suffix(sa[i]),suffix[sa[i-1]))$(i&gt;0) Âç≥$height[i]$Ë°®Á§∫Âú®‰ΩçÁΩÆ$i$Â≠òÂú®ÊúÄÂ§ßÁöÑ$x$,Êª°Ë∂≥$\forall k \in [0,x)$Êúâ$s[sa[i]+k]=s[sa[i-1]+k]$ ÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄ ÈÄöËøáÈ´òÂ∫¶Êï∞ÁªÑ$height$ ÔºåÊàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÊéíÂêçÁõ∏ÈÇªÁöÑ‰∏§‰∏™ÂêéÁºÄÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄ„ÄÇ ÂØπ‰∫éÊéíÂêç‰∏çÁõ∏ÈÇªÁöÑ‰∏§‰∏™ÂêéÁºÄÔºåÂÆÉ‰ª¨ÁöÑÂâçÁºÄÁöÑÁõ∏‰ººÊÄßÊØîÁõ∏ÈÇªÂêéÁºÄË¶ÅÂ∑Æ„ÄÇÊòæÁÑ∂ÊéíÂêç‰∏çÁõ∏ÈÇªÁöÑ‰∏§‰∏™ÂêéÁºÄÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄÈïøÂ∫¶‰∏ÄÂÆö‰∏ç‰ºöÊØîËøô‰∏§‰∏™ÂêéÁºÄÂú®ÂêéÁºÄÊï∞ÁªÑ‰∏≠Á°ÆÂÆöÁöÑ‰∏ÄÊÆµÂå∫Èó¥‰∏≠‰ªªÊÑè‰∏§‰∏™Áõ∏ÈÇªÂêéÁºÄÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄÈïøÂ∫¶Êõ¥Èïø„ÄÇ ÊâÄ‰ª•ÔºåÊ±ÇÂá∫ËøôÊÆµÂå∫Èó¥ÂÜÖÊúÄÂ∞èÁöÑ$height$ÂÄºÂç≥‰∏∫Ëøô‰∏§‰∏™‰∏çÁõ∏ÈÇªÂêéÁºÄÁöÑÊúÄÈïøÂÖ¨ÂÖ±ÂâçÁºÄÈïøÂ∫¶„ÄÇ ÈóÆÈ¢òËΩ¨Âåñ‰∏∫Âå∫Èó¥ÊúÄÂÄºÊü•ËØ¢ÔºàRange Minimum/Maximum QueryÔºåRMQÔºâÈóÆÈ¢òÔºåÂèØ‰ª•‰ΩøÁî®Á®ÄÁñèË°®ÔºàSparse TableÔºåSTÔºâ**ÁÆóÊ≥ïËß£ÂÜ≥„ÄÇËØ•ÁÆóÊ≥ïÂú®$O(n\ logn)$ ÁöÑÊó∂Èó¥ÂÜÖÈ¢ÑÂ§ÑÁêÜÔºåÂπ∂Âú® $O(1) $ÁöÑÊó∂Èó¥ÂÜÖÂÆåÊàêÊØè‰∏™ËØ¢ÈóÆ„ÄÇ ‰ª£Á†ÅÂ≠óÁ¨¶‰∏≤/Êï∞ÁªÑ‰øùÂ≠òÂú®sÊï∞ÁªÑ‰∏≠ÔºåmaxnÊòØÂ≠óÁ¨¶‰∏≤/Êï∞ÁªÑÁöÑÊúÄÂ§ßÈïøÂ∫¶ÔºårkÊòØ$rank$Êï∞ÁªÑÔºåsaÂ∞±ÊòØ$sa$Êï∞ÁªÑÔºåhtÊòØ$height$Êï∞ÁªÑ„ÄÇ ÔºàÊåâÁÖßÊ¥õË∞∑P3809ÁöÑË¶ÅÊ±ÇÔºâ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+5; char s[maxn]; int rk[maxn],sa[maxn],ht[maxn]; inline void suffixArray() { int n=strlen(s+1); static int set[maxn + 1], a[maxn + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; static int fir[maxn + 1], sec[maxn + 1], tmp[maxn + 1], buc[maxn + 1]; for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; for (int t = 1; t &lt;= n; t *= 2) { for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; } for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;,s+1);int n=strlen(s+1); suffixArray(); for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,sa[i],i==n?&apos;\n&apos;:&apos; &apos;); return 0; } ËØ¶ÁªÜÂèÇËÄÉÔºöÂêéÁºÄÊï∞ÁªÑÂ≠¶‰π†Á¨îËÆ∞]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training ÁªÑÂêàÊï∞Â≠¶]]></title>
    <url>%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-e7-bb-84-e5-90-88-e6-95-b0-e5-ad-a6%2F</url>
    <content type="text"><![CDATA[D.ÁªÑÂêàÊï∞Â≠¶+ÂÆπÊñ•ÂéüÁêÜ Ëøô‰∏™ÊØè‰∏™‰∫∫ÂøÖÈ°ªË¶ÅÊãø‰∏Ä‰∏™ÁöÑÈôêÂà∂Êù°‰ª∂ÈùûÂ∏∏ËÆ®Âéå‚Ä¶ÊâÄ‰ª•Êàë‰ª¨ÂÖà‰∏çÁÆ°‰ªñ„ÄÇ Áî±‰∫éÂêÑÁßçÁâπ‰∫ßÁõ∏‰∫íÁã¨Á´ãÔºåÊâÄ‰ª•ÂèØ‰ª•ÂÖàÁÆó‰∏ÄÁßçÁâπ‰∫ßÁöÑÂàÜÈÖçÊñπÊ≥ï‚Ä¶ ËøôÊ†∑ÁöÑËØùÂ∞±Áõ∏ÂΩì‰∫éÊääm‰∏™Áõ∏ÂêåÁöÑÂ∞èÁêÉÊîæÂÖ•n‰∏™‰∏çÂêåÁöÑÁõíÂ≠êÈáå(ÁõíÂ≠êÂ∞±ÊòØ‰∫∫)ÔºåÁ≠îÊ°àÊòØ$C_{m+n-1}^{\ n-1}$ÔºåÁÑ∂ÂêéÊääÂêÑ‰∏™Áâπ‰∫ßÁöÑËøô‰∏™ÂÄºÁõ∏‰πòÂæóÂà∞Á≠îÊ°à„ÄÇ ÈùûÂ∏∏ÁßëÂ≠¶ÔºåÈùûÂ∏∏‰ºòÈõÖÂØπ‰∏çÂØπ‚Ä¶ Êé•‰∏ãÊù•ËÄÉËôëÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏™‰∫∫Ëá≥Â∞ëÊãø‰∏Ä‰∏™ÔºåÊàë‰ª¨ÊääÈôêÂà∂ÂéªÊéâÂêéÂæóÂà∞ÁöÑÊòØËá≥Â∞ë0‰∫∫Ê≤°ÊúâÁâπ‰∫ßÁöÑÊñπÊ°àÊï∞„ÄÇ Ê†πÊçÆÂÆπÊñ•ÂéüÁêÜ $ans=C_n^0 ans[Ëá≥Â∞ë0‰∫∫Ê≤°ÊúâÁâπ‰∫ß]-C_n^1 ans[Ëá≥Â∞ë1‰∫∫Ê≤°ÊúâÁâπ‰∫ß]+C_n^2 ans[Ëá≥Â∞ë2‰∫∫Ê≤°ÊúâÁâπ‰∫ß]-‚Ä¶‚Ä¶+‚Ä¶‚Ä¶+/- C_m^m ans[Ëá≥Â∞ëm‰∫∫Ê≤°ÊúâÁâπ‰∫ß]$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int mod=1e9+7; ll c[2005][2005]; int main() { int n,m,i,j,k; c[1][1]=c[1][0]=c[0][0]=1; for(i=2;i&lt;=2000;i++) { c[i][0]=1; for (j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//È¢ÑÂ§ÑÁêÜÁªÑÂêàÊï∞ } } cin&gt;&gt;n&gt;&gt;m; int tc[1005]; for(i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;tc[i]);//Áâπ‰∫ßÊï∞Èáè ll ans=0;int cur=1; for(i=0;i&lt;=n;i++){ ll temp=cur;//ÂÆπÊñ•ÂéüÁêÜÁöÑÁ≥ªÊï∞(ÂÜ≥ÂÆöÂä†Âáè) for(j=1;j&lt;=m;j++){ temp=(temp*c[tc[j]+n-i-1][n-i-1])%mod; } ans+=temp*c[n][i]%mod;ans%=mod; cur*=-1; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0; } E.Êàë‰ª¨ÊääÂ∑¶Âè≥Âå∫Èó¥ÂàÜÂà´Â§ÑÁêÜÔºö $ r = r / k; \ l = (l - 1) / k + 1$; ËøôÊ†∑ÈóÆÈ¢òÂ∞±ËΩ¨Âåñ‰∏∫Ê±Ç[l,r] Âå∫Èó¥ÂÜÖÔºåÈÄân‰∏™Êï∞ÂÖ∂ÊúÄÂ§ßÂÖ¨Á∫¶Êï∞‰∏∫1ÁöÑÊñπÊ°àÊï∞ Âõ†‰∏∫$r-l&lt;=10^5$, ÊâÄ‰ª•Ëøô‰∏™Âå∫Èó¥ÂÜÖ‰ªªÊÑè‰∏§‰∏™‰∏çÁõ∏Á≠âÁöÑÊï∞ÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ÊúÄÂ§ß‰∏çË∂ÖËøá$10^5$ ËØÅÊòéÂæàÂ•ΩËØÅÔºöÂõ†‰∏∫‰∏§‰∏™Êï∞p &gt; qÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞Â¶ÇÊûú‰∏∫x,ÈÇ£‰πà$p / x - q / x \geq 1$,ÈÇ£‰πà$p - q \geq x$ ÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊûö‰∏æÊâÄÊúâÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞,ËÆæ[l,r]‰∏≠ÈÄân‰∏™‰∏çÂÆåÂÖ®Áõ∏ÂêåÁöÑÊï∞ÂÖ∂ÊúÄÂ§ßÂÖ¨Á∫¶Êï∞‰∏∫iÁöÑÊñπÊ°àÊï∞‰∏∫dp[i] ÈÇ£‰πà[l,r]‰∏≠ÊúâÂ§öÂ∞ëÂê´iÂõ†Â≠êÁöÑÊï∞Âë¢Ôºü ÊòæÁÑ∂Êúâ$t = r / i - (l - 1) / i$‰∏™Êï∞ ÈÇ£‰πà$dp[i] = t_n$ ÁßçÊñπÊ°àÔºå‰ΩÜÊòØËøôÈáåÈù¢ËÇØÂÆöÊúân‰∏™Êï∞ÈÉΩÁõ∏ÂêåÁöÑÊñπÊ°à‰∏ÄÂÖ±Êúât‰∏™ÔºàËøôÊó∂ÂÄô‰ªñ‰ª¨ÁöÑGCDÂ∞±‰∏ç‰ªÖ‰ªÖÊòØi‰∫ÜÔºâÔºåÊâÄ‰ª•$dp[i] = (tn - t) mod\ p$ÁßçÊñπÊ°à ‰ΩÜÊòØËøô‰∏™Êó∂ÂÄôÊ±ÇÂá∫ÁöÑÊòØÊâÄÊúân‰∏™Êï∞‰∏≠ÊúâiÂõ†Â≠êÁöÑÊñπÊ°àÊï∞ÔºåËÄå‰∏çÊòØgcd=iÁöÑÊñπÊ°àÊï∞ÔºåÊâÄ‰ª•$\forall j\ dp[i] = dp[i] - dp[j](j &lt;= r - l \ and\ j | i)$ ÁÑ∂ÂêéËøôÊ†∑dp[1]Â∞±ÊòØÊ≠£Ëß£‰∫Ü ‰ΩÜÊòØÊàë‰ª¨Ê≥®ÊÑèÂà∞ÔºåÊàë‰ª¨ÁöÑdp[1]ÊòØÂú®[l,r]‰∏≠ÈÄân‰∏™‰∏çÂÆåÂÖ®Áõ∏ÂêåÁöÑÊï∞ÂÖ∂ÊúÄÂ§ßÂÖ¨Á∫¶Êï∞‰∏∫iÁöÑÊñπÊ°àÊï∞Ôºå‰ΩÜÊòØÂÆûÈôÖ‰∏ä,Â¶ÇÊûún‰∏™Êï∞ÈÉΩÁ≠â‰∫ékÁöÑËØùÔºåÈÇ£‰πàÂÖ∂ÂÆû‰πüÊòØÊª°Ë∂≥Ë¶ÅÊ±ÇÁöÑ„ÄÇ ÊâÄ‰ª•ÂΩì$k‚àà[l,r]Êó∂Ôºådp[1] = dp[1] + 1$; #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int maxn=(100000 + 10); typedef long long ll; int dp[maxn]; int p = 1e9+7; ll mod_pow(ll n, ll k, ll mod) { ll re = 1; n = n % mod; while(k) { if(k &amp; 1) re = re * n % mod; k = k &gt;&gt; 1; n = n * n % mod; } return re; } int main() { int l,r,n,k; bool flag = false; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;l,&amp;r); if(k &gt;= l &amp;&amp; k &lt;= r)flag = true; r = r / k; l = (l - 1) / k; for(int i = r - l; i &gt;= 1; i --) { int t = r / i - l / i; dp[i] = (mod_pow(t, n, p) - t + p) % p; for(int j = 2; j * i &lt;= r - l; j ++) dp[i] = (dp[i] - dp[i * j] + p) % p; } if(flag == true) dp[1]++; printf(&quot;%d\n&quot;,dp[1] % p); return 0; } F.ÈùûÂ∏∏Â•óË∑ØÁöÑÈ¢òÁõÆÔºåÂÖ∂ÂÆûÂ∞±ÊòØË¶Å‰Ω†Âø´ÈÄüÊ±Ç1~x‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êï∞Ë∑üÁªôÂÆöÁöÑn‰∫íË¥®ÔºåÈÇ£‰πàÊäänÂàÜËß£‰∏Ä‰∏ãË¥®Âõ†Êï∞ÁÑ∂ÂêéÁî®ÂÆπÊñ•ÂéüÁêÜÊ±Ç‰∏Ä‰∏ãËøô‰∫õË¥®Âõ†Êï∞ÁöÑÂÄçÊï∞ÁöÑÊÄªÂíåÂ∞±ÂèØ‰ª•‰∫Ü #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum(ll x,ll n) { vector&lt;ll&gt;prime; ll i,j,y=x; for(i=2;i*i&lt;=n;i++){//Ê≥®ÊÑèÂàÜËß£Ë¶Å‰ªé2ÂºÄÂßã!! if(n%i==0){ prime.push_back(i); } while(n%i==0) n/=i; } ll res=0; if(n&gt;1)prime.push_back(n); for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){//Ê≥®ÊÑè‰∏ÄÂÆöË¶Å‰ªé1ÂºÄÂßã!!! ll val=1,cnt=0;//‰∫åËøõÂà∂Êûö‰∏æÊØè‰∏™Âõ†Êï∞ÊòØÂê¶Ë¶ÅÈÄâ for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1LL){ res+=y/val; } else res-=y/val; } //cout&lt;&lt;res&lt;&lt;endl; return x-res; } int main() { int t;ll a,b,n; cin&gt;&gt;t;int cnt=0; while(t--){ cnt++; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;n); printf(&quot;Case #%d: %lld\n&quot;,cnt,sum(b,n)-sum(a-1,n)); } return 0; } G.È¢òÁõÆÊ±ÇÁöÑÂÖ∂ÂÆûÂ∞±ÊòØ$\forall a_i\ a_ix=b(mod\ m )$‰∏≠bÁöÑÂíå„ÄÇ ÈÇ£‰πàÊòæÁÑ∂bÂøÖÈ°ªÊª°Ë∂≥$GCD(a_i,m)|b$,ÈÇ£‰πàÊâÄÊúâÁöÑËøôÊ†∑ÁöÑbÊòæÁÑ∂ÈÉΩÊòØmÁöÑÊüê‰∏™Á∫¶Êï∞ÁöÑÂÄçÊï∞Ôºà mÈô§Â§ñÔºåÂõ†‰∏∫$b\leq m-1$)„ÄÇ‰∫éÊòØÔºåÂØπ‰∫éÊØè‰∏™aiÔºåÊàë‰ª¨Êûö‰∏æÂÖ∂‰∏émÁöÑgcd‰∏éÂêÑ‰∏™Á∫¶Êï∞ÁöÑÂÖ≥Á≥ªÔºåÂ¶ÇÊûúÂÆÉÁöÑgcdËÉΩÊï¥Èô§Êüê‰∏™Á∫¶Êï∞ÔºåÈÇ£‰πàËøô‰∏™Á∫¶Êï∞ÁöÑÊâÄÊúâÂÄçÊï∞ÈÉΩÊòØÂèØË°åÁöÑÔºåÂπ∂‰∏îÂíåÂèØ‰ª•Áî®Á≠âÂ∑ÆÊï∞ÂàóÊ±ÇÂíåÂÖ¨ÂºèÊ±ÇÂá∫„ÄÇ‰ΩÜÊòØËøôÊòæÁÑ∂Â∞±Â∏¶Êù•‰∫Ü‰∏Ä‰∏™ÈáçÂ§çÁöÑÈóÆÈ¢òÔºåÈÇ£‰πàÊàë‰ª¨Âú®Ê±ÇÂíåÁöÑËøáÁ®ã‰∏≠ËøòË¶ÅÁªüËÆ°ÊØè‰∏™Êï∞Ë¢´Ê±ÇÂíåÁöÑÊ¨°Êï∞ÔºåÁÑ∂ÂêéËøõË°åÂ§ÑÁêÜ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; bool vis[10005]; int cnt[10005]; int gcd(int x,int y) { return y?gcd(y,x%y):x; } int main() { int t,i,j,k; cin&gt;&gt;t;int case1=0; while(t--){ case1++; int n,m;vector&lt;int&gt;ys; memset(vis,0,sizeof(vis));memset(cnt,0,sizeof(cnt)); cin&gt;&gt;n&gt;&gt;m; for(i=1;i*i&lt;=m;i++){//Ê±ÇmÁöÑÁ∫¶Êï∞ if(m%i==0){ ys.push_back(i); if(i*i!=m)ys.push_back(m/i); } } sort(ys.begin(),ys.end());ys.pop_back();//‰ΩøÁ∫¶Êï∞‰ªéÂ∞èÂà∞Â§ßÊéíÂàóÊñπ‰æøÂêéÈù¢Ê±ÇÈáçÂ§çÁöÑÈóÆÈ¢ò for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;k);// k=gcd(k,m); for(j=0;j&lt;ys.size();j++){ if(ys[j]%k==0) vis[j]=1;//Ëøô‰∏™Á∫¶Êï∞ÂèäÂÖ∂ÂÄçÊï∞ÈÉΩÊòØÂèØË°åÁöÑ } } ll ans=0; for(i=0;i&lt;ys.size();i++){ if(vis[i]&amp;&amp;cnt[i]!=1){ int last1=(m-1)/ys[i]*ys[i],num=(m-1)/ys[i]+1; ans+=(ll)(0+last1)*num/2*(1-cnt[i]); for(j=i+1;j&lt;ys.size();j++) if(ys[j]%ys[i]==0)//ÊâÄÊúâÊòØËøô‰∏™Á∫¶Êï∞ÁöÑÂÄçÊï∞ÁöÑÁ∫¶Êï∞ÈÉΩË¢´ÈáçÂ§çËÆ°Êï∞‰∫Ü,Ê†áËÆ∞‰∏Ä‰∏ã cnt[j]+=1-cnt[i]; } } printf(&quot;Case #%d: %lld\n&quot;,case1,ans); //cout&lt;&lt;ans&lt;&lt;endl; } return 0; } H.È¢òÁõÆÂèØ‰ª•ÊØîËæÉÊö¥ÂäõÁöÑÊ±ÇËß£ÔºåÂõ†‰∏∫Êúâ‰∏™ÁªìËÆ∫ÔºöÂ¶ÇÊûúaÂíåm‰∫íË¥®ÔºåÈÇ£‰πà$k* m+a$Âíå$m$‰πü‰∫íË¥®Ôºå‰∫éÊòØÊàë‰ª¨Êö¥ÂäõÊ±Ç1~mÁöÑËåÉÂõ¥ÂÜÖ‰∏ém‰∫íË¥®ÁöÑÊï∞ÁöÑ‰∏™Êï∞nÔºåÁÑ∂ÂêéÊØèm‰∏™Êï∞‰∏≠Â∞±Êúân‰∏™Êï∞‰∏ém‰∫íË¥®„ÄÇÈúÄË¶ÅÊ≥®ÊÑèÁöÑÂ∞±ÊòØÂΩì$n|k$Êó∂Ë¶ÅÁâπÂà§‰∏Ä‰∏ã„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } int main() { ll n,m,i,j,k; while(cin&gt;&gt;m&gt;&gt;k){ vector&lt;ll&gt;rp; for(i=1;i&lt;=m;i++){ if(gcd(i,m)==1) rp.push_back(i); } ll xs=k/rp.size(); ll ans; if(k%rp.size()) ans=m*xs+rp[k%rp.size()-1]; else ans=m*(xs-1)+rp[rp.size()-1];//Ê≥®ÊÑèÁâπÂà§ printf(&quot;%lld\n&quot;,ans); } return 0; } I.ÈùûÂ∏∏Â•óË∑ØÁöÑÈ¢òÔºåÊûö‰∏æÈõÜÂêàÂÜÖÁöÑÊï∞ÁÑ∂ÂêéÊ±Ç‰∏Ä‰∏ã‰ªñ‰ª¨ÁöÑLCMÔºåÁÑ∂ÂêéÂÆπÊñ•ÂéüÁêÜÊêû‰∏ÄÊêû‰ªñ‰ª¨ÁöÑÂÄçÊï∞ÁöÑ‰∏™Êï∞Â∞±ok‰∫Ü #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } ll sum(ll x,vector&lt;int&gt;v) { ll res=0,i,j; for(i=1;i&lt;(1&lt;&lt;v.size());i++){ ll val=1,cnt=0; for(j=0;j&lt;v.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val=val*v[j]/gcd(val,v[j]);//‰∏ÄÂÆöË¶ÅÊ±ÇLCM!ÈõÜÂêàÈáåÁöÑÊï∞‰∏çËßÅÂæó‰∏§‰∏§‰∫íË¥® cnt++; } } if(cnt&amp;1LL)res+=x/val; else res-=x/val; } return res; } int main() { ll n,m; int i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ vector&lt;int&gt;v;//bool haszero=false; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);if(j)v.push_back(j); } printf(&quot;%lld\n&quot;,sum(n-1,v)); //else cout&lt;&lt;0&lt;&lt;endl; } return 0; } J.ÂÖ∂ÂÆûÂ∞±ÊòØÊ±Ç1~b/kË∑ü1~d/k‰∏≠ÊúâÂ§öÂ∞ëÂØπ‰∫íË¥®ÁöÑÊï∞„ÄÇÂÅáËÆæb&gt;dÔºåÊàëÂèØ‰ª•ËÆ§‰∏∫‰ªéÂêé‰∏Ä‰∏™ÈõÜÂêà‰∏≠ÊåëÁöÑÊï∞‰∏ÄÂÆöÈÉΩÊòØÊØîËæÉÂ∞èÁöÑÊï∞ÔºàÈÅøÂÖçÈáçÂ§çÔºâÔºåÈÇ£‰πàÂØπ‰∫é‰∫íË¥®ÂØπ(x,y),x&gt;=y,ÂΩìx&lt;=d/kÊó∂ÔºåÂÖ∂ÂÆûyÁöÑÂèñÂÄºÂ∞±ÊòØxÁöÑÊ¨ßÊãâÂáΩÊï∞ÂÄº„ÄÇËÄåÂΩìd/k&lt;=x&lt;=b/kÊó∂ÔºåÂ∞±Áî®‰πãÂâçÈ¢òÁõÆ‰∏≠Ê±ÇËøáÁöÑÈÇ£ÁßçÊñπÂºèÊ±Ç1~d/k‰∏≠‰∏éx‰∫íË¥®ÁöÑÊï∞ÁöÑ‰∏™Êï∞Âç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll eular(ll x) { ll res = x, a = x; for (ll i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } ll sum(ll x,ll n) { ll i,j; vector&lt;ll&gt;prime; for(i=2;i*i&lt;=n;i++){ if(n%i==0){ prime.push_back(i); while(n%i==0) n/=i; } } if(n&gt;1)prime.push_back(n); ll res=0; for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){ ll val=1;ll cnt=0; for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1){ res+=x/val; } else res-=x/val; } return x-res; } ll phi[1000005]; void phi_table(ll n)///Ê¨ßÊãâÂáΩÊï∞ÂÄºË°® { phi[1]=1; for(ll i=2; i&lt;=n; i++) { if(!phi[i]) { for(ll j=i; j&lt;=n; j+=i) { if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); } } } } int main() { int t;ll a,b,c,d,i,j,k; cin&gt;&gt;t; phi_table(100010); for(ll i=2; i&lt;=100000; i++) phi[i]+=phi[i-1];///ÂâçÁºÄÂíå int cnt=0; while(t--){ ll ans=0; cnt++; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0 || k &gt; b || k &gt; d) { printf(&quot;Case %d: 0\n&quot;, cnt); continue; } if(b&lt;d)swap(b,d); b/=k;d/=k; // for(i=1;i&lt;=d;i++) // ans+=eular(i); for(i=d+1;i&lt;=b;i++) ans+=sum(d,i); printf(&quot;Case %d: %lld\n&quot;,cnt,ans+phi[d]); } return 0; }]]></content>
      <categories>
        <category>ÁªÑÂêàÊï∞Â≠¶</category>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâÊúÄÂ∞èÂúÜË¶ÜÁõñ]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e5-9c-86-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[ÁÆóÊ≥ïÁõÆÁöÑÔºöÂú®Á∫øÊÄßÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫Ë¶ÜÁõñn‰∏™ÁÇπÁöÑÊúÄÂ∞èÂúÜÁÆóÊ≥ïÊ≠•È™§Ôºö‚ë†È¶ñÂÖàÁé∞Â∞ÜÊâÄÊúâÁÇπÈöèÊú∫ÊéíÂàó ‚ë°ÊåâÈ°∫Â∫èÊääÁÇπ‰∏Ä‰∏™‰∏Ä‰∏™ÁöÑÂä†ÂÖ•Ôºà‰∏ÄÊ≠•‰∏ÄÊ≠•ÁöÑÊ±ÇÂâçi‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÔºâÔºåÊØèÂä†ÂÖ•‰∏Ä‰∏™ÁÇπÂ∞±ËøõÂÖ•‚ë¢ ‚ë¢Â¶ÇÊûúÂèëÁé∞ÂΩìÂâçiÂè∑ÁÇπÂú®ÂΩìÂâçÁöÑÊúÄÂ∞èÂúÜÁöÑÂ§ñÈù¢ÔºåÈÇ£‰πàËØ¥ÊòéÁÇπi‰∏ÄÂÆöÂú®Ââçi‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜËæπÁïå‰∏äÔºåÊàë‰ª¨ËΩ¨Âà∞‚ë£Êù•Ëøõ‰∏ÄÊ≠•Á°ÆÂÆöËøô‰∏™ÂúÜÔºåÂê¶ÂàôÂâçi‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜ‰∏éÂâçi-1‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂàô‰∏çÈúÄË¶ÅÊõ¥Êñ∞ÔºåËøîÂõû‚ë° ‚ë£Ê≠§Êó∂Â∑≤ÁªèÁ°ÆËÆ§ÁÇπi‰∏ÄÂÆöÂú®Ââçi‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÁöÑËæπÁïå‰∏ä‰∫ÜÔºåÈÇ£‰πàÊàë‰ª¨ÂèØ‰ª•ÊääÂΩìÂâçÂúÜÁöÑÂúÜÂøÉËÆæ‰∏∫Á¨¨i‰∏™ÁÇπÔºåÂçäÂæÑ‰∏∫0ÔºåÁÑ∂ÂêéÈáçÊñ∞ÊääÂâçi-1‰∏™ÁÇπÂä†ÂÖ•Ëøô‰∏™ÂúÜ‰∏≠ÔºàÁ±ª‰ºº‰∏äÈù¢ÁöÑÊ≠•È™§ÔºåÂè™‰∏çËøáËøôÊ¨°Êàë‰ª¨ÊèêÂâçÁ°ÆÂÆö‰∫ÜÁÇπiÂú®ÂúÜ‰∏äÔºåÁõÆÁöÑÊòØ‰∏ÄÊ≠•‰∏ÄÊ≠•Ê±ÇÂá∫ÂåÖÂê´ÁÇπiÁöÑÂâçj‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÔºâÔºåÊØèÂä†ÂÖ•‰∏Ä‰∏™ÁÇπÂ∞±ËøõÂÖ•‚ë§ ‚ë§Â¶ÇÊûúÂèëÁé∞ÂΩìÂâçjÂè∑ÁÇπÂú®ÂΩìÂâçÁöÑÊúÄÂ∞èÂúÜÁöÑÂ§ñÈù¢ÔºåÈÇ£‰πàËØ¥ÊòéÁÇπj‰πü‰∏ÄÂÆöÂú®Ââçj‰∏™ÁÇπÔºàÂåÖÊã¨iÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜËæπÁïå‰∏äÔºåÊàë‰ª¨ËΩ¨Âà∞‚ë•Êù•ÂÜçËøõ‰∏ÄÊ≠•Á°ÆÂÆöËøô‰∏™ÂúÜÔºåÂê¶ÂàôÂâçj‰∏™ÁÇπÔºàÂåÖÊã¨iÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜ‰∏éÂâçi-1‰∏™ÁÇπÔºàÂåÖÊã¨iÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂàô‰∏çÈúÄË¶ÅÊõ¥Êñ∞ÔºåËøîÂõû‚ë£ ‚ë•Ê≠§Êó∂Â∑≤ÁªèÁ°ÆËÆ§ÁÇπiÔºåj‰∏ÄÂÆöÂú®Ââçj‰∏™ÁÇπÔºàÂåÖÊã¨iÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÁöÑËæπÁïå‰∏ä‰∫ÜÔºåÈÇ£‰πàÊàë‰ª¨ÂèØ‰ª•ÊääÂΩìÂâçÂúÜÁöÑÂúÜÂøÉËÆæ‰∏∫Á¨¨i‰∏™ÁÇπ‰∏éÁ¨¨jÁöÑÁÇπËøûÁ∫øÁöÑ‰∏≠ÁÇπÔºåÂçäÂæÑ‰∏∫Âà∞Ëøô‰∏§‰∏™ÁÇπÁöÑË∑ùÁ¶ªÔºàÂ∞±ÊòØÊâæ‰∏Ä‰∏™Ë¶ÜÁõñËøô‰∏§‰∏™ÁÇπÁöÑÊúÄÂ∞èÂúÜÔºâÔºåÁÑ∂ÂêéÈáçÊñ∞ÊääÂâçj-1‰∏™ÁÇπÂä†ÂÖ•Ëøô‰∏™ÂúÜ‰∏≠ÔºàËøòÊòØÁ±ª‰ºº‰∏äÈù¢ÁöÑÊ≠•È™§ÔºåÂè™‰∏çËøáËøôÊ¨°Êàë‰ª¨ÊèêÂâçÁ°ÆÂÆö‰∫Ü‰∏§‰∏™ÁÇπÂú®ÂúÜ‰∏äÔºåÁõÆÁöÑÊòØÊ±ÇÂá∫ÂåÖÂê´ÁÇπiÔºåjÁöÑÂâçk‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÔºâÔºåÊØèÂä†ÂÖ•‰∏Ä‰∏™ÁÇπÂ∞±ËøõÂÖ•‚ë¶ ‚ë¶Â¶ÇÊûúÂèëÁé∞ÂΩìÂâçkÂè∑ÁÇπÂú®ÂΩìÂâçÁöÑÊúÄÂ∞èÂúÜÁöÑÂ§ñÈù¢ÔºåÈÇ£‰πàËØ¥ÊòéÁÇπk‰πü‰∏ÄÂÆöÂú®Ââçk‰∏™ÁÇπÔºàÂåÖÊã¨iÔºåjÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜËæπÁïå‰∏äÔºåÊàë‰ª¨‰∏çÈúÄË¶ÅÂÜçËøõ‰∏ÄÊ≠•Á°ÆÂÆöËøô‰∏™ÂúÜ‰∫ÜÔºàÂõ†‰∏∫‰∏â‰∏™ÁÇπËÉΩÁ°ÆÂÆö‰∏Ä‰∏™ÂúÜÔºÅÔºâÔºåÁõ¥Êé•Ê±ÇÂá∫Ëøô‰∏âÁÇπÂÖ±ÂúÜÔºåÂê¶ÂàôÂâçk‰∏™ÁÇπÔºàÂåÖÊã¨iÔºåjÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜ‰∏éÂâçk-1‰∏™ÁÇπÔºàÂåÖÊã¨iÔºåjÔºâÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂàô‰∏çÈúÄË¶ÅÊõ¥Êñ∞„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÔºöO(N) Á©∫Èó¥Â§çÊùÇÂ∫¶ÔºöO(N) Ê≥®ÊÑè‰∫ãÈ°π: ‰ª•‰∏äÊó∂Èó¥Â§çÊùÇÂ∫¶ÁöÑËØÅÊòéÂÖ®ÈÉ®Âü∫‰∫éÁÇπÁöÑÊéíÂàóÈöèÊú∫ÔºåÂ¶ÇÊûúÁÇπÁöÑÊéíÂàó‰∏çÈöèÊú∫ÔºåÈÇ£‰πàÊó∂Èó¥Â§çÊùÇÂ∫¶Â∞ÜÊúâÂèØËÉΩËææÂà∞O(N3) ÊâÄ‰ª•ÊúÄÂ∞èÂúÜË¶ÜÁõñÁÆóÊ≥ïÂè™ËÉΩÂú®O(N)Êó∂Èó¥ÂÜÖÊ±ÇÂá∫NÁöÑÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜÔºåËÄå‰∏çËÉΩÂú®O(N)ÁöÑÊó∂Èó¥ÂÜÖÊ±ÇÂá∫ÊâÄÊúâÁöÑÂâçi‰∏™ÁÇπÁöÑÊúÄÂ∞èË¶ÜÁõñÂúÜ ‰ª£Á†Å ÁªôÂÆön‰∏™ÁÇπÊ±ÇÊúÄÂ∞èË¶ÜÁõñÂúÜÂúÜÂøÉÂèäÂçäÂæÑ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; const int N=505; using namespace std; struct node { double x, y; }b[N]; node O; double R; double sqr(double x) { return x * x; } double dis(node x,node y)//Ë∑ùÁ¶ª { return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y)); } bool incircle(node x)//Âà§Êñ≠ÁÇπÊòØÂê¶Âú®ÂúÜÂÜÖ { if(dis(O,x)&lt;=R) return true; return false; } node solve(double a,double b,double c,double d,double e,double f) { node t; t.y=(f*a-c*d)/(b*d-e*a); t.x=(f*b-c*e)/(a*e-b*d); return t; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int i, j, k; for (i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;b[i].x, &amp;b[i].y); random_shuffle(b + 1, b + n + 1); R = 0;O.x=O.y=0; for (i = 1; i &lt;= n; i++) if (!incircle(b[i])) { O.x = b[i].x; O.y = b[i].y; R = 0; for (j = 1; j &lt; i; j++) if (!incircle(b[j])) { O.x = (b[i].x + b[j].x) / 2; O.y = (b[i].y + b[j].y) / 2; R = dis(O, b[i]); for (k = 1; k &lt; j; k++) if (!incircle(b[k])) { O = solve( b[i].x - b[j].x, b[i].y - b[j].y, (sqr(b[j].x) + sqr(b[j].y) - sqr(b[i].x) - sqr(b[i].y)) / 2, b[i].x - b[k].x, b[i].y - b[k].y, (sqr(b[k].x) + sqr(b[k].y) - sqr(b[i].x) - sqr(b[i].y)) / 2 ); R = dis(b[i], O); } } } printf(&quot;%.2f %.2f %.2f\n&quot;, O.x, O.y,R);//ÂùêÊ†á,ÂçäÂæÑ } return 0; }]]></content>
      <categories>
        <category>ËÆ°ÁÆóÂá†‰Ωï</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>ËÆ°ÁÆóÂá†‰Ωï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâ‰ªªÊÑèÂ§öËæπÂΩ¢ÁöÑÈáçÂøÉ]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e4-bb-bb-e6-84-8f-e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e9-87-8d-e5-bf-83%2F</url>
    <content type="text"><![CDATA[ËÆ°ÁÆóÂ§öËæπÂΩ¢ÈáçÂøÉÊñπÊ≥ïÔºöÔºà1ÔºâÂàíÂàÜÂ§öËæπÂΩ¢‰∏∫‰∏âËßíÂΩ¢Ôºö ‰ª•Â§öËæπÂΩ¢ÁöÑ‰∏Ä‰∏™È°∂ÁÇπV‰∏∫Ê∫êÁÇπÔºàVÂèØÂèñËæìÂÖ•ÁöÑÁ¨¨‰∏Ä‰∏™È°∂ÁÇπÔºâÔºå‰ΩúËøûÁªìV‰∏éÊâÄÊúâÈùûÁõ∏ÈÇªÈ°∂ÁÇπÁöÑÁ∫øÊÆµÔºåÂç≥Â∞ÜÂéüNËæπÂΩ¢ÊàñÂàÜ‰∏∫ÔºàN-2Ôºâ‰∏™‰∏âËßíÂΩ¢Ôºõ Ôºà2ÔºâÊ±ÇÊØè‰∏™‰∏âËßíÂΩ¢ÁöÑÈáçÂøÉÂíåÈù¢ÁßØÔºö ËÆæÊüê‰∏™‰∏âËßíÂΩ¢ÁöÑÈáçÂøÉ‰∏∫$GÔºàc_xÔºåc_yÔºâ$ÔºåÈ°∂ÁÇπÂùêÊ†áÂàÜÂà´‰∏∫$A_1Ôºàx_1Ôºåy_1ÔºâÔºåA_2Ôºàx_2Ôºåy_2ÔºâÔºåA_3Ôºàx_3Ôºåy_3Ôºâ$ÔºåÂàôÊúâ$C_x = \frac{(x_1 + x_2 + x_3)}{3}$.ÂêåÁêÜÊ±ÇÂæócy„ÄÇÊ±ÇÈù¢ÁßØÁöÑÊñπÊ≥ïÊòØ $S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$ÔºåÂΩì$A_1,A_2,A_3$È°∫Êó∂ÈíàÊéíÂàóÊó∂Âèñ-ÔºåÂê¶ÂàôÂèñÊ≠£ÔºàÂèâÁßØÔºâ„ÄÇ‰∫ãÂÆû‰∏äÔºåÂú®Ê±ÇÊØè‰∏™‰∏âËßíÂΩ¢Êó∂‰∏çÈúÄË¶ÅËæ®Âà´Ê≠£Ë¥üÔºå‰πãÂêéÊúâÊñπÊ≥ïÊäµÊ∂àË¥üÂè∑„ÄÇ Ôºà3ÔºâÊ±ÇÂéüÂ§öËæπÂΩ¢ÁöÑÈáçÂøÉÔºö ÂÖ¨ÂºèÔºö$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ÔºåÂÖ∂‰∏≠$C_{xi},C_{yi},S_i$ÂàÜÂà´ÊòØÊâÄÂàíÂàÜ‰∏âËßíÂΩ¢ÁöÑÈáçÂøÉÂùêÊ†áÂíåÈù¢ÁßØÔºõÊ≥®ÊÑèÂ¶ÇÊûúÂú®Ê±ÇÂêÑ‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÁöÑÊó∂ÂÄôÊ≤°ÊúâÈô§‰ª•3ÂàôÊúÄÂêéË¶ÅÁªü‰∏ÄÈô§‰ª•3Ôºõ ÊÄªÁªìÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºö$C_x = \frac{(x_1 + x_2 + x_3)}{3}$ÔºõcyÂêåÁêÜ„ÄÇ ÊØè‰∏™‰∏âËßíÂΩ¢Èù¢ÁßØÔºö$S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$Ôºõ Â§öËæπÂΩ¢ÈáçÂøÉÔºö$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ‰ª£Á†Å ÁªôÂÆö‰∏Ä‰∏™nËæπÂΩ¢ÔºåÊ±ÇÈáçÂøÉÂùêÊ†á #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;double,double&gt;P; P node[105]; P mass_node(P a,P b,P c)//Ê±ÇÈáçÂøÉ { return P((a.first+b.first+c.first)/3,(a.second+b.second+c.second)/3); } double square(P a,P b,P c)//Ê±ÇÈù¢ÁßØ { double s = ((b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second)) / 2; return s; } int main() { int n,i,j,k;int cnt=0; while(cin&gt;&gt;n&amp;&amp;n){ cnt++; for(i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].first,&amp;node[i].second); vector&lt;P&gt;mass;vector&lt;double&gt;s; double tots=0; for(i=2;i&lt;n;i++){ P t=mass_node(node[1],node[i],node[i+1]);mass.push_back(t);//ÂàíÂàÜ‰∏âËßíÂΩ¢Ê±ÇÈáçÂøÉ double s1=square(node[1],node[i],node[i+1]);s.push_back(s1);//Ê±ÇÈù¢ÁßØ tots+=s1; } double cx=0,cy=0; for(i=0;i&lt;mass.size();i++){ cx+=mass[i].first*s[i];cy+=mass[i].second*s[i];//Ê±ÇÂ§öËæπÂΩ¢ÈáçÂøÉ } cout&lt;&lt;&quot;Stage #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;; printf(&quot;%.6f %.6f\n&quot;,cx/tots,cy/tots); } return 0; }]]></content>
      <categories>
        <category>ËÆ°ÁÆóÂá†‰Ωï</category>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>ËÆ°ÁÆóÂá†‰Ωï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #2]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-2%2F</url>
    <content type="text"><![CDATA[A. Êúâ‰∏§‰∏™Êï∞ÁªÑAÔºåBÔºåÊØèÊ¨°ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™AÔºåB‰∏≠Âá∫Áé∞ËøáÁöÑÊï∞Â≠óxÂπ∂Â∞ÜÂÆÉÊõøÊç¢‰∏∫Âè¶‰∏Ä‰∏™ÈöèÊÑèÁöÑÊï∞yÔºå‰∏ÄÊ¨°Êìç‰Ωú‰ºöÊääAÔºåB‰∏≠ÁöÑÊâÄÊúâÁöÑxÈÉΩÊç¢ÊàêyÔºåÂπ∂‰∏îÔºåÊúÄÂêéÂ∫îÂΩì‰ΩøÂæóAÔºåBÂÆåÂÖ®Áõ∏Á≠âÔºåÂç≥ÂØπÂ∫î‰Ωç‰∏äÁöÑÊï∞‰∏ÄÊ†∑„ÄÇÂêåÊó∂ÔºåÈóÆÂú®Êìç‰ΩúÊï∞ÊúÄÂ∞ëÊó∂ÊúâÂ§öÂ∞ëÁßçÊìç‰ΩúÁöÑÊñπÊ≥ï„ÄÇ È¶ñÂÖàÔºåÂ∫îËØ•ÊÉ≥Âà∞ÁöÑ‰∏ÄÁÇπÊòØÂõ†‰∏∫‰∏Ä‰∏™Êï∞ÂèØËÉΩÈáçÂ§çÂá∫Áé∞ÂæàÂ§öÊ¨°ÔºåËÄå‰ªñÂú®‰∏çÂêå‰ΩçÁΩÆÂá∫Áé∞Êó∂‰∏é‰ªñÂêå‰∏Ä‰ΩçÁΩÆÁöÑ‰∏çÂêåÊï∞ÁªÑÁöÑÊï∞ÂæàÂèØËÉΩÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑÔºåËøôÂ∞±ÊÑèÂë≥ÁùÄÊâÄÊúâÁöÑËøô‰∫õÊï∞ÊúÄÂêéÊòØË¶ÅÂèòÊàê‰∏Ä‰∏™Áõ∏ÂêåÁöÑÊï∞ÁöÑ„ÄÇÈÇ£‰πà‰∏∫‰∫ÜÁ°ÆÂÆöÊúâÂ§öÂ∞ëÁªÑËøôÊ†∑ÊúÄÂêéË¶ÅÂèòÊàê‰∏ÄÊ†∑ÁöÑÊï∞ÔºåÂèØ‰ª•ÊêúÁ¥†ÊàñËÄÖÂπ∂Êü•ÈõÜÊêû‰∏ÄÊ≥¢„ÄÇÊ≥®ÊÑèÁöÑÊòØÊØè‰∏ÄÁªÑÈáåÈù¢Â¶ÇÊûúÊúân‰∏™Êï∞ÔºåÈÇ£‰πà‰ªñÂè™ÈúÄË¶ÅÂÅön-1Ê¨°ÂèòÊç¢„ÄÇ ÂØπ‰∫éÁ¨¨‰∫åÈóÆÔºåÈ¶ñÂÖàÊàë‰ª¨ÂÅáËÆæËøô‰∏ÄÁªÑ‰∏≠Êúân‰∏™Êï∞ÔºàÁõ∏ÂêåÁöÑÊï∞ÊêúÁ¥¢ÁöÑÊó∂ÂÄô‰ºöË¢´ÂêàÂπ∂ÔºåÊâÄ‰ª•ËÆ°ÁÆóÁöÑÊó∂ÂÄôËÇØÂÆö‰∏ç‰ºöÊúâÈáçÂ§çÔºâÔºåÈÇ£‰πàÊúÄÂêéÂèòÊàêÁöÑÊï∞Â∞±ÊúânÁßçÈÄâÊã©ÔºåËøô‰∏™Êï∞Á°ÆÂÆö‰∫Ü‰ª•ÂêéÔºåÂØπ‰∫éÂÖ∂‰Ωôn-1‰∏™Êï∞ËÄåË®ÄÔºå‰ªñ‰ª¨ÂÖàÂêéÂèòÊç¢‰∏ÄÊ¨°Ôºà‰∏ç‰∏ÄÂÆö‰∏ÄÊ¨°Â∞±Âèò‰∏∫ÈÄâÂÆöÁöÑËøô‰∏™Êï∞ÔºâÔºåÈÇ£‰πàÂèØËÉΩÊúâ$(n-1)!$Áßç„ÄÇÂêåÊó∂ÔºåÊØè‰∏™Êï∞ÂèòÊç¢ÁöÑÊó∂ÂÄô‰∏ÄÂÆöÊòØÂèò‰∏∫Ëøô‰∏ÄÁªÑ‰∏≠Ââ©‰∏ãÊï∞‰∏≠ÁöÑ‰∏Ä‰∏™ÔºàÊØèÂΩì‰∏Ä‰∏™Êï∞ÂèëÁîü‰∫ÜÂèòÊç¢Ôºå‰ªñÂ∞±Ê∞∏‰πÖ‰ªéÊï∞ÁªÑ‰∏≠Ê∂àÂ§±‰∫ÜÔºåÂõ†‰∏∫Êàë‰ª¨Ë¶ÅÊ±ÇÊÄªÊìç‰ΩúÊ¨°Êï∞ÊúÄÂ∞ëÔºâÔºåÊâÄ‰ª•ÂØπ‰∫éÁ¨¨‰∏Ä‰∏™ÂèòÁöÑÊï∞ËÄåË®ÄÔºåÂÆÉÁöÑÈÄâÊã©ÊòØ$n-1$ÔºåÁ¨¨‰∫å‰∏™Êï∞ÊòØ$n-2$‚Ä¶ÔºåÂõ†Ê≠§ÔºåÊØè‰∏ÄÁªÑÂ§ßÂ∞è‰∏∫nÁöÑÊï∞ÁöÑÂèØËÉΩÊòØ$n\times (n-1)!\times (n-1)!$Áßç„ÄÇËÄåÂØπ‰∫éÂÖ®‰ΩìÊï∞ËÄåË®ÄÔºåÊàë‰ª¨ÁöÑÂÖàÂêéÈ°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºåÊâÄ‰ª•ÂèØËÉΩÊï∞Â∫îËØ•ÊòØ$m!$,‰ΩÜÊòØÂõ†‰∏∫ÂØπ‰∫éÊØè‰∏ÄÁªÑÊï∞ÔºåÂÖ∂ÂÜÖÈÉ®ÁöÑÈ°∫Â∫èÂ∑≤ÁªèËÆ°ÁÆóËøá‰∫Ü‰∏ÄÊ¨°ÔºåÊ†πÊçÆÈô§Ê≥ïÂéüÁêÜÔºåÊØè‰∏ÄÁªÑÂ§ßÂ∞è‰∏∫nÁöÑÊï∞ÈÉΩ‰ºöÂ∏¶Êù•$(n-1)!$ÁöÑÈáçÂ§çÔºåÊâÄ‰ª•Â∫îÂΩìÈô§Âéª„ÄÇÊâÄ‰ª•ÊúÄÂêéÊÄªÁöÑÂèØËÉΩÊï∞Â∞±ÊòØ$\prod {n!}\ \times m!$ ‰ª£Á†Å#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int mod=1e9+7; vector&lt;int&gt; G[maxn]; bool vis[maxn]; ll fac[maxn]; int cnt; void dfs(int u) { vis[u]=true;cnt++; for(auto a:G[u]) if(!vis[a]) dfs(a); } int main() { fac[0] = 1;int t; cin &gt;&gt; t; while (t--) { for (int i = 0; i &lt; maxn; i++) { G[i].clear(); } memset(vis,0,sizeof(vis)); for (int i = 1; i &lt; maxn; i++) fac[i] = (fac[i - 1] * i) % mod; int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = 0; ll a[maxn], b[maxn]; for (int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;,&amp;b[i]); if (b[i] != a[i]) { G[a[i]].push_back(b[i]);G[b[i]].push_back(a[i]); } } ll ans1 = 1; for (int i = 0; i &lt; n; i++) { if (vis[a[i]])continue; cnt = 0;dfs(a[i]); ans += (cnt - 1); ans1 = ans1 * fac[cnt] % mod; } ans1 = ans1 * fac[ans] % mod; cout &lt;&lt; ans &lt;&lt; &quot; &quot;; if (k == 2)cout &lt;&lt; ans1; cout &lt;&lt; endl; } return 0; } D.ÁîªÁîªÂõæÂ§ßËÉÜÁåúÁªìËÆ∫ÂïäÔºåÂÖ∂ÂÆûÊàë‰ª¨‰ºöÂèëÁé∞Â¶ÇÊûú‰∏Ä‰∏™ÂõæÂΩ¢ËÉΩË¢´ÂàÜÂâ≤‰∏∫ÊúâÈôê‰∏™Âπ≥Ë°åÂõõËæπÂΩ¢ÁöÑËØùÔºåÈÇ£‰πàÂÆÉ‰∏ÄÂÆöÂèØ‰ª•Ë¢´ÂàÜÂâ≤‰∏∫ÈöèÊÑèÊï∞ÈáèÁöÑÊõ¥Â§öÁöÑÂπ≥Ë°åÂõõËæπÂΩ¢ÔºàÂú®ÂàÜÂâ≤Â•ΩÁöÑÂπ≥Ë°åÂõõËæπÂΩ¢ÈáåÈù¢‰∏çÊñ≠ÂÅöÂπ≥Ë°åÁ∫ø‰∏çÂ∞±Â•Ω‰∫ÜÔºâ„ÄÇÂõ†Ê≠§Â∞±ÊòØË¶ÅÂà§Êñ≠‰∏Ä‰∏™ÂõæÂΩ¢ËÉΩ‰∏çËÉΩÂàÜÊàêËã•Âπ≤‰∏™Âπ≥Ë°åÂõõËæπÂΩ¢„ÄÇ ÁåúÁªìËÆ∫ÔºöÊØèÊù°ËæπËá≥Â∞ëÊúâÂè¶Â§ñ‰∏ÄÊù°Ëæπ‰∏éÂÖ∂Âπ≥Ë°å‰∏îÈïøÂ∫¶Áõ∏Á≠â„ÄÇ ËÆ°ÁÆóÊñúÁéáÁöÑÊó∂ÂÄô‰∏∫‰∫ÜÈÅøÂÖçÂàÜÊØç‰∏∫0Ë¶ÅÊ≥®ÊÑè‰∏Ä‰∏ã„ÄÇ ‰ª£Á†Å#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,ll&gt;P; const double eps=1e-6; int main() { int n,i,j,k; cin&gt;&gt;n; vector&lt;P&gt;v; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b);v.push_back(P(a,b));//Ëæπ } vector&lt;P&gt;xl;vector&lt;double&gt;len; for(i=0;i&lt;v.size();i++){ xl.push_back(P(v[(i+1)%n].first-v[i].first, v[(i+1)%n].second-v[i].second));//ÊñúÁéá(Èò≤Ê≠¢ÂàÜÊØç0Ê≤°ÊúâÁõ¥Êé•Èô§) len.push_back(sqrt((v[(i+1)%n].first-v[i].first) * (v[(i+1)%n].first-v[i].first) + (v[(i+1)%n].second-v[i].second)*(v[(i+1)%n].second-v[i].second)));//ËæπÈïøÂ∫¶ } for(i=0;i&lt;xl.size();i++){ bool isok=false; for(j=0;j&lt;xl.size();j++){//Êö¥ÂäõÊûö‰∏æ if(i==j)continue; if(xl[i].first*xl[j].second==xl[i].second*xl[j].first&amp;&amp;fabs(len[i]-len[j])&lt;eps){ isok=true;break; } } if(!isok){ puts(&quot;no&quot;);return 0; } } puts(&quot;yes&quot;); return 0; } H.È¶ñÂÖàÊòéÁ°Æ‰∏ÄÁÇπÔºåÂç≥È¢òÁõÆ‰∏≠ÁªôÁöÑÂáΩÊï∞$f(l,r)$‰ªñÁöÑÂÄºÊòØÂîØ‰∏ÄÁ°ÆÂÆöÁöÑÔºà$ÔºàlÔºårÔºâ$‰ª£Ë°®ÂÖ∂Â∑¶Âè≥ËæπÁïå‰ΩçÁΩÆÔºâÔºå‰ΩÜÊòØÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØÂú®$(l,r)$ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâ$f(l_1,r_1)$ÁöÑÊúÄÂ§ßÂÄºÔºåËøôÂ∞±‰∏çÁ°ÆÂÆö‰∫Ü„ÄÇÂõ†Ê≠§ÊÉ≥Ê≥ïÂæàÁÆÄÂçïÔºöÂÖàÁÆóÂá∫ÊâÄÊúâÁöÑ$f$ÔºåÁÑ∂ÂêéÂå∫Èó¥dpÊ±ÇÁ≠îÊ°à„ÄÇ ÂΩìÁÑ∂ÔºåÈ¶ñÂÖàË¶ÅÁÆÄÂçïÂÜôÂÜôÔºåÊé®Âá∫ÂÖ¨ÂºèÔºö $f(l,r)=f(l,r-1)\ \oplus\ f(l+1,r)=f(l,r-2)\ \oplus\ f(l+2,r)$ÔºàÊãøÂì™‰∏™ÂÖ¨ÂºèÊù•Êé®ÈÉΩÊ≤°ÈóÆÈ¢òÔºâ ‰ª£Á†Å#include&lt;bits/stdc++.h&gt; using namespace std; int num[5005][5005],f[5005][5005]; int main() { int n,i,j,k,len; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i][i];f[i][i]=num[i][i]; num[i-1][i]=num[i-1][i-1]^num[i][i]; } for(len=2;len&lt;n;len++) for(i=1;i+len&lt;=n;i++){ num[i][i+len]=num[i][i+len-2]^num[i+2][i+len]; } for(len=1;len&lt;n;len++){ for(i=1;i+len&lt;=n;i++){ f[i][i+len]=max(num[i][i+len],max(f[i+1][i+len],f[i][i+len-1]));//Ê≥®ÊÑèËøôÈáåÁöÑÊØîËæÉ } } int q,l,r; cin&gt;&gt;q; while(q--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\n&quot;,f[l][r]); } return 0; } I. ÁªôÂÆö‰∏§‰∏™Á≠âÈïøÊï∞ÁªÑAÔºåBÔºåË¶ÅÊ±ÇÂØπ‰∫éÊØè‰∏™$a_i$,Âú®B‰∏≠Êâæ‰∏Ä‰∏™Êï∞‰∏éÂÖ∂ÂºÇÊàñÔºåÂπ∂‰∏îB‰∏≠ÊØè‰∏™Êï∞Âè™ËÉΩÁî®‰∏ÄÊ¨°ÔºåÊ±ÇÂºÇÊàñÂêéÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑAÊï∞ÁªÑ ÊòæÁÑ∂Â∞±ÊòØÂØπA‰ªéÂâçÂæÄÂêéÊâæÂÆÉÂºÇÊàñÂêéÊúÄÂ∞èÁöÑbÂ∞±Ë°å‰∫ÜÂëÄÔºå‰∏∫‰∫ÜÊâæÂá∫ÊúÄÂ∞èÁöÑbÔºåÂª∫Á´ã‰∏ÄÊ£µ‰∫åËøõÂà∂trieÊ†ëÂç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn=3e6+5; struct node{ int sum; node*next1[2]; bool tag,ask; node(){//Êñ∞Âª∫ÂáΩÊï∞ sum=0;tag=false;ask=false;next1[0]=next1[1]=NULL; } }*root=new node(); void add(int x) { int i,j; struct node*p=root; for(i=30;~i;i--) { if((1&lt;&lt;i)&amp;x){ if(!p-&gt;next1[1]) { node*t=new node(); p-&gt;next1[1] = t; } p=p-&gt;next1[1]; } else { if(!p-&gt;next1[0]) { node*t=new node(); p-&gt;next1[0] = t; } p=p-&gt;next1[0]; } p-&gt;sum++; } } int query(int x) { int i,j;node*p=root,*pre; int res=0; for(i=30;~i;i--){ pre=p; if((1&lt;&lt;i)&amp;x){ if(p-&gt;next1[1]&amp;&amp;p-&gt;next1[1]-&gt;sum) p=p-&gt;next1[1],res=res&lt;&lt;1|1; else p=p-&gt;next1[0],res&lt;&lt;=1; } else{ if(p-&gt;next1[0]&amp;&amp;p-&gt;next1[0]-&gt;sum) p=p-&gt;next1[0],res&lt;&lt;=1; else p=p-&gt;next1[1],res=res&lt;&lt;1|1; } p-&gt;sum--; } return res; } int main() { int n,i,j,k; cin&gt;&gt;n;int a[maxn]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);add(j); } for(i=1;i&lt;=n;i++){ int ans=query(a[i]);ans^=a[i]; cout&lt;&lt;ans&lt;&lt;&apos; &apos;; } return 0; } J. ÁªôÂÆön‰∏™ÂΩ¢Â¶Ç$y=(x-a_i)^2+b_i$ÁöÑÊäõÁâ©Á∫øÔºåÊ±ÇÂÆÉ‰ª¨ÂàíÂàÜÂπ≥Èù¢ÁöÑÂå∫ÂüüÊï∞„ÄÇ Ê≥®ÊÑèÂà∞ÁªôÂÆöÁöÑÊäõÁâ©Á∫øÈÉΩÊòØÂêå‰∏ÄÁßçÂΩ¢ÂºèÁöÑÔºåÂΩì$a_i\neq a_j$Êó∂ÔºåËøô‰∏§‰∏™ÊäõÁâ©Á∫øÂ∞±Êúâ‰∏Ä‰∏™‰∫§ÁÇπÔºåÂê¶ÂàôÊ≤°Êúâ„ÄÇÂõ†Ê≠§ÂèØ‰ª•Á±ªÊØîÁõ¥Á∫øÂàíÂàÜÂπ≥Èù¢Êù•ÂÅöÔºöÂØπ‰∫éÊØè‰∏ÄÊù°Êñ∞ÁöÑÊäõÁâ©Á∫øÔºåÊàë‰ª¨ËÆ°ÁÆóÂÆÉ‰∏é‰πãÂâçÊäõÁâ©Á∫øÁöÑ‰∫§ÁÇπÊï∞ÔºåÂÆÉÂàíÂàÜÂá∫Êù•ÁöÑÊñ∞Âå∫ÂüüÊï∞Â∞±ÊòØÔºà‰∫§ÁÇπÊï∞+1Ôºâ„ÄÇÊ≥®ÊÑèÊü•ÈáçÔºåÂç≥‰∫§ÁÇπÈáçÂ§çÈóÆÈ¢ò„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; pair&lt;int,int&gt; p[1010]; pair&lt;double,double&gt; s[1010]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second); sort(p + 1, p + n + 1); n = unique(p + 1, p + n + 1) - p - 1; int ans = 1; for (int i = 1; i &lt;= n; i++) { int tot = 0; for (int j = 1; j &lt; i; j++) if (p[i].first != p[j].first) { double x = (double) (p[i].first * p[i].first + p[i].second - p[j].first * p[j].first - p[j].second) / (2 * (p[i].first - p[j].first)); double y = (double) (x - p[i].first) * (x - p[i].first) + p[i].second; s[++tot] = make_pair(x, y); } sort(s + 1, s + tot + 1); tot = unique(s + 1, s + tot + 1) - s - 1; ans += tot + 1; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>ÊØîËµõÊùÇÈõÜ</category>
        <category>ÊöëÂÅáËÆ≠ÁªÉ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>ÊØîËµõÊùÇÈõÜ</tag>
        <tag>ÊöëÂÅáËÆ≠ÁªÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÁü©ÈòµÂø´ÈÄüÂπÇ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-9f-a9-e9-98-b5-e5-bf-ab-e9-80-9f-e5-b9-82%2F</url>
    <content type="text"><![CDATA[Áü©Èòµ‰πòÊ≥ïÁöÑËÆ°ÁÆóÂÖ¨ÂºèÔºöÔºàÁ¨¨‰∏Ä‰∏™Áü©Èòµ‰∏∫m s,Á¨¨‰∫å‰∏™‰∏∫s nÔºåÁªìÊûú‰∏∫m* nÁü©ÈòµÔºâ $C_{ij}=\sum a_{ik}\times b_{kj}$ Êö¥ÂäõËÆ°ÁÆó‰ª£Á†ÅÔºàÊ®°ÊãüÔºâÔºö const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//nÊòØÁü©ÈòµÂ§ßÂ∞èÔºån&lt;N { memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } Áü©ÈòµÂø´ÈÄüÂπÇ ÁªôÂÆö$n\times n$ÁöÑÁü©Èòµ$A$ÔºåÊ±Ç$A^k$ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; const int maxn=105; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//Êö¥ÂäõËÆ°ÁÆóÁü©Èòµ‰πòÊ≥ï,N‰∏∫Áü©ÈòµÂ§ßÂ∞è { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////nÊòØÂπÇÔºåNÊòØÁü©ÈòµÂ§ßÂ∞è { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01Áü©Èòµ while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;Â§çÂà∂Áõ¥Êé•Âú®multiÈáåÈù¢ÂÆûÁé∞‰∫ÜÔºõ multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn],k; cin&gt;&gt;n&gt;&gt;k;//n‰∏∫Áü©ÈòµÂ§ßÂ∞è,k‰∏∫ÂπÇÊ¨° for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;matrci[i][j]; Pow(matrci,k,n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,res[i][j],j==n?&apos;\n&apos;:&apos; &apos;); return 0; } Â∫îÁî®‰∏ªË¶ÅÈÄöËøáÊääÊï∞ÊîæÂà∞Áü©ÈòµÁöÑ‰∏çÂêå‰ΩçÁΩÆÔºåÁÑ∂ÂêéÊääÊôÆÈÄöÈÄíÊé®ÂºèÂèòÊàê‚ÄùÁü©ÈòµÁöÑÁ≠âÊØîÊï∞Âàó‚ÄùÔºåÊúÄÂêéÂø´ÈÄüÂπÇÊ±ÇËß£ÈÄíÊé®ÂºèÔºõ POJ3070 È¢òÁõÆÔºöÊñêÊ≥¢ÈÇ£Â•ëÊï∞Âàóf(n),Áªô‰∏Ä‰∏™nÔºåÊ±Çf(n)%10000,n&lt;=1e9; (ËøôÈ¢òÊòØÂèØ‰ª•Áî®fiboÁöÑÂæ™ÁéØËäÇÂéªÂÅöÁöÑÔºå‰∏çËøáËøôÈáå‰∏çËÆ≤ÔºåÂèçÊ≠£ÊòØÊ∞¥È¢ò) Áü©ÈòµÂø´ÈÄüÂπÇÊòØÁî®Êù•Ê±ÇËß£ÈÄíÊé®ÂºèÁöÑÔºåÊâÄ‰ª•Á¨¨‰∏ÄÊ≠•ÂÖàË¶ÅÂàóÂá∫ÈÄíÊé®Âºè: $ f(n)=f(n-1)+f(n-2)$ Á¨¨‰∫åÊ≠•ÊòØÂª∫Á´ãÁü©ÈòµÈÄíÊé®ÂºèÔºåÊâæÂà∞ËΩ¨ÁßªÁü©Èòµ: $\binom{1\ 1}{1\ 0}\times \binom{f_{n-1}}{f_{n-2}}=\binom{f_n}{f_{n-1}}$ ÊâÄ‰ª•ÈÄöÈ°πÂ∞±ÊòØÔºö$A_n=T^{n-1}\times A_1\ $,$\ T$Â∞±ÊòØÈÇ£‰∏™ËΩ¨ÁßªÁü©Èòµ„ÄÇ ÈÇ£‰πàÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÂÖ∂ÂÆûÂ∞±ÊòØres[1][1]; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int mod=1e4; const int maxn=5; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//Êö¥ÂäõËÆ°ÁÆóÁü©Èòµ‰πòÊ≥ï,N‰∏∫Áü©ÈòµÂ§ßÂ∞è { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////nÊòØÂπÇÔºåNÊòØÁü©ÈòµÂ§ßÂ∞è { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01Áü©Èòµ while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;Â§çÂà∂Áõ¥Êé•Âú®multiÈáåÈù¢ÂÆûÁé∞‰∫ÜÔºõ multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn]={0},k; while(cin&gt;&gt;n&amp;&amp;n!=-1){ if(n==0){ cout&lt;&lt;0&lt;&lt;endl;continue; } matrci[1][1]=1,matrci[1][2]=1,matrci[2][1]=1,matrci[2][2]=0; Pow(matrci,n-1,2); ll fibo[5][5]={0};fibo[1][1]=1; multi(res,fibo,2); cout&lt;&lt;res[1][1]&lt;&lt;endl; } return 0; } ÁÆÄÂçïÈÄíÊé®ÂºèÔºö $1.\ f(n)=a\times f(n-1)+b\times f(n-2)+c\ $ (a,b,c‰∏∫Â∏∏Êï∞) $\binom{a\ b\ 1}{\binom{1\ 0\ 0}{0\ 0\ 1}}\times \binom{f_{n-1}}{\binom{f_{n-2}}{c}}=\binom{f_{n}}{\binom{f_{n-1}}{c}}$(Âõ†‰∏∫Áü©ÈòµÊúâÁÇπÈóÆÈ¢òÊâÄ‰ª•ÊöÇÊó∂ËøôÊ†∑) $2.f(n)=c^n-f(n-1)$ÔºàcÊòØÂ∏∏Êï∞Ôºâ $\binom{-1\ c}{0\ \ c}\times \binom{f_{n-1}}{c^{n-1}}=\binom{f_n}{c^n}$]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâÁ∫øÊÄßÂêå‰ΩôÊñπÁ®ãÁªÑÔºà‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÔºâ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b-e7-bb-84-ef-bc-88-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86-ef-bc-89%2F</url>
    <content type="text"><![CDATA[‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÊ±ÇÂêå‰ΩôÊñπÁ®ãÁªÑ $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $‚Ä¶$ $x\equiv c_k(mod\ m_k)$ ÂÖ∂‰∏≠Ôºå$\forall i,j$Êúâ$gcd(m_i,m_j)=1$, ÁöÑÊúÄÂ∞èÊ≠£Êï¥Êï∞ÔºàÈùûË¥üÊï¥Êï∞ÔºâËß£Ôºõ ÁªìËÆ∫‰ª§$M=m_1\times m_2\times ‚Ä¶\times m_k$Ôºå Âàô$x=(\sum c_i\times \frac{M}{m_i}\times inv(\frac{M}{m_i},m_i))$; ÂÖ∂‰∏≠,$inv(\frac{M}{m_i},m_i)$Âç≥$\frac{M}{m_i}$Áõ∏ÂØπ‰∫é$m_i$ÁöÑ‰πòÊ≥ïÈÄÜÂÖÉ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; ll extgcd(ll a,ll b,ll&amp;x,ll&amp;y) { if(b==0){ x=1,y=0;return a;//ËøîÂõûÁöÑÊòØÂàùÂßãÊó∂a,bÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ } ll d=extgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d; } int main() { ll n,a,b,i,j,m[20],k[20];//m‰∏∫ÂêÑ‰∏™Ê®°Êï∞,k‰∏∫‰ΩôÊï∞ cin&gt;&gt;n; ll M=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;m[i]&gt;&gt;k[i]; M*=m[i];//Ê±ÇM } ll x,y;ll X=0; for(i=1;i&lt;=n;i++){ ll a=M/m[i];ll b=m[i]; extgcd(a,b,x,y); x=(x+b)%b; if(!x)x+=b; X+=k[i]*a*x; } X%=M; } Ê®°ÊùøÈ¢ò Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÊ±ÇÂêå‰ΩôÊñπÁ®ãÁªÑ $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $‚Ä¶$ $x\equiv c_k(mod\ m_k)$ ÁöÑÊúÄÂ∞èÊ≠£Êï¥Êï∞ÔºàÈùûË¥üÊï¥Êï∞ÔºâËß£ÔºõÔºàÂç≥Âà†Âéª‰∫ÜÊ®°Êï∞‰∫íË¥®ÁöÑÊù°‰ª∂Ôºâ ÁªìËÆ∫ÂØπ‰∫é‰∏§‰∏™ÊñπÁ®ã $x\equiv c_1(mod\ m_1)$Âèä$x\equiv c_2(mod\ m_2)$ÔºåÂ∞ÜÂÖ∂ÂêàÂπ∂‰∏∫‰∏Ä‰∏™ÊñπÁ®ãÔºåÊúâËß£Êù°‰ª∂‰∏∫$gcd(m_1,m_2)|(c_2-c_1)$. ÈÇ£‰πàÔºàÊúâËß£Êó∂ÔºâÔºå$m=\frac{m_1\times m_2}{gcd(m_1,m_2)}$, $c=(inv(\frac{m_1}{gcd(m_1,m_2)},\frac{m_2}{gcd(m_1,m_2)})\times \frac{c_2-c_1}{gcd(m_1,m_2)}\ mod \ \frac{m_2}{gcd(m_1,m_2)}\times m_1+c_1$Ôºå Â¶ÇÊ≠§‰ªéÂâçÂæÄÂêéÈÄíÊé®‰∏ãÂéªÔºåÁõ¥Âà∞Ê±ÇÂá∫‰∏Ä‰∏™ÂºèÂ≠êÔºö $x\equiv c(mod\ m)$Ôºå ÈÇ£‰πàÂéüÊñπÁ®ãÁªÑÁöÑ‰∏Ä‰∏™Ëß£Âç≥‰∏∫$x=c\ mod\ m$ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int N=1005; int k; ll c[N],m[N],c1,c2,m1,m2,t;//c‰∏∫‰ΩôÊï∞,m‰∏∫Ê®°Êï∞ bool flag; ll gcd(ll a,ll b) { if (!b) return a; else return gcd(b,a%b); } void exgcd(ll a,ll b,ll &amp;x,ll &amp;y) { if (!b) x=1LL,y=0LL; else exgcd(b,a%b,y,x),y-=a/b*x; } ll inv(ll a,ll b) { ll x=0LL,y=0LL; exgcd(a,b,x,y); x=(x%b+b)%b; if (!x) x+=b; return x; } int main() { while (~scanf(&quot;%d&quot;,&amp;k))//Âêå‰ΩôÊñπÁ®ã‰∏™Êï∞ { flag=true; for (int i=1;i&lt;=k;i++) scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;c[i]); for (int i=2;i&lt;=k;i++) { m1=m[i-1],m2=m[i],c1=c[i-1],c2=c[i]; t=gcd(m1,m2); if ((c2-c1)%t!=0) { flag = false; break;//‰∏çÊï¥Èô§ÂàôÊó†Ëß£ } m[i]=m1*m2/t; c[i]=inv(m1/t,m2/t)*((c2-c1)/t)%(m2/t)*m1+c1; c[i]=(c[i]%m[i]+m[i])%m[i]; } if (!flag) puts(&quot;-1&quot;); else printf(&quot;%lld\n&quot;,c[k]); } return 0; } Ê≠§Êó∂ÁöÑÊúÄÂ∞èÊ≠£Êï¥Êï∞Ëß£Â∞±ÊòØ$c[k]$ÔºàÂ∞è‰∫é0Â∞±Âä†‰∏ä$m_1\times m_2$) Ê®°ÊùøËøêË°åËøáÁ®ã‰∏≠‰ºº‰πé‰ºöÈÅáÂà∞ÂèñÊ®°Êó∂ÂÄº‰∏∫Ë¥üÊï∞ÂØºËá¥Âá∫ÈîôÁöÑÈóÆÈ¢òÔºåËß£ÂÜ≥ÊñπÊ≥ïÂ¶Ç‰∏ãÔºö a[i] = m1 * m2 / t; ll temp=(c2 - c1) / t; if(temp&lt;0){ ll t1=abs(temp)/(m2/t);temp+=(m2/t)*(t1+1); } ll temp2=inv(m1 / t, m2 / t); if(temp2&lt;0){ ll t1=abs(temp2)/(m2/t);temp2+=(m2/t)*(t1+1); } c[i] = (temp2)%(m2 / t) * ((temp) % (m2 / t)) % (m2 / t)* m1 + c1; c[i] = (c[i] % a[i] + a[i]) % a[i]; Ê®°ÊùøÈ¢òÔºöPOJ2891]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâÁ∫øÊÄßÂêå‰ΩôÊñπÁ®ã]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[ÂÆö‰πâ:a,bÊòØÊï¥Êï∞ÔºåÂΩ¢Â¶Ç$ax‚â°b(mod \ m)$Ôºå‰∏îxÊòØÊú™Áü•Êï¥Êï∞ÁöÑÂêå‰ΩôÂºèÁß∞‰∏∫‰∏ÄÂÖÉÁ∫øÊÄßÂêå‰ΩôÊñπÁ®ã„ÄÇ ÂÆöÁêÜÔºöa,b,mÊòØÊï¥Êï∞‰∏îm&gt;0,$gcd(a,m)=d$,Â¶ÇÊûú$d|b$ÔºåÂàôÊñπÁ®ãÊÅ∞Â•ΩÊúâd‰∏™Ê®°m‰∏çÂêå‰ΩôÁöÑËß£ÔºåÂê¶ÂàôÊñπÁ®ãÊó†Ëß£„ÄÇ Áî±Âêå‰ΩôÊñπÁ®ãÁöÑÂÆö‰πâÂºèÂèØÂæó$ax+my=b$ÔºåËøô‰∏™ÊñπÁ®ãÁß∞‰∏∫‰∫åÂÖÉ‰∏ÄÊ¨°‰∏çÂÆöÊñπÁ®ã„ÄÇ Áî±Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÂèØÊ±ÇÂá∫ÊñπÁ®ã$ax+my=gcd(a,m)$ÁöÑÁâπËß£ÔºåÂàôÂéüÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ $ x = x_0 \times \frac{b}{gcd(a,m)}+ \frac{m}{gcd(a,m)}\times t$ $ y = y_0 \times \frac{b}{gcd(a,m)}‚Äì \frac{a}{gcd(a,m)}\times t$ $t=0,1,2,3‚Ä¶$ Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÔºö int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//ËøîÂõûÁöÑÊòØÂàùÂßãÊó∂a,bÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } xÔºåyÂç≥‰∏∫$ax+my=gcd(a,m)$ÁöÑÁâπËß£„ÄÇ ‰æãÂ≠êÔºöNOIP2012 Âêå‰ΩôÊñπÁ®ã Ê±ÇÂÖ≥‰∫é x ÁöÑÂêå‰ΩôÊñπÁ®ã $ax‚â°1(mod\ b) $ÁöÑÊúÄÂ∞èÊ≠£Êï¥Êï∞Ëß£„ÄÇ Âõ†‰∏∫È¢òÁõÆ‰øùËØÅ‰∫Ü‰∏ÄÂÆöÊúâËß£ÔºåÊâÄ‰ª•Áõ¥Êé•Ê±ÇÂç≥ÂèØ„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//ËøîÂõûÁöÑÊòØÂàùÂßãÊó∂a,bÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } int main() { int a,b,x,y; cin&gt;&gt;a&gt;&gt;b; extgcd(a,b,x,y); x=(x+b)%b; cout&lt;&lt;x&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÈ´òÁ≤æÂ∫¶ÁÆóÊ≥ï]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[__int128ÊúÄÁÆÄÂçïÁ≤óÊö¥ÁöÑÂÅöÊ≥ï„ÄÇ ËøôÁßçÁ±ªÂûãÂè™ÊúâÈÉ®ÂàÜGCCÁºñËØëÂô®ÊîØÊåÅ„ÄÇÁªèÊµãËØïÔºåÊ≠£Â∏∏ËøêÁÆó‰∏éÊôÆÈÄöintÊó†ÂºÇÔºå‰ΩÜÊòØËæìÂÖ•ËæìÂá∫Êó∂Êó†ËÆ∫ÊòØcinÔºåcoutËøòÊòØprintfÈÉΩ‰ºöÊä•ÈîôÔºåÊâÄ‰ª•ÂøÖÈ°ªËá™Â∑±ÂÜôËæìÂÖ•ËæìÂá∫ÂáΩÊï∞„ÄÇ ÂÆö‰πâÊó∂‰∏éÂà´ÁöÑÊï∞ÊçÆÁ±ªÂûãÂπ∂Ê≤°Êúâ‰ªÄ‰πàÂå∫Âà´ eg: __int128 a,b,c; ËæìÂÖ•ÊöÇÊó∂ÈááÁî®Â≠óÁ¨¶‰∏≤ËØªÂÖ•ÊñπÂºè„ÄÇ ÊñπÊ≥ï‰∏ÄÔºöÈáçËΩΩËæìÂá∫ std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, __int128 T) { if (T&lt;0) os&lt;&lt;&quot;-&quot;;if (T&gt;=10 ) os&lt;&lt;T/10;if (T&lt;=-10) os&lt;&lt;(-(T/10)); return os&lt;&lt;( (int) (T%10) &gt;0 ? (int) (T%10) : -(int) (T%10) ) ; } ÊñπÊ≥ï‰∫åÔºöÂèò‰∏∫Â≠óÁ¨¶‰∏≤ÂºèËæìÂÖ•ËæìÂá∫ ËæìÂÖ•Ôºö void scan(__int128 &amp;x)//ËæìÂÖ• { x = 0; int f = 1; char ch; if((ch = getchar()) == &apos;-&apos;) f = -f; else x = x*10 + ch-&apos;0&apos;; while((ch = getchar()) &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) x = x*10 + ch-&apos;0&apos;; x *= f; } ËæìÂá∫Ôºö void print(__int128 x) { if(x &lt; 0) { x = -x; putchar(‚Äò-‚Äò); } if(x &gt; 9) print(x/10); putchar(x%10 + ‚Äò0‚Äò); } ÁÆÄÂçïÊ®°ÊùøÔºà‰∏çÊîØÊåÅË¥üÊï∞Ôºâ#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 1000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } Êõ¥ÂÆåÂñÑÁöÑÊ®°ÊùøÊîØÊåÅË¥üÊï∞‰πãÁ±ªÁöÑÊìç‰Ωú„ÄÇÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÂ¶ÇÊûúÊ∂âÂèäbign‰∏éÂ∏∏ËßÑÁ±ªÂûãÁöÑÊï∞ÂÄº‰πãÈó¥ÁöÑ‰πãÈó¥ËÆ°ÁÆóÔºåÊØîÂ¶Ç‰∏Ä‰∏™bign+llÔºåÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÊñ∞Â¢ûÈáçËΩΩËøêÁÆóÁ¨¶ÔºåÂõ†‰∏∫ÈªòËÆ§ÁöÑ‰ºº‰πéÂè™Êúâbign+intÁöÑÈáçËΩΩÔºåÂê¶ÂàôÂèØËÉΩÊ∫¢Âá∫Âá∫Èîô„ÄÇ ‰ª•ÂèäÔºåÂ§ßÊï∞ÁöÑÈïøÂ∫¶ÈúÄË¶ÅÈ¢ùÂ§ñÊ≥®ÊÑèÔºåÂºÄÂ§™Â§ßÂÆπÊòìÁàÜÂÜÖÂ≠ò„ÄÇ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //ÊúÄÂ§ßÈïøÂ∫¶ÔºåÂèØ‰ª•‰øÆÊîπ using namespace std; class bign { public: int len, s[MAX_L];//Êï∞ÁöÑÈïøÂ∫¶ÔºåËÆ∞ÂΩïÊï∞ÁªÑ //ÊûÑÈÄ†ÂáΩÊï∞ bign(); bign(const char *); bign(int); bool sign;//Á¨¶Âè∑ 1Ê≠£Êï∞ 0Ë¥üÊï∞ string toStr() const;//ËΩ¨Âåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰∏ªË¶ÅÊòØ‰æø‰∫éËæìÂá∫ friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//ÈáçËΩΩËæìÂÖ•ÊµÅ friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//ÈáçËΩΩËæìÂá∫ÊµÅ //ÈáçËΩΩÂ§çÂà∂ bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //ÈáçËΩΩÂêÑÁßçÊØîËæÉ bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //ÈáçËΩΩÂõõÂàôËøêÁÆó bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //ÂõõÂàôËøêÁÆóÁöÑË°çÁîüËøêÁÆó bign operator%(const bign &amp;) const;//ÂèñÊ®°Ôºà‰ΩôÊï∞Ôºâ bign factorial() const;//Èò∂‰πò bign Sqrt() const;//Êï¥Êï∞ÂºÄÊ†πÔºàÂêë‰∏ãÂèñÊï¥Ôºâ bign pow(const bign &amp;) const;//Ê¨°Êñπ //‰∏Ä‰∫õ‰π±‰π±ÁöÑÂáΩÊï∞ void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005];]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊ¨ßÊãâÂáΩÊï∞]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e6-8b-89-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[1~n‰∏≠‰∏én‰∫íË¥®ÁöÑÊï∞ÁöÑ‰∏™Êï∞Áß∞‰∏∫Ê¨ßÊãâÂáΩÊï∞ int eular(int x) { int res = x, a = x; for (int i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } ÊÄßË¥®1Ôºö1~n‰∏≠‰∏én‰∫íË¥®ÁöÑÊï∞ÁöÑÂíå‰∏∫$n\times eularÔºànÔºâ\div2$; ÊÄßË¥®2ÔºöËã•aÔºåb‰∫íË¥®ÔºåÂàô$eularÔºàa\times bÔºâ=eularÔºàaÔºâ\times eularÔºàbÔºâ$Ôºõ]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâË¥®Êï∞Á≠õÊ≥ï]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-b4-a8-e6-95-b0-e7-ad-9b-e6-b3-95%2F</url>
    <content type="text"><![CDATA[ÂüÉÊãâÊâòÊñØÁâπÂ∞ºÁ≠õÊ≥ï#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; bool notprime[10000005]; void checkprime(int n) { for(int i=2;i&lt;=n;i++){//Ê≥®ÊÑèÁ∫øÊÄßÁ≠õÊ≥ïÂÅöÂÆå‰ª•Âêé1ÊòØÊ≤°ÊúâË¢´Ê†áËÆ∞ÁöÑ... if(notprime[i])continue;//Â¶ÇÊûúÂ∑≤ÁªèË¢´Ê†áËÆ∞‰∏∫ÂêàÊï∞,ÈÇ£Â∞±ÊªöËõã for(int j=i;j&lt;=n/i;j++)//Ê≥®ÊÑèËøôÈáå‰∏ÄÂÆöË¶ÅÂ∞èÂøÉj*iÂèØËÉΩÁàÜintÁöÑ‰∫ãÂÆûÔºåÂÜôÊàê //j=i*iÁöÑÊó∂ÂÄô‰πüÊòØ‰∏ÄÊ†∑Ë¶ÅÂ∞èÂøÉÔºÅÔºÅÔºÅÊúÄÂ•ΩÁî®long long notprime[j*i]=true;//Ê†áËÆ∞ÂêàÊï∞ } } int main() { int n,m,i; cin&gt;&gt;n&gt;&gt;m; checkprime(n);notprime[1]=true;//ÁâπÂà´Ê≥®ÊÑèË¶ÅÊ†áËÆ∞1 for(i=1;i&lt;=m;i++){ int t; scanf(&quot;%d&quot;,&amp;t); if(notprime[t])cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } return 0; } Á∫øÊÄßÁ≠õÔºà‰ºº‰πé‰∏çÂ§ßÂ∏∏Áî®Ôºâ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int v[10000005],prime[10000000],cnt=0;//vËÆ∞ÂΩïÊØè‰∏™Êï∞ÁöÑÊúÄÂ∞èË¥®Âõ†Êï∞,primeËÆ∞ÂΩïÁ¥†Êï∞ void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(v[i]==0){//Â¶ÇÊûúiÊòØÁ¥†Êï∞ v[i]=i; prime[++cnt]=i; } for(int j=1;j&lt;=cnt;j++){ if(prime[j]&gt;v[i]||prime[j]&gt;n/i)//Â¶ÇÊûúÂΩìÂâçÁöÑË¥®Êï∞Â∑≤ÁªèÊØîIÁöÑÊúÄÂ∞èË¥®Âõ†Êï∞Â§ß‰∫Ü,ÈÇ£‰πàÂ∞±Ê≤°ÊúâÂøÖË¶ÅÂÜçÁªßÁª≠‰∏ãÂéª‰∫Ü,Âõ†‰∏∫ÂêéÈù¢ÁöÑi*prime[j] break;//ËÇØÂÆöÂ∑≤ÁªèË¢´v[i]ÊàñËÄÖÂÖ∂‰ªñÊõ¥Â∞èÁöÑË¥®Êï∞Ê†áËÆ∞Ëøá‰∫Ü;ÂêåÊó∂,Ë∂ÖËøánËá™ÁÑ∂‰πüÊòØ‰∏çÁî®ÁÆ°‰∫Ü v[i*prime[j]]=prime[j];//Ê†áËÆ∞ÊúÄÂ∞èË¥®Âõ†Êï∞ } } } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; checkprime(n); for(int i=1;i&lt;=m;i++){ int t;scanf(&quot;%d&quot;,&amp;t); if(v[t]==t)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊ±Ç‰πòÊ≥ïÈÄÜÂÖÉ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-b1-82-e4-b9-98-e6-b3-95-e9-80-86-e5-85-83%2F</url>
    <content type="text"><![CDATA[‰πòÊ≥ïÈÄÜÂÖÉ$x\times x^{-1}=1\ (mod\ p)$ Ë¥πÈ©¨Â∞èÂÆöÁêÜÂâçÊèêÊòØÊ®°Êï∞ÂøÖÈ°ªÊòØË¥®Êï∞ÔºõÂõ†‰∏∫$a^{p-1}\ mod\ p=1$,ÊâÄ‰ª•aÊ®°pÁöÑ‰πòÊ≥ïÈÄÜÂÖÉÂ∞±ÊòØ$a^{p-2}$ ËøêÁî®Âø´ÈÄüÂπÇ: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int n,p,i,j; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt;ans; for(i=1;i&lt;=n;i++){ ll t=pow(i,p-2,p); ans.push_back(t); } for(i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; } Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÁªôÂÆöÊ®°Êï∞mÔºåÊ±ÇaÁöÑÈÄÜÁõ∏ÂΩì‰∫éÊ±ÇËß£$ax=1(mod \ m) $ Ëøô‰∏™ÊñπÁ®ãÂèØ‰ª•ËΩ¨Âåñ‰∏∫$ax-my=1 $ ÁÑ∂ÂêéÂ•óÁî®Ê±Ç‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁöÑÊñπÊ≥ïÔºåÁî®Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÊ±ÇÂæó‰∏ÄÁªÑx0,y0Âíågcd Ê£ÄÊü•$gcd(a,m)$ÊòØÂê¶‰∏∫1 gcd‰∏ç‰∏∫1ÂàôËØ¥ÊòéÈÄÜÂÖÉ‰∏çÂ≠òÂú® Ëã•‰∏∫1ÔºåÂàôË∞ÉÊï¥ x0 Âà∞0~m-1ÁöÑËåÉÂõ¥‰∏≠Âç≥ÂèØ void exgcd (ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return ; } exgcd (b, a % b, x, y); ll tmp = x; x = y; y = tmp - a / b * y; } //‰∏ªÂáΩÊï∞ÈÉ®ÂàÜË∞ÉÁî® ll x, y; exgcd (a, b, x, y);//Ê±ÇaÂú®Ê®°bÊÑè‰πâ‰∏ãÁöÑ‰πòÊ≥ïÈÄÜÂÖÉ x = (x + p) % p; printf (&quot;%d\n&quot;, x); ÈÄíÊé®Ê±ÇÈÄÜÂÖÉÁî®‰∫éÊ±ÇËøûÁª≠ÂæàÂ§öÊï∞ÁöÑ‰πòÊ≥ïÈÄÜÂÖÉÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶Âü∫Êú¨‰∏äÊòØÁ∫øÊÄß #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; int main() { ll n,p,i,j; cin&gt;&gt;n&gt;&gt;p; ll inv[3000005]; inv[1]=1; for(i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p;//ÂÖ≥ÈîÆ for(i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,inv[i]); return 0; } Ê±ÇËøûÁª≠Èò∂‰πòÁöÑ‰πòÊ≥ïÈÄÜÂÖÉÂÖàÊ±ÇÂá∫$n!$ÁöÑÈÄÜÂÖÉÔºåÂÄíÂ∫èÈÄíÊé®„ÄÇ $inv_i = (inv_{i+1}* (i+1))mod\ p$]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e5-87-a0-e9-87-8c-e5-be-97-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[Ê¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÔºàGCDÔºâÔºö #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;gcd(x,y)&lt;&lt;endl; return 0; } Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÔºö int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//ËøîÂõûÁöÑÊòØÂàùÂßãÊó∂a,bÁöÑÊúÄÂ§ßÂÖ¨Á∫¶Êï∞ } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } Êâ©Ê¨ßÊ±ÇÂá∫ÁöÑ$x$,$y$ ÊòØ$a x + b y = gcd(a,b)$ÁöÑ‰∏Ä‰∏™ÁâπËß£ÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•Áî® x0 Âíå y0 Ë°®Á§∫Âá∫Êï¥‰∏™‰∏çÂÆöÊñπÁ®ãÁöÑÈÄöËß£Ôºö $ x = x_0 + (b/gcd) t$ $ y = y_0 ‚Äì (a/gcd) t$]]></content>
      <categories>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâÂø´ÈÄüÂπÇ‰∏éÂø´ÈÄü‰πòÊ≥ï]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e5-b9-82-e4-b8-8e-e5-bf-ab-e9-80-9f-e4-b9-98-e6-b3-95%2F</url>
    <content type="text"><![CDATA[Âø´ÈÄüÂπÇÂØπ‰∫é‰ªª‰Ωï‰∏Ä‰∏™Êï¥Êï∞ÁöÑÊ®°ÂπÇËøêÁÆó $a^b\ mod \ c$ ÂØπ‰∫ébÊàë‰ª¨ÂèØ‰ª•ÊãÜÊàê‰∫åËøõÂà∂ÁöÑÂΩ¢Âºè $b=b_0+b_1 2+b_2 2^2+‚Ä¶+b_n* 2^n$ ËøôÈáåÊàë‰ª¨ÁöÑ$b_0$ÂØπÂ∫îÁöÑÊòØb‰∫åËøõÂà∂ÁöÑÁ¨¨‰∏Ä‰Ωç ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } Âø´ÈÄü‰πòÊ≥ï Áî±‰∫éËÆ°ÁÆóÊú∫Â∫ïÂ±ÇËÆæËÆ°ÁöÑÂéüÂõ†ÔºåÂÅöÂä†Ê≥ïÂæÄÂæÄÊØî‰πòÊ≥ïÂø´ÁöÑÂ§öÔºåÂõ†Ê≠§Â∞Ü‰πòÊ≥ïËΩ¨Êç¢‰∏∫Âä†Ê≥ïËÆ°ÁÆóÂ∞Ü‰ºöÂ§ßÂ§ßÊèêÈ´òÔºàÂ§ßÊï∞ÔºåÊØîËæÉÂ∞èÁöÑÊï∞‰πüÊ≤°ÂøÖË¶ÅÔºâ‰πòÊ≥ïËøêÁÆóÁöÑÈÄüÂ∫¶ÔºåÈô§Ê≠§‰πãÂ§ñÔºåÂΩìÊàë‰ª¨ËÆ°ÁÆóa* b%modÁöÑÊó∂ÂÄôÔºåÂæÄÂæÄËæÉÂ§ßÁöÑÊï∞ËÆ°ÁÆóaÔºäb‰ºöË∂ÖÂá∫long long intÁöÑËåÉÂõ¥ÔºåËøô‰∏™Êó∂ÂÄô‰ΩøÁî®Âø´ÈÄü‰πòÊ≥ïÊñπÊ≥ï‰πüËÉΩËß£ÂÜ≥‰∏äËø∞ÈóÆÈ¢òÔºé Âø´ÈÄü‰πòÊ≥ïÁöÑÂéüÁêÜÂ∞±ÊòØÂà©Áî®‰πòÊ≥ïÂàÜÈÖçÁéáÊù•Â∞ÜaÔºäbËΩ¨Âåñ‰∏∫Â§ö‰∏™ÂºèÂ≠êÁõ∏Âä†ÁöÑÂΩ¢ÂºèÊ±ÇËß£ÔºàÊ≥®ÊÑèËøôÊó∂‰ΩøÁî®‰πòÊ≥ïÂàÜÈÖçÁéáÁöÑÊó∂ÂÄôÂêéÈù¢ÁöÑ‰∏Ä‰∏™‰πòÊï∞ËΩ¨Âåñ‰∏∫‰∫åËøõÂà∂ÁöÑÂΩ¢ÂºèËÆ°ÁÆóÔºâÔºé EXÔºö$ 20Ôºä 14 Ôºù 20Ôºä (1110)_2 = 20 Ôºä (2^3)Ôºä1 + 20Ôºä(2^2)Ôºä1+20Ôºä(2^1)ÔºäÔºë+20Ôºä (2^0)Ôºä 0 = 160+80+40=280$ ‰∏äÈù¢Âç≥‰∏∫Âø´ÈÄü‰πòÊ≥ïÁöÑÂü∫Êú¨ÂéüÁêÜ ll quick_mul(ll a, ll b, ll c) { ll ans = 0; a %= c; b %= c; while (b) { if (b &amp; 1)//Â¶ÇÊûúÂØπÂ∫î‰Ωç‰∏∫1 ans = (ans + a) % c; a &lt;&lt;= 1; a %= c;//ÂØπÂ∫îbÁöÑ‰ΩçÊØèÊ¨°ÁöÑÂπÇÊ¨°‰ºöÂ¢ûÂä†ÔºåÂä†Âú®a‰∏ä b &gt;&gt;= 1; } return ans; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âü∫Á°ÄÊï∞Â≠¶</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âü∫Á°ÄÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâËÆ°ÁÆóÂá†‰Ωï]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-ae-a1-e7-ae-97-e5-87-a0-e4-bd-95%2F</url>
    <content type="text"><![CDATA[Ê®°ÊùøÂ¶Ç‰∏ãÔºåËß£ÈáäËßÅÊ≥®ÈáäÔºö #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 100000; const double EPS = 1e-8; // Â∏¶ËØØÂ∑ÆÊØîËæÉ inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } /* * ÂêëÈáèÔºàVectorÔºâÊàñÁÇπ * * ‰ΩøÁî®ÂéüÁÇπÂà∞‰∏Ä‰∏™ÁÇπ (x, y) ÁöÑÊúâÂêëÁ∫øÊÆµË°®Á§∫ÂêëÈáè * ‰ªéÁÇπ A Âà∞ÁÇπ B ÁöÑÂêëÈáèË°®Á§∫‰∏∫ A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // Áõ∏Âä† Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // Áõ∏Âáè Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // Êï∞‰πòÔºà‰º∏Èïø„ÄÅÁº©Áü≠Ôºâ Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // ËåÉÊï∞ÔºåÁî®Êù•ÊØîËæÉÈïøÂ∫¶ÔºåÁ≠â‰∫éÈïøÂ∫¶ÁöÑÂπ≥Êñπ double norm() const { return x * x + y * y; } } Pt; // ÁÇπ‰πò double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // Âèâ‰πò double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } // Á∫øÊÆµÔºàSegmentÔºâÔºåÁî®‰∏§‰∏™ÁÇπË°®Á§∫ struct Seg { Pt a, b; Seg(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} // Á∫øÊÆµÂåÖÂê´ÁÇπÔºàÁÇπÂú®Á∫øÊÆµ‰∏äÔºâ bool include(const Pt &amp;p) { // PA √ó PB = 0ÔºöPA ‰∏é PB ÂÖ±Á∫øÔºåÂç≥ÁÇπÂú®Á∫øÊÆµÊâÄÂú®ÁöÑÁõ¥Á∫ø‰∏ä // PA ¬∑ PB = 0ÔºöPA ‰∏é PB ÊñπÂêë‰∏çÂêåÔºàA Âíå B ÂàÜÂà´Âú® P ÁöÑ‰∏§ËæπÔºâÔºåÂ¶ÇÊûú PA ¬∑ PB = 0 Âàô P = A Êàñ P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } }; // Áõ¥Á∫øÔºåÁî®‰∏§‰∏™ÁÇπË°®Á§∫ struct Line { Pt a, b; Line() {} // Êèê‰æõ‰∏Ä‰∏™‰∏çÈúÄË¶ÅÂèÇÊï∞ÁöÑÊûÑÈÄ†ÂáΩÊï∞ Line(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } // ‰∏§Áõ¥Á∫øÂÖ≥Á≥ªÔºà‰∫§ÁÇπ‰∏™Êï∞Ôºâ // 0 Ë°®Á§∫Âπ≥Ë°åÔºàÊó†‰∫§ÁÇπÔºâ // 1 Ë°®Á§∫Áõ∏‰∫§Ôºà‰∏Ä‰∏™‰∫§ÁÇπÔºâ // -1 Ë°®Á§∫ÈáçÂêàÔºàÊó†Êï∞‰∏™‰∫§ÁÇπÔºâ static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } // Ê±Ç‰∏§Áõ¥Á∫ø‰∫§ÁÇπÔºàÈúÄË¶Å‰øùËØÅ‰∏§Áõ¥Á∫øÊúâ‰∫§ÁÇπÔºâ static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } }; // Ê±ÇÂá∏ÂåÖÁî®ÁöÑÁÇπ int n; Pt a[MAXN + 1]; // Âá∏ÂåÖÊûÅËßíÊéíÂ∫èÁöÑÊØîËæÉÂáΩÊï∞ inline bool compare(const Pt &amp;a, const Pt &amp;b) { // ‰∏§‰∏™ÂêëÈáè Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB ÊòØÈÄÜÊó∂ÈíàÔºåÂàô A ÊûÅËßíÂ∫èÂú®ÂÖà else return va.norm() &lt; vb.norm(); // norm ËæÉÂ∞èÁöÑÈïøÂ∫¶ËæÉÂ∞è } struct Poly { std::vector&lt;Pt&gt; pts; //Â¶ÇÊûú‰∏çÊ±ÇÂá∏ÂåÖÁöÑËØù,ÊääÂ§öËæπÂΩ¢ÁöÑÁÇπÁõ¥Êé•‰øùÂ≠òÂú®ËøôÈáå,Âê¶ÂàôÊääÂ§öËæπÂΩ¢ÁöÑÁÇπ‰øùÂ≠òÂú®Â§ñÈù¢ÁöÑaÊï∞ÁªÑ‰∏≠ bool include(const Pt &amp;p) const { int cnt = 0; // Âà§Êñ≠‰∏éÊØèÊù°ËæπÊúâÊ≤°Êúâ‰∫§ÁÇπ for (size_t i = 0; i &lt; pts.size(); i++) { // Êûö‰∏æÁõ∏ÈÇªÁöÑÊØè‰∏§‰∏™ÁÇπ const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // Â¶ÇÊûúÁÇπ P Âú®Ëæπ AB ‰∏ä if (Seg(a, b).include(p)) return true; // ËØ¶ËßÅÂõæ double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // Â•áÊï∞ÁöÑ‰∫§ÁÇπ return cnt % 2 == 1; } // Â§öËæπÂΩ¢Èù¢ÁßØÔºàÊúâÂêëÈù¢ÁßØÔºâ double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // Êûö‰∏æÊØè‰∏§‰∏™ÁÇπ const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } // Ê±ÇÂá∏ÂåÖÔºàConvexÔºâÔºåÁªìÊûúÂÇ®Â≠òÂú®Ëá™Ë∫´ pts ‰∏≠ void convex() { // ÊâæÂá∫ÊúÄÂ∑¶‰∏ãËßíÁöÑÁÇπ int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // ÊéíÂ∫è std::sort(a + 2, a + n + 1, &amp;compare); // ÊûÅËßíÂ∫èÊâ´Êèè pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // ÊØîËæÉÔºåÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÁÇπÈúÄË¶ÅË¢´Âà†ÊéâÂàôÂºπÂá∫Ôºàpop_backÔºâ while (pts.size() &gt;= 2 &amp;&amp; cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) &gt;= 0) pts.pop_back(); pts.push_back(a[i]); } } }; ÊóãËΩ¨Âç°Â£≥ÔºàÂú®ÂéüÊúâÊ®°Êùø‰∏äÊ±ÇÂá∫Âá∏ÂåÖÂêéÂ¢ûÂä†‰ª•‰∏ã‰ª£Á†ÅÂç≥ÂèØÔºâÔºöÊ≥®ÊÑèÔºöÊ®°ÊùøÈáåÁöÑansÊ≤°ÊúâÂºÄÊñπÔºÅËøîÂõûÁöÑÊòØÊúÄËøúÁÇπÂØπË∑ùÁ¶ªÁöÑÂπ≥ÊñπÔºÅËß£ÈáäÔºöhttp://www.cnblogs.com/Booble/archive/2011/04/03/2004865.html double cross(Pt a,Pt b,Pt c)//Ê±ÇÂèâÁßØ { return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x); } double dist2(Pt a,Pt b)//Ê±ÇË∑ùÁ¶ª { Pt x=a-b; return (x.norm());//Âõ†‰∏∫Êú¨È¢òÂè™Ë¶ÅÊ±ÇÊ±ÇË∑ùÁ¶ªÁöÑÂπ≥ÊñπÊâÄ‰ª•Ê≤°ÊúâÂºÄÊñπ } double rotating_calipers(Poly p)//ÊóãËΩ¨Âç°Â£≥ { int j=1,n=p.pts.size();p.pts.push_back(p.pts[0]); double ans=0; for(int i=0;i&lt;n;i++) { while(cross(p.pts[i],p.pts[i+1],p.pts[j])&lt;cross(p.pts[i],p.pts[i+1],p.pts[j+1])) j=(j+1)%n; ans=max(ans,max(dist2(p.pts[i],p.pts[j]),dist2(p.pts[i+1],p.pts[j+1]))); } return ans; }]]></content>
      <categories>
        <category>ËÆ°ÁÆóÂá†‰Ωï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>ËÆ°ÁÆóÂá†‰Ωï</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Ê®°ÊùøÔºâSplayÁª¥Êä§Âå∫Èó¥ÁøªËΩ¨]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fe6-a8-a1-e6-9d-bf-ef-bc-89splay-e7-bb-b4-e6-8a-a4-e5-8c-ba-e9-97-b4-e7-bf-bb-e8-bd-ac%2F</url>
    <content type="text"><![CDATA[ÊÇ®ÈúÄË¶ÅÂÜô‰∏ÄÁßçÊï∞ÊçÆÁªìÊûÑÔºàÂèØÂèÇËÄÉÈ¢òÁõÆÊ†áÈ¢òÔºâÔºåÊù•Áª¥Êä§‰∏Ä‰∏™ÊúâÂ∫èÊï∞ÂàóÔºåÂÖ∂‰∏≠ÈúÄË¶ÅÊèê‰æõ‰ª•‰∏ãÊìç‰ΩúÔºöÁøªËΩ¨‰∏Ä‰∏™Âå∫Èó¥Ôºå‰æãÂ¶ÇÂéüÊúâÂ∫èÂ∫èÂàóÊòØ5 4 3 2 1ÔºåÁøªËΩ¨Âå∫Èó¥ÊòØ[2,4]ÁöÑËØùÔºåÁªìÊûúÊòØ5 2 3 4 1 ËæìÂÖ•ËæìÂá∫Ê†ºÂºèËæìÂÖ•Ê†ºÂºèÔºöÁ¨¨‰∏ÄË°å‰∏∫n,m nË°®Á§∫ÂàùÂßãÂ∫èÂàóÊúân‰∏™Êï∞ÔºåËøô‰∏™Â∫èÂàó‰æùÊ¨°ÊòØ $(1,2,‚Ä¶n-1,n)$ ,mË°®Á§∫ÁøªËΩ¨Êìç‰ΩúÊ¨°Êï∞ Êé•‰∏ãÊù•mË°åÊØèË°å‰∏§‰∏™Êï∞$ [l,r][l,r]$ Êï∞ÊçÆ‰øùËØÅ $1‚â§l‚â§r‚â§n$ ËæìÂá∫Ê†ºÂºèÔºöËæìÂá∫‰∏ÄË°ån‰∏™Êï∞Â≠óÔºåË°®Á§∫ÂéüÂßãÂ∫èÂàóÁªèËøámÊ¨°ÂèòÊç¢ÂêéÁöÑÁªìÊûú Á±ª‰ººÁ∫øÊÆµÊ†ëÁöÑlazytabÊìç‰Ωú. SplayÂèØ‰ª•Áî®Êù•Áª¥Êä§Â∫èÂàó„ÄÇËøôÊ†∑ÁöÑËØùÊòØÊääSplayÂΩì‰Ωú‰∏ÄÊ£µÂå∫Èó¥Ê†ë„ÄÇ ÊâÄË∞ìÂå∫Èó¥Ê†ëÂíåÊùÉÂÄºÊ†ëÁöÑÂå∫Âà´ÔºåÂ§ßÊ¶ÇÂ∞±ÊòØÂå∫Èó¥Ê†ëÊØè‰∏™ËäÇÁÇπ‰ª£Ë°®ÁöÑÊòØ‰∏ÄÊÆµÂå∫Èó¥ÔºàÂÖ∏Âûã‰ª£Ë°®Â∞±ÊòØ‰∏ÄËà¨ÁöÑÁ∫øÊÆµÊ†ëÔºâ ÊùÉÂÄºÊ†ëÂ•ΩÁêÜËß£‰∏ÄÁÇπÔºåÂ∞±ÊòØÊØè‰∏™ÁÇπÁúüÁöÑ‰ª£Ë°®‰∏Ä‰∏™ÁÇπ„ÄÇ Ëá≥‰∫éÁøªËΩ¨Êìç‰ΩúÔºåÊàë‰ª¨ÂèØ‰ª•Âà©Áî®SplayÁöÑËøáÁ®ãÂÆûÁé∞„ÄÇ #include&lt;bits/stdc++.h&gt; #define N 100005 using namespace std; int n,m; int fa[N],ch[N][2],size[N],rev[N],rt; inline void pushup(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; } void pushdown(int x){ if(rev[x]){ swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0; } } void rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],kind; if(ch[y][0]==x)kind=1;else kind=0; if(y==k)k=x; else{if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} ch[y][kind^1]=ch[x][kind];fa[ch[y][kind^1]]=y; ch[x][kind]=y;fa[y]=x;fa[x]=z; pushup(x);pushup(y); } void splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } void build(int l,int r,int f){ if(l&gt;r)return; int mid=(l+r)/2; if(mid&lt;f)ch[f][0]=mid;else ch[f][1]=mid; fa[mid]=f;size[mid]=1; if(l==r)return; build(l,mid-1,mid);build(mid+1,r,mid); pushup(mid); } int find(int x,int k){ pushdown(x);int s=size[ch[x][0]]; if(k==s+1)return x; if(k&lt;=s)return find(ch[x][0],k); else return find(ch[x][1],k-s-1); } void rever(int l,int r){ int x=find(rt,l),y=find(rt,r+2); splay(x,rt);splay(y,ch[x][1]);int z=ch[y][0]; rev[z]^=1; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt=(n+3)/2;build(1,n+2,rt); for(int i=1;i&lt;=m;i++){ int L,R;scanf(&quot;%d%d&quot;,&amp;L,&amp;R); rever(L,R); } for(int i=2;i&lt;=n+1;i++)printf(&quot;%d &quot;,find(rt,i)-1); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Âπ≥Ë°°Ê†ë</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Âπ≥Ë°°Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #499 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-499-div-2%2F</url>
    <content type="text"><![CDATA[A. Êö¥ÂäõÊêûÊêûÂ∞±Ë°å #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int main() { int n,k,i,j; string str; cin&gt;&gt;n&gt;&gt;k&gt;&gt;str; vector&lt;char&gt;v; for(auto a:str)v.push_back(a); sort(v.begin(),v.end()); int pre=0;int cnt=0,w=0; for(i=0;i&lt;v.size();i++){ if(v[i]-pre&lt;2)continue; else{ cnt++;pre=v[i];w+=v[i]-&apos;a&apos;+1; } if(cnt==k)break; } if(cnt&lt;k){ puts(&quot;-1&quot;); } else{ cout&lt;&lt;w&lt;&lt;endl; } return 0; } B. ÊØîËµõÁöÑÊó∂ÂÄôÂÇªÈÄº‰∫ÜÔºåÂÜô‰∫ÜÂçäÂ§©‰ºòÂÖàÈòüÂàóÔºåÊï∞ÊçÆÈÇ£‰πàÂ∞èÈ™ëÂ£´Êö¥ÂäõÊûö‰∏æÊØè‰∏™‰∫∫ËÉΩÂàÜÂ§öÂ∞ë‰∏™Â∞±ÂèØ‰ª•‰∫ÜÔºåÊï∞ÊçÆË¶ÅÊòØÂ§ß‰∏ÄÁÇπ‰∫åÂàÜ‰πüË°å„ÄÇ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int cnt[105], b[105]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; cnt[i]; b[cnt[i]]++; } for (int i = 100; i &gt;= 1; i--) { int t = 0; for (int j = 1; j &lt;= 100; j++) { t += b[j] / i; } if (t &gt;= n) { cout &lt;&lt; i; return 0; } } cout &lt;&lt; 0; return 0; } C. ÊÑüËßâËøôÈ¢òÈùûÂ∏∏Á≠æÂà∞ÂëÄÔºåÁõ¥Êé•ÈÄíÊé®Â∞±Ë°å‰∫Ü #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,m,i,j,k,a[1005],b[1005]; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; if(a[i]==1){ puts(&quot;-1&quot;);return 0; } } for(i=1;i&lt;=n;i++){ cin&gt;&gt;b[i]; if(b[i]==1){ puts(&quot;-1&quot;);return 0; } } double w=m; w+=w/(b[1]-1); for(i=n;i&gt;1;i--){ w+=w/(a[i]-1); w+=w/(b[i]-1); } w+=w/(a[1]-1); printf(&quot;%.10f\n&quot;,w-m); return 0; } D. È¢òÁõÆÊØîËæÉÈïøÔºåÈöæÂ∫¶‰∏ªË¶ÅÊòØÂú®ËØªÈ¢ò‰∏äËøòÊúâËæìÂá∫flush‰∏ä„ÄÇÂÖ∂ÂÆûÊú¨Ë∫´‰∏çÂ§™ÈöæÔºåÈ¶ñÂÖàÊàë‰ª¨‰∏çÁü•ÈÅìÁúüÂÅáÂ∫èÂàóÊòØ‰ªÄ‰πàÁöÑËØùÊòæÁÑ∂ÊòØÊó†‰ªé‰∏ãÊâãÁöÑÔºåÂõ†Ê≠§Êàë‰ª¨Âè™Ë¶ÅÈóÆnÊ¨°ÊúÄÂ§ßÂÄºmÊàñËÄÖnÊ¨°1Â∞±ÂèØ‰ª•‰∫ÜÔºåÂõ†‰∏∫Êàë‰ª¨Áü•ÈÅìËøôÁßçÊÉÖÂÜµ‰∏ãÁöÑÁ≠îÊ°àÔºàÂ¶ÇÊûúËøîÂõû0ÁöÑËØùÈÇ£Áõ¥Êé•ÁªìÊùüÁ®ãÂ∫èÂ∞±Ë°å‰∫ÜÔºâÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Ê±ÇÂá∫Êï¥‰∏™Â∫èÂàó‰∫Ü„ÄÇÁÑ∂ÂêéÂõ†‰∏∫mÁöÑËåÉÂõ¥ÊúâÈôêÔºåËÄåÊàë‰ª¨Áü•ÈÅì‰ªª‰Ωï‰∏Ä‰∏™Ê≠£Êï¥Êï∞ÈÉΩÂèØ‰ª•Áî®2ÁöÑËã•Âπ≤‰∏™ÂπÇÊ¨°ÁöÑÂíåË°®Áé∞Âá∫Êù•ÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ã„ÄÇ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int wrong[31], poww[31]; int main() { int m, n, q1,i,j,k; cin &gt;&gt; m &gt;&gt; n; poww[0] = 1; for (i = 1; i &lt; 31; i++) { poww[i] = poww[i - 1] &lt;&lt; 1;//È¢ÑÂ§ÑÁêÜ2ÁöÑÂπÇÊ¨°Êñπ } for (i = 0; i &lt; n; i++) { printf(&quot;%d\n&quot;, m);//ËØ¢ÈóÆnÊ¨°m fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (q1 == -1) wrong[i] = 1; else if (q1 == 1) wrong[i] = 0; else return 0;//Â¶ÇÊûúÊòØ0Áõ¥Êé•ËøîÂõû } int ans = 0;int num = 0; for (i = 29; ~i ; i--) { if (ans + poww[i]&gt;m)continue; printf(&quot;%d\n&quot;, ans + poww[i]); fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (wrong[num%n] == 0)q1 *= -1;//Ê†πÊçÆÈ¢ÑÂ§ÑÁêÜÁúüÂÅáÂ∫èÂàóÊîπÂèò if (q1 == 1) { ans += poww[i]; } else if (q1 == 0) { return 0; } num++; } printf(&quot;%d\n&quot;, ans); return 0; } E. È¢òÁõÆÁúüÁöÑÊå∫ÈöæÊáÇÁöÑ„ÄÇÂÖ∂ÂÆûÂ∞±ÊòØÁªôÂÆönÁßçÊï∞ÂèäkÔºåÊØè‰∏™Êï∞ÂèØ‰ª•Áî®Êó†ÈôêÊ¨°ÔºåÈóÆËøô‰∫õÊï∞ÈöèÊÑèÁªÑÂêàÁöÑÂíå%kÊúâÂ§öÂ∞ëÁßçÂèØËÉΩÔºåÂπ∂ËæìÂá∫ÊâÄÊúâÂèØËÉΩ„ÄÇ ÂÖ∂ÂÆûÂ∞±ÊòØÊ±ÇÂêå‰ΩôÊñπÁ®ã$a_1 x_1+a_2 x_2+‚Ä¶+a_n* x_n=m (mod k)$‰∏≠ÊâÄÊúâÁöÑm„ÄÇ Ê†πÊçÆË¥ùÁ•ñÂÆöÁêÜÂèØ‰ª•Áü•ÈÅìÔºåËøôÁ≠â‰ª∑‰∫éÈóÆÊúâÂ§öÂ∞ë‰∏™mÊª°Ë∂≥$gcd(a_1,a_2,a_3‚Ä¶a_n)|m$ ÈÇ£‰πàÂÖ∂ÂÆûÂ∞±ÂæàÂ•ΩÊ±Ç‰∫Ü„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; //set&lt;int&gt;s; int d=k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); d=gcd(d,j%k); } int cnt=0; for(i=0;i&lt;k;i+=d) cnt++; cout&lt;&lt;cnt&lt;&lt;endl; for(i=0;i&lt;k;i+=d) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2486 Ê†ëÈìæÂâñÂàÜÔºàÂå∫Èó¥Êõ¥ÊîπÔºåÂå∫Èó¥Êü•ÈáçÔºâ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fp2486-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8c-ba-e9-97-b4-e6-9b-b4-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-9f-a5-e9-87-8d-ef-bc-89%2F</url>
    <content type="text"><![CDATA[Ê†ëÂâñÔºåÁî®Á∫øÊÆµÊ†ëÁª¥Êä§Ôºö Êï∞ÁªÑa[N]Ë°®Á§∫Ê≠§Êó∂ÁöÑÈ¢úËâ≤ÊÆµÊï∞„ÄÇ Êï∞ÁªÑleft1[N]Ë°®Á§∫Ê≠§Êó∂ÊúÄÂ∑¶ËæπÁöÑËäÇÁÇπÁöÑÈ¢úËâ≤„ÄÇ Êï∞ÁªÑright1[N]Ë°®Á§∫Ê≠§Êó∂ÊúÄÂè≥ËæπÁöÑËäÇÁÇπÁöÑÈ¢úËâ≤„ÄÇ ÂàôÔºö È¶ñÂÖàÊàë‰ª¨Ë¶ÅÊòéÁ°ÆÔºåÁ∫øÊÆµÊ†ëÁöÑÂè∂Â≠êËäÇÁÇπ‰∏ÄÂÆöÂè™Êúâ‰∏ÄÁßçÈ¢úËâ≤Ôºå‰πüÂ∞±ÊòØ‰∏ÄÊù°È¢úËâ≤ÊÆµ„ÄÇ a[Áà∂‰∫≤]=a[Â∑¶ÂÑøÂ≠ê]+a[Âè≥ÂÑøÂ≠ê]Ôºõ if (left1[Âè≥ÂÑøÂ≠ê]==right1[Â∑¶ÂÑøÂ≠ê]) {a[Áà∂‰∫≤]‚Äì;} Âç≥Â¶ÇÊûúÂè≥ÂÑøÂ≠êÁöÑÊúÄÂ∑¶ËæπÈ¢úËâ≤ÂíåÂ∑¶ÂÑøÂ≠êÁöÑÊúÄÂè≥ËæπÈ¢úËâ≤Áõ∏ÂêåÔºåÈÇ£‰πàËÇØÂÆöÊúâ‰∏≠Èó¥ÈÉ®ÂàÜÂ±û‰∫éÂêå‰∏ÄÈ¢úËâ≤ÊÆµ„ÄÇ ‰ª•ÂèäÂæÄ‰∏äË∑≥ÁöÑÊó∂ÂÄôÈáçÈìæËøûÊé•Â§ÑÈ¢úËâ≤ÊòØÂê¶Áõ∏ÂêåÁöÑÈóÆÈ¢òÔºåÁõ∏ÂêåÁöÑËØù‰πüË¶ÅÂáè„ÄÇ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=100000+10; vector&lt;int&gt;G[maxn]; //int mod; //ËßÅÈ¢òÊÑè int w[maxn],wt[maxn]; //w[]„ÄÅwt[]ÂàùÂßãÁÇπÊùÉÊï∞ÁªÑ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],left1[maxn&lt;&lt;2],right1[maxn&lt;&lt;2]; //Á∫øÊÆµÊ†ëÊï∞ÁªÑ„ÄÅlazyÊìç‰Ωú int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]ÈáçÂÑøÂ≠êÁºñÂè∑,id[]Êñ∞ÁºñÂè∑,fa[]Áà∂‰∫≤ËäÇÁÇπ,cnt dfs_clock/dfsÂ∫è,dep[]Ê∑±Â∫¶,siz[]Â≠êÊ†ëÂ§ßÂ∞è,top[]ÂΩìÂâçÈìæÈ°∂Á´ØËäÇÁÇπ //int res=0; //Êü•ËØ¢Á≠îÊ°à //-------------------------------------- ‰ª•‰∏ã‰∏∫Á∫øÊÆµÊ†ë inline void pushdown(int rt) { a[rt&lt;&lt;1]=a[rt&lt;&lt;1|1]=1; lazytab[rt&lt;&lt;1]=lazytab[rt&lt;&lt;1|1]=left1[rt&lt;&lt;1]=right1[rt&lt;&lt;1]=left1[rt&lt;&lt;1|1]=right1[rt&lt;&lt;1|1]=lazytab[rt]; lazytab[rt]=0; } void pushup(int r) { a[r]=a[r&lt;&lt;1]+a[r&lt;&lt;1|1]; left1[r]=left1[r&lt;&lt;1];right1[r]=right1[r&lt;&lt;1|1]; if(right1[r&lt;&lt;1]==left1[r&lt;&lt;1|1])a[r]--; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=1; left1[rt]=right1[rt]=wt[l]; //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); //a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); pushup(rt); } inline int query(int rt,int l,int r,int L,int R) { int ans=0; if(L&lt;=l&amp;&amp;r&lt;=R){ return a[rt]; } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))ans+=query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)ans+=query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); if(L&lt;=((l+r)&gt;&gt;1)&amp;&amp;R&gt;(l+r)&gt;&gt;1&amp;&amp;right1[rt&lt;&lt;1]==left1[rt&lt;&lt;1|1])ans--;//ËøôÈáå‰πüË¶ÅÊ≥®ÊÑèÁöÑ‰∏§ËæπÈÉΩÊúâÁöÑÊÉÖÂÜµ‰∏ãÊâçË¶ÅÂáè } return ans; } inline void update(int rt,int l,int r,int L,int R,int color) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]=color;left1[rt]=right1[rt]=color;a[rt]=1; return; //a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,color); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,color); pushup(rt); } } //---------------------------------‰ª•‰∏ä‰∏∫Á∫øÊÆµÊ†ë int QAQ(int rt, int l, int r, int p) { if (l==r) return left1[rt]; if (lazytab[rt]) pushdown(rt); if (p&gt;(l+r&gt;&gt;1)) return QAQ((rt &lt;&lt; 1 | 1), (l + r &gt;&gt; 1) + 1, r, p); else return QAQ((rt &lt;&lt; 1), l, (l + r &gt;&gt; 1), p); }//ËøîÂõûÈáçÈìæÈ°∂ÁÇπÁöÑÈ¢úËâ≤ inline int queryrange(int x, int y,int n)//Êü•ËØ¢‰ªéxÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÁöÑÊùÉÂÄº‰πãÂíå,nÂ∞±ÊòØËäÇÁÇπÁöÑÊÄªÊï∞ { int ans=0; while(top[x]!=top[y]){//ÂΩì‰∏§‰∏™ÁÇπ‰∏çÂú®Âêå‰∏ÄÊù°Èìæ‰∏ä if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//ÊääxÁÇπÊîπ‰∏∫ÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ //res=0; ans+=query(1,1,n,id[top[x]],id[x]);//ansÂä†‰∏äxÁÇπÂà∞xÊâÄÂú®ÈìæÈ°∂Á´Ø Ëøô‰∏ÄÊÆµÂå∫Èó¥ÁöÑÁÇπÊùÉÂíå int nc= QAQ(1, 1, n, id[top[x]]);//ÂæÄÈ°∂Á´ØË∑≥ÁöÑÊó∂ÂÄôËøòË¶ÅÁïôÊÑè‰∏Ä‰∏™ÈóÆÈ¢ò,Â∞±ÊòØ‰∏çÂêåÈáçÈìæ‰πãÈó¥ÁöÑËøûÊé•Â§ÑÈ¢úËâ≤ÊòØÂê¶Áõ∏ÂêåÁöÑÈóÆÈ¢ò int fc= QAQ(1, 1, n, id[fa[top[x]]]); if(nc==fc) ans--; x=fa[top[x]];//ÊääxË∑≥Âà∞xÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÈÇ£‰∏™ÁÇπÁöÑ‰∏äÈù¢‰∏Ä‰∏™ÁÇπ } //Áõ¥Âà∞‰∏§‰∏™ÁÇπÂ§Ñ‰∫é‰∏ÄÊù°Èìæ‰∏ä if(dep[x]&gt;dep[y])swap(x,y);//ÊääxÁÇπÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ //res=0; ans+=query(1,1,n,id[x],id[y]);//ËøôÊó∂ÂÜçÂä†‰∏äÊ≠§Êó∂‰∏§‰∏™ÁÇπÁöÑÂå∫Èó¥ÂíåÂç≥ÂèØ //ans+=res; return ans?ans:1;//%mod; } inline void addrange(int x, int y, int color,int n)//xÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÈÉΩÂä†‰∏äk {//Âêå‰∏ä //color%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],color); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],color); } inline void dfs1(int x,int f,int deep) {//xÂΩìÂâçËäÇÁÇπÔºåfÁà∂‰∫≤ÔºådeepÊ∑±Â∫¶ dep[x]=deep;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊ∑±Â∫¶ fa[x]=f;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ siz[x]=1;//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÂ≠êÊ†ëÂ§ßÂ∞è int maxson=-1;//ËÆ∞ÂΩïÈáçÂÑøÂ≠êÁöÑÂÑøÂ≠êÊï∞ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//Ëã•‰∏∫Áà∂‰∫≤Âàôcontinue dfs1(y,x,deep+1);//dfsÂÖ∂ÂÑøÂ≠ê siz[x]+=siz[y];//ÊääÂÆÉÁöÑÂÑøÂ≠êÊï∞Âä†Âà∞ÂÆÉË∫´‰∏ä if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÈáçÂÑøÂ≠êÁºñÂè∑ } } inline void dfs2(int x,int topf) {//xÂΩìÂâçËäÇÁÇπÔºåtopfÂΩìÂâçÈìæÁöÑÊúÄÈ°∂Á´ØÁöÑËäÇÁÇπ id[x]=++cnt;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊñ∞ÁºñÂè∑ wt[cnt]=w[x];//ÊääÊØè‰∏™ÁÇπÁöÑÂàùÂßãÂÄºËµãÂà∞Êñ∞ÁºñÂè∑‰∏äÊù• top[x]=topf;//Ëøô‰∏™ÁÇπÊâÄÂú®ÈìæÁöÑÈ°∂Á´Ø if(!son[x])return;//Â¶ÇÊûúÊ≤°ÊúâÂÑøÂ≠êÂàôËøîÂõû dfs2(son[x],topf);//ÊåâÂÖàÂ§ÑÁêÜÈáçÂÑøÂ≠êÔºåÂÜçÂ§ÑÁêÜËΩªÂÑøÂ≠êÁöÑÈ°∫Â∫èÈÄíÂΩíÂ§ÑÁêÜ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//ÂØπ‰∫éÊØè‰∏Ä‰∏™ËΩªÂÑøÂ≠êÈÉΩÊúâ‰∏ÄÊù°‰ªéÂÆÉËá™Â∑±ÂºÄÂßãÁöÑÈìæ } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;n;i++){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); G[x].push_back(y);G[y].push_back(x); } dfs1(1,0,1);dfs2(1,1);build(1,1,n); for(i=1;i&lt;=m;i++){ char con;cin&gt;&gt;con; if(con==&apos;C&apos;){ int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); addrange(a,b,c,n); } else{ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,queryrange(a,b,n)); } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê†ëÈìæÂâñÂàÜ</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê†ëÈìæÂâñÂàÜ</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê¥õË∞∑P2590 Ê†ëÈìæÂâñÂàÜÔºàÂçïÁÇπ‰øÆÊîπÔºåÂå∫Èó¥Ê±ÇÂíåandÂçïÁÇπÊü•ËØ¢Ôºâ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-b4-9b-e8-b0-b7p2590-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8d-95-e7-82-b9-e4-bf-ae-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-b1-82-e5-92-8cand-e5-8d-95-e7-82-b9-e6-9f-a5-e8-af-a2-ef-bc-89%2F</url>
    <content type="text"><![CDATA[‰∏ÄÊ£µÊ†ë‰∏äÊúân‰∏™ËäÇÁÇπÔºåÁºñÂè∑ÂàÜÂà´‰∏∫1Âà∞nÔºåÊØè‰∏™ËäÇÁÇπÈÉΩÊúâ‰∏Ä‰∏™ÊùÉÂÄºw„ÄÇ Êàë‰ª¨Â∞Ü‰ª•‰∏ãÈù¢ÁöÑÂΩ¢ÂºèÊù•Ë¶ÅÊ±Ç‰Ω†ÂØπËøôÊ£µÊ†ëÂÆåÊàê‰∏Ä‰∫õÊìç‰ΩúÔºö I. CHANGE u t : ÊääÁªìÁÇπuÁöÑÊùÉÂÄºÊîπ‰∏∫t II. QMAX u v: ËØ¢ÈóÆ‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÁöÑÊúÄÂ§ßÊùÉÂÄº III. QSUM u v: ËØ¢ÈóÆ‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÁöÑÊùÉÂÄºÂíå Ê≥®ÊÑèÔºö‰ªéÁÇπuÂà∞ÁÇπvÁöÑË∑ØÂæÑ‰∏äÁöÑËäÇÁÇπÂåÖÊã¨uÂíåvÊú¨Ë∫´ Âú®ÊùøÂ≠êÁöÑÂü∫Á°Ä‰∏äÁ±ª‰ººÁ∫øÊÆµÊ†ëÈÇ£Ê†∑‰øÆÊîπÂç≥ÂèØÔºåÊ≥®ÊÑènÁöÑ‰ΩçÁΩÆÔºÅÔºÅÂÆö‰πâÂú®‰∫ÜÊâÄÊúâÂáΩÊï∞ÂâçÈù¢ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int n,m,r; //ËßÅÈ¢òÊÑè int w[maxn],wt[maxn]; //w[]„ÄÅwt[]ÂàùÂßãÁÇπÊùÉÊï∞ÁªÑ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],mx[maxn]; //Á∫øÊÆµÊ†ëÊï∞ÁªÑ„ÄÅlazyÊìç‰Ωú int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]ÈáçÂÑøÂ≠êÁºñÂè∑,id[]Êñ∞ÁºñÂè∑,fa[]Áà∂‰∫≤ËäÇÁÇπ,cnt dfs_clock/dfsÂ∫è,dep[]Ê∑±Â∫¶,siz[]Â≠êÊ†ëÂ§ßÂ∞è,top[]ÂΩìÂâçÈìæÈ°∂Á´ØËäÇÁÇπ int res=0; //Êü•ËØ¢Á≠îÊ°à //-------------------------------------- ‰ª•‰∏ã‰∏∫Á∫øÊÆµÊ†ë inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l];mx[rt]=wt[l];//Â¢ûÂä†maxÊï∞ÁªÑ //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);//Êõ¥Êñ∞Êó∂Êõ¥Êñ∞max } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];return;//Ê±ÇÂíåÁöÑËØ¢ÈóÆ } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } int query1(int rt,int l,int r,int L,int R) { int q1=-99999999,q2=-99999999;//ÂàùÂßãÂåñ‰∏çËÉΩ‰∏∫0!ÂèØËÉΩÊúâÂæàÂ§öË¥üÊï∞! if(L&lt;=l&amp;&amp;r&lt;=R){ return mx[rt];//Ê±ÇÊúÄÂ§ßÂÄºÁöÑËØ¢ÈóÆ } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))q1=query1(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)q2=query1(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } return max(q1,q2); } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ //lazytab[rt]+=k; a[rt]=k;mx[rt]=k; } else{ //if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]); } } //---------------------------------‰ª•‰∏ä‰∏∫Á∫øÊÆµÊ†ë inline int queryrange(int x, int y)//Êü•ËØ¢‰ªéxÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÁöÑÊùÉÂÄº‰πãÂíå { int ans=0; while(top[x]!=top[y]){//ÂΩì‰∏§‰∏™ÁÇπ‰∏çÂú®Âêå‰∏ÄÊù°Èìæ‰∏ä if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//ÊääxÁÇπÊîπ‰∏∫ÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ res=0; query(1,1,n,id[top[x]],id[x]);//ansÂä†‰∏äxÁÇπÂà∞xÊâÄÂú®ÈìæÈ°∂Á´Ø Ëøô‰∏ÄÊÆµÂå∫Èó¥ÁöÑÁÇπÊùÉÂíå ans+=res; //ans%=mod;//ÊåâÈ¢òÊÑèÂèñÊ®° x=fa[top[x]];//ÊääxË∑≥Âà∞xÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÈÇ£‰∏™ÁÇπÁöÑ‰∏äÈù¢‰∏Ä‰∏™ÁÇπ } //Áõ¥Âà∞‰∏§‰∏™ÁÇπÂ§Ñ‰∫é‰∏ÄÊù°Èìæ‰∏ä if(dep[x]&gt;dep[y])swap(x,y);//ÊääxÁÇπÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ res=0; query(1,1,n,id[x],id[y]);//ËøôÊó∂ÂÜçÂä†‰∏äÊ≠§Êó∂‰∏§‰∏™ÁÇπÁöÑÂå∫Èó¥ÂíåÂç≥ÂèØ ans+=res; return ans;//%mod; } inline int querymax(int x, int y)//Êü•ËØ¢‰ªéxÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÁöÑÊúÄÂ§ßÊùÉÂÄº { int ans=-99999999;//ÂàùÂßãÂåñ! while(top[x]!=top[y]){//ÂΩì‰∏§‰∏™ÁÇπ‰∏çÂú®Âêå‰∏ÄÊù°Èìæ‰∏ä if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//ÊääxÁÇπÊîπ‰∏∫ÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ //res=0; ans=max(ans,query1(1,1,n,id[top[x]],id[x]));//ansÂä†‰∏äxÁÇπÂà∞xÊâÄÂú®ÈìæÈ°∂Á´Ø Ëøô‰∏ÄÊÆµÂå∫Èó¥ÁöÑÊúÄÂ§ßÊùÉÂÄº x=fa[top[x]];//ÊääxË∑≥Âà∞xÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÈÇ£‰∏™ÁÇπ ÁöÑ‰∏äÈù¢‰∏Ä‰∏™ÁÇπ } //Áõ¥Âà∞‰∏§‰∏™ÁÇπÂ§Ñ‰∫é‰∏ÄÊù°Èìæ‰∏ä if(dep[x]&gt;dep[y])swap(x,y);//ÊääxÁÇπÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ //res=0; ans=max(ans,query1(1,1,n,id[x],id[y])); //ans+=res; //return ans%mod; return ans; } inline void addrange(int x, int y, int k)//xÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÂèò‰∏∫k {//Âêå‰∏ä //k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline void dfs1(int x,int f,int deep) {//xÂΩìÂâçËäÇÁÇπÔºåfÁà∂‰∫≤ÔºådeepÊ∑±Â∫¶ dep[x]=deep;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊ∑±Â∫¶ fa[x]=f;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ siz[x]=1;//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÂ≠êÊ†ëÂ§ßÂ∞è int maxson=-1;//ËÆ∞ÂΩïÈáçÂÑøÂ≠êÁöÑÂÑøÂ≠êÊï∞ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//Ëã•‰∏∫Áà∂‰∫≤Âàôcontinue dfs1(y,x,deep+1);//dfsÂÖ∂ÂÑøÂ≠ê siz[x]+=siz[y];//ÊääÂÆÉÁöÑÂÑøÂ≠êÊï∞Âä†Âà∞ÂÆÉË∫´‰∏ä if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÈáçÂÑøÂ≠êÁºñÂè∑ } } inline void dfs2(int x,int topf) {//xÂΩìÂâçËäÇÁÇπÔºåtopfÂΩìÂâçÈìæÁöÑÊúÄÈ°∂Á´ØÁöÑËäÇÁÇπ id[x]=++cnt;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊñ∞ÁºñÂè∑ wt[cnt]=w[x];//ÊääÊØè‰∏™ÁÇπÁöÑÂàùÂßãÂÄºËµãÂà∞Êñ∞ÁºñÂè∑‰∏äÊù• top[x]=topf;//Ëøô‰∏™ÁÇπÊâÄÂú®ÈìæÁöÑÈ°∂Á´Ø if(!son[x])return;//Â¶ÇÊûúÊ≤°ÊúâÂÑøÂ≠êÂàôËøîÂõû dfs2(son[x],topf);//ÊåâÂÖàÂ§ÑÁêÜÈáçÂÑøÂ≠êÔºåÂÜçÂ§ÑÁêÜËΩªÂÑøÂ≠êÁöÑÈ°∫Â∫èÈÄíÂΩíÂ§ÑÁêÜ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//ÂØπ‰∫éÊØè‰∏Ä‰∏™ËΩªÂÑøÂ≠êÈÉΩÊúâ‰∏ÄÊù°‰ªéÂÆÉËá™Â∑±ÂºÄÂßãÁöÑÈìæ } } int main() { int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); dfs1(1,0,1);dfs2(1,1);build(1,1,n); int q;cin&gt;&gt;q; while(q--){ string str;int u,t; cin&gt;&gt;str&gt;&gt;u&gt;&gt;t; if(str==&quot;CHANGE&quot;){ addrange(u,u,t); } else if(str==&quot;QMAX&quot;){ printf(&quot;%d\n&quot;,querymax(u,t)); } else{ printf(&quot;%d\n&quot;,queryrange(u,t)); } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Ê†ëÈìæÂâñÂàÜ</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Ê†ëÈìæÂâñÂàÜ</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê†ëÈìæÂâñÂàÜÔºàÊ®°ÊùøÔºâ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89%2F</url>
    <content type="text"><![CDATA[ÂÖàÊù•ÂõûÈ°æ‰∏§‰∏™ÈóÆÈ¢òÔºö 1ÔºåÂ∞ÜÊ†ë‰ªéxÂà∞yÁªìÁÇπÊúÄÁü≠Ë∑ØÂæÑ‰∏äÊâÄÊúâËäÇÁÇπÁöÑÂÄºÈÉΩÂä†‰∏äz Ëøô‰πüÊòØ‰∏™Ê®°ÊùøÈ¢ò‰∫ÜÂêß Êàë‰ª¨ÂæàÂÆπÊòìÊÉ≥Âà∞ÔºåÊ†ë‰∏äÂ∑ÆÂàÜÂèØ‰ª•‰ª•O(n+m)ÁöÑ‰ºòÁßÄÂ§çÊùÇÂ∫¶Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò 2ÔºåÊ±ÇÊ†ë‰ªéxÂà∞yÁªìÁÇπÊúÄÁü≠Ë∑ØÂæÑ‰∏äÊâÄÊúâËäÇÁÇπÁöÑÂÄº‰πãÂíå lcaÂ§ßÊ∞¥È¢òÔºåÊàë‰ª¨ÂèàÂæàÂÆπÊòìÂú∞ÊÉ≥Âà∞Ôºådfs O(n)È¢ÑÂ§ÑÁêÜÊØè‰∏™ËäÇÁÇπÁöÑdisÔºàÂç≥Âà∞Ê†πËäÇÁÇπÁöÑÊúÄÁü≠Ë∑ØÂæÑÈïøÂ∫¶Ôºâ ÁÑ∂ÂêéÂØπ‰∫éÊØè‰∏™ËØ¢ÈóÆÔºåÊ±ÇÂá∫x,y‰∏§ÁÇπÁöÑlcaÔºåÂà©Áî®lcaÁöÑÊÄßË¥®distance ( x , y ) = dis ( x ) + dis ( y ) - 2 * dis ( lca )Ê±ÇÂá∫ÁªìÊûú Êó∂Èó¥Â§çÊùÇÂ∫¶O(mlogn+n) Áé∞Âú®Êù•ÊÄùËÄÉ‰∏Ä‰∏™bugÔºö Â¶ÇÊûúÂàöÊâçÁöÑ‰∏§‰∏™ÈóÆÈ¢òÁªìÂêàËµ∑Êù•ÔºåÊàê‰∏∫‰∏ÄÈÅìÈ¢òÁöÑ‰∏§ÁßçÊìç‰ΩúÂë¢Ôºü Ê®°ÊùøË¶ÅÊ±ÇÔºö Â¶ÇÈ¢òÔºåÂ∑≤Áü•‰∏ÄÊ£µÂåÖÂê´N‰∏™ÁªìÁÇπÁöÑÊ†ëÔºàËøûÈÄö‰∏îÊó†ÁéØÔºâÔºåÊØè‰∏™ËäÇÁÇπ‰∏äÂåÖÂê´‰∏Ä‰∏™Êï∞ÂÄºÔºåÈúÄË¶ÅÊîØÊåÅ‰ª•‰∏ãÊìç‰ΩúÔºö Êìç‰Ωú1Ôºö Ê†ºÂºèÔºö 1 x y z Ë°®Á§∫Â∞ÜÊ†ë‰ªéxÂà∞yÁªìÁÇπÊúÄÁü≠Ë∑ØÂæÑ‰∏äÊâÄÊúâËäÇÁÇπÁöÑÂÄºÈÉΩÂä†‰∏äz Êìç‰Ωú2Ôºö Ê†ºÂºèÔºö 2 x y Ë°®Á§∫Ê±ÇÊ†ë‰ªéxÂà∞yÁªìÁÇπÊúÄÁü≠Ë∑ØÂæÑ‰∏äÊâÄÊúâËäÇÁÇπÁöÑÂÄº‰πãÂíå Êìç‰Ωú3Ôºö Ê†ºÂºèÔºö 3 x z Ë°®Á§∫Â∞Ü‰ª•x‰∏∫Ê†πËäÇÁÇπÁöÑÂ≠êÊ†ëÂÜÖÊâÄÊúâËäÇÁÇπÂÄºÈÉΩÂä†‰∏äz Êìç‰Ωú4Ôºö Ê†ºÂºèÔºö 4 x Ë°®Á§∫Ê±Ç‰ª•x‰∏∫Ê†πËäÇÁÇπÁöÑÂ≠êÊ†ëÂÜÖÊâÄÊúâËäÇÁÇπÂÄº‰πãÂíå ‰ª•‰∏ãÊ®°ÊùøËØ∑Âä°ÂøÖÊ≥®ÊÑèÔºö ‰∏çÈúÄË¶ÅmodÁöÑÊó∂ÂÄôËØ∑Ê≥®ÊÑèÁâπÊÆäÂ§ÑÁêÜÔºÅÔºÅÔºÅ‰ª•ÂèäÊØè‰∏™ÂáΩÊï∞ÈáåÂü∫Êú¨ÈÉΩÊúâÁöÑnËøô‰∏™ÂèÇÊï∞ÔºåÂ∞±ÊòØËØªÂÖ•ÁöÑÊó∂ÂÄôËäÇÁÇπÁöÑÊÄªÊï∞ÔºÅÔºÅÔºÅ#include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int mod; //ËßÅÈ¢òÊÑè int w[maxn],wt[maxn]; //w[]„ÄÅwt[]ÂàùÂßãÁÇπÊùÉÊï∞ÁªÑ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2]; //Á∫øÊÆµÊ†ëÊï∞ÁªÑ„ÄÅlazyÊìç‰Ωú int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]ÈáçÂÑøÂ≠êÁºñÂè∑,id[]Êñ∞ÁºñÂè∑,fa[]Áà∂‰∫≤ËäÇÁÇπ,cnt dfs_clock/dfsÂ∫è,dep[]Ê∑±Â∫¶,siz[]Â≠êÊ†ëÂ§ßÂ∞è,top[]ÂΩìÂâçÈìæÈ°∂Á´ØËäÇÁÇπ int res=0; //Êü•ËØ¢Á≠îÊ°à //-------------------------------------- ‰ª•‰∏ã‰∏∫Á∫øÊÆµÊ†ë inline void pushdown(int rt,int lenn) { lazytab[rt&lt;&lt;1]+=lazytab[rt]; lazytab[rt&lt;&lt;1|1]+=lazytab[rt]; a[rt&lt;&lt;1]+=lazytab[rt]*(lenn-(lenn&gt;&gt;1)); a[rt&lt;&lt;1|1]+=lazytab[rt]*(lenn&gt;&gt;1); a[rt&lt;&lt;1]%=mod; a[rt&lt;&lt;1|1]%=mod; lazytab[rt]=0; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l]; if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];res%=mod;return; } else{ if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]+=k; a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } } //---------------------------------‰ª•‰∏ä‰∏∫Á∫øÊÆµÊ†ë inline int queryrange(int x, int y,int n)//Êü•ËØ¢‰ªéxÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÁöÑÊùÉÂÄº‰πãÂíå,nÂ∞±ÊòØËäÇÁÇπÁöÑÊÄªÊï∞ { int ans=0; while(top[x]!=top[y]){//ÂΩì‰∏§‰∏™ÁÇπ‰∏çÂú®Âêå‰∏ÄÊù°Èìæ‰∏ä if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//ÊääxÁÇπÊîπ‰∏∫ÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ res=0; query(1,1,n,id[top[x]],id[x]);//ansÂä†‰∏äxÁÇπÂà∞xÊâÄÂú®ÈìæÈ°∂Á´Ø Ëøô‰∏ÄÊÆµÂå∫Èó¥ÁöÑÁÇπÊùÉÂíå ans+=res; ans%=mod;//ÊåâÈ¢òÊÑèÂèñÊ®° x=fa[top[x]];//ÊääxË∑≥Âà∞xÊâÄÂú®ÈìæÈ°∂Á´ØÁöÑÈÇ£‰∏™ÁÇπÁöÑ‰∏äÈù¢‰∏Ä‰∏™ÁÇπ } //Áõ¥Âà∞‰∏§‰∏™ÁÇπÂ§Ñ‰∫é‰∏ÄÊù°Èìæ‰∏ä if(dep[x]&gt;dep[y])swap(x,y);//ÊääxÁÇπÊ∑±Â∫¶Êõ¥Ê∑±ÁöÑÈÇ£‰∏™ÁÇπ res=0; query(1,1,n,id[x],id[y]);//ËøôÊó∂ÂÜçÂä†‰∏äÊ≠§Êó∂‰∏§‰∏™ÁÇπÁöÑÂå∫Èó¥ÂíåÂç≥ÂèØ ans+=res; return ans%mod; } inline void addrange(int x, int y, int k,int n)//xÂà∞yÊúÄÁü≠Ë∑ØÂæÑ‰∏äÁöÑÁÇπÈÉΩÂä†‰∏äk {//Âêå‰∏ä k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline int qSon(int x,int n)//Êü•ËØ¢xÁöÑÂ≠êÊ†ëÁöÑÊùÉÂÄºÂíå { res=0; query(1,1,n,id[x],id[x]+siz[x]-1);//Â≠êÊ†ëÂå∫Èó¥Âè≥Á´ØÁÇπ‰∏∫id[x]+siz[x]-1 return res; } inline void updSon(int x,int k,int n)//xÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÈÉΩÂä†‰∏äk {//Âêå‰∏ä update(1,1,n,id[x],id[x]+siz[x]-1,k); } inline void dfs1(int x,int f,int deep) {//xÂΩìÂâçËäÇÁÇπÔºåfÁà∂‰∫≤ÔºådeepÊ∑±Â∫¶ dep[x]=deep;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊ∑±Â∫¶ fa[x]=f;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ siz[x]=1;//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÂ≠êÊ†ëÂ§ßÂ∞è int maxson=-1;//ËÆ∞ÂΩïÈáçÂÑøÂ≠êÁöÑÂÑøÂ≠êÊï∞ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//Ëã•‰∏∫Áà∂‰∫≤Âàôcontinue dfs1(y,x,deep+1);//dfsÂÖ∂ÂÑøÂ≠ê siz[x]+=siz[y];//ÊääÂÆÉÁöÑÂÑøÂ≠êÊï∞Âä†Âà∞ÂÆÉË∫´‰∏ä if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//Ê†áËÆ∞ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÁöÑÈáçÂÑøÂ≠êÁºñÂè∑ } } inline void dfs2(int x,int topf) {//xÂΩìÂâçËäÇÁÇπÔºåtopfÂΩìÂâçÈìæÁöÑÊúÄÈ°∂Á´ØÁöÑËäÇÁÇπ id[x]=++cnt;//Ê†áËÆ∞ÊØè‰∏™ÁÇπÁöÑÊñ∞ÁºñÂè∑ wt[cnt]=w[x];//ÊääÊØè‰∏™ÁÇπÁöÑÂàùÂßãÂÄºËµãÂà∞Êñ∞ÁºñÂè∑‰∏äÊù• top[x]=topf;//Ëøô‰∏™ÁÇπÊâÄÂú®ÈìæÁöÑÈ°∂Á´Ø if(!son[x])return;//Â¶ÇÊûúÊ≤°ÊúâÂÑøÂ≠êÂàôËøîÂõû dfs2(son[x],topf);//ÊåâÂÖàÂ§ÑÁêÜÈáçÂÑøÂ≠êÔºåÂÜçÂ§ÑÁêÜËΩªÂÑøÂ≠êÁöÑÈ°∫Â∫èÈÄíÂΩíÂ§ÑÁêÜ for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//ÂØπ‰∫éÊØè‰∏Ä‰∏™ËΩªÂÑøÂ≠êÈÉΩÊúâ‰∏ÄÊù°‰ªéÂÆÉËá™Â∑±ÂºÄÂßãÁöÑÈìæ } } int main() { int n,m,r; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } dfs1(r,0,1); dfs2(r,r); build(1,1,n);//Âª∫Ê†ë while(m--){ int k,x,y,z; cin&gt;&gt;k; if(k==1){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addrange(x, y, z,n); } else if(k==2){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\n&quot;, queryrange(x, y, n)); } else if(k==3){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); updSon(x,y,n); } else{ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\n&quot;,qSon(x,n)); } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Ê†ëÈìæÂâñÂàÜ</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Ê†ëÈìæÂâñÂàÜ</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #455 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-455-div-2%2F</url>
    <content type="text"><![CDATA[A. Êö¥ÂäõÊûö‰∏æÂç≥ÂèØ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;set&gt; using namespace std; int main() { set&lt;string&gt;s; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int i,j; for(i=0;i&lt;str1.size();i++){ string str11=str1.substr(0,i+1); for(j=0;j&lt;str2.size();j++){ string str22=str2.substr(0,j+1); s.insert(str11+str22); } } cout&lt;&lt;*s.begin()&lt;&lt;endl; return 0; } B. ÁªìËÆ∫È¢ò„ÄÇÈ¶ñÂÖàÊÉ≥Ë±°ÂØπ‰∫é‰∏Ä‰∏™Âå∫Èó¥[i,i+1],ÊâÄÊúâË¶ÜÁõñËøô‰∏™Âå∫Èó¥ÁöÑÁ∫øÊÆµÈÉΩÂøÖÁÑ∂Â±û‰∫é‰∏çÂêåÁöÑÂ±ÇÔºåÂê¶Âàô‰ªªÊÑè‰∏§‰∏™Á∫øÊÆµÈÉΩ‰ºöÁõ∏‰∫§ÔºåÊòæÁÑ∂‰∏çË°å„ÄÇÈÇ£‰πàÊàë‰ª¨Êúâ‰∏Ä‰∏™Â§ßËÉÜÁöÑÊÉ≥Ê≥ïÔºöÊûö‰∏æÊâÄÊúâÁöÑiÔºåÊâæÂá∫(i+1)* (n-i)‰∏≠ÊúÄÂ§ßÁöÑÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰∫ãÂÆû‰∏äÁ°ÆÂÆûÂ¶ÇÊ≠§„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,i,j,ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++){ ans=max(ans,(i+1)*(n-i)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. È¢òÊÑèÔºöf‰ª£Ë°®forËØ≠Âè•ÔºåÂÆÉÂêéÈù¢ÁöÑËØ≠Âè•Ëá≥Â∞ëÊúâ‰∏ÄÂè•ÊòØÂÆÉÂÜÖÈÉ®ÁöÑÔºåÂÖ∂‰ªñËØ≠Âè•Ë¶Å‰πàÂú®ÂÜÖÈÉ®Ë¶Å‰πàÂú®Â§ñÈÉ®ÔºåsËØ≠Âè•ÊòØÊôÆÈÄöËØ≠Âè•„ÄÇÁªô‰∏Ä‰∏™Ê≤°ÊúâÁº©ËøõÁöÑf, s‰ª£Á†ÅÔºåÊ±Ç‰∏ÄÂÖ±ÊúâÂ§öÂ∞ëÁßçÊª°Ë∂≥‰∏äËø∞ÁöÑÁº©ËøõÊñπÊ°àÔºåÁªìÊûúÊ®°1e9+7„ÄÇ ‰ª§f[i][j]‰ª£Ë°®Á¨¨iË°åÊúâj‰∏™Áº©ËøõÁöÑÂèØËÉΩÊï∞„ÄÇÈÇ£‰πàÂØπ‰∫éÊØè‰∏ÄË°åÁöÑËØ≠Âè•ÔºåÂ¶ÇÊûú‰ªñÊòØfÁöÑËØùÔºåÈÇ£‰πàÊòæÁÑ∂ÔºåËøô‰∏ÄË°åÁöÑÁº©ËøõÂè™ËÉΩ++Ôºõ‰ΩÜÂ¶ÇÊûúËøô‰∏ÄË°åÊòØsÁöÑËØùÔºåÈÇ£‰πàÂÖ∂ÂÆûËøô‰∏Ä‰∏™ËØ≠Âè•ÂèØ‰ª•ÊòØ‰∏äÈù¢‰ªªÊÑè‰∏Ä‰∏™fÁöÑÁº©Ëøõ„ÄÇÂõ†Ê≠§ÂØπ‰∫éj=1‚Ä¶cnt,Êúâf[i][j]+=f[i-1]kÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•Ë∂ÅÊú∫ÂéãÁº©‰∏ÄÁª¥ÔºàÂâçÁºÄÂíådpÔºâÔºåÂØπ‰∫éj=1..cntÔºåÊúâf[j]+=f[j-1]Âç≥ÂèØÔºåÂΩìÁÑ∂Ë¶ÅÂèñÊ®°Ôºõ ÊúÄÂêé‰∏ÄË°åÂ¶ÇÊûú‰∏çÊòØÁ¥ßÊé•ÁùÄfÁöÑÔºåÈÇ£‰πàf[cnt]Â∞±ÊòØÂâçÁºÄÂíådpÔºåÂê¶ÂàôÂ∞±ÊòØfÂú®Êúâcnt‰∏™Áº©Ëøõ‰∏ãÁöÑÊÉÖÂÜµÔºåÂõ†Ê≠§ËæìÂá∫f[cnt]Âç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; long long f[5005]; const int mod=1e9+7; int main() { int n,i,j,cnt=0;char c; cin&gt;&gt;n; f[0]=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;c; if(c==&apos;f&apos;) cnt++; else{ for(j=1;j&lt;=cnt;j++) f[j]=(f[j]+f[j-1])%mod; } } cout&lt;&lt;f[cnt]&lt;&lt;endl; return 0; } D. Êàë‰ª¨ÂèØ‰ª•ËÆæÊÉ≥ÔºåÂ¶ÇÊûúÊàë‰ª¨ÊääËøô‰∫õÁÇπÊåâÁÖßÁõ∏ÈÇªÁöÑÁõ∏ÂêåÈ¢úËâ≤‰∏∫Ê†áÂáÜÂàÜ‰∏∫ËøûÁª≠ÁöÑ‰∏ÄÁªÑÁªÑÁöÑËØùÔºåÈÇ£‰πàÊØèÊ¨°Êìç‰ΩúÂêéË¢´Âà†ÂéªÁöÑÁÇπËÇØÂÆöÈÉΩÊòØÊØè‰∏ÄÁªÑÂ∑¶Âè≥‰∏§Á´ØÁöÑ‰∏§‰∏™ÁÇπÔºåÂõ†‰∏∫Ëøô‰∏§‰∏™ÁÇπ‰∏é‰∏çÂêåÈ¢úËâ≤ÁöÑÊÆµÊé•Â£§ÔºàÂΩìÁÑ∂Á¨¨‰∏ÄÊÆµ‰∏éÊúÄÂêé‰∏ÄÊÆµÈô§Â§ñÔºå‰ªñ‰ª¨ÊØèÊ¨°Âè™Âáè1Ôºâ„ÄÇÈÇ£‰πàÊàë‰ª¨ÂèØ‰ª•ÈáçÂ§çÊ≠§Êìç‰ΩúÔºåÁõ¥Âà∞Ëá≥Â∞ëÊúâ‰∏ÄÊÆµË¢´Âà†ÂÖâÔºåËøôÊó∂Ôºå‰ªñÁöÑÂ∑¶Âè≥‰∏§‰∏™Âå∫Èó¥ÂèØËÉΩÂõ†‰∏∫È¢úËâ≤Áõ∏ÂêåÂèòÊàê‰∏Ä‰∏™Âå∫Èó¥ÔºåËøôÊó∂ÂÄôÂ∞±ÂøÖË¶ÅÈáçÊñ∞ÂÆâÊéí‰∫Ü„ÄÇÂÜôÊ≥ïËøòÊòØÊå∫Á≤æÂ¶ôÁöÑ „ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef pair&lt;char,int&gt;P; const int maxn=1e6+5; char s[maxn]; int main() { int cnt,i,j,ans=0,tot=0; scanf(&quot;%s&quot;,s+1); P pa[maxn]; int n=strlen(s+1); for(i=1;i&lt;=n;i++) { if (s[i] != s[i - 1]) pa[++tot] = P(s[i], 1);//È¢ÑÂ§ÑÁêÜÊÆµ else pa[tot].second++; } for(;tot&gt;1;tot=cnt,ans++){ pa[1].second--;pa[tot].second--;//Â§ÑÁêÜÂ§¥Â∞æ for(i=2;i&lt;tot;i++)//‰∏≠Èó¥ÂêÑÊÆµ-=2 pa[i].second-=2; for(cnt=0,i=1;i&lt;=tot;i++){ if(pa[i].second&gt;0) {//Â¶ÇÊûúËøô‰∏ÄÊÆµËøòÊ≤°ÊúâË¢´Âà†ÂÆå if (pa[i].first != pa[cnt].first)//Â¶ÇÊûú‰ªñË∑üÂâçÈù¢Êé•Â£§ÁöÑÂå∫Èó¥È¢úËâ≤‰∏çÁõ∏Âêå,ËÆ∞‰∏∫Êñ∞ÁöÑÂå∫Èó¥ pa[++cnt]=pa[i]; else pa[cnt].second += pa[i].second;//Âê¶ÂàôÈáçÊñ∞ËÆ°ÈáèËØ•Âå∫Èó¥ } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. ÂèØ‰ª•ÊÉ≥Ë±°ÔºåÊòØ‰ªÄ‰πàÊÉÖÂÜµ‰∏ãÂàÜÁªôÂâØÊ†∏ÁöÑ‰ªªÂä°ÈúÄË¶ÅÂàÜÊàêÂá†Ê¨°ÔºüÊòæÁÑ∂ÊòØÂõ†‰∏∫ÂâØÊ†∏‰æùËµñ‰∏Ä‰∏™‰∏ªÊ†∏ÁöÑ‰ªªÂä°ÔºåËÄåËøô‰∏™‰∏ªÊ†∏ÁöÑ‰ªªÂä°Âèà‰æùËµñ‰∫é‰∏Ä‰∏™ÂâØÊ†∏ÁöÑ‰ªªÂä°„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÂÖ∂‰Ωô‰ªªÂä°ÈÉΩÊòØÂèØ‰ª•‰∏ÄÊ¨°‰∏¢ËøõÊ†∏‰∏≠ÂÆåÊàêÁöÑ„ÄÇÂõ†Ê≠§ÔºåÊàë‰ª¨ÈááÁî®‰∏§‰∏™ÈòüÂàóÔºåÊØèÊ¨°ÊääÊâÄÊúâÂèØ‰ª•‰∏ÄÊ¨°ÂÆåÊàêÁöÑ‰ªªÂä°ÂàÜÂà´‰∏¢Ëøõ‰∏ªÂâØÊ†∏ÁöÑÈòüÂàó‰∏≠ÔºàÁ±ª‰ººÊãìÊâëÊéíÂ∫èÁöÑÊÄùÊÉ≥ÔºâÔºåÁõ¥Âà∞ÈòüÂàó‰∏∫Á©∫„ÄÇ #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int N=100050; vector&lt;int&gt; E[N]; queue&lt;int&gt; q[2]; int c=0,in[N],col[N],sol=0; int main() { int n,m,u,v,i; scanf(&quot;%i %i&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;col[i]); while(m--) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); E[v].push_back(u); in[u]++;//ÂÖ•Â∫¶ } for(i=0;i&lt;n;i++) if(!in[i]) q[col[i]].push(i); while(!q[0].empty() || !q[1].empty()) { if(q[c].empty()) {//Ê≠§ÈòüÂàóÁ©∫‰∫ÜËÄåÂè¶‰∏Ä‰∏™ÈòüÂàóÊú™Á©∫,ËØ¥ÊòéÈúÄË¶ÅÊç¢ÈòüÂàóÊâßË°å‰ªªÂä°‰∫Ü if (!c) sol++;//ÂâØÊ†∏Ê∏ÖÁ©∫ËÄå‰∏ªÊ†∏Êú™Ê∏ÖÁ©∫,ÊòæÁÑ∂ÂâØÊ†∏ÈúÄË¶ÅÊ¨°Êï∞++ c ^= 1;//Êç¢Ê†∏ } u=q[c].front(); q[c].pop(); for(i=0;i&lt;E[u].size();i++) { v=E[u][i]; in[v]--; if(!in[v]) q[col[v]].push(v); } } printf(&quot;%d\n&quot;,sol); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LucasÂÆöÁêÜ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Flucas-e5-ae-9a-e7-90-86%2F</url>
    <content type="text"><![CDATA[LucasÂÆöÁêÜÊòØÁî®Êù•Ëß£ÂÜ≥Â§ßÁªÑÂêàÊï∞ÂèñÊ®°ÁöÑÔºåÂç≥Ê±Ç$C_n ^m \ mod\ p$,ÂÖ∂‰∏≠$p$‰∏∫Ë¥®Êï∞„ÄÇ ÂÖ¨ÂºèÔºö$C_n ^m\ mod\ p=C_{n/p}^{m/p}\times C_{n\ mod\ p}^{m\ mod\ p}\ mod\ p$ ÂΩìÊ®°Êï∞pÂú®ÂèòÂåñÊó∂ËøêÁî®Êö¥ÂäõÊñπÊ≥ïËÆ°ÁÆóÁªÑÂêàÊï∞Ôºö#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; ll Power_mod(ll a, ll b, ll p)//Âø´ÈÄüÂπÇ { ll res = 1; while(b!=0) { if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; } return res; } ll Comb(ll a,ll b, ll p)//Êö¥ÂäõËÆ°ÁÆóÁªÑÂêàÊï∞ { if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b;//ÁªÑÂêàÊï∞ÁöÑÊÄßË¥®,C(m,n)=C(m,m-n); ll ans = 1, ca = 1, cb = 1; for(ll i=0; i&lt;b; ++i) {//Êö¥ÂäõËÆ°ÁÆóÈò∂‰πò ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; } ans = (ca*Power_mod(cb, p-2, p))%p; return ans; } ll Lucas(int n, int m, int p)//Lucas { ll ans = 1; while(n &amp;&amp; m &amp;&amp; ans) { ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; } return ans; } int main() { int n,m,p; while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p) !=EOF) { printf(&quot;%lld\n&quot;, Lucas(n, m, p)); } return 0; } ÂΩìÊ®°Êï∞pÂõ∫ÂÆöÊó∂ÂàôÂØπÁªÑÂêàÊï∞ËøõË°åÈ¢ÑÂ§ÑÁêÜÔºåÈÄíÊé®Ê±ÇÈÄÜÂÖÉÔºõ#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1e5+5; typedef long long ll; ll inv[maxn],fac[maxn];ll p; void init() { fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=fac[i-1]*i%p;//Ê±ÇÈò∂‰πò inv[0] = inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (p - p / i) * inv[p % i] % p;//ÈÄíÊé®Ê±ÇÈÄÜÂÖÉ } ll C(ll n,ll m) { if (n&lt;m) return 0; return fac[n]*inv[fac[m]]*inv[fac[n-m]]%p;//Âà©Áî®ÈÄÜÂÖÉÊ±ÇÁªÑÂêàÊï∞ } ll lucas(ll n,ll m) { if (!m) return 1ll; return C(n%p,m%p)*lucas(n/p,m/p)%p;//Lucas } int main() { return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁªÑÂêàÊï∞]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe7-bb-84-e5-90-88-e6-95-b0%2F</url>
    <content type="text"><![CDATA[ÁªÑÂêàÊï∞ÂÖ¨ÂºèÔºö $C_{m}^{n}=\frac{m!}{n!(m-n)!}$ ÊñπÊ≥ï‰∏ÄÔºöÂà©Áî®ÂÖ¨Âºè $C_m^n=C_{m-1}^{n-1}+C_{m-1}^{n}$ ‰ªém‰∏™ÂÖÉÁ¥†ÈáåÊåën‰∏™ÂÖÉÁ¥†ÔºåÈíàÂØπÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†Ë¶Å‰πàÊòØn‰∏™ÈáåÁöÑË¶Å‰πà‰∏çÊòØÔºåÂ¶ÇÊûúÊòØÁöÑ,ÈÇ£‰πàÂ∞±‰ªéÂâ©‰∏ãÁöÑm-1‰∏™ÈáåÊåën-1‰∏™ Â∞±ÊòØc(m-1,n-1);Â¶ÇÊûúÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†‰∏çÊòØnÈáåÁöÑÔºåÂ∞±‰ªéÂâ©‰∏ãÁöÑm-1‰∏™ÂÖÉÁ¥†ÈáåÊåën‰∏™ÔºåÂ∞±ÊòØc(m-1,n)„ÄÇ ÈÄíÂΩíÊ±ÇÊ≥ïÔºö #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long comb(int m,int n) { if(n==0) return 1; if(n==1) return m; if(n&gt;m/2) return comb(m,m-n); if(n&gt;1) return (comb(m-1,n-1)+comb(m-1,n)); } int main() { int m,n; while(cin&gt;&gt;m&gt;&gt;n) cout&lt;&lt;comb(m,n)&lt;&lt;endl; return 0; } ÊñπÊ≥ï‰∫åÔºö 1„ÄÅÊ±ÇÂèñ1Âà∞nÁöÑÈò∂‰πòÂØπ mod ÂèñÊ®°ÁöÑÁªìÊûúÂ≠òÂÖ•Êï∞ÁªÑ JC ‰∏≠Ôºõ 2„ÄÅÊ±ÇÂèñ C(n,r) Êó∂Ôºå ÂÖàÂà©Áî®‚ÄúÊãìÂ±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï‚ÄùÊàñËÄÖ‚ÄúË¥πÈ©¨Â∞èÂÆöÁêÜ+Âø´ÈÄüÂπÇ‚ÄùÊ±Ç JC[r]ÁöÑÈÄÜÂÖÉÂ≠òÂÖ•‰∏¥Êó∂ÂèòÈáè x1 ; 3„ÄÅÁÑ∂ÂêéËÆ°ÁÆó JC[n] ‚àó x1 % mod Â≠òÂÖ•‰∏¥Êó∂ÂèòÈáè x2;Ôºàx2 Âç≥‰∏∫n!/r! %mod ÁöÑÂÄºÔºâ 4„ÄÅÊ±ÇÂèñJC[n - r] ÁöÑÈÄÜÂÖÉÂ≠òÂÖ•‰∏¥Êó∂ÂèòÈáè x3; 5„ÄÅÂàôÂèØ‰ª•ÂæóÂà∞ C(n,r)=x2‚àóx3%mod]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 35 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-35-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. Êö¥ÂäõÊâ´Âç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } B. ÊúÄÂ§ßÂåñÊúÄÂ∞èÂÄºÔºå‰∏ÄÁúãÂ∞±ÂèØ‰ª•‰∫åÂàÜ„ÄÇÊ≥®ÊÑèÊØè‰∏™ËõãÁ≥ïÈÉΩË¶ÅÊúâÂéªÂ§Ñ‚Ä¶ÊâÄ‰ª•Ë¶ÅÊ≥®ÊÑèÂ¶ÇÊûúÊúâ‰∏ÄÁßçËõãÁ≥ïÈùûÂ∏∏Â∞ëÁöÑËØù‰πüÊòØË¶ÅÂçïÁã¨Âç†‰∏ÄÁõòÁöÑ‚Ä¶ÁéÑÂ≠¶‰∫åÂàÜÂ±ÖÁÑ∂Ê≤°Ê≠ªÂæ™ÁéØÔºåÂºÄÂøÉ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. ËØ¥ÁôΩ‰∫ÜÂ∞±ÊòØÊûö‰∏æÊâæËßÑÂæãÔºå‰ºöÂèëÁé∞Êúâ1ÁöÑÊó∂ÂÄôÔºåÊàñËÄÖÊúâ‰ø©2ÔºåÊàñËÄÖ3‰∏™ÈÉΩÊòØ3ÔºåÂèàÊàñËÄÖ‰∏Ä‰∏™2ÈÖç‰ø©4ÊòØÂèØ‰ª•ÁöÑÔºåÂÖ∂‰ªñÈÉΩÊòØ‰∏çË°åÁöÑ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int k,cnt[1505]={0},i; for(i=1;i&lt;=3;i++){ cin&gt;&gt;k;cnt[k]++; } if(cnt[1]||cnt[2]&gt;=2||cnt[3]==3||(cnt[2]==1&amp;&amp;cnt[4]==2)){ puts(&quot;YES&quot;); } else puts(&quot;NO&quot;); return 0; } D. ÁªôÂá∫‰∏Ä‰∏™Âê´Êúâ n ‰∏™Êï∞ÁöÑÂ∫èÂàóÔºåËÆ©‰Ω†Ê±ÇÊØèÊ¨°ÂèçËΩ¨Âå∫Èó¥ [ l , r ] ÂêéÊï¥‰∏™Â∫èÂàóÁöÑÈÄÜÂ∫èÊï∞ÊòØÂ•áÊòØÂÅ∂„ÄÇ È¶ñÂÖàÊúâ‰∏Ä‰∏™Êú¥Á¥†ÁöÑÊÉ≥Ê≥ïÂ∞±ÊòØÊö¥ÂäõÊûö‰∏æÔºåÂΩìÁÑ∂Â∞±ÁÆóÁî®ÂΩíÂπ∂ÊéíÂ∫èÂéªËÆ°ÁÆóÈÄÜÂ∫èÂØπ‰πüÊòØ‰ºötleÁöÑ‚Ä¶ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int cnt; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } int main() { int n,i,j,a[1600],a1[1600],t[1600],m,l,r; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); cin&gt;&gt;m; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);cnt=0; reverse(a+l,a+r+1); memcpy(a1,a,sizeof(a)); mergesort(a1,1,n,t); //cout&lt;&lt;cnt&lt;&lt;endl; if(cnt&amp;1) puts(&quot;odd&quot;); else puts(&quot;even&quot;); } return 0; } ÂΩìÂ∞ÜÂå∫Èó¥$ [ l , r ]$ ÂèçËΩ¨ÂêéÔºåÂè™ÊúâËØ•Âå∫Èó¥ÂÜÖÁöÑÈÄÜÂ∫èÊï∞‰∫ßÁîü‰∫ÜÂèòÂåñÔºåÂÖ∂‰ªñÁöÑ‰∏çÂèò„ÄÇÂÖ∑‰ΩìÂèòÂåñÊòØËØ•Âå∫Èó¥‰πãÂâçÊòØÊ≠£Â∫èÁöÑÂèòÊàê‰∫ÜÈÄÜÂ∫èÔºå‰πãÂâçÊòØÈÄÜÂ∫èÁöÑÂèòÊàê‰∫ÜÊ≠£Â∫è„ÄÇÂ¶ÇÊûúÊàë‰ª¨Áü•ÈÅìÂèçËΩ¨ÂâçÈÄÜÂ∫èÊï∞ÊòØÂ•áÊòØÂÅ∂ÔºåÂÜçÂä†‰∏äÁü•ÈÅìÂèçËΩ¨ÂêéÈÄÜÂ∫èÂØπÁõ∏Â∑ÆÊòØÂ•áÊòØÂÅ∂Â∞±ÂèØ‰ª•Áü•ÈÅìÁªìÊûú‰∫Ü„ÄÇ ËÆæËØ•Âå∫Èó¥ÈïøÂ∫¶‰∏∫ lenÔºåÂàôËØ•Âå∫Èó¥ÂÖ±Êúâ $len (len-1)/2$ ‰∏™Êï∞ÂØπÔºåËÆæÂèçËΩ¨ÂêéÈÄÜÂ∫èÁöÑÊúâ num ‰∏™ÔºåÂàôÊ≠£Â∫èÁöÑÊúâ $len(len-1)/2 - num$ ‰∏™ÔºåÂèçËΩ¨ÂâçÂêéÈÄÜÂ∫èÂØπÁõ∏Â∑Æ $num-( len(len-1)/2 - num )$ ‰∏™ÔºåÂåñÁÆÄÂæó $num 2 - len(len-1)/2$ ‰∏™Ôºå$num 2$ ‰∏ÄÂÆö‰∏∫ÂÅ∂Êï∞Ôºå‰∏çÂΩ±ÂìçÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Âè™Áúã $len(len-1)/2 $ÁöÑÂ•áÂÅ∂ÊÄßÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ Âà§Êñ≠Â•áÂÅ∂ÂèØ‰ª•Áî®ÂºÇÊàñÊù•ÂÅö #include&lt;cstdio&gt; int main() { int n,i,j,a[1505],m,l,r,x=0; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); for(i=1;i&lt;n;++i) for(j=i+1;j&lt;=n;++j) x^=a[i]&gt;a[j]; scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);i=r-l+1; x^=(i*(i-1)&gt;&gt;1)&amp;1; puts(x?&quot;odd&quot;:&quot;even&quot;); } return 0; } E. ÂØπ‰∫éÁªôÂÆöÁöÑÂâçk‰∏™ÔºåÂÖ∂ÂÆûÊ≤°‰ªÄ‰πàÂ•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÊ®°ÊãüÔºåÁúãÈáåÈù¢ÊúâÂØπÂ∞ë‰∏™Êï∞ËÉΩÂ§üÁõ¥Êé•ÊîæÂà∞bÈáåÈù¢ÔºåÊâ´ÂÆåËøôk‰∏™‰πãÂêéÔºåÂ¶ÇÊûúÊ†àÈáåËøòÊúâÈÇ£‰πàËÇØÂÆöÊòØÈÇ£‰∫õÁº∫‰πèÂ∞èÁöÑÊï∞‰ª•Ëá¥‰∫éÊó†Ê≥ïÊîæËøõbÁöÑÔºåËøôÊó∂ÂÄôÊàë‰ª¨‰∏∫‰∫ÜËÉΩÂ§üÊääËøô‰∫õÊï∞È°∫Âà©ÊîæËøõbÔºåËÇØÂÆöÊòØË¶ÅÈÄêÊ≠•Ë°•ÈΩêÊ†àÈ°∂È°πÂà∞b‰∏≠Â∑≤ÊúâÈ°π‰πãÈó¥Áº∫Â§±ÁöÑÈ°πÁöÑÔºåËøôÂêåÊó∂ËÇØÂÆö‰πüÊòØÂ≠óÂÖ∏Â∫èÊúÄÂ§ßÂÄº„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; const int N=2e5+1; int n,k,a[N],t=1; stack&lt;int&gt;s; int main() { cin&gt;&gt;n&gt;&gt;k; s.push(n+1);//ÂÖàÁΩÆÂÖ•‰∏Ä‰∏™n+1‰ª•Èò≤Ê†àÁ©∫re for(int i=0;i&lt;n;i++){ if(i&lt;k)cin&gt;&gt;a[i]; else a[i]=s.top()-1;//Ââ©‰∏ãÁöÑÈÉΩÊòØÁº∫Â∞èÈ°πÊó†Ê≥ïÂá∫Ê†àÁöÑ s.push(a[i]); while(s.size()&amp;&amp;s.top()==t)s.pop(),t++; } if(s.size())puts(&quot;-1&quot;);//Â¶ÇÊûúËøòÊúâÂâ©‰ΩôËØ¥ÊòéÂéüÊù•ÁöÑÈ°∫Â∫èÊúâÈóÆÈ¢ò else for(int i=0;i&lt;n;i++)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂΩíÂπ∂ÊéíÂ∫è]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[Â§ç‰π†‰∏ÄÊ≥¢ÔºåÂèëÁé∞ÈÉΩÂø´ÂøòÂÖâ‰∫ÜQAQ‚Ä¶ Âà©Áî®‰∫åÂàÜÁöÑÊÄùÊÉ≥Ôºå‰∏çÊñ≠ÂàÜÂâ≤ÊéíÂ∫èÂå∫Èó¥„ÄÇ void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++]; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i];//ËøôÈáåË¶ÅÊ≥®ÊÑèÂâçÈù¢Êï∞ÁªÑÁöÑ‰∏ãÊ†á } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } ÂΩíÂπ∂ÊéíÂ∫èËØæÁî®‰∫éËÆ°ÁÆóÈÄÜÂ∫èÂØπÔºåÂõ†‰∏∫Â¶ÇÊûúÊòØÈùûÈÄÜÂ∫èÁöÑÊï∞ÔºåÈÇ£‰πàÂú®mergearrayÁöÑÊó∂ÂÄôÂâçÈù¢ÁöÑËÇØÂÆöÊØîÂêéÈù¢ÁöÑÂ∞èÔºåÂ¶ÇÊûúÂá∫Áé∞‰∏Ä‰∏™ÊØîÂêéÈù¢Â§ßÁöÑÔºåÈÇ£‰πàËøô‰∏™Êï∞ÂêéÈù¢ÁöÑÊâÄÊúâÂâçÈù¢ÁöÑÊï∞ÈÉΩ‰∏ÄÂÆöÊØîÂêéÈù¢ÁöÑÊï∞Â§ß„ÄÇ int cnt=0; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1;//ÂÖ∂ÂÆûÂè™ÊúâËøôÈáå‰∏çÂêå } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim Ê∏∏Êàè]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fnim-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[NimÊ∏∏ÊàèÊòØÁªÑÂêàÊ∏∏Êàè(Combinatorial Games)ÁöÑ‰∏ÄÁßçÔºåÂáÜÁ°ÆÊù•ËØ¥ÔºåÂ±û‰∫é‚ÄúImpartial Combinatorial Games‚ÄùÔºà‰ª•‰∏ãÁÆÄÁß∞ICGÔºâ„ÄÇÊª°Ë∂≥‰ª•‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÊòØICGÔºàÂèØËÉΩ‰∏çÂ§™‰∏•Ë∞®ÔºâÔºö1„ÄÅÊúâ‰∏§ÂêçÈÄâÊâãÔºõ2„ÄÅ‰∏§ÂêçÈÄâÊâã‰∫§ÊõøÂØπÊ∏∏ÊàèËøõË°åÁßªÂä®(move)ÔºåÊØèÊ¨°‰∏ÄÊ≠•ÔºåÈÄâÊâãÂèØ‰ª•Âú®Ôºà‰∏ÄËà¨ËÄåË®ÄÔºâÊúâÈôêÁöÑÂêàÊ≥ïÁßªÂä®ÈõÜÂêà‰∏≠‰ªªÈÄâ‰∏ÄÁßçËøõË°åÁßªÂä®Ôºõ3„ÄÅÂØπ‰∫éÊ∏∏ÊàèÁöÑ‰ªª‰Ωï‰∏ÄÁßçÂèØËÉΩÁöÑÂ±ÄÈù¢ÔºåÂêàÊ≥ïÁöÑÁßªÂä®ÈõÜÂêàÂè™ÂèñÂÜ≥‰∫éËøô‰∏™Â±ÄÈù¢Êú¨Ë∫´Ôºå‰∏çÂèñÂÜ≥‰∫éËΩÆÂà∞Âì™ÂêçÈÄâÊâãÊìç‰Ωú„ÄÅ‰ª•ÂâçÁöÑ‰ªª‰ΩïÊìç‰Ωú„ÄÅÈ™∞Â≠êÁöÑÁÇπÊï∞ÊàñËÄÖÂÖ∂ÂÆÉ‰ªÄ‰πàÂõ†Á¥†Ôºõ 4„ÄÅÂ¶ÇÊûúËΩÆÂà∞ÊüêÂêçÈÄâÊâãÁßªÂä®Ôºå‰∏îËøô‰∏™Â±ÄÈù¢ÁöÑÂêàÊ≥ïÁöÑÁßªÂä®ÈõÜÂêà‰∏∫Á©∫Ôºà‰πüÂ∞±ÊòØËØ¥Ê≠§Êó∂Êó†Ê≥ïËøõË°åÁßªÂä®ÔºâÔºåÂàôËøôÂêçÈÄâÊâãË¥ü„ÄÇÊ†πÊçÆËøô‰∏™ÂÆö‰πâÔºåÂæàÂ§öÊó•Â∏∏ÁöÑÊ∏∏ÊàèÂπ∂ÈùûICG„ÄÇ‰æãÂ¶ÇË±°Ê£ãÂ∞±‰∏çÊª°Ë∂≥Êù°‰ª∂3ÔºåÂõ†‰∏∫Á∫¢ÊñπÂè™ËÉΩÁßªÂä®Á∫¢Â≠êÔºåÈªëÊñπÂè™ËÉΩÁßªÂä®ÈªëÂ≠êÔºåÂêàÊ≥ïÁöÑÁßªÂä®ÈõÜÂêàÂèñÂÜ≥‰∫éËΩÆÂà∞Âì™ÂêçÈÄâÊâãÊìç‰Ωú„ÄÇ ÁªèÂÖ∏NimÊ∏∏ÊàèÈÄöÂ∏∏ÁöÑNimÊ∏∏ÊàèÁöÑÂÆö‰πâÊòØËøôÊ†∑ÁöÑÔºöÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºåÊØèÂ†ÜÁü≥Â≠êÁöÑÊï∞ÈáèÈÉΩÊòØÊúâÈôêÁöÑÔºåÂêàÊ≥ïÁöÑÁßªÂä®ÊòØ‚ÄúÈÄâÊã©‰∏ÄÂ†ÜÁü≥Â≠êÂπ∂ÊãøËµ∞Ëã•Âπ≤È¢óÔºà‰∏çËÉΩ‰∏çÊãøÔºâ‚ÄùÔºåÂ¶ÇÊûúËΩÆÂà∞Êüê‰∏™‰∫∫Êó∂ÊâÄÊúâÁöÑÁü≥Â≠êÂ†ÜÈÉΩÂ∑≤ÁªèË¢´ÊãøÁ©∫‰∫ÜÔºåÂàôÂà§Ë¥üÔºàÂõ†‰∏∫‰ªñÊ≠§ÂàªÊ≤°Êúâ‰ªª‰ΩïÂêàÊ≥ïÁöÑÁßªÂä®Ôºâ„ÄÇ Êàë‰ª¨ÂÆö‰πâPosition: PÔºöË°®Á§∫ÂΩìÂâçÂ±ÄÈù¢‰∏ãÂÖàÊâãÂøÖË¥• NÔºöË°®Á§∫ÂΩìÂâçÂ±ÄÈù¢‰∏ãÂÖàÊâãÂøÖËÉú ÁªìËÆ∫Ôºö(Bouton‚Äôs Theorem)Ôºö ÂØπ‰∫é‰∏Ä‰∏™NimÊ∏∏ÊàèÁöÑÂ±ÄÈù¢(a1,a2,‚Ä¶,an)ÔºåÂÆÉÊòØP-positionÔºàÂêéÊâãÂøÖËÉúÔºâÂΩì‰∏î‰ªÖÂΩì a1^a2^‚Ä¶^an=0ÔºåÂÖ∂‰∏≠^Ë°®Á§∫ÂºÇÊàñ(xor)ËøêÁÆó„ÄÇ ÂèØ‰ª•Âà©Áî®‰∫åËøõÂà∂Êù•ËØÅÊòéÔºåËØ¶ÁªÜËØÅÊòéËøáÁ®ãÔºöhttps://blog.csdn.net/Summer\_\_show\_/article/details/70185470 Â¶ÇÊûúNimÊ∏∏Êàè‰∏≠ÁöÑËßÑÂàôÁ®çÂæÆÂèòÂä®‰∏Ä‰∏ã,ÊØèÊ¨°ÊúÄÂ§öÂè™ËÉΩÂèñK‰∏™,ÊÄé‰πàÂ§ÑÁêÜ? AnsÔºöÂ∞ÜÊØèÂ†ÜÁü≥Â≠êÊï∞mod (k+1). NimÁöÑÂêÑÁßçÂèòÂΩ¢Moore‚Äôs Nimk nÂ†ÜÁü≥Â≠êÔºåÊØèÊ¨°‰ªé‰∏çË∂ÖËøákÂ†Ü‰∏≠Âèñ‰ªªÊÑèÂ§ö‰∏™Áü≥Â≠êÔºåÊúÄÂêé‰∏çËÉΩÂèñÁöÑ‰∫∫Â§±Ë¥•„ÄÇ ËøôÊòØ‰∏Ä‰∏™nimÊ∏∏ÊàèÁöÑÂèòÂΩ¢Ôºå‰πüÊòØÊúâÁªìËÆ∫ÁöÑ„ÄÇ ÁªìËÆ∫‰∏∫ÔºöÊäänÂ†ÜÁü≥Â≠êÁöÑÁü≥Â≠êÊï∞Áî®‰∫åËøõÂà∂Ë°®Á§∫ÔºåÁªüËÆ°ÊØè‰∏™‰∫åËøõÂà∂‰Ωç‰∏ä1ÁöÑ‰∏™Êï∞ÔºåËã•ÊØè‰∏Ä‰Ωç‰∏ä1ÁöÑ‰∏™Êï∞mod(k+1)ÂÖ®ÈÉ®‰∏∫0ÔºåÂàôÂøÖË¥•ÔºåÂê¶ÂàôÂøÖËÉú„ÄÇ anti-nim(ÂèçNimÊ∏∏Êàè) Ê≠£Â∏∏ÁöÑnimÊ∏∏ÊàèÊòØÂèñËµ∞ÊúÄÂêé‰∏ÄÈ¢óÁöÑ‰∫∫Ëé∑ËÉúÔºåËÄåÂèçnimÊ∏∏ÊàèÊòØÂèñËµ∞ÊúÄÂêé‰∏ÄÈ¢óÁöÑ‰∫∫Ëæì„ÄÇ ‰∏Ä‰∏™Áä∂ÊÄÅ‰∏∫ÂøÖËÉúÊÄÅÔºåÂΩì‰∏î‰ªÖÂΩìÔºö 1ÔºâÊâÄÊúâÂ†ÜÁöÑÁü≥Â≠ê‰∏™Êï∞‰∏∫1Ôºå‰∏îNIM_sum=0 2ÔºâËá≥Â∞ëÊúâ‰∏ÄÂ†ÜÁöÑÁü≥Â≠ê‰∏™Êï∞Â§ß‰∫é1Ôºå‰∏î NIM_sum‚â†0 ‰æãÂ≠êÔºöBzoj1022 : https://www.lydsy.com/JudgeOnline/problem.php?id=1022 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int t,i,j,k,n; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; bool onlyone=true; int sum=0; while(n--){ scanf(&quot;%d&quot;,&amp;j); if(j!=1)onlyone=false; sum^=j; } if((onlyone&amp;&amp;!sum)||(!onlyone&amp;&amp;sum)){ puts(&quot;John&quot;); } else puts(&quot;Brother&quot;); } return 0; } Â®Å‰ΩêÂ§´ÂçöÂºà ‰∏§Â†ÜÁü≥Â≠êÔºåÊØèÊ¨°ÂèØ‰ª•‰ªé‰∏ÄÂ†ÜÊàñ‰∏§Â†Ü‰∏≠Âèñ‰ªªÊÑèÊï∞ÁõÆÁöÑÁü≥Â≠êÔºå‰ªé‰∏§Â†Ü‰∏≠ÂèñÂæóÊó∂ÂÄô,‰ªé‰∏çÂêåÂ†ÜÂèñÁöÑÁü≥Â≠ê‰∏™Êï∞ÂøÖÈ°ªÁõ∏ÂêåÔºåÂÖàÂèñÂÆåÁöÑËé∑ËÉú„ÄÇ ËøôÁßçÊÉÖÂÜµ‰∏ãÊòØÈ¢á‰∏∫Â§çÊùÇÁöÑ„ÄÇÊàë‰ª¨Áî®ÔºàakÔºåbkÔºâÔºàak ‚â§ bk ,k=0Ôºå1Ôºå2Ôºå‚Ä¶,n)Ë°®Á§∫‰∏§Â†ÜÁâ©ÂìÅÁöÑÊï∞ÈáèÂπ∂Áß∞ÂÖ∂‰∏∫Â±ÄÂäøÔºåÂ¶ÇÊûúÁî≤Èù¢ÂØπÔºà0Ôºå0ÔºâÔºåÈÇ£‰πàÁî≤Â∑≤ÁªèËæì‰∫ÜÔºåËøôÁßçÂ±ÄÂäøÊàë‰ª¨ Áß∞‰∏∫Â•áÂºÇÂ±ÄÂäø„ÄÇÂâçÂá†‰∏™Â•áÂºÇÂ±ÄÂäøÊòØÔºöÔºà0Ôºå0Ôºâ„ÄÅÔºà1Ôºå2Ôºâ„ÄÅÔºà3Ôºå5Ôºâ„ÄÅÔºà4Ôºå7Ôºâ„ÄÅÔºà6Ôºå10Ôºâ„ÄÅÔºà8Ôºå13Ôºâ„ÄÅÔºà9Ôºå15Ôºâ„ÄÅÔºà11Ôºå18Ôºâ„ÄÅÔºà12Ôºå20Ôºâ„ÄÇ Â•áÂºÇÂ±ÄÂäøÁöÑ3Êù°ÊÄßË¥®Ôºö 1.‰ªª‰ΩïËá™ÁÑ∂Êï∞ÈÉΩÂåÖÂê´Âú®‰∏Ä‰∏™‰∏î‰ªÖÊúâ‰∏Ä‰∏™Â•áÂºÇÂ±ÄÂäø‰∏≠„ÄÇ 2.‰ªªÊÑèÊìç‰ΩúÈÉΩÂèØÂ∞ÜÂ•áÂºÇÂ±ÄÂäøÂèò‰∏∫ÈùûÂ•áÂºÇÂ±ÄÂäø„ÄÇ 3.ÈááÁî®ÈÄÇÂΩìÁöÑÊñπÊ≥ïÔºåÂèØ‰ª•Â∞ÜÈùûÂ•áÂºÇÂ±ÄÂäøÂèò‰∏∫Â•áÂºÇÂ±ÄÂäø„ÄÇ ÂÅáËÆæÈù¢ÂØπÁöÑÂ±ÄÂäøÊòØÔºàa,bÔºâÔºö 1.Ëã• b = aÔºåÂàôÂêåÊó∂‰ªé‰∏§Â†Ü‰∏≠ÂèñËµ∞ a ‰∏™Áâ©‰ΩìÔºåÂ∞±Âèò‰∏∫‰∫ÜÂ•áÂºÇÂ±ÄÂäøÔºà0Ôºå0ÔºâÔºõ 2.Â¶ÇÊûúa = ak Ôºåb &gt; bkÔºåÈÇ£‰πàÔºåÂèñËµ∞b ‚Äì bk‰∏™Áâ©‰ΩìÔºåÂç≥Âèò‰∏∫Â•áÂºÇÂ±ÄÂäøÔºõ 3.Â¶ÇÊûú a = ak Ôºå b &lt; bk ,ÂàôÂêåÊó∂‰ªé‰∏§Â†Ü‰∏≠ÊãøËµ∞ ak ‚Äì ab ‚Äì ak‰∏™Áâ©‰Ωì,Âèò‰∏∫Â•áÂºÇÂ±Ä ÂäøÔºà ab ‚Äì ak , ab ‚Äì ak+ b ‚Äì akÔºâÔºõ 4.Â¶ÇÊûúa &gt; ak Ôºåb= ak + k,Âàô‰ªéÁ¨¨‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Â§ö‰ΩôÁöÑÊï∞Èáèa ‚Äì ak Âç≥ÂèØÔºõ 5.Â¶ÇÊûúa &lt; ak Ôºåb= ak + k,ÂàÜ‰∏§ÁßçÊÉÖÂÜµÔºåÁ¨¨‰∏ÄÁßçÔºåa=aj Ôºàj &lt; kÔºâ,‰ªéÁ¨¨‰∫åÂ†ÜÈáåÈù¢ÊãøËµ∞ b ‚Äì bj Âç≥ÂèØÔºõÁ¨¨‰∫åÁßçÔºåa=bj Ôºàj &lt; kÔºâ,‰ªéÁ¨¨‰∫åÂ†ÜÈáåÈù¢ÊãøËµ∞ b ‚Äì aj Âç≥ÂèØ„ÄÇ ‰ªéÂ¶Ç‰∏äÊÄßË¥®ÂèØÁü•Ôºå‰∏§‰∏™‰∫∫Â¶ÇÊûúÈÉΩÈááÁî®Ê≠£Á°ÆÊìç‰ΩúÔºåÈÇ£‰πàÈù¢ÂØπÈùûÂ•áÂºÇÂ±ÄÂäøÔºåÂÖàÊãøËÄÖÂøÖËÉú ÔºõÂèç‰πãÔºåÔºàÈù¢ÂØπÂ•áÂºÇÂ±ÄÂäøÔºâÂàôÂêéÊãøËÄÖÂèñËÉú„ÄÇ ‰ªªÁªô‰∏Ä‰∏™Â±ÄÂäøÔºàaÔºåbÔºâÔºåÂà§Êñ≠ÂÆÉÊòØ‰∏çÊòØÂ•áÂºÇÂ±ÄÂäøÔºàÂÖàÊâãË¥üÔºâÔºö $a_k =[k\times \frac{Ôºà1+‚àö5Ôºâ}{2}]Ôºå b_k= a_k + k $ Ôºàk=0Ôºå1Ôºå2Ôºå‚Ä¶,n ÔºåÊñπÊã¨Âè∑Ë°®Á§∫Âêë‰∏ãÂèñÊï¥ÂáΩÊï∞) ÂÖ∂‰∏≠kÁî±bk-akÊ±ÇÂæóÔºåÂ¶ÇÊûú‰∏§‰∏™Êï∞‰∏çÁ¨¶ÂêàËøôÊ†∑ÁöÑÂΩ¢ÂºèÔºåÂàô‰∏çÊòØÂ•áÂºÇÂ±ÄÂäø Ê≥®ÊÑè‰∏ÄÂÆöË¶ÅÊª°Ë∂≥a&lt;=bÔºå‰∏çÊª°Ë∂≥Êó∂ÂØπË∞ÉaÔºåb ‰æãÂ≠êÔºöhttp://poj.org/problem?id=1067 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double t=(1+sqrt(5.0))/2;//Á≥ªÊï∞ int a,b,k; while(cin&gt;&gt;a&gt;&gt;b){ if(a&gt;b)swap(a,b); k=b-a; if(a==(int)(k*t)){//ËÆ°ÁÆóaÊòØÂê¶Á¨¶ÂêàËØ•ÂΩ¢Âºè cout&lt;&lt;0&lt;&lt;endl; } else cout&lt;&lt;1&lt;&lt;endl; } return 0; } Â∑¥‰ªÄÂçöÂ•ï Âè™Êúâ‰∏ÄÂ†ÜÁü≥Â≠êÂÖ±n‰∏™„ÄÇÊØèÊ¨°‰ªéÊúÄÂ∞ëÂèñ1‰∏™ÔºåÊúÄÂ§öÂèñm‰∏™ÔºåÊúÄÂêéÂèñÂÖâÁöÑ‰∫∫ÂèñËÉú„ÄÇ Â¶ÇÊûú$n=(m+1)* k+s (s!=0)$ ÈÇ£‰πàÂÖàÊâã‰∏ÄÂÆöÂøÖËÉúÔºåÂõ†‰∏∫Á¨¨‰∏ÄÊ¨°ÂèñËµ∞s‰∏™ÔºåÊé•‰∏ãÊù•Êó†ËÆ∫ÂØπÊâãÊÄé‰πàÂèñÔºåÊàë‰ª¨ÈÉΩËÉΩ‰øùËØÅÂèñÂà∞ÊâÄÊúâ(m+1)ÂÄçÊï∞ÁöÑÁÇπÔºåÈÇ£‰πàÂæ™ÁéØ‰∏ãÂéª‰∏ÄÂÆöËÉΩÂèñÂà∞ÊúÄÂêé‰∏Ä‰∏™„ÄÇ(‰πüÂ∞±ÊòØËØ¥Âè™Ë¶Ån‰∏çÊòØm+1ÁöÑÂÄçÊï∞ÂÖàÊâãÂøÖËÉú) staircase nim È°æÂêçÊÄù‰πâÂ∞±ÊòØÂú®Èò∂Ê¢Ø‰∏äËøõË°åÔºåÊØèÂ±ÇÊúâËã•Âπ≤‰∏™Áü≥Â≠êÔºåÊØèÊ¨°ÂèØ‰ª•ÈÄâÊã©‰ªªÊÑèÂ±ÇÁöÑ‰ªªÊÑè‰∏™Áü≥Â≠ê&gt;Â∞ÜÂÖ∂ÁßªÂä®Âà∞ËØ•Â±ÇÁöÑ‰∏ã‰∏ÄÂ±Ç„ÄÇÊúÄÂêé‰∏çËÉΩÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÔºàËøô‰∏™ÂçöÂºàÁöÑËß£Èáä‰∏çÊòØÁâπÂà´ÊòéÁôΩQAQÔºâ Èò∂Ê¢ØÂçöÂºàÁªèËøáËΩ¨Êç¢ÂèØ‰ª•Âèò‰∏∫NimÔºåÊääÊâÄÊúâÂ•áÊï∞Èò∂Ê¢ØÁúãÊàêNÂ†ÜÁü≥Â≠êÂÅönim„ÄÇÊääÁü≥Â≠ê‰ªéÂ•áÊï∞Â†ÜÁßªÂä®Âà∞ÂÅ∂Êï∞Â†ÜÂèØ‰ª•ÁêÜËß£‰∏∫ÊãøËµ∞Áü≥Â≠êÔºåÂ∞±Áõ∏ÂΩì‰∫éÂá†‰∏™Â•áÊï∞Â†ÜÁöÑÁü≥Â≠êÂú®ÂÅöNim„ÄÇ ÁªìËÆ∫ÔºöÊâÄÊúâÂ•áÊï∞Èò∂Ê¢ØÔºàÂ•áÊï∞Â†ÜÔºâÁöÑÁü≥Â≠êÁöÑNim sumÂ¶ÇÊûú‰∏ç‰∏∫0ÔºåÂÖàÊâãËÉúÔºåÂê¶ÂàôÂêéÊâãËÉú Ôºà‰ª•‰∏ã‰ªÖ‰æõÂèÇËÄÉÔºåÊ≤°Â§™ÁúãÊáÇÔºâ ÂÅáËÆæÊàë‰ª¨ÊòØÂÖàÊâãÔºåÊâÄÁªôÁöÑÈò∂Ê¢ØÁü≥Â≠êÁä∂ÊÄÅÁöÑÂ•áÊï∞Â†ÜÂÅöNimÂÖàÊâãËÉΩÂøÖËÉú.ÊàëÂ∞±ÊåâÁÖßËÉΩËµ¢ÁöÑÊ≠•È™§Â∞ÜÂ•áÊï∞Â†ÜÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂÅ∂Êï∞Â†Ü.Â¶ÇÊûúÂØπÊâã‰πüÊòØÁßªÂä®Â•áÊï∞Â†ÜÔºåÊàë‰ª¨ÁªßÁª≠ÁßªÂä®Â•áÊï∞Â†Ü.Â¶ÇÊûúÂØπÊâãÂ∞ÜÂÅ∂Êï∞Â†ÜÁöÑÁü≥Â≠êÁßªÂä®Âà∞‰∫ÜÂ•áÊï∞Â†Ü..ÈÇ£‰πàÊàë‰ª¨Á¥ßÊé•ÁùÄÂ∞ÜÂØπÊâãÊâÄÁßªÂä®ÁöÑËøô‰πàÂ§öÁü≥Â≠ê‰ªéÈÇ£‰∏™Â•áÊï∞Â†ÜÁßªÂä®Âà∞‰∏ãÈù¢ÁöÑÂÅ∂Êï∞Â†Ü.‰∏§Ê¨°Êìç‰ΩúÂêé.Áõ∏ÂΩì‰∫éÂÅ∂Êï∞Â†ÜÁöÑÁü≥Â≠êÂêë‰∏ãÁßªÂä®‰∫ÜÂá†‰∏™„ÄÇËÄåÂ•áÊï∞Â†Ü‰æùÁÑ∂ÊòØÂéüÊù•ÁöÑÊ†∑Â≠êÔºåÂç≥‰∏∫ÂøÖËÉúÁöÑÁä∂ÊÄÅ„ÄÇÂ∞±ÁÆóÂêéÊâã‰∏ÄÁõ¥Âú®ÁßªÂä®ÂÅ∂Êï∞Â†ÜÁöÑÁü≥Â≠êÂà∞Â•áÊï∞Â†ÜÔºåÊàë‰ª¨Â∞±‰∏ÄÁõ¥Ë∑üÁùÄ‰ªñÂ∞ÜÁü≥Â≠êÁªßÁª≠ÂæÄ‰∏ãÁßªÔºå‰øùÊåÅÂ•áÊï∞Â†Ü‰∏çÂèò„ÄÇÊàëÂèØ‰ª•Ë∑üÁùÄÂêéÊâãÊääÂÅ∂Êï∞Â†ÜÁöÑÁü≥Â≠êÊúÄÁªàÁßªÂä®Âà∞0ÔºåÁÑ∂ÂêéÂØπÊâãÂ∞±‰∏çËÉΩÁßªÂä®Ëøô‰∫õÁü≥Â≠ê‰∫Ü.ÊâÄ‰ª•Êï¥‰∏™ËøáÁ®ã.Â∞ÜÂÅ∂Êï∞Â†ÜÁßªÂä®Âà∞Â•áÊï∞Â†Ü‰∏ç‰ºöÂΩ±ÂìçÂ•áÊï∞Â†ÜÂÅöNimÂçöÂºàÁöÑËøáÁ®ã..Êï¥‰∏™ËøáÁ®ãÂèØ‰ª•ÊäΩË±°‰∏∫Â•áÊï∞Â†ÜÁöÑNimÂçöÂºà. ‰∏∫‰ªÄ‰πàÊòØÂè™ÂØπÂ•áÊï∞Â†ÜÂÅöNimÂ∞±ÂèØ‰ª•ËÄå‰∏çÊòØÂÅ∂Êï∞Â†ÜÂë¢ÔºüÂõ†‰∏∫Â¶ÇÊûúÊòØÂØπÂÅ∂Êï∞Â†ÜÂÅöNimÔºåÂØπÊâãÁßªÂä®Â•áÊï∞Â†ÜÁöÑÁü≥Â≠êÂà∞ÂÅ∂Êï∞Â†ÜÔºåÊàë‰ª¨Ë∑üÁùÄÁßªÂä®Ëøô‰∫õÁü≥Â≠êÂà∞‰∏ã‰∏Ä‰∏™Â•áÊï∞Â†Ü„ÄÇÈÇ£‰πàÊúÄÂêéÊòØÂØπÊâãÊääËøô‰∫õÁü≥Â≠êÁßªÂä®Âà∞‰∫Ü0ÔºåÊàë‰ª¨‰∏çËÉΩÁªßÁª≠Ë∑üÁùÄÁßªÂä®ÔºåÂ∞±Âè™ËÉΩÂéªÁ†¥ÂùèÂéüÊúâÁöÑNimËÄåÂØºËá¥ËÉúË¥üÂÖ≥Á≥ªÁöÑ‰∏çÁ°ÆÂÆö„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπÂ•áÊï∞Â†ÜÂÅöNimÂà§Êñ≠Âç≥ÂèØÁü•ÈÅìËÉúË¥üÊÉÖÂÜµ„ÄÇ ‰æãÂ≠êÔºöhttp://poj.org/problem?id=1704 Ôºà POJ1704Ôºâ ÔºàÂèØÂèÇËÄÉÊåëÊàòÁ®ãÂ∫èËÆæËÆ°Á´ûËµõP312Ôºâ Êú¨È¢òÁöÑÂÅöÊ≥ï‰∏é‰∏äÈù¢ÊèèËø∞ÁöÑÂèà‰∏çÂÆåÂÖ®‰∏ÄËá¥„ÄÇÊàë‰ª¨ÊääÊ£ãÂ≠êÊåâ‰ΩçÁΩÆÂçáÂ∫èÊéíÂàóÂêéÔºàÊ≤°Êúâ‰øùËØÅ‰∏ÄÂÆöÊåâÂçáÂ∫èÁªôÂá∫ÔºâÔºå‰ªéÂêéÂæÄÂâçÊää‰ªñ‰ª¨‰∏§‰∏§ÁªëÂÆöÊàê‰∏ÄÂØπ„ÄÇÂ¶ÇÊûúÊÄª‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÂ∞±ÊääÊúÄÂâçÈù¢‰∏Ä‰∏™ÂíåËæπÁïåÔºà‰ΩçÁΩÆ‰∏∫0ÔºâÁªëÂÆö„ÄÇ Âú®Âêå‰∏ÄÂØπÊ£ãÂ≠ê‰∏≠ÔºåÂ¶ÇÊûúÂØπÊâãÁßªÂä®Ââç‰∏Ä‰∏™Ôºå‰Ω†ÊÄªËÉΩÂØπÂêé‰∏Ä‰∏™ÁßªÂä®Áõ∏ÂêåÁöÑÊ≠•Êï∞ÔºåÊâÄ‰ª•‰∏ÄÂØπÊ£ãÂ≠êÁöÑÂâç‰∏Ä‰∏™ÂíåÂâç‰∏ÄÂØπÊ£ãÂ≠êÁöÑÂêé‰∏Ä‰∏™‰πãÈó¥ÊúâÂ§öÂ∞ë‰∏™Á©∫‰ΩçÁΩÆÂØπÊúÄÁªàÁöÑÁªìÊûúÊòØÊ≤°ÊúâÂΩ±ÂìçÁöÑ„ÄÇ‰∫éÊòØÊàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÂêå‰∏ÄÂØπÁöÑ‰∏§‰∏™Ê£ãÂ≠ê‰πãÈó¥ÊúâÂ§öÂ∞ëÁ©∫‰Ωç„ÄÇ ËøôÊ†∑‰∏ÄÊù•Â∞±Êàê‰∫ÜNÂ†ÜÂèñÁü≥Â≠êÊ∏∏Êàè‰∫Ü. #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,k; int s[1010]; int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;s[i]); sort(s+1, s+n+1); int ans; if(n%2 == 0) { ans = s[2]-s[1]-1; for(int i=4; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } else { ans = s[1]-1; for(int i=3; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>ÂçöÂºàËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>ÂçöÂºàËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Good Bye 2017]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-good-bye-2017%2F</url>
    <content type="text"><![CDATA[A. Ê®°ÊãüÂç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str;int cnt=0; cin&gt;&gt;str; for(auto a:str){ if(a==&apos;a&apos;||a==&apos;i&apos;||a==&apos;o&apos;||a==&apos;e&apos;||a==&apos;u&apos;||a==&apos;1&apos;||a==&apos;3&apos;||a==&apos;5&apos;||a==&apos;7&apos;||a==&apos;9&apos;) cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. Êö¥ÂäõÊûö‰∏æ24ÁßçÊò†Â∞ÑÁöÑÊÉÖÂÜµÂç≥ÂèØ‚Ä¶.È¢òÁõÆÂæàÁÆÄÂçïÔºå‰ΩÜÊòØ‰∏çÊòØÂæàÂ•ΩÂÜô #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; using namespace std; typedef pair&lt;int,int&gt;P; vector&lt;int&gt;per; void rotate(P*a,P*b) { for(int i=0;i&lt;4;i++) a[i]=b[per[i]]; } int main() { P mps[4]={ {0,1},{-1,0},{0,-1},{1,0}},mp[4]; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str; for(i=0;i&lt;4;i++)per.push_back(i); char mp1[55][55]; int x,y; for(i=1;i&lt;=n;i++){ cin&gt;&gt;mp1[i]+1; for(j=1;j&lt;=m;j++){ if(mp1[i][j]==&apos;S&apos;){ x=j,y=i;break; } } } cin&gt;&gt;str;int ans=0; for(int r=1;r&lt;=24;r++){ if(r&gt;1)next_permutation(per.begin(),per.end()); rotate(mp,mps); int x1=x,y1=y; for(auto a:str){ int p=a-&apos;0&apos;; x1+=mp[p].first;y1+=mp[p].second; if(x1&lt;1||x1&gt;m||y1&lt;1||y1&gt;n||mp1[y1][x1]==&apos;#&apos;)break; if(mp1[y1][x1]==&apos;E&apos;){ ans++;break; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. Êú¨Êù•ÊÉ≥ÁùÄÂØπ‰∫éÊØè‰∏™Êñ∞Âä†ÂÖ•ÁöÑÂúÜÊâæÂá∫ÊâÄÊúâÂèØËÉΩË∑ü‰ªñÂÜ≤Á™ÅÁöÑÂúÜËøõË°åËÆ°ÁÆóÁöÑÔºå‰ΩÜÊòØËæπÁïå‰∏çÂ§™Â•ΩÊääÊè°‚Ä¶ÂêéÊù•ÂèëÁé∞Ëøô‰∏™Êï∞ÊçÆËåÉÂõ¥‚Ä¶Áõ¥Êé•Êö¥ÂäõÊûö‰∏æ‰πãÂâçÂä†ÂÖ•ÁöÑÊâÄÊúâÂúÜ‰∏éËøôÂúÜÂÜ≤Á™ÅÁöÑÂèØËÉΩÂç≥ÂèØ‚Ä¶ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int n,r,x[1005]={0},t,i,j;double y[1005]={0}; scanf(&quot;%d%d&quot;,&amp;n,&amp;r); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x[i]);y[i]=r; for(j=1;j&lt;i;j++) { t = x[i] - x[j], y[i] = max(y[i], y[j] + sqrt(4 * r * r - t * t)); } printf(&quot;%.10f &quot;,y[i]); } return 0; } F. Êàë‰ª¨ÂèØ‰ª•Áî®ÁªøËâ≤ÁöÑÁÇπÊääÊï¥‰∏™Á∫øÊÆµÂàÜÂºÄÔºåÈÇ£‰πàÂØπ‰∫éÊØè‰∏Ä‰∏™Âå∫Èó¥Ôºà‰∏§Á´ØÊòØÁªøËâ≤ÁöÑÁÇπÔºâÔºåÊúâ‰∏§ÁßçÈÄâÊã©Ôºö1.‰∏§‰∏™ÁªøËâ≤ÁöÑÁÇπ‰∏çËøûÊé•ÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÊääÈáåÈù¢ÊâÄÊúâÁöÑÁ∫¢Ëâ≤ÁÇπËìùËâ≤ÁÇπÈÉΩËøûÊé•Ëµ∑Êù•ÔºåÈïøÂ∫¶ÊòØ2 Âå∫Èó¥ÈïøÂ∫¶ 2.ËøûÊé•ÁªøËâ≤ÁÇπÔºåÈÇ£‰πàÈïøÂ∫¶Â∞±ÊòØÂå∫Èó¥ÈïøÂ∫¶ 3-ÈïøÂ∫¶ÊúÄÈïøÁöÑËøûÊé•Á∫¢ÁÇπÁöÑËæπ-ÈïøÂ∫¶ÊúÄÈïøÁöÑËøûÊé•ËìùÁÇπÁöÑËæπ #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,x,pr,pb,pg,mr,mb,ans=0; char s[10]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%s&quot;,&amp;x,s); if(s[0]==&apos;R&apos;||s[0]==&apos;G&apos;){ if(pr){ ans+=x-pr; mr=max(mr,x-pr); } pr=x; } if(s[0]==&apos;B&apos;||s[0]==&apos;G&apos;){ if(pb){ ans+=x-pb; mb=max(mb,x-pb); } pb=x; } if(s[0]==&apos;G&apos;){ if(pg)ans+=min(0,x-pg-mr-mb); pg=x;mr=0;mb=0; } } printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #498 (Div. 3)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-498-div-3%2F</url>
    <content type="text"><![CDATA[A. Âº±Êô∫È¢ò #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&amp;1)cout&lt;&lt;j&lt;&lt;&apos; &apos;; else cout&lt;&lt;j-1&lt;&lt;&apos; &apos;; } return 0; } B. ‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåÂâçkÂ§ßÂ∞±ÊòØÊâÄÊ±Ç #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;set&gt; using namespace std; bool cmp(int x,int y) { return x&gt;y; } int main() { int n,k,i,j; int num[2005],num1[2005]; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);num1[i]=num[i]; } sort(num1+1,num1+1+n,cmp); map&lt;int,int&gt;mp1; int sum=0; for(i=1;i&lt;=k;i++)mp1[num1[i]]++,sum+=num1[i]; int pre=1; cout&lt;&lt;sum&lt;&lt;endl; for(i=1;i&lt;=n;i++){ if(mp1.count(num[i])){ k--; if(k)cout&lt;&lt;i-pre+1&lt;&lt;&apos; &apos;; else cout&lt;&lt;n-pre+1&lt;&lt;endl; pre=i+1;mp1[num[i]]--; if(mp1[num[i]]==0)mp1.erase(num[i]); } } return 0; } C. ÂâçÂêéÊ±ÇÂâçÁºÄÂíåÂç≥ÂèØ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum[200005]; int main() { int n,i,j,k,d[200005]; cin&gt;&gt;n; map&lt;ll,int&gt;mp1; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;d[i]); sum[i]+=sum[i-1]+d[i]; mp1[sum[i]]=i; } ll ans=0,sum1=0; for(i=n;i;i--){ sum1+=d[i]; if(mp1.count(sum1)){ if(mp1[sum1]&gt;=i) break; else{ ans=sum1; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. Ê≥®ÊÑèÂè™ËÉΩÊç¢a‰∏≠ÁöÑÂ≠óÊØçÔºÅÔºÅ ÂàÜÊûê‰∏Ä‰∏ãÂèØ‰ª•ÂèëÁé∞a[i],a[n-i+1],b[i],b[n-i+1]ËøôÂá†‰∏™Â≠óÊØç‰πãÈó¥ÁöÑ‰ΩçÁΩÆÊòØÂèØ‰ª•Èöè‰æøÊç¢ÁöÑÔºåÂõ†Ê≠§Âè™Ë¶ÅÊûö‰∏æÊâÄÊúâËøôÊ†∑ÁöÑÂ≠óÊØçÁªÑÂç≥ÂèØ„ÄÇ ÂΩì4‰∏™Â≠óÊØçÂÖ®ÈÉΩ‰∏çÂêåÁöÑÊó∂ÂÄôÔºåaÈáåÈù¢‰∏§‰∏™Â≠óÊØçËÇØÂÆöË¶ÅÊç¢Ôºõ ÂΩìÊúâ‰∏§‰∏™Áõ∏ÂêåÊó∂ÔºåÂè¶‰∏§‰∏™‰∏çÂêåÔºà‰πüÂ∞±ÊòØÊúâ3ÁßçÂ≠óÊØçÔºâÔºåÂ¶ÇÊûú‰∏§‰∏™Áõ∏ÂêåÁöÑÂú®aÔºåÈÇ£‰πàÂ∞±Ë¶Å‰∏§‰∏™ÈÉΩÊç¢ÔºåÂê¶ÂàôÁöÑËØùÈÉΩÊòØÊç¢1‰∏™Â∞±Â§ü‰∫Ü„ÄÇ ÂΩìÊúâ3‰∏™Áõ∏ÂêåÊó∂ÔºåÊç¢‰∏Ä‰∏™Âç≥ÂèØ„ÄÇ Â¶ÇÊûú4‰∏™ÈÉΩÁõ∏ÂêåÊàñËÄÖ‰∏§‰∏§Áõ∏ÂêåÔºå‰∏çÁî®Êç¢„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; int main() { char a[100005],b[100005]; int i,j,k,n; cin&gt;&gt;n&gt;&gt;a+1&gt;&gt;b+1; int sum=0; for(i=1;i&lt;=n/2;i++){ map&lt;char,int&gt;mp1; mp1[a[i]]++;mp1[a[n-i+1]]++;mp1[b[i]]++;mp1[b[n-i+1]]++; if(mp1.size()==4){ sum+=2; } else if(mp1.size()==2){ if(mp1.begin()-&gt;second==2); else{ sum+=1; } } else if(mp1.size()==1); else{ if(a[i]==a[n-i+1])sum+=2; else sum+=1; } } if(n&amp;1){ if(a[n/2+1]!=b[n/2+1])sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; } E. È¢òÁõÆÂæàÈïøÔºå‰ΩÜÂÖ∂ÂÆûÂ∞±ÊòØ‰∏Ä‰∏™ÂæàÁÆÄÂçïÁöÑdfs„ÄÇÂõ†‰∏∫‰ªñÁöÑdfsÈ°∫Â∫èÊòØÂõ∫ÂÆöÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨‰ºöÂèëÁé∞ÂÖ∂ÂÆûÂè™Ë¶Å‰ªéÊ†πÂºÄÂßãdfs‰∏ÄÈÅçÔºåÂπ∂ÊääÁªìÊûú‰øùÂ≠òËµ∑Êù•Âç≥ÂèØÔºå‰ª•ÂêéÊØèÊ¨°ËØ¢ÈóÆÊü•ËØ¢‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂÆåÂÖ®Ê®°Êãü‰ºötleÔºåÊØè‰∏™ËäÇÁÇπ‰øùÂ≠òËá™Â∑±ÁöÑÂ≠êÊ†ëÂàô‰ºömleÔºåÊâÄ‰ª•Âè™ËÉΩÂú®Ê†πÈÇ£Èáå‰øùÂ≠òÁªìÊûú„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N=2e5+5; vector&lt;int&gt;G[N]; vector&lt;int&gt;ans; int child[N]; int pos[N]; int dfs(int x) { ans.push_back(x); pos[x]=ans.size()-1; child[x]++; for(auto a:G[x]){ child[x]+=dfs(a); } return child[x]; } int main() { int n,q,i,j,k,u; cin&gt;&gt;n&gt;&gt;q; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); for(i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;k); if(child[u]&lt;k){ printf(&quot;-1\n&quot;); } else{ printf(&quot;%d\n&quot;,ans[pos[u]+k-1]); } } return 0; } F. Êúâ‰∏Ä‰∏™ÈùûÂ∏∏simpleÁöÑdpÂÅöÊ≥ïÔºå‰ΩÜÊòØ‰ºömleÔºåÂç≥‰ΩøÊç¢ÊàêÊªöÂä®Êï∞ÁªÑ‰πü‰ºötle‚Ä¶ #include &lt;bits/stdc++.h&gt; using namespace std; long long n,m,k; map&lt;long long,long long&gt; a[25][25]; long long b[25][25]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) cin&gt;&gt;b[i][j]; a[1][1][b[1][1]]++; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { for (auto k:a[i-1][j]) { a[i][j][k.first^b[i][j]]+=k.second; } for (auto k:a[i][j-1]) { a[i][j][k.first^b[i][j]]+=k.second; } } cout&lt;&lt;a[n][m][k]; } Ê≠£Ëß£ÁöÑËØùÔºåÊòØ‰∫∫‰∏∫ÁöÑÂàí‰∫Ü‰∏ÄÊù°Á∫øÔºåÂç≥i+j==n+1ÔºåËøôÊòØ‰∏ÄÊù°ÊñúÂØπËßíÁ∫øÔºåÊàë‰ª¨ÂàÜÂà´‰ªéÔºà1Ôºå1ÔºâÂíåÔºànÔºåmÔºâÂ§ÑÂºÄÂßãÊêúÁ¥¢ÔºåÂ¶ÇÊûúËÉΩÂ§üÂà∞Ëææ‰∏≠Á∫øÔºåÂ∞±ÂÅö‰∏Ä‰∏™ËÆ∞ÂΩïÔºåÁÑ∂ÂêéÁªüËÆ°Á≠îÊ°à„ÄÇ #include &lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll num[25][25]; map&lt;ll,ll&gt;mp[25]; ll n,m,k; void dfs1(int i,int j,ll v) { v^=num[i][j]; if(i+j==n+1){ mp[i][v]++;return;//Â¶ÇÊûúÂà∞Ëææ‰∏≠Á∫øÂ∞±‰∏çÁî®ÂÜçÊêú‰∏ãÂéª‰∫Ü } if(i&lt;n)dfs1(i+1,j,v); if(j&lt;m)dfs1(i,j+1,v); } ll ans=0; void dfs2(int i,int j,ll v) { if(i+j==n+1) { ans += mp[i][v ^ k];return;//Âà∞Ëææ‰∏≠Á∫ø,Êàë‰ª¨Â∏åÊúõÈÅáÂà∞ÁöÑ‰∏≠Á∫øÂ§ÑÁöÑÂÄºÊòØv^k, // Âõ†‰∏∫Âú®‰∏≠Á∫ø‰∏ãÂçäÈÉ®ÂàÜÁöÑxorÂíå‰∏∫v,v^k^v=k,Êª°Ë∂≥È¢òÊÑè } v^=num[i][j]; if(i&gt;1)dfs2(i-1,j,v); if(j&gt;1)dfs2(i,j-1,v); } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf(&quot;%lld&quot;,&amp;num[i][j]); dfs1(1,1,0);dfs2(n,m,0); cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 47 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-47-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. ÊåâÁÖßÈ¢òÊÑèÊ®°ÊãüÂç≥ÂèØ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;deque&gt; using namespace std; int main() { deque&lt;int&gt;a; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; int c[1005]; for(i=1;i&lt;=n;i++)cin&gt;&gt;c[i]; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);a.push_back(j); } int cnt=0; for(i=1;i&lt;=n;i++){ if(!a.empty()&amp;&amp;a.front()&gt;=c[i]){ a.pop_front();cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. È¶ñÂÖàÊàë‰ª¨Ê≥®ÊÑèÂà∞1ÊòØÂèØ‰ª•‰ªªÊÑèÁßªÂä®ÁöÑÔºå‰πüÂ∞±ÊòØËØ¥1ÂèØ‰ª•ÁßªÂä®Âà∞‰ªª‰Ωï‰∏Ä‰∏™‰ΩçÁΩÆÔºåËÄå2ÊòØÊØîËæÉÈ∫ªÁÉ¶ÁöÑÔºåÂõ†Ê≠§Êàë‰ª¨‰ªéÂâçÂæÄÂêéÊâ´ÊèèÔºåÊØèÊâ´ÊèèÂà∞‰∏Ä‰∏™2Â∞±ËÆ∞ÂΩï‰∏Ä‰∏ãÂΩìÂâçÊâ´ÊèèÂà∞ÁöÑËøôÊÆµ0 ÁöÑÊï∞ÁõÆÔºåÁÑ∂Âêé‰∏¢ËøõvectorÈáåËÆ∞ÂΩï‰∏ãÊù•„ÄÇÊ≥®ÊÑèÔºöË¶ÅËÆ∞ÂæóÁâπÂà§Ê≤°Êúâ2 ÁöÑÊÉÖÂΩ¢ÔºÅ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string s; int num0(0), num1(0); vector &lt;int&gt; v; bool pd(false); int main() { cin &gt;&gt; s; for (auto i : s) { if (i == &apos;0&apos;)num0++;//ÁªüËÆ°0 else if (i == &apos;1&apos;)num1++;//ÁªüËÆ°1 else {//ÈÅáÂà∞2 v.push_back(num0); num0 = 0; } } for (auto i : v) {//2ÊääËøûÁª≠ÁöÑ0ÂàÜÊàê‰∫ÜÂæàÂ§öÊÆµ for (int j = 1; j &lt;= i; j++)cout &lt;&lt; 0; if (!pd) for (int j = 1; j &lt;= num1; j++)cout &lt;&lt; 1;//1ÂèØ‰ª•ÂÖ®ÈÉ®ÁßªÂà∞Á¨¨‰∏Ä‰∏™‰πãÂâç cout &lt;&lt; 2; pd = true; } for (int j = 1; j &lt;= num0; j++)cout &lt;&lt; 0; if(!pd){//‰∏ÄÂÆöË¶ÅÁâπÂà§Ê≤°Êúâ2ÁöÑÊÉÖÂΩ¢ for(int i=1;i&lt;=num1;i++)cout&lt;&lt;1; } return 0; } C. ÂÖ∂ÂÆûËøôÈ¢òÁúãÊáÇ‰πãÂêé‰ºº‰πéÊòØÊå∫ÁÆÄÂçïÁöÑ‚Ä¶?ÊòæÁÑ∂dÂ¶ÇÊûúÊòØÊ≠£ÁöÑÔºåÊàë‰ª¨ Â∞±Â∏åÊúõdist‰πãÂíåÊúÄÂ§ßÔºåÂèØ‰ª•ÂèëÁé∞ÊòØÊîæÊï∞ÂàóÁöÑ‰∏§Á´ØÊúÄ‰Ω≥ÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÈÄâÂú®Êï∞ÂàóÁöÑ‰∏≠Èó¥ÂèØ‰ª•‰ΩøÂæódist‰πãÂíåÊúÄÂ∞è„ÄÇËÆ∞ÂæóÂºÄlonglongÂç≥ÂèØ„ÄÇ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; int main() { ll n, m; ll ans=0, x, d; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; d; ans += x * n; if (d &gt; 0) { ans += d * n * (n - 1) / 2; } else { ans += ((n % 2 == 0) ? (n / 2 * n / 2 * d) : ((n + 1) / 2 * (n - 1) / 2 * d)); } } printf(&quot;%.20lf&quot;,(double)ans / n); return 0; } D. Ë¶ÅÊ≥®ÊÑè‰∏ÄÁÇπÔºåÂ∞±ÊòØÊûÑÈÄ†ÁöÑÂõæÂøÖÈ°ªÊòØËÅîÈÄöÁöÑ„ÄÇËôΩÁÑ∂È¢òÁõÆËåÉÂõ¥Áúã‰ººÂæàÂ§ßÔºåÁêÜËÆ∫ÊòØÊö¥ÂäõÊûö‰∏æÂ§çÊùÇÂ∫¶1e10,‰ΩÜÊòØmÂ∞èÂìáÔºåÊö¥Âäõ‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æÊàêÂØπÁöÑ‰∫íË¥®ÁöÑÊï∞ÔºåÂÖ∂ÂÆûÂæàÂø´Â∞±Â§ü‰∫ÜÔºåÂ¶ÇÊûúimpossibleÁöÑËØùÂè™ÂèØËÉΩÊòØnÊØîËæÉÂ∞èmÊØîËæÉÂ§ßÁöÑÊÉÖÂÜµ„ÄÇÁÑ∂ÂêéÊ≥®ÊÑèmÂ¶ÇÊûúÂ∞è‰∫én-1ÁöÑËØùÈÇ£‰πàËøôÂπÖÂõæÊÄé‰πàÁúãÈÉΩ‰∏çÂèØËÉΩÁöÑËÅîÈÄöÁöÑÔºàË¶ÅÊ±ÇÊòØÊØè‰∏™ÁÇπÈÉΩÂøÖÈ°ªÂú®Ëøô‰∏™ÂõæÈáåÈù¢ÔºåÊâÄ‰ª•‰∏Ä‰∏™Ë°å‰πãÊúâÊïàÁöÑÂäûÊ≥ïÂ∞±ÊòØÊØè‰∏™ÁîµËÑëÈÉΩË∑ü1ËøûÊé•Ëµ∑Êù•ÔºâÔºõ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int gcd(int x,int y) { return y?gcd(y,x%y):x; } typedef pair&lt;int,int&gt;P; int main() { int n,m,i,j,k,cnt=0; cin&gt;&gt;n&gt;&gt;m; vector&lt;P&gt;ans; if(m&lt;n-1){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } for(i=1;i&lt;n;i++) for(j=i+1;j&lt;=n;j++){ if(gcd(i,j)==1){ m--;ans.push_back(P(i,j)); if(!m)goto step; } } if(m){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } step:cout&lt;&lt;&quot;Possible&quot;&lt;&lt;endl; for(auto a:ans) printf(&quot;%d %d\n&quot;,a.first,a.second); return 0; } E. Êüê‰∫∫‰ªéx=0ÊóÖË°åËá≥x=nÔºåÂú®‰∏äÊ¨°‰ºëÊÅØËøáÂêéËµ∞ÂΩìÂâçÂÖ¨ÈáåÁöÑÁñ≤Âä≥ÂÄº‰∏∫aiÔºå‰ºëÊÅØÁÇπÁöÑ‰ΩçÁΩÆ‰∏çÁ°ÆÂÆöÔºåÊ±ÇÁñ≤Âä≥ÂÄº‰πãÂíåÁöÑÊï∞Â≠¶ÊúüÊúõ„ÄÇ ÂØπ‰∫éÊüê‰∏™‰ΩçÁΩÆx=iÔºåÁñ≤Âä≥ÂÄº‰∏∫aiÁöÑÂèØËÉΩ‰ºëÊÅØÁÇπÊÉÖÂÜµÊï∞‰∏∫2^(n-i)ÁßçÔºåÁñ≤Âä≥ÂÄº‰∏∫aj(j&lt;i)ÁöÑÂèØËÉΩ‰ºëÊÅØÁÇπÊÉÖÂÜµÊï∞‰∏∫2^(n-i-1)Áßç„ÄÇÂ§ÑÁêÜËøáÂêéÂèëÁé∞ÂØπ‰∫éÊüê‰∏™Áñ≤Âä≥ÂÄºaiÔºåÂÖ∂ÊÄªÁöÑÂá∫Áé∞ÊÉÖÂÜµÊï∞‰∏∫2^(n-i)+2^(n-i-1)* (n-i)„ÄÇ‰πãÂêéÁõ¥Êé•Â•óÂÖ¨ÂºèÂç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int mod=998244353; long long a[1000005],b[1000005]; int main() { int n,i,j,k; cin&gt;&gt;n; b[0]=1; for(i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); b[i]=(b[i-1]&lt;&lt;1)%mod; } long long ans=0; for(i=1;i&lt;=n;i++){ ans+=a[i]*b[n-i]%mod; ans+=a[i]*b[n-i-1]%mod*(n-i)%mod;//Ê≥®ÊÑèÂ§ömodÈò≤Ê≠¢ÁàÜint } cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F20172018%2F</url>
    <content type="text"><![CDATA[ËøáÂéªÁöÑ‰∏ÄÂπ¥ÂâçÂá†Â§©ËÄÉÂÆå‰∫ÜËøôÂ≠¶ÊúüÁöÑÊúÄÂêé‰∏ÄÁßëÔºåÈÇ£‰πàÔºåÂ§ß‰∏Ä‰πüÂ∞±ÁÆóÊòØÁªìÊùü‰∫ÜÂêßÔºåÂõûÊÉ≥ËøáÂéªÁöÑ‰∏ÄÂπ¥ÔºåÊÄªÊÉ≥ÂÜôÁÇπ‰ªÄ‰πàÔºåÂç¥Âèà‰∏çÁü•ÈÅìÂ¶Ç‰ΩïÂÖ•ÊâãÔºåÈÇ£Áé∞Âú®Â∞±Á∫ØÂΩìÊµÅÊ∞¥Ë¥¶Èöè‰æøÂÜôÂÜôÂêß„ÄÇ ÂéªÂπ¥Ôºå2017ÔºåÊòØÁõ∏ÂΩìÂ•áÂπªÁöÑÔºå‰∏ÄÂú∫È´òËÄÉÂ∞Ü‰∏ÄÂπ¥Ê®™Âäà‰∏∫‰∫å„ÄÇÂàöËÄÉÂÆåÈÇ£Â§©‰∏ãÂçàÊãøÂá∫‰∫ÜÂ∞òÂ∞ÅÂ∑≤‰πÖÁöÑiPadÔºåÊâì‰∫Ü‰∏Ä‰ºöwotbÔºå‰ΩÜÊòØ‰ºº‰πéÂ∫î‰∫ÜÈÇ£Âè•ËØù‚Äî‚ÄîÊ∏∏ÊàèËøòÊòØËÄÉËØïÂâçÁöÑÂ•ΩÁé©ÔºåËÄÉÂÆå‰πãÂêéÂèòÂæóÊúâ‰∫õÁ¥¢ÁÑ∂Êó†Âë≥Ëµ∑Êù•„ÄÇ4Â§©‰πãÂêéÂâÅ‰∫Ü‰∏™Ê∏∏ÊàèÊú¨ÔºåÁÑ∂ÂêéÂºÄÂêØ‰∫ÜÊöëÂÅáÁöÑÊ≤âËø∑Ê∏∏Êàè‰πãÊóÖ„ÄÇ‰∏çËøáÂêéÊù•ÂºÄÂ≠¶ÂêéÂæàÂø´Â∞±ÂêéÊÇî‰π∞‰∫Ü‰∏™Â¶ÇÊ≠§ÂéöÈáçÁöÑÊ∏∏ÊàèÊú¨ÔºåÂΩìÁÑ∂ËøôÊòØÂêéËØù‰∫Ü„ÄÇ ÊöëÂÅáÂÖàÊòØË∑üÂêåÂ≠¶‰∏ÄËµ∑Âéª‰∫ÜË∂üË¥µÂ∑ûÔºåÁé∞Âú®ÊÉ≥ÊÉ≥ËøôË∂üÊóÖÁ®ãÂÖ∂ÂÆûÊòØÊúâ‰∫õ‰ª§‰∫∫Â§±ÊúõÁöÑ„ÄÇË¥µÂ∑ûÊú¨Ë∫´Âπ∂‰∏çÂ§™Â•ΩÁé©ÔºåËä±Âú®Ë∑Ø‰∏äÁöÑÊó∂Èó¥Â•áÈïøÊó†ÊØî„ÄÇÊõ¥ÈáçË¶ÅÁöÑÊòØÈ´ò‰∏≠ÁöÑ‰∏ÄÁæ§ÂêåÂ≠¶Ôºå‰ºº‰πéÊÄªÊúâ‰∫õËØ¥‰∏çÊ∏ÖÁöÑÈöîÈòÇÊÑüÂêßÔºå‰πüËÆ∏ÊòØ‰∏ÄÁæ§Ê∏ÖÂåóËÅöËÅöÂÆûÂú®Ë∑üÊàëËøôÁßçË£∏ËÄÉÂº±Ê∏£Â∑ÆÂà´ËøáÂ§ßÂêß„ÄÇËÄå‰∏îÊÑüËßâËµ∑Êù•ÔºåÈ´ò‰∏≠ÂêåÂ≠¶ÊÄª‰ΩìËøòÊòØÊØîËæÉÂ•áÁâπÁöÑÔºåÊï¥‰∏™Áè≠Á∫ßÊÄªÊòØÁº∫Â∞ë‰∫õÂáùËÅöÂäõÔºåÊàñËÆ∏ÊòØÂ§ßÂÆ∂ÈÉΩÂ§™Êúâ‰∏™ÊÄß‰∫ÜÔºå‰πüÂèØËÉΩÊòØÂ§ßÂÆ∂È´ò‰∏≠ÈÉΩÂøôÔºåÊÄªËÄåË®Ä‰πãÔºåÂπ∂Ê≤°ÊúâÈùûÂ∏∏Â•ΩÁöÑ‰ΩìÈ™å„ÄÇ ÂõûÊù•‰πãÂêéÂ°´‰∫Ü‰∏™ÂøóÊÑø„ÄÇÊàë‰πü‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÊàëÂ∞±ÊÉ≥Êä•ËÆ°ÁÆóÊú∫Ôºå‰πüËÆ∏ÊòØË¢´Êüê‰πéÊ¥óËÑë‰∫ÜÂêßÔºåËá™Â∑±‰πüÁúãËµ∑Êù•ÊòØÊúâÁÇπÂÖ¥Ë∂£„ÄÇ ËÆ∞ÂæóÂΩìÊó∂ËøòË∑üÁà∂ÊØçÂêµ‰∫Ü‰∏ÄÊû∂ÔºåÂõ†‰∏∫‰∏çÁü•ÈÅìÈÄâÂì™‰∏™Â≠¶Ê†°„ÄÇÂΩìÊó∂‰πü‰∏çÁü•ÈÅì‰∏∫‰ΩïÂ∞±ÈÄâÂÆö‰∫ÜÂ∞èÁ†¥ÈÇÆÔºå‰∏çËøáÁé∞Âú®ÊÉ≥ÊÉ≥ÂìàÊ∑±ÁöÑËÆ°ÁÆóÊú∫ÊàëËøò‰∏çÂ§üÂàÜÊù•ÁùÄÔºåÂΩìÊó∂Â¶ÇÊûúÂ°´‰∫ÜÁé∞Âú®ÂèØËÉΩÂ∞±Âú®Â≠¶Êú∫Ê¢∞‰∫ÜÔºàÊëîÔºâ„ÄÇÁé∞Âú®ÊÉ≥ÊÉ≥‰ºº‰πéÂÄí‰πü‰∏çÁÆó‰ªÄ‰πàÈîôËØØÁöÑÂÜ≥ÂÆö‚Äî‚ÄîÂ∞èÁ†¥ÈÇÆËôΩÁ†¥Ôºå‰ΩÜÊòØÂÅèËøúÁöÑÊ≤ôÊ≤≥ÂÄí‰πüËÉΩËÆ©‰∫∫‰∏ìÂøÉ‰∏ãÊù•Â≠¶‰π†ÔºåËÄå‰∏îËØ¥ÂÆûËØùÂêßÔºåÂü∫Êú¨‰∏äËØ•ÊúâÁöÑËÆæÊñΩ‰πüÈÉΩÁÆóÊúâ‰∫ÜÔºåÊõ¥ÈáçË¶ÅÁöÑÊòØÔºåÂ∞èÁ†¥ÈÇÆÁöÑÂêåÂ≠¶ÊÄª‰Ωì‰∏äÊÑüËßâËøòÊòØÊå∫Â•ΩÁöÑ~ÊÄª‰ΩìËÄåË®ÄÂ≠¶È£éËâØÂ•ΩÔºåËÄå‰∏î‰πüÊúâÈùûÂ∏∏Â§öÂú®ÊàëÁúãËµ∑Êù•ÈùûÂ∏∏ÂéâÂÆ≥ÁöÑÂêåÂ≠¶ÔºåËÆ©ÊàëÊÑüËßâËá™Â∑±ÈùûÂ∏∏ÁöÑËíüËíªQAQ„ÄÇ ÂêéÊù•ÁöÑÂÅáÊúüÂü∫Êú¨‰∏äÂ∞±ÊòØÊâìÊ∏∏ÊàèÔºåÂ≠¶Êû∂Â≠êÈºìÔºåË∏¢Ë∂≥ÁêÉÔºåÂÅ•Ë∫´Âá†Ê†∑‰πãÈó¥ËΩÆÊç¢„ÄÇ‰∏çÂæó‰∏çËØ¥ÊàëËøòÊòØÊå∫ÈöæÂéªÂùöÊåÅ‰∏Ä‰∫õÁà±Â•ΩÁöÑ‚Ä¶Áé∞Âú®Èô§‰∫ÜÂÅ∂Â∞îÂéªÂéªÂÅ•Ë∫´ÊàøÔºåÂÖ∂‰ªñÂá†È°πÂü∫Êú¨ÈÉΩËçíÂ∫ü‰∫ÜÔºåËôΩËØ¥Ëøô‰∏ÄÂπ¥Êù•Á°ÆÂÆûÂøôÁ¢åÔºå‰ΩÜÊòØÈöæ‰ª•ÊåÅ‰πã‰ª•ÊÅí‰ºº‰πé‰πüÊàê‰∏∫‰∫ÜÊàë‰∏ÄË¥Ø‰ª•Êù•ÁöÑÂùèÊØõÁóÖÂêß„ÄÇ8ÊúàÂéª‰∫ÜË∂üÊñ∞ÁñÜÔºåÊÄª‰ΩìËÄåË®ÄÔºåÊôØËâ≤ÊòØ‰ºòÁæéÁöÑÔºå‰ΩÜÊòØÊöëÂÅáÊµ©Êµ©Ëç°Ëç°ÁöÑ‰∫∫ÊµÅÂÆûÂú®ÊòØ‰ª§‰∫∫Èöæ‰ª•ÊèêËµ∑‰ªª‰ΩïÊ∏∏Áé©ÁöÑÂÖ¥Ëá¥„ÄÇËÄåÂêéÂèàÂéªË•øÂÆâÊêû‰∫ÜË∂üÁñØÁãÇ‰πãÊóÖÔºåÁé∞Âú®ÊÉ≥ÊÉ≥ÊòØÊúâ‰∫õÂêéÊÇîÁöÑÔºåÊµ™Ë¥πÈí±ÔºåÊµ™Ë¥πÊó∂Èó¥„ÄÇ ÊâìÊ∏∏ÊàèÁöÑÂÅáÊúüËøòÊòØËøáÂæóÊå∫Âø´ÁöÑÔºå‰∏ÄËΩ¨ÁúºÂ∞±ÂºÄÂ≠¶‰∫Ü„ÄÇ‰∏§Âë®ÁöÑÂÜõËÆ≠‰ª§‰∫∫Âç∞Ë±°Ê∑±ÂàªÔºåÂ§ßÊ¶ÇÊòØËøôËæàÂ≠êËøÑ‰ªä‰∏∫Ê≠¢ËøáÂæóÊúÄÈöæÂèóÁöÑ‰∏§Âë®‰∫ÜÔºåÁîüÊ¥ªË¥®ÈáèÂ•áÂ∑ÆÔºåËÄå‰∏îÊØ´Êó†ÊÑè‰πâ„ÄÇÁî®‰∏ÄÂè•ÊîøÊ≤ª‰∏çÊ≠£Á°ÆÁöÑËØùÊù•ËØ¥ÔºåÂ∞±ÊòØ‰∏§Âë®ÁöÑÂèÇÂÜõÂäùÈÄÄËØæÔºåÈô§‰∫ÜÊ≤°ÊãîËçâÔºåÈÉ®ÈòüÈáåÂèØ‰ª•Âπ≤ÁöÑÊó†ËÅä‰∫ã‰ºº‰πéÈÉΩ‰ΩìÈ™åÁöÑÂ∑Æ‰∏çÂ§ö‰∫Ü„ÄÇÂèçÊ≠£Ôºå‰∏™‰∫∫ÊòØÈùûÂ∏∏ÂèçÊÑüËøôÁßçÊØ´Êó†ÊÑè‰πâÁöÑÂÆòÂÉöÊÄßËØæÁ®ãÁöÑ„ÄÇ ÂõûÊù•‰ª•ÂêéÂ∞±ÂºÄÂ≠¶Ôºå‰∏çËøáÂõΩÂ∫ÜÂâçÂü∫Êú¨‰∏äÂï•ÈÉΩÊ≤°ÁúãÔºåÊØèÂ§©Â∞±ÊòØÁé©‰∏ÄÁé©ÔºåÁúã‰∏ÄÁúãÔºåÂÄí‰πüÊÇ†ÂìâÊÇ†Âìâ„ÄÇÂä†‰∫ÜÂ≠¶Áîü‰ºöÁöÑ‰∏Ä‰∏™ÈÉ®Èó®ÔºåÁé∞Âú®ÊÉ≥ÊÉ≥Ëøô‰∏™ËøòÊòØÊå∫ÊúâÊÑè‰πâÁöÑ‚Ä¶Âõ†‰∏∫Ê≤°ËøõËøôÈÉ®Èó®ÁöÑËØùÔºå|Ê≤°ËÆ§ËØÜÊüêËèäËã£ÁöÑËØùÔºåÊàëÂèØËÉΩÂ∑≤ÁªèË¢´ÁºñÁ®ãÂäùÈÄÄ‰∫ÜÔºåÊõ¥‰∏ç‰ºöÊ∑∑ËøõÂÆûÈ™åÁè≠‰∫Ü‚Ä¶‰πüÂ∞±Ê≤°ÊúâÂæàÂ§öÊïÖ‰∫ã‰∫Ü233‚Ä¶‰∏≠Èó¥‰πüÊ≤°Âï•‰∫ãÔºåÁõ¥Âà∞9.27‚Äî‚ÄîÈÇ£‰∏ÄÂ§©ÔºåÊàëÁ™ÅÁÑ∂ÂºÄÂßãÁ†îÁ©∂‰∫Ü‰∏ÄÊ≥¢C Primer PlusÔºåÂÜô‰∫ÜÁ¨¨‰∏Ä‰∏™CÁ®ãÂ∫èÔºåÂï•ÂÜÖÂÆπ‰∏çËÆ∞Âæó‰∫ÜÔºåÊÄª‰πãÔºåÊÑüËßâÊå∫Â•ΩÁé©ÁöÑÔºå‰πüËÆ©ÊàëÂØπËøôÁé©ÊÑèÂÑøÁ™ÅÁÑ∂ÊÑüÂÖ¥Ë∂£Ëµ∑Êù•„ÄÇÁé∞Âú®ÊÉ≥ÊÉ≥ÔºåÈô§‰∫Ü‰∏ÄÂºÄÂßãÁöÑÂÖ¥Ë∂£‰ª•Â§ñÔºåÂ§ßÊ¶Ç‰πüË∑üÁ®ãÂ∫èÁöÑÂèçÈ¶àÊÄßÊúâÂÖ≥Âêß‚Äî‚ÄîÂç≥Êó∂ÁöÑËæìÂá∫ÔºåËôΩÁÑ∂Âè™ÊòØÊéßÂà∂Âè∞ÈÇ£‰∏™ÈªëÊ°ÜÊ°Ü„ÄÇ‰ª•ÂèäÂêéÊù•ÁöÑÂêÑÁßçOJÔºåACÔºåWAÔºåTLEÔºåÂÖ∂ÂÆûÈÉΩ‰ª§‰∫∫Âà∫ÊøÄÔºå‰∏çÂÉèÈÇ£ËâπËõãÁöÑÈ´òÊï∞ÔºåËá≥‰ªäÈÉΩÊèê‰∏çËµ∑‰ªÄ‰πàÂÖ¥Ë∂£„ÄÇ ÂêéÈù¢Â§ßÊ¶ÇÂ∞±ÊòØ‰∏äËØæÔºå‰∏äËØæÔºåÂÖ∂ÂÆûÂç∞Ë±°ÈÉΩ‰∏çÊòØÂæàÊ∑±ÔºåÂõ†‰∏∫Á¨¨‰∏Ä‰∏™Â≠¶ÊúüÂÖ∂ÂÆûÂè™Êúâ‰∏Ä‰ª∂‰∫ã‰ª§ÊàëÊÑüÂÖ¥Ë∂£ÔºåÈÇ£Â∞±ÊòØÁºñÁ®ã„ÄÇÂΩìÊó∂Ëä±‰∫ÜÂ§ßÊ¶Ç‰∏Ä‰∏™ÊúàÂ§ßËá¥Áúã‰∫ÜÁúãCÁöÑÂü∫Êú¨ËØ≠Ê≥ïÔºåÁÑ∂ÂêéÂ∞±ÂºÄÂßãÂØπÁÆóÊ≥ïÊúâ‰∫Ü‰∫õÂÖ¥Ë∂£‚Äî‚ÄîÂ§ßÊ¶ÇË∑üÂ§¥Âá†Ê¨°Êú∫ËÄÉÁöÑÊó∂ÂÄôÊøÄÂä®‰∫∫ÂøÉÁöÑÊéíË°åÊ¶ú‰πüÊúâÁÇπÂÖ≥Á≥ªÂêß„ÄÇÊÄª‰πãÊúü‰∏≠‰πãÂêéÔºåÈô§‰∫ÜÁ†îÁ©∂Êñ∞ÁÆóÊ≥ïÂÜôOJÔºåÂΩìÊó∂Âï•ÈÉΩ‰∏çÊÉ≥Âπ≤ÔºåËøûÊ∏∏ÊàèÈÉΩÊ≤°Á¢∞ËøáÔºåÂØºËá¥ÊàëÂØíÂÅáÊääÊ∏∏ÊàèÊú¨ÁªôÂçñ‰∫ÜÔºàÁ¨ëÔºâ„ÄÇ‰∏çËøáÂπ≥ÂøÉËÄåËÆ∫ÔºåÁ†îÁ©∂‰∏Ä‰∏™ÁÆóÊ≥ïÔºåËØïÁùÄÁî®ÂÆÉÂéªÂ•ó‰∏Ä‰∫õÁÆÄÂçïÊ®°ÊùøÈ¢òÔºåËé∑Âæó‰∏Ä‰∏™‰∏™ACÔºåÁúüÁöÑÊòØÊå∫ÊúâÊÑèÊÄùÁöÑÔºåËÆ©ÊàëÂ§ßÂçä‰∏™Â≠¶Êúü‰πêÊ≠§‰∏çÁñ≤„ÄÇÁ¨¨‰∏ÄÂ≠¶ÊúüÊÄé‰πàËØ¥Âë¢ÔºåÂÖ∂ÂÆûËá™ÊàëÊÑüËßâËøòÊòØÊå∫ËÆ§ÁúüÁöÑÔºåÂèØÊÉúÂ∞±ÊòØÂØπËØæÂÜÖÁöÑ‰∫ãÊÉÖ‰∏çÂ§™‰∏äÂøÉÔºåÊúÄÂêéÊàêÁª©‰πü‰∏çÊÄé‰πàÂ•ΩÁúãÔºåÈ´òÊï∞Â≠¶Âæó‰π±‰∏ÉÂÖ´Á≥üÊüêÁßçÊÑè‰πâ‰∏ä‰πüÂΩ±Âìç‰∫ÜÁ¨¨‰∫åÂ≠¶ÊúüÁöÑÈ´òÊï∞„ÄÇÂΩìÊó∂ÊÉ≥ÁùÄÁ¨¨‰∫åÂ≠¶Êúü‰∏ÄÂÆöË¶ÅÂ•ΩÂ•ΩÂÅö‰∫∫Ôºå‰∏çËÉΩÂøΩËßÜËØæÂÜÖÁöÑ‰∏úË•øÔºåÁÑ∂ËÄå‰∏ÄËøû‰∏≤ÁöÑÊÑèÂ§ñËøòÊòØËÆ©Ëøô‰∏™ËÆæÊÉ≥ËêΩÁ©∫‰∫Ü‚Ä¶‰∫ãÂÆû‰∏äÔºåËøôÂ≠¶ÊúüÊÄª‰ΩìËÄåË®Ä‰æùÁÑ∂ÁöÑÊå∫Á≥üÁ≥ïÁöÑ„ÄÇ ÂØíÂÅáËøáÁöÑÂÖ∂ÂÆû‰∏çÊòØÂæàÂ¶ô„ÄÇÂõûÂÆ∂ÂâçÂéª‰∫ÜË∂üÂ§©Ê¥•ÔºåÂÖ∂ÂÆûÂπ∂‰∏çÂ•ΩÁé©Ôºå‰∏çËøá‰∏ÄËµ∑ÂéªÁöÑÂ∞è‰ºô‰º¥ËøòÊòØÊå∫ÊúâÊÑèÊÄùÁöÑ„ÄÇÂõûÂÆ∂‰πãÂêéÂÆûÂú®ÊòØÊúâÁÇπÈ¢ìÔºåÊú¨Êù•ÊÉ≥Â•ΩÂ•ΩÁ†îÁ©∂‰∏ÄÊ≥¢ÁÆóÊ≥ïÁöÑÔºå‰ΩÜÊòØÁé∞Âú®ÊÉ≥ÊÉ≥Â•ΩÂÉèÂΩìÊó∂‰πüÊ≤°Âπ≤‰ªÄ‰πàÔºåÂêéÊù•Êó•Â≠ê‰πüÂ∞±ËøáÂéª‰∫Ü„ÄÇÂπ¥ÂêéÂéª‰∫ÜË∂üÂüÉÂèäÔºåÂΩìÊó∂ÁöÑÊó•Á®ãÂÆâÊéíÁöÑ‰∏çÊòØÁâπÂà´Â•ΩÔºåÂΩìÁÑ∂Ëøô‰∏™ÂõΩÂÆ∂‰∏ç‰∏ÄÊ†∑ÁöÑÈ£éÊÉÖËøòÊòØÊå∫ÊúâÊÑèÊÄùÁöÑ„ÄÇÊÄªËÄåË®Ä‰πãÔºåÂØíÂÅáÂª∂Áª≠‰∫ÜÊàë‰∏ÄË¥Ø‰ª•Êù•ÊîæÂÅáÈ¢ìÂ∫üÁöÑ‰ΩúÈ£é„ÄÇ ÂºÄÂ≠¶Â∞±ÊòØÊñ∞ÁîüËµõÔºåÊúÄÂêéÁªìÊûúËøòÊòØokÁöÑÔºåÊØïÁ´ü‰∏ÄÁæ§OIËèäËã£‰ª¨ÂéãÈòµÔºå‰∏Ä‰∏™Â∞èÁôΩ‰πüÂ∞±ËøôÊ†∑‰∫ÜÂêß„ÄÇÁÑ∂ÂêéÂ∞±ÊòØÊ†°ËµõÁöÑÁΩëÁªúËµõÔºåÁ¨¨‰∏ÄÊ¨°ÁªÑÈòüÊêû‰∫Ü‰∏ÄÊ≥¢Ôºå‰πüÁÆóÊòØËÆ§ËØÜ‰∫ÜÁ¨¨‰∏ÄÊ≥¢ÈòüÂèãÂêß„ÄÇÂÜçÂêéÈù¢Â∞±ÊòØÂÆûÈ™åÁè≠ÁöÑÈÄâÊãîÔºå‰∏çÂæó‰∏çËØ¥Ëøô‰∫ãËøòÊòØÊå∫Á≥üÂøÉÁöÑÔºå‰∏çÁü•ÈÅìÊòØË∞ÅÂä†ÁöÑÊä•ÂêçÈôêÂà∂‚Äî‚ÄîÊô∫ËÇ≤Ââç40%„ÄÇÂèçÊ≠£Â∞±ËÆ∞ÂæóÈÇ£Âë®Êå∫ÈöæÂèóÁöÑÔºåÂπ≥ÂøÉËÄåËÆ∫Â≠¶Èô¢Ëøô‰πàÂÆöÂÖ∂ÂÆû‰πüÊó†ÂèØÂéöÈùûÔºå‰ΩÜÊàëËøòÊòØÈùûÂ∏∏ÁöÑÈÉÅÈó∑„ÄÇÊØïÁ´ü‰∏Ä‰∏™Êú∫ËÄÉÈÄâÊãîÔºåÂ¶ÇÊûúËøûÂèÇÂä†ÁöÑÊú∫‰ºöÈÉΩÊ≤°ÊúâÁöÑËØùÔºåËøòÊòØ‰ª§‰∫∫Êå∫Èöæ‰ª•Êé•ÂèóÁöÑ„ÄÇÂπ∏Â•ΩÂêéÊù•Â•ΩÂÉèÂπ∂Ê≤°Êúâ‰∫∫ËÆ∞ÂæóÊúâËøô‰πà‰∏ÄÂõû‰∫ãÔºåÊú∫ËÄÉ‰πüÈ°∫Âà©ÁöÑÂèÇÂä†‰∫Ü„ÄÇ‰∏çËøáÈÇ£ÊÆµÊó∂Èó¥Â§ßÊ¶ÇÁä∂ÊÄÅ‰∏çÂ§™Â•ΩÂêßÔºåÂä†‰∏äÂÜÖÂøÉÂøßÈÉÅÔºåÊâÄ‰ª•Êú∫ËÄÉÁöÑÁöÑÊó∂ÂÄôÁ∫ØÁ≤πÊòØÈù†ÁΩöÊó∂Â∞ëÊääÊéíÂêçÊãâ‰∫Ü‰∏äÊù•„ÄÇÁÑ∂ÂêéÂ∞±ÊòØÈù¢ËØïÔºåÂøêÂøëÂú∞ÈÇìÁªìÊûú„ÄÇÂΩìÊó∂Èù¢ËØïÁöÑÊó∂ÂÄôË¢´ËÄÅÂ∏àÈóÆ‰∫Ü‰∏ÄÂ†ÜËØæÂÜÖÊàêÁª©ÁöÑÊÉÖÂÜµÔºåÊÑüËßâËá™Â∑±Âø´Âáâ‰∫ÜÔºåÂπ∏Â•ΩÊúÄÂêéËøòÊòØËøá‰∫Ü„ÄÇÊ†°ËµõÁöÑËØùÊàë‰ª¨ÈòüÊÑüËßâÈÉΩ‰∏çÂú®Áä∂ÊÄÅÔºåÁΩöÊó∂ÁàÜÁÇ∏Ê∑∑‰∫Ü‰∏™ÈìúÔºå‰∏çËøáÂΩìÊó∂ÊÉ≥ÊÉ≥Ôºå‰πüÁÆóÊòØÊ∑∑ËøõÂÆûÈ™åÁè≠‰∫ÜÔºå‰πü‰∏çËÉΩÂ§™Â∏åÊúõ‰∏ÄÂàáÈÉΩÂæàÈ°∫Âà©Âêß„ÄÇ ‰∏çËøáÔºåÂºÄÂ≠¶ÈÇ£‰ºöÂøô‰∫éÂáÜÂ§áÂêÑÁßçËµõÔºå‰πãÂêéÂèàÊòØÁ≥üÂøÉÁöÑÈÄâÊãîÔºåÁÑ∂ÂêéËΩ¨Áè≠ÂèàÊòØ‰∏ÄÁâáÊ∑∑‰π±ÔºåÊüêÁßçÊÑè‰πâ‰∏ä‰πüÂæàÂ§ßÁöÑÂΩ±Âìç‰∫ÜËøôÂ≠¶ÊúüÂêéÁª≠ÁöÑËØæÁ®ã„ÄÇÁâπÂà´ÊòØÊ®°ÁîµÔºåËΩ¨ËøáÂéª‰πãÂêéÂèëÁé∞‰ªñ‰ª¨Â∑≤Áªè‰∏äÂÆå‰∫ÜÔºå‰∫éÊòØÂà∞ÊúÄÂêéÊàë‰πüÊ≤°ÊÄé‰πàÂ≠¶ËøôÁé©ÊÑèÂÑøÔºåÊúüÊú´‰πüÊòØ‰∏çÊòé‰∏çÁôΩÊ∑∑ËøáÂéª‰∫Ü„ÄÇÊúüÊú´ÁöÑÂçä‰∏™ÊúàÂÖ∂ÂÆû‰πüÂä™Âäõ‰∫Ü‰∏Ä‰∏ãÂ∏åÊúõÊãØÊïë‰∏Ä‰∏ãËØæÂÜÖÔºå‰ΩÜÂÖ∂ÂÆûÊúÄÂêé‰πüÂ∞±ÈÇ£Ê†∑‰∫ÜÔºåÁßØÈáçÈöæËøî„ÄÇ Â∫îËØ•ËØ¥ÔºåËøô‰∏™Áè≠Áâõ‰∫∫ËøòÊòØÂæàÂ§öÁöÑÔºåÊØîËµ∑Êù•ÊàëÂÖ∂ÂÆûÂï•ÈÉΩ‰∏çË°å‚Äî‚Äî‰ª£Á†Å‰∏çÂ¶ÇOIÂÖöÔºåËØæÂÜÖÊàêÁª©‰∏ÄÂ°åÁ≥äÊ∂ÇÔºåÊàë‰πü‰∏çÁü•ÈÅìËØ¥‰ªÄ‰πàÂ•Ω‰∫ÜQAQÔºåÂ∏åÊúõÂèØ‰ª•Âú®‰ºóÂ§öËèäËã£ÁöÑÂà∫ÊøÄ‰∏ã‰ª•ÂêéÂÅöÁöÑÊõ¥Â•ΩÂêß‚Ä¶ÁÑ∂ÂêéËøôÂçä‰∏™Â≠¶Êúü‰πüÊúâÂπ∏ÈÅáÂà∞‰∫ÜÂá†‰ΩçÊå∫Â•ΩÁöÑÂêåÂ≠¶ÔºåÂá†‰ΩçËèäËã£ÊÑøÊÑèÊê≠ÁêÜÊàëËøô‰∏™ËíüËíªÔºåÂÖ∂ÂÆûËøòÊòØÊå∫ÂºÄÂøÉÁöÑÔºå‰πüÁÆóÊúâ‰∫õÊÑüË∞¢Âêß‚Ä¶‰πãÂâçËøòÊúâÁÇπÊãÖÂøÉ‰ºö‰∏ç‰ºöÊ∑∑ÊàêÂ≠§ÂÆ∂ÂØ°‰∫∫ÁöÑÊÑüËßâ‚Ä¶. ÊµÅÊ∞¥Ë¥¶ÂÜô‰∫ÜÂÜôÔºåÂèëÁé∞Êó∂Èó¥ËøòÊòØËøáÂæóÂæàÂø´ÁöÑ„ÄÇÊÄª‰Ωì‰∏äÊù•ËØ¥ÔºåËøô‰∏ÄÂπ¥ËøòÊòØÊå∫ÂøôÁöÑÔºåÊØèÂ§©ÈÉΩËøáÂæóÂæàÂø´Ôºå‰πüÁÆóÊòØÊå∫ÂÖÖÂÆû‰∫Ü„ÄÇÂΩìÁÑ∂ÂêéÊù•ËøòÊòØÊúâÁÇπÈ¢ì‰∫ÜÔºåËÄå‰∏îÁª©ÁÇπÂ∫îËØ•ÁÆóÊòØÊå∫Á≥üÁ≥ï‰∫Ü‚Ä¶‚Ä¶‰∏ÄÂπ¥Êç¢‰∫Ü‰∏§‰∏™Áè≠ÔºåËÆ§ËØÜ‰∫Ü‰∏ÄÂ§ßÊ≥¢Êñ∞ÂêåÂ≠¶ÔºåËøòÊòØËõÆÂºÄÂøÉÁöÑ„ÄÇÂ∏åÊúõÊöëÂÅáÁöÑËÆ≠ÁªÉÔºå‰ª•ÂèäÂêéÈù¢ÁöÑÂ§ß‰∫åÔºåÂèØ‰ª•Âê∏ÂèñÁªèÈ™åÔºåËøáÂæóÊõ¥È°∫Âà©‰∏Ä‰∫õÂêßÔºå‰πü‰∫âÂèñÊ∑∑‰∏™Êõ¥Â•ΩÁöÑÊàêÁª©„ÄÇÂä†Ê≤πÔºÅ]]></content>
      <categories>
        <category>ÁîüÊ¥ª</category>
      </categories>
      <tags>
        <tag>ÁîüÊ¥ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #456 (Div. 2) D.Fishes]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-456-div-2-d-fishes%2F</url>
    <content type="text"><![CDATA[ÊòæÁÑ∂ÔºåÊö¥ÂäõÊ®°ÊãüÊØè‰∏™r* rÁöÑÊ°ÜË¶ÜÁõñÊòØ‰ºötleÁöÑÔºåÊàë‰ª¨‰∏çÂ¶®Êç¢‰∏ÄÁßçÊÄùË∑ØÔºåÂç≥ËÆ°ÁÆóÊØè‰∏™cellË¢´Â§öÂ∞ë‰∏™Ê°ÜÊâÄË¶ÜÁõñ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂú®‰ΩçÁΩÆxÔºåyÁöÑcellÁöÑÊ°ÜË¶ÜÁõñÊï∞‰∏∫Ôºö Âõ†Ê≠§ÔºåÊÄªÁöÑÊ°ÜË¶ÜÁõñÊï∞Â∞±ÊòØ Ê≥®ÊÑèÂà∞Êó†ËÆ∫ÊòØÊÄé‰πàÊ†∑ÁöÑÊÉÖÂÜµÔºå‰Ωç‰∫é(n+1)/2,(m+1)/2Â§ÑÁöÑcellÁöÑÊ°ÜË¶ÜÁõñÊï∞‰∏ÄÂÆöÊòØÊúÄÂ§ßÁöÑ‰πã‰∏ÄÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•‰ªéËøô‰∏™cellÂºÄÂßãbfsÔºå‰ΩÜÊòØËøôÈáåÁöÑqueueuÈááÁî®ÊúâÈôêÈòüÂàóÔºåÂç≥‰ª•Ê°ÜË¶ÜÁõñÊï∞‰∏∫‰ºòÂÖàÂÄº„ÄÇÊúÄÂêéÊ≥®ÊÑè‰∏Ä‰∏ãÈáçÂ§çÁöÑÈóÆÈ¢òÂç≥ÂèØÔºàÂÜôÁöÑÊó∂ÂÄôÁî®setÂà§‰∫Ü‰∏Ä‰∏ãÈáçÔºâ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;set&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt;P; struct cell{ int x,y;ll f; bool operator&lt;(const cell&amp;v)const{ return f&lt;v.f; } }; int n,m,r,k; ll cal(int x,int y) { return (ll)(min(n+1,x+r)-max(x,r))*(min(m+1,y+r)-max(y,r)); } bool ch(int x,int y) { if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return false; return true; } int main() { int i,j; int move1[4][2]={-1,0,1,0,0,-1,0,1}; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;k; priority_queue&lt;cell&gt;que; set&lt;P&gt;ck; ll sum=0; que.push(cell{(n+1)/2,(m+1)/2,cal((n+1)/2,(m+1)/2)}); ck.insert(P((n+1)/2,(m+1)/2)); while(!que.empty()){ k--; cell t=que.top();que.pop(); sum+=t.f; for(i=0;i&lt;4;i++){ int x1=t.x+move1[i][0],y1=t.y+move1[i][1]; if(ch(x1,y1)&amp;&amp;!ck.count(P(x1,y1))){ que.push(cell{x1,y1,cal(x1,y1)});ck.insert(P(x1,y1)); } } if(!k)break; } printf(&quot;%.10f\n&quot;,(double)sum/((ll)(n-r+1)*(m-r+1))); return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Hello 2018]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-hello-2018%2F</url>
    <content type="text"><![CDATA[A. 2ÁöÑÂπÇÊ¨°ÊØîËæÉÂ§ßÁöÑÊó∂ÂÄôÊòæÁÑ∂Áõ¥Êé•ËæìÂá∫mÂ∞±Ë°å‰∫ÜÔºåÊØîËæÉÂ∞èÁöÑÊó∂ÂÄôÊö¥ÂäõÁÆó‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { long long n,m; cin&gt;&gt;n&gt;&gt;m; if(n&gt;=63){ cout&lt;&lt;m&lt;&lt;endl; } else{ cout&lt;&lt;m%(1LL&lt;&lt;n)&lt;&lt;endl; } return 0; } B. dfsÂà§Êñ≠‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;G[1005]; bool dfs(int x) { if(G[x].empty()) return true; if(G[x].size()&amp;&amp;G[x].size()&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } int cnt=0; for(auto a:G[x]) if(dfs(a)) cnt++; if(cnt&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } return false; } int main() { int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; return 0; } C. Âíã‰∏ÄÁúãÊÑüËßâÊòØ‰∏™ÂÆåÂÖ®ËÉåÂåÖÔºåÁÑ∂ËÄå1e9ÁöÑËåÉÂõ¥Âä†‰∏äÂèØ‰ª•Ë∂ÖËøáLÔºå‰ΩøÂæóËÉåÂåÖ‰∏çÂ§™ÂèØËÉΩ„ÄÇ Âõ†‰∏∫ÂÆπÈáèÈÉΩÊòØ2ÁöÑÂπÇÊ¨°ÔºåÂõ†Ê≠§‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑ‰ºòÂåñÂ∞±ÊòØÔºåÂ¶ÇÊûúci+1&gt;ci * 2ÔºåÈÇ£‰πàÊòæÁÑ∂‰π∞i+1‰∏çÂ¶Ç‰π∞‰∏§‰∏™iÔºåÂõ†Ê≠§ÂèØ‰ª•Êääi+1ÁªôÊç¢Êéâ„ÄÇ ÂÅöÂÆåËøô‰∏™ÊõøÊç¢‰πãÂêéÔºåÊúâ‰∏ÄÁÇπÊòæÁÑ∂ÁöÑÂ∞±ÊòØÂ¶ÇÊûúÊúÄÁªà‰π∞ÁöÑÊÄªÂÆπÈáè‰∏çË∂ÖËøáLÁöÑËØùÔºåÈÇ£‰πàÊòæÁÑ∂ÊòØ‰π∞Â∞èÂÆπÈáèÁöÑ‰∏çÂ¶Ç‰π∞Â§ßÂÆπÈáèÁöÑ„ÄÇ‰ΩÜÊòØËøòÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÂ∞±ÊòØÊúâÂèØËÉΩ‰π∞Ë∂ÖÂá∫LÁöÑÊÄªÂÆπÈáè‰ºöÊõ¥ÂàíÁÆóÔºåÊâÄ‰ª•Êàë‰ª¨‰ªéÂ§ßÂÆπÈáèÊûö‰∏æÂà∞Â∞èÂÆπÈáèÔºåÂØπ‰∫éÊØè‰∏™ÂÆπÈáèÔºåÊàë‰ª¨ÈÉΩËÄÉËôëÂ¶ÇÊûúÊúÄÂ∞èÁöÑÂÆπÈáèÂ∞±ÊòØ‰ªñÁöÑÊÉÖÂÜµÔºåÂπ∂Áî®Ê≠§ÂéªÊõ¥Êñ∞Á≠îÊ°à„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;c; typedef long long ll; int main() { int n,i,j,k,l; cin&gt;&gt;n&gt;&gt;l; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;c.push_back(j); } for(i=0;i&lt;c.size()-1;i++){ c[i+1]=min(c[i+1],c[i]&lt;&lt;1); } ll sum=0,ans=1LL&lt;&lt;62; for(i=n-1;~i;i--){ int need=l/(1&lt;&lt;i); sum+=(ll)need*c[i]; l-=need*(1&lt;&lt;i); ans=min(ans,sum+(l?c[i]:0)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. ËøôÊòØ‰∏Ä‰∏™ÊØîËæÉÂ§çÊùÇÁöÑÊéíÂ∫èÈóÆÈ¢ò„ÄÇ È¶ñÂÖàÊàë‰ª¨Â∞ÜËÄÉËØïÊåâa‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåaÁõ∏ÂêåÊó∂Êåât‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫è„ÄÇÁÑ∂Âêé‰æùÊ¨°ÊãøÂá∫ÊØè‰∏™ËÄÉËØïÔºåÁî®‰∏Ä‰∏™Â§ßÊ†πÂ†ÜÁª¥Êä§Êàë‰ª¨ÈÄâÊã©ÁöÑËÄÉËØïÔºåÂ§ßÊ†πÂ†ÜÊ†πÊçÆÊØè‰∏™ËÄÉËØïÁöÑtÊéíÂ∫è„ÄÇÂØπ‰∫éÊØè‰∏™‰ªéÂ∫èÂàó‰∏≠ÊãøÂá∫ÁöÑËÄÉËØïÔºåÂ¶ÇÊûúÂÆÉÁöÑÈó®Êï∞==Â†Ü‰∏≠ÁöÑËÄÉËØïÊï∞ÔºåÈÇ£‰πàÂè™ÊúâËøô‰∏™ËÄÉËØïÁöÑtÊØîÂ†ÜÈ°∂ÁöÑËÄÉËØïÁöÑtÂ∞èÁöÑÊó∂ÂÄôÊàë‰ª¨ÊâçÊúâÂøÖË¶ÅÊää‰ªñ‰∏¢ËøõÂéª„ÄÇÂ¶ÇÊûúÊãøÂá∫ÁöÑËÄÉËØïÁöÑa&gt;=Â†Ü‰∏≠Èó®Êï∞+1ÔºåÈÇ£‰πàÂ¶ÇÊûúÂ†Ü‰∏≠ÊÄªÂíå+ÊãøÂá∫ÁöÑt&lt;=ÊÄªÊó∂ÈïøÔºåÂ∞±Áõ¥Êé•‰∏¢ËøõÂ†Ü„ÄÇÂê¶ÂàôÊääÊãøÂá∫ÁöÑËÄÉËØï‰∏éÂ†ÜÈ°∂ËÄÉËØï‰∏≠tÊØîËæÉÂ∞èÁöÑÊîæËøõÂéªÂç≥ÂèØ„ÄÇÊúÄÂêéÂ†Ü‰∏≠ËÄÉËØïÂç≥‰∏∫ÊâÄÊ±Ç„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct test{ int id,a,t; bool operator&lt;(const test&amp;v)const{ return t&lt;v.t; } }T[200005]; bool cmp(test a,test b) { if(a.a==b.a) return a.t&lt;b.t; return a.a&gt;b.a; } int main() { int n,t,i,j,cnt=0; cin&gt;&gt;n&gt;&gt;t; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;T[i].a,&amp;T[i].t);T[i].id=i; } sort(T+1,T+1+n,cmp); priority_queue&lt;test&gt;que; for(i=1;i&lt;=n;i++){ if(T[i].a==que.size()){ if(!que.empty()){ if(que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } else if(T[i].a&gt;=que.size()+1){ if(cnt+T[i].t&lt;=t){ que.push(T[i]);cnt+=T[i].t; } else{ if(!que.empty()&amp;&amp;que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } } cout&lt;&lt;que.size()&lt;&lt;endl&lt;&lt;que.size()&lt;&lt;endl; while(!que.empty()){ cout&lt;&lt;que.top().id&lt;&lt;&apos; &apos;;que.pop(); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mash upÂç†Âùë]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2Fmash-up-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>‰π±Êêû</category>
      </categories>
      <tags>
        <tag>‰π±Êêû</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Life Âç†Âùë]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2Flife-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>ÁîüÊ¥ª</category>
      </categories>
      <tags>
        <tag>ÁîüÊ¥ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 36 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-educational-codeforces-round-36-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. Á≠æÂà∞È¢ò‰∏çËß£Èáä #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; bool cmp(int a,int b) { return a&gt;b; } int main() { int n,k,i,j; //cin&gt;&gt;n; vector&lt;int&gt;v; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(k%j==0)v.push_back(j); } sort(v.begin(),v.end(),cmp); cout&lt;&lt;k/v[0]&lt;&lt;endl; return 0; } B. ÊÄªÂÖ±Âè™Êúâ‰∏§ÁßçÊÉÖÂÜµÔºöÂÖàÂÖ≥Â∑¶ËæπÂÜçÂÖ≥Âè≥ËæπÔºåÊàñËÄÖÂèçËøáÊù•ÔºåËÆ®ËÆ∫‰∏Ä‰∏ãÁâπÊÆäËæπÁïåÊÉÖÂΩ¢Âç≥ÂèØÔºåÁ≠æÂà∞*2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,pos,l,r,i,j,k; cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r; if(l==1&amp;&amp;r==n){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(l==1&amp;&amp;r!=n){ cout&lt;&lt;abs(pos-r)+1&lt;&lt;endl; } else if(l!=1&amp;&amp;r==n){ cout&lt;&lt;abs(pos-l)+1&lt;&lt;endl; } else{ int a=abs(pos-l)+1+abs(r-l)+1; int b=abs(pos-r)+1+abs(l-r)+1; cout&lt;&lt;min(a,b)&lt;&lt;endl; } return 0; } C. ÊòæÁÑ∂Êàë‰ª¨ÊòØÊÉ≥Ê±Ç‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ≠óÂÖ∏Â∫èÊúÄÂ§ßÁöÑÊéíÂàóÔºåÈÇ£‰πàÂØπ‰∫éÊØè‰∏Ä‰ΩçÔºåÊàë‰ª¨‰ªéÂèØÊîæÁΩÆÁöÑÊúÄÂ§ßÊï∞Âá∫ÂèëÔºåÊâæÂá∫Âú®ÂΩìÂâçÁä∂ÂÜµ‰∏ãÂêéÁª≠ËÉΩÊéíÂá∫ÁöÑÊúÄÂ∞èÂ∫èÂàóÔºåË∑übÂâ©‰∏ãÁöÑ‰ΩçÊï∞ÊØîËæÉÔºåÂ¶ÇÊûúÊúÄÂ∞èÂ∫èÂàóÊØîbÂ∞èÔºåÈÇ£‰πàËøô‰∏Ä‰ΩçÂ∞±ÂèØ‰ª•ÊîæÊúÄÂ§ßÁöÑÊï∞„ÄÇÂê¶ÂàôËøô‰∏Ä‰ΩçÂ∞±ÂøÖÈ°ªÊîæÊØîËæÉÂ∞èÁöÑÊï∞„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; int cnt[15]; string build(void) { string res; for(int i=0;i&lt;10;i++){ for(int j=1;j&lt;=cnt[i];j++) res+=char(i+&apos;0&apos;); } return res; } int main() { string a,b;int i,j,k; cin&gt;&gt;a&gt;&gt;b; int num[25]; for(i=0;i&lt;b.size();i++) num[i]=b[i]-&apos;0&apos;;//ÊØè‰ΩçÊï∞Â≠ó,‰æø‰∫éÊØîËæÉ for(i=0;i&lt;a.size();i++)//ÁªüËÆ°ÊØèÁßçÊï∞Â≠óÁöÑ‰∏™Êï∞ cnt[a[i]-&apos;0&apos;]++; if(a.size()&lt;b.size()){//Â¶ÇÊûú‰ΩçÊï∞Â∞ëÁõ¥Êé•ËæìÂá∫ÊúÄÂ§ßÊéíÂàó for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl;return 0; } string ans;bool ismall=false; for(i=0;i&lt;a.size();i++){ if(ismall)break; for(j=num[i];~j;j--){//ÂØªÊâæËøô‰∏Ä‰ΩçÊúÄÂ§ßÁöÑÂèØËÉΩ if(cnt[j]){ cnt[j]--; if(j&lt;num[i]){//Â¶ÇÊûúËøô‰∏Ä‰ΩçÂ∑≤ÁªèÊØîbÂ∞è‰∫Ü,Áõ¥Êé•ËæìÂá∫ÂêéÁª≠ÊúÄÂ§ßÊéíÂàóÂç≥ÂèØ ismall=true;ans+=char(j+&apos;0&apos;);break; } string minn=build();string bnow=b.substr(i+1);//ÂØªÊâæÂú®ÂΩìÂâçÊÉÖÂÜµ‰∏ãÂêéÁª≠ËÉΩÊéíÂá∫ÁöÑÊúÄÂ∞èÊéíÂàó if(minn&lt;=bnow){ ans+=char(j+&apos;0&apos;); break; } cnt[j]++; } } } cout&lt;&lt;ans; for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl; return 0; } D. ÁªôÂÆö‰∏ÄÂπÖÊúâÂêëÂõæÔºåÈóÆÊòØÂê¶ÂèØ‰ª•ÊúÄÂ§öÂéªÊéâ‰∏ÄÊù°Ëæπ‰ΩøÂæóËØ•ÊúâÂêëÂõæÊó†ÁéØÔºü È¢òÁõÆÁöÑÂÅöÊ≥ïÊØîËæÉÁ•ûÂ•á„ÄÇ‰∏ÄÂºÄÂßãÁöÑÊÉ≥Ê≥ïÊòØÂÖàÊ±Ç‰∏ÄÊ≥¢Âº∫ËøûÈÄöÂàÜÈáèÔºåÁÑ∂ÂêéÁâπÂà§‰∏Ä‰∏ãÂº∫ËøûÈÄöÂàÜÈáè‰∏∫1ÁöÑÊÉÖÂÜµÔºåÁÑ∂ËÄåtest56 GG‰∫Ü„ÄÇ ÁúãÂà∞‰∏ÄÁßçÂÅöÊ≥ïÔºåÂç≥‰ªé1~nÔºåÊØèÊ¨°‰ª•‰∏çÂêåÁöÑËµ∑ÁÇπÂºÄÂßãdfsÊâæÁéØÔºåÂà§Êñ≠Âõæ‰∏≠ÊòØÂê¶ÂèØËÉΩÂ≠òÂú®Âè™ÂéªÊéâ‰∏ÄÊù°ËæπÂ∞±Êó†ÁéØÁöÑÊÉÖÂÜµÔºàÂΩìÁÑ∂Ë¶ÅÊòØÊú¨Êù•Â∞±Ê≤°ÁéØÈÇ£Â∞±ÊòØÂ∫üËØùÔºâ„ÄÇ ‰∏∫‰ªÄ‰πà‰ªé‰∏çÂêåÁöÑÁÇπÂºÄÂßãdfsÁªìÊûú‰ºö‰∏ç‰∏ÄÊ†∑ÔºüÂõ†‰∏∫ËøôÈÅìÈ¢ò‰∏≠‰ºöÊúâ‰∏ÄÁßçÊØîËæÉÂ•áÁâπÁöÑÊÉÖÂΩ¢ÔºåÊúâÂèØËÉΩÊúâÂ§ö‰∏™ÁéØÈÉΩ‰æùËµñ‰∫é‰∏ÄÊù°ÊúâÂêëËæπËÄåÂ≠òÂú®ÔºåÊØîÂ¶ÇÊ†∑‰æã1ÔºàÂ¶ÇÂõæÔºâ Âú®ËøôÈáå‰ºöÂèëÁé∞2-&gt;3ÁöÑËæπÊòØ‰∏ÄÊù°ÂÖ≥ÈîÆËæπÔºå‰ªé3ÂºÄÂßãÊêúÁ¥¢Êó∂Âõ†‰∏∫ÂÖàÂà∞2ÔºåÂÜçÂºÄÂßãÊêúÁ¥¢1ÔºåÂõ†Ê≠§vis[2]=1ËÄå‰∏ç‰ºöË¢´1ÊêúÁ¥¢Âà∞Ôºå‰∫éÊòØcntÂè™Êúâ1.Âõ†Ê≠§ËøôÂ∞±ÊòØ‚ÄúYES‚Äù„ÄÇ ÁúãËµ∑Êù•‰ºº‰πéËøòÊòØÊå∫Â•áÂ¶ôÁöÑ233 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[505]; int cnt; int vis[505]; void dfs(int x) { vis[x]=2;//Ê≠£Âú®ÂΩìÂâçÊêúÁ¥¢Â∫èÂàó‰∏≠ÁöÑÊ†áËÆ∞‰∏∫2 for(auto a:G[x]){ if(vis[a]==2) cnt++;//ÊØèÊâæÂà∞‰∏Ä‰∏™ÁéØcnt++ else if(!vis[a]) dfs(a); } vis[x]=1;//Â∑≤ÁªèËÆøÈóÆËøá‰ΩÜ‰∏çÊòØÂΩìÂâçÊêúÁ¥¢Â∫èÂàó‰∏≠ÁöÑÊ†áËÆ∞‰∏∫1 } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); } for(i=1;i&lt;=n;i++){ memset(vis,0,sizeof(vis));cnt=0; dfs(i); for(j=1;j&lt;=n&amp;&amp;cnt&lt;=1;j++) if(!vis[j]) dfs(j); if(cnt&lt;=1){//Â¶ÇÊûú‰ªéËøô‰∏™ÁÇπÂá∫ÂèëÂè™ÊâæÂà∞‰∏Ä‰∏™ÁéØ(ÂÖ≥Âª∫Ëæπ) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } E. ÁªôÂÆö‰∏Ä‰∏™ÂàùÂßãÂÖ®‰∏∫1ÁöÑÂ∫èÂàóÔºå‰∏çÂÅúÂú∞ÁªôÂá∫‰∏Ä‰∏™ÊØîËæÉÁü≠ÁöÑÂ∫èÂàó(l,r),Â∞Ü(l,r)ËåÉÂõ¥ÂÜÖÊï∞ÂÖ®ÈÉ®Âèò‰∏∫1Êàñ0ÔºàÊ†πÊçÆkÁöÑÂÄºÂÜ≥ÂÆöÔºâ„ÄÇÂ∫èÂàóËåÉÂõ¥ËæÉÂ§ß„ÄÇ ‰∏ÄÁúºÁúã‰∏ãÂéªÊÑüËßâÁ∫øÊÆµÊ†ëËÉΩÊêûÔºå‰∏ÄÁúãËåÉÂõ¥1e9‚Ä¶‰∫ãÂÆû‰∏äËøôÈÅìÈ¢òÂèàÊòØ‰∏Ä‰∏™Áî®mapÁª¥Êä§Âå∫Èó¥‰ø°ÊÅØÁöÑÂÖ∏‰æã‚Ä¶Êàë‰ª¨Â∞ÜËøûÁª≠ÁöÑÂ∑•‰ΩúÊó•Âå∫Èó¥ÊåâÂè≥Á´ØÁÇπ‰∏∫ÂÖ≥ÈîÆÂÄºÊèíÂÖ•map‰∏≠ÔºåmapÁöÑÁ¨¨‰∫å‰∏™ÈîÆÂÄºÂ∞±ÊòØÂå∫Èó¥ÁöÑÂ∑¶Á´ØÁÇπ„ÄÇÈÇ£‰πàÂàùÂßãÊó∂Êúârange[n]=1 ÂØπ‰∫éÊØèÊ¨°ËØ¢ÈóÆÔºåÊàë‰ª¨ÊâæÂá∫Â§ß‰∫élÁöÑÁöÑÊúÄÂ∞èÁöÑÂú®map‰∏≠ÁöÑÂ∑•‰ΩúÂå∫Èó¥ÔºåÊääÂÆÉ‰∏éËøôÊ¨°ËØ¢ÈóÆÁöÑÂå∫Èó¥Áõ∏‰∫§ÁöÑÈÉ®ÂàÜÂÖ®ÈÉ®Âà†ÂéªÔºåÁÑ∂Âêé‰æùÊ¨°Á±ªÊé®Áõ¥Ëá≥map‰∏≠ÁöÑÂå∫Èó¥‰∏ç‰∏éËØ¢ÈóÆÂå∫Èó¥Áõ∏‰∫§„ÄÇÂ¶ÇÊûúk=2ÔºåÈÇ£‰πàÁ≠îÊ°àÂä†‰∏är-l+1Âç≥ÂèØ„ÄÇ‰∏∫‰ªÄ‰πà‰∏çËÆ®ËÆ∫k=1ÔºüÂõ†‰∏∫Âç≥‰ΩøÊòØk=1ÔºåËØ¢ÈóÆÁöÑÁ©∫Èó¥‰πüÂèØËÉΩÊòØÊîØÁ¶ªÁ†¥Á¢éÁöÑÔºåÂπ∂‰∏çÂÆπÊòìÁªüËÆ°Ôºå‰∏çÂ¶ÇÊää‰ªñ‰ª¨ÂÖ®ÈÉ®Âà†ÊéâÈáçÁΩÆ„ÄÇ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int main() { map&lt;int,int&gt;range;//Ê†áËÆ∞Âë®Êúü int n,i,j,k,q; cin&gt;&gt;n&gt;&gt;q; range[n]=1;int ans=n; for(i=1;i&lt;=q;i++){ int l,r,k; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); auto a=range.lower_bound(l);//ÊâæÂá∫Â§ß‰∫éÁ≠â‰∫éËØ¢ÈóÆÂå∫Èó¥ÁöÑÁ¨¨‰∏Ä‰∏™mapÁöÑÂè≥Á´ØÁÇπ while(a!=range.end()){ int cl=a-&gt;second,cr=a-&gt;first; if(cl&gt;r)break;//Â¶ÇÊûúÂå∫Èó¥ÁöÑÂ∑¶Á´ØÁÇπÂ∑≤ÁªèÂ§ß‰∫éËØ¢ÈóÆÂå∫Èó¥ÁöÑÂè≥Á´ØÁÇπ,ÊòæÁÑ∂Ê≤°Êúâ‰∫§ÈõÜ‰∫Ü ans-=(min(cr,r)-max(cl,l)+1);//Èô§ÂéªËØ¢ÈóÆÂå∫Èó¥ÁöÑÊâÄÊúâÂ∑•‰ΩúÊó• range.erase(a++);//Âà†ÂéªÈáçÂè†Âå∫Èó¥ if(cr&gt;r)range[cr]=r+1;//Â¶ÇÊûúÂ§ßÂå∫Èó¥Ë¢´ËØ¢ÈóÆÂå∫Èó¥ËÇ¢Ëß£‰∫Ü,Âä†ÂÖ•Â∞èÁöÑÊú™Ê∂âÂèäÂå∫Èó¥ if(cl&lt;l)range[l-1]=cl; } if(k==2){ range[r]=l;ans+=r-l+1;//k=2Êó∂Âä†ÂÖ•ËØ¢ÈóÆÂå∫Èó¥ } printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÔºàÊ®°ÊùøÔºâSplay Âπ≥Ë°°Ê†ë]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fsplay%2F</url>
    <content type="text"><![CDATA[ÊÇ®ÈúÄË¶ÅÂÜô‰∏ÄÁßçÊï∞ÊçÆÁªìÊûÑÔºàÂèØÂèÇËÄÉÈ¢òÁõÆÊ†áÈ¢òÔºâÔºåÊù•Áª¥Êä§‰∏Ä‰∫õÊï∞ÔºåÂÖ∂‰∏≠ÈúÄË¶ÅÊèê‰æõ‰ª•‰∏ãÊìç‰ΩúÔºö 1.ÊèíÂÖ• xx Êï∞ 2.Âà†Èô§ xx Êï∞(Ëã•ÊúâÂ§ö‰∏™Áõ∏ÂêåÁöÑÊï∞ÔºåÂõ†Âè™Âà†Èô§‰∏Ä‰∏™) 3.Êü•ËØ¢ xx Êï∞ÁöÑÊéíÂêç(ÊéíÂêçÂÆö‰πâ‰∏∫ÊØîÂΩìÂâçÊï∞Â∞èÁöÑÊï∞ÁöÑ‰∏™Êï∞ +1+1 „ÄÇËã•ÊúâÂ§ö‰∏™Áõ∏ÂêåÁöÑÊï∞ÔºåÂõ†Ëæì4.Âá∫ÊúÄÂ∞èÁöÑÊéíÂêç) 5.Êü•ËØ¢ÊéíÂêç‰∏∫ xx ÁöÑÊï∞ 6.Ê±Ç xx ÁöÑÂâçÈ©±(ÂâçÈ©±ÂÆö‰πâ‰∏∫Â∞è‰∫é xx Ôºå‰∏îÊúÄÂ§ßÁöÑÊï∞) 7.Ê±Ç xx ÁöÑÂêéÁªß(ÂêéÁªßÂÆö‰πâ‰∏∫Â§ß‰∫é xx Ôºå‰∏îÊúÄÂ∞èÁöÑÊï∞) Ê¥õË∞∑P3369 ‰∏çËÆ≤Ëß£ÔºåÁõ¥Êé•‰∏ä‰ª£Á†ÅÔºö #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int MAXN=1000000; int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN]; int nodecnt,root; void clear(int x)//Ê∏ÖÈô§(ÂΩìËøô‰∏™ÁÇπË¢´Âà†Èô§‰πãÂêé) { ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0; } bool get(int x)//Âà§Êñ≠ÊòØÁà∂ËäÇÁÇπÁöÑÂ∑¶ËäÇÁÇπËøòÊòØÂè≥ËäÇÁÇπ { return ch[f[x]][1]==x; } void update(int x)//Êõ¥Êñ∞ÂΩìÂâçÁÇπ‰ª•‰∏ãÁöÑÂÖÉÁ¥†‰∏™Êï∞(ÂèëÁîü‰øÆÊîπ‰ª•ÂêéÊõ¥Êñ∞) { if (x){ size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; } } void rotate(int x)//ÊóãËΩ¨ { int old=f[x],oldf=f[old],whichx=get(x); ch[old][whichx]=ch[x][whichx^1]; f[ch[old][whichx]]=old; ch[x][whichx^1]=old; f[old]=x; f[x]=oldf; if (oldf) ch[oldf][ch[oldf][1]==old]=x; update(old); update(x); } void splay(int x)//splay,‰∏çÂÅúÂú∞rotateÁõ¥Âà∞Êª°Ë∂≥Ë¶ÅÊ±Ç { for (int fa;fa=f[x];rotate(x)) if (f[fa]) rotate((get(x)==get(fa))?fa:x); root=x; } void insert(int x)//ÊèíÂÖ• { if (root==0) { nodecnt++; ch[nodecnt][0] = ch[nodecnt][1] = f[nodecnt] = 0; root = nodecnt; size[nodecnt] = cnt[nodecnt] = 1; key[nodecnt] = x; return; } int now=root,fa=0; while(1){ if (x==key[now]){ cnt[now]++; update(now); update(fa); splay(now); break; } fa=now; now=ch[now][key[now]&lt;x]; if (now==0){ nodecnt++; ch[nodecnt][0]=ch[nodecnt][1]=0; f[nodecnt]=fa; size[nodecnt]=cnt[nodecnt]=1; ch[fa][key[fa]&lt;x]=nodecnt; key[nodecnt]=x; update(fa); splay(nodecnt); break; } } } int find(int x)//Êü•ËØ¢xÁöÑÊéíÂêç(ÊéíÂêçÂÆö‰πâ‰∏∫ÊØîÂΩìÂâçÊï∞Â∞èÁöÑÊï∞ÁöÑ‰∏™Êï∞ +1+1 „ÄÇËã•ÊúâÂ§ö‰∏™Áõ∏ÂêåÁöÑÊï∞ÔºåÂ∫îËæìÂá∫ÊúÄÂ∞èÁöÑÊéíÂêç) { int now=root,ans=0; while(1){ if (x&lt;key[now]) now=ch[now][0]; else{ ans+=(ch[now][0]?size[ch[now][0]]:0); if (x==key[now]){ splay(now); return ans+1; } ans+=cnt[now]; now=ch[now][1]; } } } int findx(int x)//ÂØªÊâæÊéíÂêç‰∏∫xÁöÑÊï∞ { int now=root; while(1){ if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else{ int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp; now=ch[now][1]; } } } int pre()//Ê±Ç xx ÁöÑÂâçÈ©±(ÂâçÈ©±ÂÆö‰πâ‰∏∫Â∞è‰∫é xx Ôºå‰∏îÊúÄÂ§ßÁöÑÊï∞),Ê≥®ÊÑèËøô‰∏™Êï∞‰∏ç‰∏ÄÂÆöÂú®Ê†ë‰∏≠ { int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now; } //Ê≥®ÊÑè,Êü•ÊâæÊüê‰∏™Êï∞ÁöÑÂâçÈ©±ÂêéÈ©±Êó∂,Ë¶ÅÂÖàÊääËøô‰∏™Êï∞ÊèíËøõÊ†ë‰∏≠,ÁÑ∂ÂêéÊääËøô‰∏™Êï∞ËΩ¨Âà∞Ê†πËäÇÁÇπ(insert‰∏≠Â∑≤ÈõÜÊàê), //Ê±ÇxÁöÑÂâçÈ©±ÂÖ∂ÂÆûÂ∞±ÊòØÊ±ÇxÁöÑÂ∑¶Â≠êÊ†ëÁöÑÊúÄÂè≥ËæπÁöÑ‰∏Ä‰∏™ÁªìÁÇπÔºåÂêéÁªßÊòØÊ±ÇxÁöÑÂè≥Â≠êÊ†ëÁöÑÂ∑¶Ëæπ‰∏Ä‰∏™ÁªìÁÇπ,Ê±ÇÂÆåÂêéË¶ÅÂà†Èô§Ëøô‰∏™ÁÇπ int next1()//Ê±Ç xx ÁöÑÂêéÁªß(ÂêéÁªßÂÆö‰πâ‰∏∫Â§ß‰∫é xx Ôºå‰∏îÊúÄÂ∞èÁöÑÊï∞) { int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now; } void del(int x)//Âà†Èô§ÂÄº‰∏∫xÁöÑËäÇÁÇπ { int whatever=find(x);//‰∏ªË¶Å‰ΩúÁî®Â∞±ÊòØÊääxÊóãËΩ¨Âà∞Ê†πËäÇÁÇπ...‰∏çËÉΩÁúÅÁï• if (cnt[root]&gt;1) { cnt[root]--; update(root); return; } if (!ch[root][0]&amp;&amp;!ch[root][1]) { clear(root); root = 0; return; } if (!ch[root][0]) { int oldroot = root; root = ch[root][1]; f[root] = 0; clear(oldroot); return; } else if (!ch[root][1]) { int oldroot = root; root = ch[root][0]; f[root] = 0; clear(oldroot); return; } int leftbig=pre(),oldroot=root; splay(leftbig); ch[root][1]=ch[oldroot][1]; f[ch[oldroot][1]]=root; clear(oldroot); update(root); } int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k); if(j==1){ insert(k); } else if(j==2){ del(k); } else if(j==3){ cout&lt;&lt;find(k)&lt;&lt;endl; } else if(j==4){ cout&lt;&lt;findx(k)&lt;&lt;endl; } else if(j==5){ insert(k);cout&lt;&lt;key[pre()]&lt;&lt;endl;del(k); } else if(j==6){ insert(k);cout&lt;&lt;key[next1()]&lt;&lt;endl;del(k); } } return 0; }]]></content>
      <categories>
        <category>ÁÆóÊ≥ï</category>
        <category>Ê®°Êùø</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
        <category>Âπ≥Ë°°Ê†ë</category>
      </categories>
      <tags>
        <tag>ÁÆóÊ≥ï</tag>
        <tag>Ê®°Êùø</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Âπ≥Ë°°Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2FUncategorized%2Ftest-1%2F</url>
    <content type="text"><![CDATA[testtesttest#include&lt;iostream&gt; int main() { std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; return 0; } hjsfkwhfkhfh fsdfggs hkjhka jhhhj njhkkjk $f^2+2f+4$ ~hjkahfh~ ‰∏≠ÊñáÊµãËØï ÊµãËØïÊµãËØï]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2FUncategorized%2Fe4-bd-a0-e5-a5-bd-e4-b8-96-e7-95-8c%2F</url>
    <content type="text"><![CDATA[Welcome to WordPress. This is your first post. Edit or delete it, then start writing!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
</search>
