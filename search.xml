<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux若干命令]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FLinux%2FLinux%E8%8B%A5%E5%B9%B2%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近突然开始研究了一下Linux，随手记录一下一些用过的看起来比较有意思的命令吧QAQ Shell的几个快捷键Ctrl+a 光标移动到行头 Ctrl+e光标移动到行末 Ctrl+k删除从光标位置到行末 文件浏览&amp;常用乱七八糟编译命令： g++ a+b.cpp -o a+b+c -std=c++11 a+b.cpp是cpp文件名，a+b+c则是可执行文件名，后面则可以选择编译标准。 ls 浏览当前文件夹下的所有文件（不包含隐藏文件 ls -a 显示所有文件（包括隐藏文件） man ls man后面加东西，显示该命令的帮助，上下/空格浏览，q退出 cal 显示日历。cal 5 2018可显示指定月份。 文件打开&amp;新建&amp;删除 cd name 打开文件 cd/cd ~ 回到根目录 cd .. 回到上一级目录 pwd 显示当前路径 mkdir name 新建文件夹 mkdir -p name/name/name 按路径建立多个新文件夹 rmdir name 删除此文件夹（被删除文件夹必须为空） rm -r name 干翻name目录下所有文件（删库跑路？） 文件复制，移动，删除文件复制 cp ~/testpdf.pdf ~/test/ 将根目录下的文件copy到空格后的目录中，~/不填则默认为当前目录下的文件 可以在复制的同时对复制后的文件进行重命名： cp ~/testpdf.pdf ~/test/notest.pdf 复制过去的pdf名字就变了 可以加上-i选项，这样有同名文件覆盖前会询问是否覆盖： cp -i ~/testpdf.pdf ~/test 如果要复制一个目录，或者说是文件夹，那么需要加上指令 -r cp -r test1 test2 如果要强制执行，还可以使用-f指令；同时，多个指令可以叠加使用，例如： cp -rf test1 test2 强制复制目录 一般来说，如果复制文件的新位置是一个目录（复制过去的文件名与源文件名字保持一致），会在目录最后加上一个/明确目的 也可以在cp命令中采用通配符*进行批量复制，例如： 文件删除使用指令rm以达到目的，同样，删除目录需要使用-r，这是递归删除命令； rm -r test1 -i则会在删除前确认，-f表示强制执行。同时，还可以使用指令 rm test* 通过加上 “* ” 来删除此目录下所有文件名以test为前缀的文件； 文件移动使用mv指令来达成目的。mv指令可以移动普通文件和目录，因此不存在-r-f 强制，-i：如果存在同名文件，询问是否覆盖； -u：如果目标文件已存在，且当前来源较新才会更新 mv a+b ~/test/test2/ 将当前目录中的可执行文件a+b移动到指定文件夹中； mv a+b ~/test/test2/a+c 移动文件的同时进行名称变更； mv a+b a+c ~/test/ 同时移动多个文件；注意此时最后一个一定是目录！！！ 文件建立 touch file_name 建立文件 touch file_name{1..number}.txt 括号中写好数字，就会批量建立相应文件 链接Linux中存在两种链接，硬链接与软链接（符号链接），他们大体用途相同，但是也有一些不同点。 相同点从使用的角度讲，两者没有任何区别，都与正常的文件访问方式一样，支持读写，如果是可执行文件的话也可以直接执行。 不同点硬链接可以理解为一个文件的多个别名，例如原来有一个文件file，现在有一个file的硬链接hard，可以发现hard的文件属性与file是完全一致的，并且删除file及hard中的任何一个，都不影响另一个文件正常被执行。 而软链接相当于是保存了一个文件file的绝对路径，如果删除了file，那么尝试打开软链接的时候就会失败 以及，对于文件目录只能创建软链接而不腻创建硬链接 创建软链接1ln -s sourcefile softname 创建硬链接1ln sourcefile hardname 查看文件内容查看文件类型（file命令）file命令能够探测文件内部并决定文件是什么类型的，例如： 1file sourcefile 会根据文件类型的不同返回不同的结果：ASCII text/directory etc. 查看整个文件]]></content>
      <categories>
        <category>乱搞</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something about vim]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FSomething-about-vim%2F</url>
    <content type="text"><![CDATA[基础操作 删除操作 修改操作 定位与查找 外部命令与文件输入输出 复制、查找与其他命令]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础语法]]></title>
    <url>%2FMySQL%2FMySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用MySQLOS X配置问题目前似乎每次关闭terminal之后都要重新配置一下？暂时没找到啥方法解决233 12export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin/source ~/.zshrc 为了连接到MySQL，需要以下信息:主机名(计算机名)——如果连接到本地MySQL服务器，为localhost; 端口(如果使用默认端口3306之外的端口); 例：连接本地服务器 1mysql -u root -p 显示所有数据库 1show databases; 选择数据库 1use database_name; 注意，必须先选择一个数据库才能进行更多的操作 查看一个数据库内的表的列表 1show tables; 显示表列（一个表的详细信息） 1show columns from table_name; 也可以使用 1describe table_name; 检索数据select 语句 上述语句利用SELECT语句从products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 例如： 1select prod_name from products; 注意prod_name是列名，products是表名 检索多个列 用逗号分隔即可 1select prod_id,prod_name from products; 检索所有列 使用通配符*即可 1select * from products 检索不同的行 SELECT检索列时返回所有匹配的行。但是，如果你不想要每个值每次都出现，怎么办? 解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。这时，如果有多行值相同时只会返回一行。 例如： 1select distinct vend_id from products; 不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出 SELECT DISTINCT vend_id, prod_price，除非指定的两个列都相同，否则所有行都将被检索出来。 存疑 限制返回结果 SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 如： 1select prod_name from products limit 5; 此语句使用SELECT语句检索单个列。LIMIT 5指示MySQL返回 不多于5行。 也可以从指定位置开始，如： 1select prod_name from products limit 5,5; LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始 位置，第二个数为要检索的行数。(行号从0开始) MySQL 支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。 排序检索的数据可使用 order by语句取一个或多个列的名字对输出进行排序，例如： 1select prod_name from products order by prod_name; 这条语句除了指示MySQL对prod_name列以字母顺序排序数据 的ORDER BY子句外，与前面的语句相同 选择按照多个列排序的时候只要用逗号隔开即可，如： 1select prod_name from products order by prod_name,prod_price; 使用多个列进行排序时，前面的列优先级比后面的高，在上面也就是，先按prod_name进行排序再按prod_price进行排序 指定排序方向默认情况下是按照字典序升序进行排序的，也可以按照字典序进行降序排序，使用关键字DESC即可。 注意此关键字只对一个列有效，并不对所有列有效（需要对每个列单独指定是否是降序）。 例如： 1select prod_name from products order by prod_name,prod_price desc; note：区分大小写和排序顺序 在对文本性的数据进行排序时，A与a相同吗?a位于B之前还是位于Z之后?这些问题不是理论问 题，其答案取决于数据库如何设置。 在字典(dictionary)排序顺序中，A被视为与a相同，这是MySQL(和大多数数据库管理系统)的默认行为。但是，许多数据库 管理员能够在需要时改变这种行为(如果你的数据库包含大量外语字符，可能必须这样做)。 关键字顺序问题order by语句必须在from子句后面，如果使用limit，则limit应该在order by语句后面 过滤数据使用where子句对数据进行过滤，where子句放在from语句后面，例如： 1select prod_name,prod_price from products where prod_price = 2.50; where子句的操作符 注意：where子句在执行匹配时默认不区分大小写！ 范围值检查使用between进行范围值检查，例如： 1select prod_name,prod_price from products where prod_price between 5 and 10; 注意使用between时，前小后大并且包含这两个端点值 空值检查 使用is null进行空值检查，例如： 1select prod_name from products where prod_price is null; 数据过滤（逻辑运算符）and操作符and运算符可以组合多个where子句，代表需要同时满足多个条件，如： 1select prod_id from products where vend_id=1003 and prod_price&lt;=10; or操作符or操作符指示MySQL检索匹配任何一个条件的行，用法与and一致 优先级问题同时使用and与or操作符时，and操作符的优先级比or要高，因此尽量使用括号来保证优先级不会发生错误，例如： 1select * from products where (vend_id=1002 or vend_id=1003) and prod_price &gt;= 10; in操作符in操作符用于指定条件范围，范围中的每个条件都可以进行匹配，并且只有括号中的范围可以进行匹配（相当于一个简写的or）。例如： 1select prod_name from products where vend_id in (1002,1003,1004) order by prod_name desc; not操作符where子句中的not有且只有一个功能：否定它之后所跟的任何条件。 例如： 1select * from products where vend_id not in (1002,1003) order by prod_name; 用通配符进行过滤使用通配符的操作符是 like ,他告诉MySQL后面是通配符 %操作符% 表示任何字符出现任何次数 ，当然也可以匹配0个字符，除了NULL以外，例如： 1select prod_id,prod_name from products where prod_name like &apos;jet%&apos;; 这将检索所有以jet开头的词，无论后面跟的是什么 如果使用`%anvil%’则表示匹配任何位置包含文本anvil的值 _通配符下划线的用途与%基本一致，但是只匹配单个字符。 使用正则表达式进行搜索正则表达式的关键字：REGEXP，告诉了MySQL后面的东西是正则表达式。正则表达式匹配默认不区分大小写 如果要区分，可以使用binary关键字，如where prod_name regexp binary &#39;.000&#39;; 例如： 1select prod_name from products where prod_name REGEXP &apos;.000&apos;; .在正则表达式中的一个特殊字符，表示匹配任何字符 正则表达式与通配符最大的区别是什么？通配符一定从单词的开始位置开始匹配而正则表达式却可以匹配任何位置。 进行or匹配使用符号|进行or匹配，也就是匹配两个串之一。 例如： 1select prod_name from products where prod_name regexp &apos;1000|2000&apos; order by prod_name; 匹配几个字符之一]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝控制]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2F%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[基本概念定义一个类时的5个基本函数：拷贝构造函数和移动构造函数定义了当用同类型的另一个对象初始化当前对象的时候发生什么。拷贝赋值运算符和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时发生什么。析构函数则定义了此类型对象销毁时做什么。这些操作统称为拷贝控制操作。（很多时候我们会依赖于编译器提供的默认定义）例子：1234Person p;Person p1=p; //调用拷贝构造函数Person p2;p2=p; //调用拷贝赋值函数 拷贝、赋值与销毁拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且其他任何额外参数都有默认值，则这个构造函数是拷贝构造函数。同时，拷贝构造函数的第一个参数也就是对自身类型的引用几乎都是const类型的。 例如：12345class fool&#123;public: fool(); //默认构造函数 fool(const fool&amp;); //拷贝构造函数&#125;; 拷贝初始化直接初始化与拷贝初始化的几个例子：12345string dots(10,'.'); //直接初始化string s(dots); //直接初始化string s2=dots; //拷贝初始化string null_book="9999999"; //拷贝初始化string nines=string(100,'9'); //拷贝初始化 使用直接初始化，事实上是要求编译器选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，编译器会将右侧运算对象拷贝到正在创建的对象中，必要时还会进行类型转换。 发生拷贝初始化的几种情况：·将一个对象作为实参传递给一个非引用类型&amp;的形参·从一个返回类型为非引用类型的函数返回一个对象·用花括号列表初始化一个数组中的元素或者一个聚合类中的成员·某些标准库容器的insert或push操作，而用emplace成员创建的元素都会进行直接初始化 拷贝赋值运算符赋值运算符其实就是一个名为operator=的函数，这个函数也有一个返回类型和参数列表。同时，赋值运算符必须定义为成员函数，其左侧运算对象绑定到了隐式的*this参数，右侧运算对象则作为显示参数传递。赋值运算符接受一个与其所在类相同类型的参数，并通常返回一个指向其左侧运算对象的引用。例子：12345class Foo&#123;public: Foo&amp; operator=(const Foo&amp;); //... &#125;; 如果一个类没有定义自己的拷贝赋值运算符，那么编译器会为它生成一个合成拷贝赋值运算符，它会将右侧对象的每个非static值赋予左侧运算对象的相应成员。 析构函数析构函数执行与构造函数相反的操作：销毁对象的非static成员。析构函数是类的一个成员函数，名字由波浪号+类名构成，没有返回值也不接受任何参数，也不能被重载例子：12345class Foo&#123;public: ~Foo(); //... &#125;; 只要一个对象被销毁，就会自动调用其析构函数。一般来说，大多数对象在离开时都会被自动销毁，但是动态分配的对象并不会被销毁（当指向一个对象的引用或指针离开作用域时，析构函数不会执行），此时就必须依赖自定义的析构函数。例如：12345678910class M&#123; private: int *p; /* data */ public: M(int n) &#123; p = new int[n]; &#125; ~M() &#123; delete[] p; &#125;//默认析构函数只会销毁p，而不会销毁动态分配的p指向的内存&#125;;delete P;//对p指向的对象调用析构函数 同样的，如果没有显示定义，编译器也会为类定义一个合成析构函数。如果一个类需要一个析构函数，那么它也几乎必须拥有一个拷贝构造函数和一个拷贝赋值函数。 这是因为默认的构造与赋值函数只会进行简单的复制操作，而简单的指针复制会使多个对象中的指针指向同一个地址，如果其中一个指针进行了销毁操作，那么其他指针也会随之变为无效指针。 阻止拷贝（定义删除的函数）对于某些类而言，希望禁止拷贝构造与拷贝赋值操作，比如iostream类，这种情况下，我们可以将拷贝构造函数与拷贝赋值函数定义为删除的函数(deleted function)：我们声明了他们，但是不能以任何方式使用他们，在函数参数列表后面加上=delete来指出这一点。例如：1234struct Nocopy&#123; Nocopy()-default; Nocopy(const Nocopy&amp;)=delete; //阻止拷贝构造函数 Nocopy &amp;operator=(const Nocopy&amp;)=delete; //阻止拷贝赋值 注意：析构函数不能是删除的成员。在某些情况下，合成的构造/赋值函数也可能是删除的。在新标准发布之前，很多时候回通过将构造/赋值运算符声明为private的来阻止拷贝。]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-2018 ACM-ICPC East Central North America Regional Contest (ECNA 2017)]]></title>
    <url>%2F%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%AF%94%E8%B5%9B%2F%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%2F%E5%8C%BA%E5%9F%9F%E8%B5%9B%E8%AE%AD%E7%BB%83%2F2017-2018-ACM-ICPC-East-Central-North-America-Regional-Contest-ECNA-2017%2F</url>
    <content type="text"><![CDATA[C - DRM Messages模拟题 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a,b,c; cin&gt;&gt;a; b=a.substr(0,a.length()/2);c=a.substr(a.length()/2); int cntb=0,cntc=0; for(auto x:b)&#123; cntb+=x-'A'; &#125; for(auto x:c)&#123; cntc+=x-'A'; &#125; for(auto &amp;x:b)&#123; x=(x-'A'+cntb)%26+'A'; &#125; for(auto &amp;x:c)&#123; x=(x-'A'+cntc)%26+'A'; &#125; for(int i=0;i&lt;b.length();i++)&#123; cout&lt;&lt;(char)((b[i]-'A'+c[i]-'A')%26+'A'); &#125; return 0;&#125;/*EWPGAJRB*/ D - Game of Throwns处理一下输入，用栈保存一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int can(string s)&#123; int res=0;bool isfu=false; for(auto a:s)&#123; if(a=='-')isfu=true; else res=res*10+(a-'0'); &#125; if(isfu)res=-res; return res;&#125;int main()&#123; int i,j,k,n;string str,s; cin&gt;&gt;n&gt;&gt;k; getline(cin,str); getline(cin,str); stringstream command(str); vector&lt;int&gt;cc; while(command&gt;&gt;s)&#123; if(s=="undo")&#123; command&gt;&gt;s; int qx=can(s); while(!cc.empty()&amp;&amp;qx)&#123; qx--;cc.pop_back(); &#125; &#125; else&#123; cc.push_back(can(s)); &#125; &#125; int sum=0; for(auto a:cc)sum+=a; sum+=(int)1e6*n; cout&lt;&lt;sum%n&lt;&lt;endl; return 0;&#125;/*5 48 -2 3 undo 25 107 -3 undo 1 4 3 -9 5 undo 2 undo 1 6*/ H-Sheba’s Amoebas 题意：有一堆黑白染色的格子，每个黑格的8个邻居中必有2个是黑格，同时每个黑格必然是某个黑格形成的圈里的一部分，求黑格组成了多少个圈。(圈与圈之间不会重复或交叉) 因为题意说的非常明确了，所以要考虑的情况其实非常少，直接dfs即可 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int move1[8][2]=&#123;-1,0,1,0,0,-1,0,1,-1,-1,1,-1,-1,1,1,1&#125;;char mp[105][105];void color(int x,int y)&#123; if(mp[x][y]!='#')return; mp[x][y]=' '; for(int i=0;i&lt;8;i++)&#123; color(x+move1[i][0],y+move1[i][1]); &#125;&#125;int main()&#123; int m,n,i,j,k; scanf("%d%d",&amp;m,&amp;n); for(i=1;i&lt;=m;i++)scanf("%s",mp[i]+1);//printf("%s\n",mp[i]+1);; int cnt=0; for(i=1;i&lt;=m;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(mp[i][j]=='#')&#123; color(i,j);cnt++; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; F-Keeping On Track 题意：有$n+1$个节点，构成了一棵树，现在要摧毁其中一个节点，使得摧毁这个节点后两两之间不存在路径的点对的数目最大，但是在摧毁前允许你在原本没有边相连的两个点之间添加一条边，输出在没有加边之前摧毁节点后两两之间不存在路径的点对数目以及加边后这样的点对数目(加边前后摧毁的都是同一个顶点)。 做法：第一问的关键是处理出摧毁每个点后会存在的两两之间不存在路径的点对的数目。假设对于顶点$i$，它有一个直接相连的顶点$j$，那么如果以$i$为顶点，摧毁$i$之后造成的两两之间没有路径的点对数目就是$\Sigma( size[j] \times (n-1-size[j]))$ 其中$size[j]$是以$j$为顶点的子树的大小。而这些计算，都可以通过一次dfs来$O(n)$处理。 对于第二问，其实这条边肯定是连在这个被摧毁节点的最大的两个子树之间，因此合并被摧毁的顶点的两个最大子树然后计算一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100005;vector&lt;int&gt;G[N];int res1=0,res2=0,n;int size[N];void dfs(int x,int fa)&#123; size[x]++;int ans=0,total=n;//此处total其实相当于是n-1 vector&lt;int&gt;subtree;//记录所有x的子树的大小 for(auto a:G[x])&#123; if(a==fa)continue; dfs(a,x); size[x]+=size[a];//统计以x为根的子树 total-=size[a];//避免重复计算 ans+=total*size[a]; subtree.push_back(size[a]); &#125; if(ans&gt;res1)&#123;//如果第一个答案更新了，第二个答案才有更新的必要 res1=ans;subtree.push_back(n+1-size[x]);//特别注意此处的n+1，因为整个树的大小是n+1，那么 //除去以x为顶点的子树，剩下那个树的顶点数当然是n+1-size[x] res2=0;sort(subtree.begin(),subtree.end()); int temp=subtree.back();subtree.pop_back();subtree.back()+=temp;total=n; for(auto a:subtree)&#123; total-=a;//同样避免重复计算 res2+=total*a; &#125; &#125;&#125;int main()&#123; int i,j,k,a,b; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); &#125; dfs(0,-1);//任意从哪个店开始dfs都是可以的 cout&lt;&lt;res1&lt;&lt;' '&lt;&lt;res2&lt;&lt;endl; return 0;&#125; G-A Question of Ingestion 有个人去吃饭，他有一个初始的胃口容量，如果连续吃，那么每一天的胃口容量都是前一天的$\frac{2}{3}$,但是如果他休息一天，那么他后一天的胃口就是他之前那一天的胃口(休息的前一天的胃口)。如果他休息2天，那么胃口容量就恢复初始值。同时，每天的食物量也有一个限制的数字，求这个人最多能吃多少东西 做法：dp，$f[i][j]$表示在第$i$天时，这个人已经连续吃了$j$天了，设当日食物限量为$v[i]$,连续吃了$j$天之后的胃口容量为$limit[j]$,那么对于所有的$i$，必然有$f[i][0]=min(v[i],limit[0])$，同时转移方程为：$f[i+1][j+1]=f[i][j]+min(v[i+1],limit[j+1])$，休息1天与2天的同理。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int limit[105],f[105][105],v[105];int main()&#123; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)cin&gt;&gt;v[i]; limit[0]=m; for(i=1;i&lt;105;i++)limit[i]=limit[i-1]*2/3; for(i=1;i&lt;=n;i++)f[i][0]=min(m,v[i]); for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=i;j++)&#123; f[i+1][j+1]=max(f[i+1][j+1],f[i][j]+min(v[i+1],limit[j+1]));//不休息 f[i+2][j]=max(f[i+2][j],f[i][j]+min(v[i+2],limit[j]));//休息1天 f[i+3][0]=max(f[i+3][0],f[i][j]+min(v[i+3],m));//休息2天 &#125; &#125; int ans=0; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=n;j++)&#123; ans=max(ans,f[i][j]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; J-Workout for a Dumbbell一个看起来很复杂很麻烦事实上考虑清楚之后也不是特别复杂的题目 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct machine&#123; int work,rest,lasttime; //lasttime last start int jimwork,jimrest;&#125; mac[15];int ac(machine &amp;mac,int lasttime)&#123; //ret:end time int ret; if (lasttime&lt;mac.lasttime)&#123; // zhi jie kai shi (ta hai mei kai shi) ret=lasttime+mac.jimwork+mac.jimrest; mac.lasttime=max(mac.lasttime,lasttime+mac.jimwork); &#125; else &#123; mac.lasttime=(lasttime-mac.lasttime)/(mac.work+mac.rest)*(mac.work+mac.rest)+mac.lasttime; int mod=(lasttime-mac.lasttime)%(mac.work+mac.rest); if (mod&lt;mac.work)&#123; // deng dai jie shu ret=mac.lasttime+mac.work+mac.jimwork+mac.jimrest; mac.lasttime=max(mac.lasttime+mac.work+mac.jimwork,mac.lasttime+mac.rest+mac.work); &#125; else &#123; // zhi jie kai shi ret=lasttime+mac.jimwork+mac.jimrest; mac.lasttime=max(mac.lasttime+mac.work+mac.rest,lasttime+mac.jimwork); &#125; &#125; return ret;&#125;int main()&#123; for (int i=1;i&lt;=10;i++)&#123; cin&gt;&gt;mac[i].jimwork&gt;&gt;mac[i].jimrest; &#125; for (int i=1;i&lt;=10;i++)&#123; cin&gt;&gt;mac[i].work&gt;&gt;mac[i].rest&gt;&gt;mac[i].lasttime; &#125; int lasttime=0; for (int i=1;i&lt;=3;i++)&#123; for (int j=1;j&lt;=10;j++)&#123; lasttime=ac(mac[j],lasttime); //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;lasttime&lt;&lt;' '&lt;&lt;mac[j].lasttime&lt;&lt;endl; &#125; &#125; cout&lt;&lt;lasttime-mac[10].jimrest; return 0;&#125;]]></content>
      <categories>
        <category>乱七八糟的比赛</category>
        <category>组队训练</category>
        <category>区域赛训练</category>
      </categories>
      <tags>
        <tag>乱七八糟的比赛</tag>
        <tag>组队训练</tag>
        <tag>区域赛训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPP正则表达式]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FCPP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式中的通配符例如：\d匹配任意数字，也就说\d可以匹配0，也可以匹配1，还有2，3，…9都可以匹配。 \d 匹配一个数字，也就是匹配0-9\w匹配单词字符，也就是匹配a-z和A-Z还有’_’。\s匹配空白字符（空格）。\b匹配单词边界（匹配位置而不是实际的字符，边界可以是符号或空格）. 匹配任意字符 正则表达式中的量词？ 匹配前面的字符0次或1次* 匹配前面的字符0次或多次+ 匹配前面的字符1次或者多次{m} 匹配前面表达式m次{m,} 匹配前面表达式至少m次{,n} 匹配前面的正则表达式最多n次{m,n} 匹配前面的正则表达式至少m次，最多n次例子：“abc+”可以匹配abc, abcc, abccc, abcccc, abccccc，以此类推。“yts*”可以匹配 yt, yts, ytss, ytsss, ytsss“y{1,5}”可以匹配 y, yy, yyy, yyyy, yyyyy. 转义字符当想要匹配一些上面的通配符或者量词中的符号时，就需要用到转义字符例如：既然’+’在正则表达式中是一个量词，那么如何让正则表达式匹配加号呢？\+表示匹配一个加号，类似的\？匹配一个问号，\. 匹配一个句点 原始字符串在C++11中原始字符串具有如下的形式：R”(data)”具体来说，以大写字母R开头，后面是一个引号对和一个小括号对，在小括号中的内容才是字符串的正真内容，其中的内容不会反生转义。也就是说R”(\n)”就是字符串\n，而不是换行符。因此，如果在原始字符串中想要匹配一些诸如?这样的符号的时候，就必须使用/?我们在写正则表达式的时候一定要用原始字符串！ regex_replace在regex头文件还定义了一个regex_replace函数，用来进行正则表达式的替换。regex_replace(string data, regex re, string new_string);功能是将data中满足正则表达式re的所有位置替换成new_string，返回替换后的字符串。注意：regex_replace不会修改输入字符串，它会创建一个新的字符串进行替换后返回。 两道来自$c^4$的例题： 题意：从左到右扫描输入的句子：如果句子中有超过 3 个连续的 6，则将这串连续的 6 替换成 9；但如果有超过 9 个连续的 6，则将这串连续的 6 替换成 27。其他内容不受影响，原样输出。 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; getline(cin,str); str=regex_replace(str,regex(R"(6&#123;10,&#125;)"),"27");//匹配10个9或以上 str=regex_replace(str,regex(R"(6&#123;4,9&#125;)"),"9"); cout&lt;&lt;str&lt;&lt;endl; return 0;&#125; 本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：无论用户说什么，首先把对方说的话在一行中原样打印出来；消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格把行首尾的空格全部删掉把标点符号前面的空格删掉；把原文中所有大写英文字母变成小写，除了 I；把原文中所有独立的 can you、could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词；把原文中所有独立的 I 和 me 换成 you；把原文中所有的问号？换成惊叹号 !；在一行中输出替换后的句子作为 AI 的回答。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n;string str; cin&gt;&gt;n;getline(cin,str); while(n--)&#123; getline(cin,str); cout&lt;&lt;str&lt;&lt;endl; str=regex_replace(str,regex(R"(\s+)")," ");//处理多个空格 if(str.back()==' ')str.pop_back(); if(str.front()==' ')str.erase(str.begin());//处理行末行首空格 str=regex_replace(str,regex(R"( !)"), "!"); str=regex_replace(str,regex(R"( ,)"), ","); str=regex_replace(str,regex(R"( \.)"), "."); str=regex_replace(str,regex(R"( \?)"), "?"); str=regex_replace(str,regex(R"( ')"), "'");//处理符号前的空格 for(auto &amp;a:str) a=(a=='I'?'I':tolower(a)); str=regex_replace(str,regex(R"(\bcan you\b)"),"_I can"); str=regex_replace(str,regex(R"(\bcould you\b)"),"_I could");//处理can you,因为后面还要处理I所以都替换成_I str=regex_replace(str,regex(R"(\bI\b)"),"you"); str=regex_replace(str,regex(R"(\bme\b)"),"you"); str=regex_replace(str,regex(R"(\?)"),"!"); str=regex_replace(str,regex(R"(_I)"),"I");//替换_I cout&lt;&lt;"AI: "&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO类]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FIO%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[IO类IO对象不能拷贝或者被赋值例子：1234ofstream out1,out2;out1=out2;//error!不能对流对象赋值ofstream print(ofstream);//错误，不能初始化ofstream参数out2=print(out2);//错误：不能拷贝流对象 因为不能拷贝流对象，所以也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，所以传递和返回的引用不能是const的。 条件状态（存疑）12345strm::iostate //一种机器相关类型，提供表达条件状态的完整功能strm::badbit //指出流已崩溃strm::failbit //指出一个IO操作失败了strm::eofbit //指出流到达了文件结束strm::goodbit //指出流未处于错误状态 一些对应函数：1234s.eof(); //若eofbit置位，返回trues.fail(); //若failbit或badbit置位，返回trues.bad(); //若badbit置位，返回trues.good(); //若流处于有效状态，返回true 刷新缓冲区的几种方式123cout&lt;&lt;"HI"&lt;&lt;endl; //输出一个换行后刷新缓冲区cout&lt;&lt;"HI"&lt;&lt;flush; //输出后刷新，不添加额外字符cout&lt;&lt;"HI"&lt;&lt;ends; //输出一个空字符，然后刷新 输入输出流的关联当一个输入流被关联到一个输出流时，任何从输入流读取数据的操作都会先刷新关联的输出流，例如：标准库将cin与cout关联在一起。 tie有2个重载的版本，一个版本不带参数，返回指向输出流的指针，如果本对象目前关联到一个输出流，那么输出的就是指向这个流的指针。若对象没关联则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream（istream与ostream皆可进行关联操作）。 例如：123cin.tie(&amp;cout);//cin关联到coutostream *old_tie=cin.tie(nullptr);//old_tie指向当前cin关联的流（如果有），同时cin不再关联其他流cin.tie(old_tie);//重建cin与cout的关联 文件输入输出头文件fstream中包含三个类型用来支持文件IO：ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，fstream可以读写给定文件。 （其余待进一步理解（ string流sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据。istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可以读也可以写。 stringstream特有的操作1234sstream strm; //strm是一个未绑定的stringstream对象，sstream是头文件sstream中定义的一个类型sstream strm(s); //strm是一个sstream对象，保存string s的一个拷贝strm.str(); //返回strm所保存的string的拷贝strm.str(s); //将string s拷贝到strm中，返回void 使用istringstream例子：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;struct PersonInfo&#123; string name; vector&lt;string&gt;phone;&#125;;int main()&#123; string line,word; vector&lt;PersonInfo&gt;people; while(getline(cin,line))&#123; PersonInfo info; istringstream record(line);//似乎使用stringstream也可以 record&gt;&gt;info.name; while(record&gt;&gt;word) info.phone.push_back(word); people.push_back(info); &#125; return 0;&#125;/*morgan 312342234 452423424drew 32321321 537648658lee 8983888898 88809099 9090909909 999900909 */ 使用ostringstream接着上面的例子，现在的例子如下：12345678910for(const auto &amp;a:people)&#123; ostringstream t1,t2;//同样可以使用stringstream t1&lt;&lt;a.name; for(const auto &amp;b:a.phone)&#123; t1&lt;&lt;' '&lt;&lt;b; &#125; if(!t1.str().empty()) cout&lt;&lt;t1.str()&lt;&lt;endl; else cerr&lt;&lt;"input error!"&lt;&lt;a.name&lt;&lt;endl; &#125;]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串与向量]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%90%91%E9%87%8F%2F</url>
    <content type="text"><![CDATA[string初始化string的一些方法：123string s3="hiya";//s3是字面值的副本string s4(10,'c');//s4的内容是cccccccccccstring s2(s1);//s2是s1的副本 使用=执行的是拷贝初始化，而反之则是直接初始化。 getline函数的参数是一个输入流和一个string对象，函数从输入流中读取直到遇到换行符为止（换行符也被读入），但是string中不会存换行符。 string.size()函数返回的是一个string::size_type类型的值，这个值是无符号整形数，因此不能直接与一个带负值的int作比较，例如s.size()&lt;n这样，因为负值n会自动转换为一个比较大的无符号值，结果肯定是true. string比较大小按照大小写敏感的字典序比较；2个注意点：1.如果2个string对象长度不同且较短的对象的每个字符都与较长的string对应位置相等的话，那么较短的string小于较长的string。2.如果2个字符串不完全相同，那么比较的结果其实是第一对相异字符的比较结果。 注意：字符串字面值与string并不是同一种类型！因此当把string对象与字符/字符串字面值混在一个语句中使用时，应该保证+左右两侧至少有一个是string。例如：1234string s3=s1+','+s2+'\n';string s5="hello"+",";//错误string s6=s1+","+"world";//正确，左边两个先相加依然是一个stringstring s7="hello"+","+s2;//错误！左边两个都不是string vectorvector初始化的几种方法：12345vector&lt;T&gt;v2(v1);//v2有v1中所有元素的副本Vector&lt;T&gt;v2=v1;vector&lt;T&gt;v3(n,val);//v3包含了n个重复元素，每个都是valvector&lt;T&gt;v4(n);//v4包含了n个重复的执行了默认值初始化的对象，一般来说int为0，string为空vector&lt;T&gt;v5&#123;a,b,c,d,e...&#125;;//列表初始化，注意一定要使用花括号 通过圆括号与花括号的区别区分初始化的意义例子：1234vector&lt;int&gt;v1(10);//v1有10个元素，每个的值都是0vector&lt;int&gt;v2&#123;10&#125;;//v2有一个元素，该元素值为10vector&lt;int&gt;v3(10,1);//v3有10个元素，每个值都为1vector&lt;int&gt;v4&#123;10,1&#125;;//v4有2个元素，分别为10，1 一般来说，花括号就意味着列表初始化，但是如果确认了无法执行列表初始化以后，编译器就会尝试用默认值初始化vector对象。例如：1vector&lt;string&gt;v7&#123;10&#125;;//v7有10个默认初始化的元素 vector对象的下标运算符可用于访问已存在的元素而不能用来添加元素使用了迭代器的循环体，都不要向迭代器所属容器添加元素，否则会造成迭代器失效！]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ICPC沈阳现场赛模拟]]></title>
    <url>%2F%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%AF%94%E8%B5%9B%2F%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%2F%E5%8C%BA%E5%9F%9F%E8%B5%9B%E8%AE%AD%E7%BB%83%2F2018ICPC%E6%B2%88%E9%98%B3%E7%8E%B0%E5%9C%BA%E8%B5%9B%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[J. How Much Memory Your Code Is Using?大意：对一堆变量声明进行扫描然后计算占用的空间。 一道签到题，注意考虑周全即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int findlb(string &amp;b)&#123; for(int i=0;i&lt;b.length();i++)&#123; if(b[i]=='[')return i; &#125; return -1;&#125;int fbyte(string &amp;b)&#123; // cout &lt;&lt; b&lt;&lt;endl; if(b[0]=='b')&#123; return 1; &#125; if(b[0]=='c')&#123; return 1; &#125; if(b[0]=='i')&#123; return 4; &#125; if(b[0]=='_')&#123; return 16; &#125; if(b[0]=='f')&#123; return 4; &#125; if(b[0]=='d')&#123; return 8; &#125; if(b[0]=='l')&#123; if(b[5]=='d')&#123; return 16; &#125;else&#123; return 8; &#125; &#125; return -1;&#125;int farr(string &amp;b)&#123; if(b[b.length()-2]!=']')return 1; int x=findlb(b) + 1,res=0; for(int i=x;i&lt;b.length()-2;i++)&#123; res=res*10+b[i]-'0'; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(false); int T,n,gt,arrl; cin&gt;&gt;T; string l,a,b; for(int i=1;i&lt;=T;i++)&#123; cin&gt;&gt;n; int res=0; getline(cin,l); for(int i=1;i&lt;=n;i++)&#123; getline(cin,l); gt = fbyte(l); arrl = farr(l); res+=gt*arrl; // cout &lt;&lt; gt &lt;&lt;" "&lt;&lt;arrl&lt;&lt;endl; &#125; res = res/1024 + ((res%1024)&gt;0); cout&lt;&lt;"Case #"&lt;&lt;i&lt;&lt;": " &lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; C. Insertion Sort大意：给定一个$n$，然后问对于所有1~n这n个数的排列中，有多少个排列在把那个排列的前k项从小到大拍好之后，排列中的最长上升子序列的长度$\geq n-1$，要取模。 挺玄学的一道题…看起来要么打表找规律要么玄学推公式… 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,k,q; int t; cin&gt;&gt;t; for (int i=1;i&lt;=t;i++)&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;q; if (k&gt;n)k=n; long long temp = k*(n-k)+(n-k)*(n-k-1)+1; for (int i=1;i&lt;=k;i++)&#123; temp *=i; temp %=q; &#125; int k = temp; printf ("Case #%d: %d\n",i,k); &#125;&#125; G. Best ACMer Solves the Hardest Problem大意：6000x6000的平面上有n个点，每个点有点权。m次操作。操作1：插入一个点。操作2：删除一个点。操作3：给出一个圆心(x,y)，半径为sqrt(k)的圆，当前圆上存在的点，点权+w。操作4：询问圆心(x,y)，半径为sqrt(k)的圆，当前圆上存在的点的点权和。强制在线。 由于题目给的都是整数点，在圆上的整数格点很少，所以对于操作3和操作4暴力枚举圆上的整数点即可。 那么先预处理出所有的$a^2 +b^2=c^2$，对应每个$c^2$，把符合条件的$(a,b)$存到vector里。 对于操作3和4，即$(x-x_0)^2+(y-y_0)^2=k$，展开$|x-x_0|$和$|y-y_0|$的绝对值，判断存不存在$(x_0,y_0)$即可。 实现中因为c可能会对应一些特别的a，b的情况，比如a=0，这样往4个方向展开的$|x-x_0|$可能会一样导致点重复，因此应当查重，代码中用set去重。 再就是每次初始化都memset会tle，因此要用时间戳。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;typedef pair&lt;int,int&gt;P;typedef long long ll;vector&lt;P&gt;yc[maxn];vector&lt;P&gt;clear;//时间戳ll lastans;void init(void)&#123; int i,j,k; for(i=0;i&lt;=6000;i++)&#123;//此处一定要从0开始！否则k=1这种情况就会被忽略 for(j=0;j&lt;=6000;j++)&#123; if(i*i+j*j&lt;=maxn-10) yc[i*i+j*j].push_back(P(i,j)); else break; &#125; &#125;&#125;bool judge(int x,int y)&#123; if(x&lt;0||x&gt;6000||y&lt;0||y&gt;6000)//判定边界 return false; return true;&#125;void change(int &amp;x,int &amp;y)&#123; x=(x+lastans)%6000+1; y=(y+lastans)%6000+1;&#125;bool exist[6005][6005];int W[6005][6005];int move1[4][2]=&#123;1,-1,1,1,-1,1,-1,-1&#125;;int main()&#123; int n,m,i,j,k,T,x,y,w; init(); cin&gt;&gt;T; int cnt=0; while(T--)&#123; cnt++;printf("Case #%d:\n",cnt);lastans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); exist[x][y]=true;W[x][y]=w;clear.push_back(P(x,y)); &#125; int opt; for(i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y);change(x,y); if(opt==1)&#123; scanf("%d",&amp;w);exist[x][y]=true; W[x][y]=w;clear.push_back(P(x,y)); &#125; else if(opt==2)&#123; exist[x][y]=false;W[x][y]=0; &#125; else if(opt==3)&#123; scanf("%d%d",&amp;k,&amp;w); set&lt;P&gt;s;//set去重 for(auto a:yc[k])&#123; for(j=0;j&lt;4;j++)&#123; int xx=x+move1[j][0]*a.first; int yy=y+move1[j][1]*a.second; if(!judge(xx,yy))continue; if(exist[xx][yy])s.insert(P(xx,yy)); &#125; &#125; for(auto a:s)W[a.first][a.second]+=w; &#125; else&#123; scanf("%d",&amp;k); set&lt;P&gt;s; for(auto a:yc[k])&#123; for(j=0;j&lt;4;j++)&#123; int xx=x+move1[j][0]*a.first; int yy=y+move1[j][1]*a.second; if(!judge(xx,yy))continue; if(exist[xx][yy])s.insert(P(xx,yy)); &#125; &#125; ll ans=0; for(auto a:s)ans+=W[a.first][a.second]; printf("%lld\n",ans); lastans=ans; &#125; &#125; for(auto a:clear)&#123; exist[a.first][a.second]=false; W[a.first][a.second]=0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>乱七八糟的比赛</category>
        <category>组队训练</category>
        <category>区域赛训练</category>
      </categories>
      <tags>
        <tag>乱七八糟的比赛</tag>
        <tag>组队训练</tag>
        <tag>区域赛训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左值引用，const限定符与类型]]></title>
    <url>%2FCpp%E8%AF%AD%E6%B3%95%2FCpp%2F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%2Fconst%2F%E7%B1%BB%E5%9E%8B-auto%2Fdecltype%2F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8Cconst%E9%99%90%E5%AE%9A%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引用 这里的引用指左值引用而不是C++11中的右值引用 引用为对象起了一个别名。注意：引用并不是对象，它只是为一个已经存在的对象所起的另外一个名字。 因为引用不是一个对象，所以不能定义引用的引用！ 为引用赋值，实际上是把值赋给了引用绑定的对象，获取引用的值，其实也是获取了引用绑定对象的值。 引用的类型必须和要绑定的对象严格匹配（比如int类型的引用不能绑定在double上），但是有2个例外。而且引用只能绑定在对象上而不能与字面值或者某个表达式的计算结果绑定在一起。 在定义引用时，程序把引用跟它的初始值绑定在一起（而不是拷贝），无法令引用绑定到另一个对象，所以引用定义时必须被初始化。 constconst对象一旦创造就不能再更改，所以const对象必须被初始化； 默认情况下const对象被设定为仅在文件内有效，当多个文件内出现同名的const变量时相当于在不同文件中分别定义了独立变量；如果要在多个文件中使用同一个const变量，那么它的声明与定义都应该加上extern关键字（存疑）； const的引用可以把引用绑定到const对象上，就像绑定到其他对象上一样，称之为对常量的引用。对常量的引用并不能修改它绑定的对象，同时，非常量引用也不能绑定到常量对象上；例如：123const int ci=1024;const int &amp;ri=ci;//正确,引用及其对应对象都是常量int &amp;r2=ci;//错误,试图用一个非常量引用指向一个常量对象 “对const的引用”简称为“常量引用”。 之前提到过： 引用的类型必须和要绑定的对象严格匹配（比如int类型的引用不能绑定在double上），但是有2个例外。 其中一个例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可。允许为一个常量引用绑定非常量的对象，字面值甚至一个一般表达式。例如：12345int i=42;const int &amp;r1=i;//正确const int &amp;r2=42;//correctconst int &amp;r3=r1*2//correctint &amp;r4=r1*2;//错误！非常量引用不允许这么搞！ 甚至可以这么搞：123double a=1.22;const int &amp;ri=a;cout&lt;&lt;ri&lt;&lt;endl; 这种情况下ri其实是绑定了一个由a转换而来的临时的int类型的变量。 注意：对const的引用可能引用一个并非const的对象其实就是，只有常量引用可以绑定到常量对象上，但是常量引用也可以绑定到非常量对象上，此时可以通过其他途径修改非常量对象的值。例子：12345int i=42;int &amp;r1=i;const int &amp;r2=i;//并不能通过让r2修改i的值r1=0;//correctr2=0;//illegal! 指针和const指向常量的指针（pointer to const）不能用于改变其所指向对象的值，要想存放常量对象的地址，只能使用指向常量的指针。但是，可以改变指针指向的地址。例子：1234const double pi=3.14;double *ptr=&amp;pi;//illegal!ptr是普通指针const double *cptr=&amp;pi;//correct!*cptr=42;//illegal! 和常量引用一样，指向常量的指针也没用规定其所指的对象必须是一个常量，所谓指向常量的指针只是要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变（如果指向的对象是非常量当然可以更改它的值）。 指针本身是一个对象，因此也可以定义常量指针（const pointer）。常量指针必须初始化，并且一旦初始化完成，它的值也就是存放在指针中的那个地址就不能再改变了。把* 放在const关键字之前用以说明指针是一个常量，即不变的是指针本身的值而不是指向的那个值。例子：1234int errnumb=0;int *const curErr=&amp;errnum;//常量指针curErr将一直指向errnumconst double pi=3,1415;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针 指针本身是常量并不意味着不能通过指针去修改所指对象的值（可以通过非常量指针修改该对象的值）。 指针本身是不常量以及指向的对象是不是常量是两个相互独立的问题。 常量表达式与constexpr常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。如果一个对象是const型但是对象的值要到运行时才能获取（比如一个非常量函数的返回值），那么它也不是常量表达式。 在C++11中，允许将变量声明为constexpr类型然后由编译器来验证变量的值是否是一个常量表达式。声明constexpr时用到的类型称为“字面值类型”，它们可以是算术类型，引用和指针。 指针与引用都可以被声明为constexpr类型，但是指针的初始值必须是nullptr或者0或者是存储于某个固定地址中的对象。 注意区分：123const int *p=nullptr;//p是一个指向整形常量的指针constexpr int *q=nullptr;//q是一个指向整数的常量指针（类似于*const)constexpr const int *p=nullptr;//指向整形常量的常量指针 于其他常量指针类似，constexpr既可以指向常量又可以指向一个非常量。 类型类型别名有两种方式可以定义类型别名。 typedef例如typedef double wages; using新标准规定的一种新的方法，使用别名声明来定义类型的别名例如：12using db=double;db a=1.22; 作用是把等号左侧的名字规定成等号右侧类型的别名。类型别名和类型的名字等价，只要类型的名字能出现的地方，都可以使用类型别名。 请注意以下情况：123typedef char *pstring;const pstring cstr=nullptr;//cstr是是指向char的常量指针const char *cstr1=0; 注意两个声明是不同的！pstring实际上是指向char的指针，因此const pstring就是指向char的常量指针（类似于*const)，而后面那个则是指向const char 的指针（指向常量的指针）。 autoauto定义的变量必须有初始值（不然编译器怎么推断是什么类型233）同一条声明语句中可以有多个auto变量，但是变量的初始基本数据类型必须一样，例如：12auto i=0,*p=&amp;i;//正确，一个是整数，一个是整数指针auto sz=0,pi=3.14;//错误，类型不一致 注意，符号&amp;和*只从属于某个声明符，不影响基本数据类型，但是int和const int并不是同一种基本数据类型！！ 当auto遇到const类型时，一般会忽略顶层const而保留底层的const。顶层const：指针本身是一个常量底层const：指针所指对象是一个常量例如：12345const int ci=i,&amp;cr=ci;auto b=ci;//b是一个整数,顶层const特性忽略auto c=cr;//c是一个整数auto d=&amp;i;//d是一个整形指针auto e=&amp;ci;//e是一个指向整数常量的指针（对常量对象取地址是一种底层const） 如果希望推导出的auto类型是一个顶层const，需要明确指出：1const auto f=ci; 也可以将引用的类型设置为auto，原本的初始化规则依然适用：123auto &amp;g=ci;auto &amp;h=42;//错误，非常量引用不能绑定字面值const auto &amp;j=42;//correct decltypedecltype的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，但是并不计算表达式的具体值。例子：12345678910int f(void)&#123; return 1;&#125;decltype(f())sum=2;//sum的类型就是函数f的返回类型const int ci=0,&amp;cj=ci;decltype(ci)x=0;//x的类型是const intdecltype(cj)y=x;//y的类型是const int&amp;，y绑定到xdecltype(cj)z;//错误！z是一个引用，必须被初始化 上述例子中也可以看到decltype处理顶层const和引用的方式与auto不同，如果decltype使用的表达式是一个变量，那么decltype返回该变量的类型（包括顶层const和引用在内） 注意：decltype((variable))（两个括号或者以上）的结果永远是返回一个引用，而decltype(variable)结果只有在变量本身是引用时才会返回一个引用。 一些其他例子：123int i=42,*p=&amp;i,&amp;r=i;decltype(r+0)b;//correct,加法结果是int，b是一个未初始化的intdecltype(*p)c;//illegal! c是&amp;int，必须初始化！]]></content>
      <categories>
        <category>Cpp语法</category>
        <category>Cpp</category>
        <category>左值引用</category>
        <category>const</category>
        <category>类型/auto</category>
        <category>decltype</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
        <tag>左值引用</tag>
        <tag>const</tag>
        <tag>类型/auto</tag>
        <tag>decltype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp阅读笔记-类]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FCPP%E7%B1%BB%2FCpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类的基本概念首先是一段自定义类的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;class Screen&#123;public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; string pr()const; Screen &amp;move(pos r,pos c); void move(pos r,pos c,int sit); Screen &amp;set(char); Screen &amp;set(pos,pos,char); Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125; const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; friend class window_mgr; //friend void window_mgr::clear(Screenindex);private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125;&#125;;Screen &amp;Screen::move(pos r,pos c)&#123; pos row=r*width; cursor=row+c; return *this;&#125;void Screen::move(pos r,pos c,int sit)&#123; pos row=r*width; cursor=row+c; //return *this;&#125;char Screen::get(pos r,pos c)const&#123; pos row=r*width; return contents[row+c];&#125;Screen &amp;Screen::set(char c)&#123; contents[cursor]=c; return *this;&#125;Screen &amp;Screen::set(pos r,pos col,char ch)&#123; contents[r*width+col]=ch; return *this;&#125;string Screen::pr() const &#123; return contents;&#125;class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;;void window_mgr::clear(window_mgr::Screenindex i)&#123; Screen &amp;s=screens[i]; s.contents.clear();&#125;window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s)&#123; screens.push_back(s); return screens.size()-1;&#125;int main()&#123; int x=10; Screen screen1; Screen screen2(10, 10, 'a');screen2.sit=3; cout&lt;&lt;screen1.sit&lt;&lt;endl; //screen1.move(2,3); screen1.move(2,3,1); screen1.move(3,4).sit=screen2.sit;// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; screen1.getH() &lt;&lt; endl;// cout&lt;&lt;screen1.sit&lt;&lt;endl; screen2.set(5,5,'d');// cout&lt;&lt;screen2.get(5,5)&lt;&lt;endl;// cout&lt;&lt;screen2.pr()&lt;&lt;endl; screen2 .display(cout); window_mgr w1; // w1.screens[0].display(cout); w1.clear(0); return 0;&#125; 成员函数（类似Screen1.set()这种）的声明必须在类的内部，定义则可以在类内部也可以在类外部。而接口组成部分的函数或者说只是使用了类的函数，比如说用两个类作为自己的参数的函数，声明和定义都在类外部 this实例函数：std::string isbn() const{return bookNo;} 成员函数通过名为this的隐式参数来访问调用它的那个对象。例如，如果调用total.isbn()，编译器会把total的地址传递给isbn的隐式形参this，相当于Sales_data::isbn(&amp;total) this形参是隐式定义的，任何自定义名为this的参数或变量的行为都是非法的，我们可以在成员函数体内部使用this，虽然没有必要。例：isbn还能如下定义：std::string isbn() const{return this-&gt;bookNo;} isbn函数参数列表后的const的作用是修改this指针的类型，默认情况下，this的类型是指向类类型的非常量版本的常量指针。这就意味着在默认情况下我们不能把this绑定在一个常量对象上。 类作用域和成员函数编译器处理类时， 首先编译成员声明，然后才轮到成员函数体（如果有的话）因此，成员函数体可以随意使用类中的其他成员函数而不必在意这些成员出现的先后顺序（即使出现在函数声明之后也没有问题）。 作用域运算符：类似于Sales_data::avg_price这样的：：，说明了以下事实：有一个名为avg_price的函数，并且该函数被声明在类Sales_data的作用域内。 关于函数引用IO类型作为参数IO类属于不能被拷贝的类型，因此只能通过引用来传递他们。 构造函数构造函数的名称与类的名称相同只要类的对象被创造，就会执行构造函数。注意：构造函数没有返回类型一个类可以包含多个构造函数，和其他重载函数类似。但是，构造函数不能被声明成const的。 如果一个类没有显式定义构造函数，那么编译器就会隐式地指定一个默认构造函数（即合成的默认构造函数），一般来说，容器都为空，数据都为0，bool都为false。在C++11中，如果需要默认行为，可以在参数列表后写上=default来要求编译器生成默认构造函数 构造函数举例：12Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;Sales_data(const std::string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125; 冒号与花括号之间的部分称为构造函数初始值列表，它负责为新创建对象的一个或者几个数据成员赋值。如果有数据成员被初始化列表所忽略，那么它将被以与默认构造函数相同的方式隐式初始化。 注意：上面的函数中的函数体中还可以执行其他的任务或空置。 一般来说，初始化函数中成员初始化的顺序没什么关系，但是如果涉及到用一个成员去初始化另一个成员时，就有关系了。比如说：123456class X&#123; int i; int j;public: X(int val):j(val),i(j)&#123;&#125;//这是错误的，因为i在j之前被初始化 &#125;； 在上面这个类的构造函数中，i先被初始化，j接着才被初始化，因此会出错！ 拷贝，赋值和析构通俗来说，一个类的对象可以直接被赋予另一个对象的值，例如total=trans,其中total跟trans都是类对象。但是，管理动态内存的类通常不能这么做。不过使用vector跟string的类并不受此影响。 访问控制与封装访问说明符：public与private定义在private之后的成员可以被类的成员函数以及友元访问，但不能被使用该类的函数访问。注意，struct默认为public，class默认为private 友元类可以把其他的类定义为友元，也可以把其他类的成员函数定义为友元；类可以允许其他类或者函数访问他的private成员，只要给其他类或者函数加上friend（友元）的声明即可。 例如：1234567891011121314151617181920212223242526272829class Screen&#123;public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; friend class window_mgr;//将window_mgr声明为Screen的友元 //friend void window_mgr::clear(Screenindex);private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125;&#125;;class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;; 这样一来，window_mgr就可以访问Screen类的私有数据成员了。友元声明只能出现在类的内部，但是类内部出现的具体位置不限友元的声明仅仅提供了一个访问权限，要想真的使用这个函数，在类的外部需要再专门声明一次友元关系不具有传递性如果将一个其他类的成员函数声明为当前类的友元函数，那么这个函数必须已经被定义；但是如果是将其他一个类声明为友元，那么这个类只需要被声明即可如果把一组重载函数声明为友元，那么每一个函数都必须声明一次友元函数可以定义在类内部，但是必须在类的外部声明使得函数可见 类的其他特性（类成员）除了定义数据和函数成员以外，类还可以自定义某种类型在类中的别名，由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。 和非成员函数一样，成员函数也可以被重载，只要函数之间在参数数量或者类型上有所区别即可。 类数据成员的初始值可以给类的数据成员添加一个默认的初始值12345678class window_mgr&#123;public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;);private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;;&#125;; 返回*this的成员函数12345Screen &amp;Screen::set(pos r,pos col,char ch)&#123; contents[r*width+col]=ch; return *this;&#125; 返回引用的函数是左值的，（通过函数名前面的&amp;符号来体现）意味着这些函数返回的是对象本身而不是对象的副本；如果这个函数不是左值的，那么返回的数据只是函数中调用对象的一个copy；举个例子，如果有这么一系列操作：myscreen.move(4,0).set(&#39;#&#39;);这些操作会在同一个对象上执行，因为move() 和set()函数都是左值的；也就是说，这个函数等价于myscreen.move(4,0);myscreen.set(&#39;#&#39;); 如果move() 和set()函数不是左值的，那么上述语句将会变成：Screen temp=myscreen.move(4,0);temp,set(&#39;#&#39;);也就是说，第2步并不会改变原来myscreen中的contents（内容）； 注意：一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用，也就是一个常量 基于const的重载通过区分成员函数是否是const的，我们也可以对其进行重载例如：123456Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125;const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; 当我们在某个对象上调用display函数时，该对象是否是const决定了应该调用display的哪个版本；例如：1234Screen myscreen(5,3);const Screen blank(5,3);myscreen.set('#').display(cout);//调用非常量版本blank.display(cout);//调用常量版本 类类型注意：即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类而言，它的成员和其他任何类的成员都是不一样的。 类的声明我们可以仅声明类而暂时不定义它；这就是所谓的前向声明，在声明之后定义之前的类型被称为不完全类型； 不完全类型只能在非常有限的场景下使用：可以定义指向这种类型的指针和引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数； 对于一个类而言，我们在创造它的对象之前必须将其定义（不然编译器哪知道怎么初始化233）。但是一个类一旦名字出现后，它就被认为是声明过了，因此类允许包含指向它自身类型的引用或指针。 类的作用域 对于一条函数定义，一旦遇到了类名，定义的剩余部分就在类的作用域之内了。因此在参数列表和函数体内就可以直接使用成员函数而不必再次声明了； 同时，函数的返回类型通常出现在函数名之前，因此如果成员函数的定义在类的外部时，返回类型就必须指明它是哪个类的成员例如:12345window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s)&#123; screens.push_back(s); return screens.size()-1;&#125; 编译器处理完类中的全部声明后才会处理成员函数的定义；因此函数可以使用类定义中的任何名字。 成员函数查找名字采取以下方式： 首先，在类内部成员函数之前查找该名字的声明； 其次，如果没有找到，则在类内部的其他地方继续查找； 最后，如果整个类都没有这个名字的声明，那么在成员函数定义之前的作用域内进行查找； 如果在成员函数内需要用到外层作用域内的名字，可以显性地使用作用域运算符来体现； 聚合类当一个类满足下列条件时，它是聚合的： 所有成员都是public的； 没有定义任何构造函数； 没有类内初始值； 聚合类的一大特点是可以用一个花括号括起来的成员初始值列表进行初始化；例如：12345struct Data&#123; int ival;string s; &#125;; Data val=&#123;0,"Anna"&#125;; 注意：初始值的顺序必须与声明顺序一致 类的静态成员在类的成员声明之前加上static使得它可以与类关联在一起，称为静态成员。静态成员可以是public或者private的，类型可以是常量，引用，指针，类类型等。类的静态成员独立于任何对象之外。例如：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;public: void calculate()&#123;amount+=amount*interestrate;&#125; double rate()&#123;return interestrate;&#125; static void rate(double);private: std::string owner; double amount; static constexpr double interestrate=6; static double initrate();&#125;;//double Account::interestrate=5;//void Account::rate(double newrate1)//&#123;// interestrate=newrate1;//&#125;int main()&#123; Account a,b; //a.rate(6.04); cout&lt;&lt;a.rate()&lt;&lt;' '&lt;&lt;b.rate()&lt;&lt;endl; return 0;&#125; 在上面这个例子中，每个Account对象都拥有自己的两个数据成员owner和amount，但是只存在一个interestRate并且被所有Account对象共享，也就是说，当这个值发生变化时，所有对象中的interestrate的值都会变化。 静态成员函数不包含this指针，也不能被声明为const的。 虽然静态成员不属于任何一个对象，但是依然可以使用类的对象、引用和指针来访问静态成员。 对于静态成员函数，也可以在类的外部进行定义，但是不能重复static关键字，也就是说，关键字只能出现在类内部声明的时候。 注意：一般来说，不能在类内部初始化静态成员，必须在类的外部定义和初始化每个静态成员，并且，每个静态数据成员只能定义一次。当然，如果静态成员是字面值常量类型的constexpr，那么我们乐意在类内部提供const整数类型的初始值给静态成员 例如上面那个例子中，如果删去interestRate前面的constexpr,那么就必须在类外部对其进行初始化，如下：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;public: void calculate()&#123;amount+=amount*interestrate;&#125; double rate()&#123;return interestrate;&#125; static void rate(double);private: std::string owner; double amount; static double interestrate;//注意此时就不能在类内部初始化了 static double initrate();&#125;;double Account::interestrate=5;void Account::rate(double newrate1)&#123; interestrate=newrate1;&#125;int main()&#123; Account a,b; //a.rate(6.04); cout&lt;&lt;a.rate()&lt;&lt;' '&lt;&lt;b.rate()&lt;&lt;endl; return 0;&#125; 静态成员还有一个用处就是可以作为成员函数的默认实参。]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cpp语法</category>
        <category>CPP类</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cpp语法</tag>
        <tag>CPP类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本语法]]></title>
    <url>%2FPython%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本语法与运算符注释# 基本数据类型int可以是任何大小的整数 变量名的第一个字符必须是字母或下划线；变量名区分大小写； 使用单/双引号指定字符串，所有引号内的字符，包括空格与制表符都将原样保留。两种引号工作机制相同 输出格式三引号用于指定多行字符串（&quot;&quot;&quot;或&#39;&#39;&#39;均可以）例如：123print('''this is the first lineand this is the secondhhahahah''') 就会原样输出3行 有时候我们会想要从其他信息中构建字符串。这正是 format() 方法大有用武之地的地方。例如：1234age = 20name = 'Swaroop'print('&#123;&#125; was &#123;&#125; years old when he wrote this book'.format(name, age))print('Why is &#123;&#125; playing with that python?'.format(name)) Python 中 format 方法所做的事情便是将每个参数值替换至格式所在的位置。这之中可以有 更详细的格式，例如:123456789# 对于浮点数 '0.333' 保留小数点(.)后三位print('&#123;0:.3f&#125;'.format(1.0/3))# 或者省略花括号里面那个0也是可以的print('&#123;:.3f&#125;'.format(1.0/3))# 使用下划线填充文本，并保持文字处于中间位置# 使用 (^) 定义 '___hello___'字符串长度为 11print('&#123;0:_^11&#125;'.format('hello'))# 基于关键词输出 'Swaroop wrote A Byte of Python'print('&#123;name&#125; wrote &#123;book&#125;'.format(name='Swaroop', book='A Byte of Python')) 由于我们正在讨论格式问题，就要注意 print 总是会以一个不可见的“新一行”字符( \n ) 结尾，因此重复调用 print 将会在相互独立的一行中分别打印。为防止打印过程中出现这一 换行符，你可以通过 end 指定其应以空白结尾:12print('a', end='')print('b', end=' ')#以空格结尾 转义序列 如果希望生成一串包含单引号( ‘ )的字符串，你应该如何指定这串字符串? 例如，你想要的字符串是 “What’s your name?” 。你不能指定 ‘What’s your name?’ ，因为这 会使 Python 对于何处是字符串的开始、何处又是结束而感到困惑。所以，你必须指定这个单引号不代表这串字符串的结尾。这可以通过转义序列(Escape Sequence) 来实现。你通过\ 来指定单引号:要注意它可是反斜杠。现在，你可以将字符串指定为 ‘What\’s your name?’ 另一种指定这一特别的字符串的方式是这样的: “What’s your name?” ，如这个例子般使用 双引号。类似地， 你必须在使用双引号括起的字符串中对字符串内的双引号使用转义序列。 同样，你必须使用转义序列 \ 来指定反斜杠本身。 如果你想指定一串双行字符串该怎么办?一种方式即使用如前所述的三引号字符串，或者你 可以使用一个表示新一行的转义序列——\n 来表示新一行的开始。（与cpp类似） 在一个字符串中，一个放置在末尾的反斜杠表示字符串将在下一行继续，但不会添加新的一行。来看看例子:12"This is the first sentence. \This is the second sentence." 相当于&quot;This is the first sentence. This is the second sentence.&quot; 基础语法所谓物理行(Physical Line)是你在编写程序时 你所看到的内容。所谓逻辑行(Logical Line)是 Python 所看到 的单个语句。Python 会假定每一物理行会对应一个逻辑行。如果你希望在一行物理行中指定多行逻辑行，那么你必须通过使用分号( ; )来明确表明逻辑行或语句的结束。 空白区在 Python 中十分重要。实际上，空白区在各行的开头非常重要。这被称作 缩进 (Indentation)。在逻辑行的开头留下空白区(使用空格或制表符)用以确定各逻辑行的缩 进级别，而后者又可用于确定语句的分组。这意味着放置在一起的语句必须拥有相同的缩进。每一组这样的语句被称为 块(block)。 Attention：使用四个空格来缩进。这是来自 Python 语言官方的建议。好的编辑器会自动为你完成这 一工作。请确保你在缩进中使用数量一致的空格，否则你的程序将不会运行，或引发不 期望的行为。 运算符与优先级需要注意的运算符** (乘方)返回 x 的 y 次方。3**4 输出 81 (即 3 3 3* 3 )。 /(除)x 除以 y13 / 3 输出 4.333333333333333 。 // (整除)x 除以 y 并对结果向下取整至最接近的整数。 13 // 3 输出 4 。-13 // 3 输出 -5 。 &lt; (小于) &gt; (大于)返回 x 是否小于 y。所有的比较运算符返回的结果均为 True 或 False 。请注意这 些名称之中的大写字母。5&lt;3 输出 False ，3&lt;6 输出 True 。比较可以任意组成链接: 3 &lt; 5 &lt; 7 返回 True 。如果两个操作数均为数字，它们首先将会被转换至一种共同的类型。否则，它将总是返回 False 。 not (布尔“非”) 对应cpp的！and (布尔“与”) 对应cpp的&amp;or (布尔“或”) 对应cpp的| 其余运算符与cpp基本一致 优先级以下运算符优先级由低至高排序lambda :Lambda 表达式 if - else :条件表达式 or :布尔“或”and:布尔“与”not x :布尔“非”in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == :比较，包括成员资格测试 (Membership Tests)和身份测试(Identity Tests)。| :按位或^ :按位异或&amp; :按位与&lt;&lt;, &gt;&gt; :移动+, -:加与减*, /, //, %:乘、除、整除、取余+x, -x, ~x :正、负、按位取反** :求幂x[index], x[index:index], x(arguments...), x.attribute :下标、切片、调用、属性引 用(expressions...), [expressions...], {key: value...}{expressions...}:表示绑定或元 组、表示列表、表示字典、表示集合 控制与循环If…else…例子如下，注意缩进:123456789101112131415161718number = 23guess = int(input('Enter an integer : '))if guess == number: # 新块从这里开始 print('Congratulations, you guessed it.') print('(but you do not win any prizes!)') # 新块在这里结束elif guess &lt; number: # 另一代码块 print('No, it is a little higher than that') # 你可以在此做任何你希望在该代码块内进行的事情else: print('No, it is a little lower than that') # 你必须通过猜测一个大于(&gt;)设置数的数字来到达这里。 print('Done')# 这最后一句语句将在# if 语句执行完毕后执行。 Python 中不存在 switch 语句。你可以通过使用 if..elif..else 语句来实现同样的事情 while循环1234567891011121314151617number = 23running = Truewhile running: guess = int(input('Enter an integer : ')) if guess == number: print('Congratulations, you guessed it.') # 这将导致 while 循环中止 running = False elif guess &lt; number: print('No, it is a little higher than that.') else: print('No, it is a little lower than that.')else: print('The while loop is over.') # 在这里你可以做你想做的任何事 print('Done') 注意：你可以在 while 循环中使用 else 从句。 for循环1234for i in range(1, 5): print(i)else: print('The for loop is over') 注意range里面是前闭后开的区间！ else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。 在这里我们所要做的事情是提供两个数字，而 range 将会返回一个数字序列，从第一个数字 开始，至第二个数字结束。举个例子， range(1,5) 将输出序列 [1, 2, 3, 4] 。在默认情况下，range 将会以 1 逐步递增。如果我们向 range 提供第三个数字，则这个数字将成为逐 步递增的加数。 同样举个例子来说明range(1,5,2) 将会输出 [1, 3] 。要记住这一序列扩 展直到第二个数字，也就是说，它不会包括第二个数字在内。 break123456while True: s = input('Enter something : ') if s == 'quit':break print('Length of the string is', len(s))print('Done') 有一点需要尤其注意，如果你 中断 了一个 for 或 while 循环，任何相应循环中的 else块都将不会被执行。 continuecontinue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。123456789while True: s = input('Enter something : ') if s == 'quit': break if len(s) &lt; 3: print('Too small') continueprint('Input is of sufficient length')# 自此处起继续进行其它任何处理 函数函数可以通过关键字 def 来定义。这一关键字后跟一个函数的标识符名称，再跟一对圆括号，其中可以包括一些变量的名称，再以冒号结尾，结束这一行。随后而来的语句块是函数的一部分。12345678910111213def print_max(a, b): if a &gt; b: print(a, 'is maximum') elif a == b: print(a, 'is equal to', b) else:print(b, 'is maximum') # 直接传递字面值print_max(3, 4) x=5y=7# 以参数的形式传递变量print_max(x, y) global语句如果你想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还 是类)，那么你必须告诉 Python 这一变量并非局部的，而是全局(Global)的。我们需要通 过 global 语句来完成这件事。因为在不使用 global 语句的情况下，不可能为一个定义于 函数之外的变量赋值。 说人话就是，Python的函数中如果想用函数外部的变量的话，必须在函数中声明这个变量是global的，不然会在函数内创建一个同名的局部变量，并且局部变量与外部变量并没有什么关系。也就是说，全局变量其实并不是很好用；例子： 声明global的情况：123456789x=50def func(): global x x=10print('x is', x)x=2print('Changed global x to', x)func()print('Value of x is', x) 输出：123x is 50Changed global x to 2Value of x is 10 不声明global的情况：123456789x=50def func(): #global x x=10print('x is', x)x=2print('Changed global x to', x)func()print('Value of x is', x) 输出：123x is 50Changed global x to 2Value of x is 2 默认参数值 对于一些函数来说，你可能为希望使一些参数可选并使用默认的值，以避免用户不想为他们 提供值的情况。默认参数值可以有效帮助解决这一情况。你可以通过在函数定义时附加一个 赋值运算符( = )来为参数指定默认参数值。 要注意到，默认参数值应该是常数。更确切地说，默认参数值应该是不可变的例子：1234def say(message, times=1): print(message * times)say('Hello')say('World', 5) 输出：123$ python function_default.pyHelloWorldWorldWorldWorldWorld 注意! 只有那些位于参数列表末尾的参数才能被赋予默认参数值，意即在函数的参数列表中拥有默认参数值的参数不能位于没有默认参数值的参数之前。这是因为值是按参数所处的位置依次分配的。举例来说，def func(a, b=5) 是有效的， 但 def func(a=5, b) 是无效的。 关键字参数 如果你有一些具有许多参数的函数，而你又希望只对其中的一些进行指定，那么你可以通过 命名它们来给这些参数赋值——这就是关键字参数(Keyword Arguments)——我们使用命名(关键字)而非位置(一直以来我们所使用的方式)来指定函数中的参数。 这样做有两大优点——其一，我们不再需要考虑参数的顺序，函数的使用将更加容易。其二，我们可以只对那些我们希望赋􏰀的参数以赋值，只要其它的参数都具有默认参数值。例子：12345def func(a, b=5, c=10): print('a is', a, 'and b is', b, 'and c is', c)func(3, 7)func(25, c=24)func(c=50, a=100) 输出：1234$ python function_keyword.pya is 3 and b is 7 and c is 10a is 25 and b is 5 and c is 24a is 100 and b is 5 and c is 50 可变参数留空待补 return语句大体与Cpp的类似，例子：12345678def maximum(x, y): if x &gt; y: return x elif x == y: return 'The numbers are equal' else: return yprint(maximum(2, 3)) 要注意到如果 return 语句没有搭配任何一个值则代表着 返回 None 。 None 在 Python 中一 个特殊的类型，代表着虚无。 每一个函数都在其末尾隐含了一句return None ，除非你写了你自己的 return 语句。 Python 中的 pass 语句用于指示一个没有内容的语句块。 DocStrings文档字符串Python 有一个甚是优美的功能称作文档字符串(Documentation Strings)，在称呼它时通常 会使用另一个短一些的名字docstrings。DocStrings 是一款你应当使用的重要工具，它能够帮 助你更好地记录程序并让其更加易于理解。 函数的第一行逻辑行中的字符串是该函数的 文档字符串(DocString)。这里要注意文档字符串也适用于后面相关章节将提到的模块(Modules)与类(Class) 。 该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。 第二行为空行，后跟的第三行开始是任何详细的解释说明。在此强烈建议你在你所有重要功 能的所有文档字符串中都遵循这一约定。 但是事实上，像例子中的那样，只要是函数第一行开始的多行字符串里面的内容都没什么问题 例子：1234567891011121314def print_max(x, y): '''233打印两个数值中的最大数。233 wewe这两个数都应该是整数 dsfsvsg'''# 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x &gt; y: print(x, 'is maximum') else: print(y, 'is maximum')print_max(3, 5)print(print_max.__doc__)#我们可以通过使用函数的 __doc__ (注意其中的双下划綫)属性(属于函数的名称)来获取 函数 print_max 的文档字符串属性。 输出：12345675 is maximum233打印两个数值中的最大数。233 wewe这两个数都应该是整数 dsfsvsgProcess finished with exit code 0 模块编写模块有很多种方法，其中最简单的一种便是创建一个包含函数与变量、以 .py 为后缀的 文件。另一种方法是使用撰写 Python 解释器本身的本地语言来编写模块。举例来说，你可以使用 C 语言来撰写 Python 模块，并且在编译后，你可以通过标准 Python 解释器在你的 Python 代 码中使用它们。一个模块可以被其它程序导入并运用其功能。我们在使用 Python 标准库的功能时也同样如 此。首先，我们要了解如何使用标准库模块。例子：12345import sysprint('The command line arguments are:')for i in sys.argv: print(i)print('\n\nThe PYTHONPATH is', sys.path, '\n') 当 Python 运行 import sys 这一语句时，它会开始寻找 sys 模块。在这一案例中，由于其 是一个内置模块，因此 Python 知道应该在哪里找到它。 如果它不是一个已编译好的模块，即用 Python 编写的模块，那么 Python 解释器将从它的 sys.path 变量所提供的目录中进行搜索。 from…import…如果你希望直接将 argv 变量导入你的程序 (为了避免每次都要输入 sys.)，那么你可以通过使用 from sys import argv 语句来实现这一点。 警告:一般来说，你应该尽量避免使用 from…import 语句，而去使用 import 语句。这是为了避免在你的程序中出现名称冲突，同时也为了使程序更加易读。 eg:12from math import sqrtprint("Square root of 16 is", sqrt(16)) 模块的 __name__ （不甚明确） 每个模块都有一个名称，而模块中的语句可以找到它们所处的模块的名称。这对于确定模块是独立运行的还是被导入进来运行的这一特定目的来说大为有用。 每一个 Python 模块都定义了它的 name 属性。如果它与 main 属性相同则代表这一 模块是由用户独立运行的，因此我们便可以采取适当的行动。1234if __name__ == '__main__': print('This program is being run by itself')else: print('I am being imported from another module') 编写自己的模块编写自己的模块很简单，这是因为每一个 Python 程序同时也是一个模块。你只需要保证它以 .py 为扩展名即可。下面的案例会作出清晰的解释。例子：test1.py12345def say_hi(): print('hi!This is my first module!')__version__='0.1'#say_hi() 上方所呈现的就是一个简单的模块。正如你所看见的，与我们一般所使用的 Python 的程序相 比其实并没有什么特殊的区别。我们接下来将看到如何在其它 Python 程序中使用这一模块。要记住该模块应该放置于与其它我们即将导入这一模块的程序相同的目录下，或者是放置在 sys.path 所列出的其中一个目录下。test2.py:1234import test1test1.say_hi()print('Version:',test1.__version__) 输出：12hi!This is my first module!(&apos;Version:&apos;, &apos;0.1&apos;) 当然也可以采用from...import...的做法：1234from test1 import say_hi,__version__say_hi()print('Version:',__version__) 在这里需要注意的是，如果导入到 mymodule 中的模块里已经存在了 version 这一名 称，那将产生冲突。这可能是因为每个模块通常都会使用这一名称来声明它们各自的版本号。 还可以使用：from test1 import * 这将导入诸如 say_hi 等所有公共名称，但不会导入 version 名称，因为后者以双下划线开头。 dir函数内置的 dir() 函数能够返回由对象所定义的名称列表。 如果这一对象是一个模块，则该列表会包括函数内所定义的函数、类与变量。该函数接受参数。 如果参数是模块名称，函数将返回这一指定模块的名称列表。 如果没有提供参数，函数将返回当前模块的名称列表。例子：（在上面的test2中调用这一函数）12345import test1import sysprint(dir(test1))print(dir()) 输出：12[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__version__&apos;, &apos;say_hi&apos;][&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;test1&apos;] 数据结构Python 中有四种内置的数据结构——列表(List)、元组(Tuple)、字典(Dictionary)和集合(Set)。 列表列表 是一种用于保存一系列有序项目的集合.（比较类似于cpp中的list）注意列表使用[]来体现这是一个列表而不是元组 项目的列表应该用方括号括起来，这样Python才能理解到你正在指定一张列表。一旦你创建了一张列表，你可以添加、移除或搜索列表中的项目。既然我们可以添加或删除项目，我们 会说列表是一种可变的(Mutable)数据类型，意即，这种类型是可以被改变的。例子：123456789101112131415161718192021# This is my shopping listshoplist = ['apple', 'mango', 'carrot', 'banana']print('I have', len(shoplist), 'items to purchase.')print('These items are:',end=' ')for item in shoplist: print(item, end=' ')#使用 for...in 循环来遍历列表中的每一个项目。print('\nI also have to buy rice.')shoplist.append('rice')#可以添加任意类型print('My shopping list is now', shoplist)print('I will sort my list now')shoplist.sort()#按照字典序从小到大排序print('Sorted shopping list is', shoplist)print('The first item I will buy is', shoplist[0])olditem = shoplist[0]del shoplist[0]#删除列表中的第一项print('I bought the', olditem)print('My shopping list is now', shoplist) 可以向同一个列表中添加任何类型的 对象，包括数字，甚至是其它列表。（但是此时如果要sort必须定义比较函数，否则int与字符类型比较会出错） 元组元组与列表比较类似，但是使用的括号（标识符）不同，并且，元组不能进行更改。注意：元组使用()或者不使用任何括号来体现 比较正式的说法：元组(Tuple)用于将多个对象保存到一起。你可以将它们近似地看作列表，但是元组不能提供列表类能够提供给你的广泛的功能。元组的一大特征类似于字符串，它们是不可变的，也就是说，你不能编辑或更改元组。元组是通过特别指定项目来定义的，在指定项目时，你可以给它们加上括号，并在括号内部用逗号进行分隔。（也就是说可以不加括号）。例子：123456789zoo= ('python', 'elephant', 'penguin')print('Number of animals in the zoo is', len(zoo))new_zoo = 'monkey', 'camel', zoo#注意此处元组中以另一个元组作为自己的一个项print('Number of cages in the new zoo is', len(new_zoo))#此时作为项的元组总体视为一项print('All animals in new zoo are', new_zoo)print('Animals brought from old zoo are', new_zoo[2])print('Last animal brought from old zoo is', new_zoo[2][2])#注意类似数组的用法print('Number of animals in the new zoo is', len(new_zoo)-1+len(new_zoo[2])) 输出：123456Number of animals in the zoo is 3Number of cages in the new zoo is 3All animals in new zoo are (&apos;monkey&apos;, &apos;camel&apos;, (&apos;python&apos;, &apos;elephant&apos;, &apos;penguin&apos;))Animals brought from old zoo are (&apos;python&apos;, &apos;elephant&apos;, &apos;penguin&apos;)Last animal brought from old zoo is penguinNumber of animals in the new zoo is 5 包含 0 或 1 个项目的元组一个空的元组由一对圆括号构成，就像 myempty = () 这样。然而，一个只拥有一个项目的元组并不像这样简单。你必须在第一个(也是唯一一个)项目的后面加上一个逗号 来指定它，如此一来 Python 才可以识别出在这个表达式想表达的究竟是一个元组还是只 是一个被括号所环绕的对象，也就是说，如果你想指定一个包含项目 2的元组，你必 须指定 singleton = (2, )。当然，你甚至可以把只有一个项目的元组的括号也省略掉！（空的元组显然不行，不然解释器并不知道你在定义什么…） 字典字典提供的功能是将键值(Keys)(即姓名)与值(Values)(即地址等详细信息)联立到一起。在这里要注意到键值必须是唯一的。（类似map，不提供multimap功能） 另外要注意的是你只能使用不可变的对象(如字符串)作为字典的键值，但是你可以使用可变或不可变的对象作为字典中的值。基本上这段话也可以翻译为你只能使用简单对象作为键值。 在字典中，你可以通过使用符号构成d = {key : value1 , key2 : value2} 这样的形式，来成 对地指定键值与值。在这里要注意到成对的键值与值之间使用冒号分隔，而每一对键值与值 则使用逗号进行区分，它们全都由一对花括号括起。另外需要记住，字典中的成对的键值—值配对不会以任何方式进行排序。如果你希望为它们安排一个特别的次序，只能在使用它们之前自行进行排序。例子：123456789101112131415161718# “ab”是地址(Address)簿(Book)的缩写ab = &#123; 'Swaroop': 'swaroop@swaroopch.com', 'Larry': 'larry@wall.org', 'Matsumoto': 'matz@ruby-lang.org', 'Spammer': 'spammer@hotmail.com', 6:234#可以同时添加几种类型&#125;print("Swaroop's address is", ab['Swaroop'])# 删除一对键值—值配对del ab['Spammer']print('\nThere are &#123;&#125; contacts in the address-book\n'.format(len(ab)))for name, address in ab.items():#注意name，address这两个关键字，这两个字用a,b也没用关系，是自己指定的 print('Contact &#123;&#125; at &#123;&#125;'.format(name, address))# 添加一对键值—值配对ab['Guido'] = 'guido@python.org'#类似map的插入功能if 'Guido' in ab:#检测是否存在这一键值 print("\nGuido's address is", ab['Guido']) 输出：12345678910Swaroop&apos;s address is swaroop@swaroopch.comThere are 4 contacts in the address-bookContact Swaroop at swaroop@swaroopch.comContact Larry at larry@wall.orgContact Matsumoto at matz@ruby-lang.orgContact 6 at 234Guido&apos;s address is guido@python.org 可以通过del 语句—来删除某一 键值—值 配对。我们只需指定字典、包含需要删除的键值名称的索引算符，并将其传递给del 语句。这一操作不需要你知道与该键值相对应的值。可以使用in运算符来检查某对键值-键配对是否存在 序列序列的主要功能是资格测试(Membership Test)(也就是 in 与 not in 表达式)和索引操作(Indexing Operations)，它们能够允许我们直接获取序列中的特定项目。 上面所提到的序列的三种形态——列表、元组与字符串，同样拥有一种切片(Slicing)运算符，它能够允许我们序列中的某段切片——也就是序列之中的一部分。 例子：1234567891011121314151617181920shoplist = ['apple', 'mango', 'carrot', 'banana']name = 'swaroop'print('Item 0 is', shoplist[0]) print('Item 1 is', shoplist[1]) print('Item 2 is', shoplist[2]) print('Item 3 is', shoplist[3]) print('Item -1 is', shoplist[-1]) print('Item -2 is', shoplist[-2]) print('Character 0 is', name[0])print('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# 从某一字符串中切片 #print('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:]) 输出：123456789101112131415Item 0 is appleItem 1 is mangoItem 2 is carrotItem 3 is bananaItem -1 is bananaItem -2 is carrotCharacter 0 is sItem 1 to 3 is [&apos;mango&apos;, &apos;carrot&apos;]Item 2 to end is [&apos;carrot&apos;, &apos;banana&apos;]Item 1 to -1 is [&apos;mango&apos;, &apos;carrot&apos;]Item start to end is [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]characters 1 to 3 is wacharacters 2 to end is aroopcharacters 1 to -1 is waroocharacters start to end is swaroop 使用说明：如上所示，每当你在方括号中为序列指定一个数字，Python 将 获取序列中与该位置编号相对应的项目。要记得 Python 从 0 开始计数。因此 shoplist[0] 将获得 shoplist 序列中的第一个项目，而 shoplist[3] 将获得第四个项目。索引操作也可以使用负数，在这种情况下，位置计数将从队列的末尾开始。 因此，shoplist[-1] 指的是序列的最后一个项目，shoplist[-2] 将获取序列中倒数第二个项目。 在序列中切片 在切片操作中，第一个数字(冒号前面的那位)指的是切片开始的位置，第二个数字(冒号后面的那位)指的是切片结束的位置。如果第一位数字没有指定，Python 将会从序列的起始处开始操作。如果第二个数字留空，Python 将会在序列的末尾结束操作。要注意的是切片操作会在开始处返回 start，并在 end 前面的位置结束工作。也就是说，序列切片将包括起始位置，但不包括结束位置。 因此， shoplist[1:3] 返回的序列的一组切片将从位置 1 开始，包含位置 2 并在位置 3 时结束，因此，这块切片返回的是两个项目。类似地，shoplist[:] 返回的是整个序列。 你同样可以在切片操作中使用负数位置。使用负数时位置将从序列末端开始计算。例 如，shoplist[:-1] 强返回一组序列切片，其中不包括序列的最后一项项目，但其它所有项目都包含其中。 但是诸如shoplist[-1:1]这样的操作是不行的。 切片的步长你同样可以在切片操作中提供第三个参数，这一参数将被视为切片的步长(Step)(在默认情况下，步长大小为 1):例如：123456789&gt;&gt;&gt; shoplist = ['apple', 'mango', 'carrot', 'banana']&gt;&gt;&gt; shoplist[::1]['apple', 'mango', 'carrot', 'banana']&gt;&gt;&gt; shoplist[::2]['apple', 'carrot']&gt;&gt;&gt; shoplist[::3]['apple', 'banana']&gt;&gt;&gt; shoplist[::-1]['banana', 'carrot', 'mango', 'apple'] 你会注意到当步长为 2 时，我们得到的是第 0、2、4…… 位项目。当步长为 3 时，我们得到的是第 0、3……位项目。 集合 集合(Set)是简单对象的无序集合(Collection)。当集合中的项目存在与否比起次序或其出 现次数更加重要时，我们就会使用集合。 通过使用集合，你可以测试某些对象的资格或情况，检查它们是否是其它集合的子集，找到两个集合的交集，等等。例子：123456789101112&gt;&gt;&gt; bri = set(['brazil', 'russia', 'india'])&gt;&gt;&gt; 'india' in briTrue&gt;&gt;&gt; 'usa' in briFalse&gt;&gt;&gt; bric = bri.copy()&gt;&gt;&gt; bric.add('china')&gt;&gt;&gt; bric.issuperset(bri)True&gt;&gt;&gt; bri.remove('russia')&gt;&gt;&gt; bri &amp; bric # OR bri.intersection(bric)&#123;'brazil', 'india'&#125; 引用看起来这个引用与CPP中的&amp;并没有太大区别，只不过Python中声明似乎更简单一些，直接令mylist=shoplist即可，注意这并不是声明另一个同类型的对象并进行拷贝赋值的意思。例子：123456789101112131415161718print('Simple Assignment')shoplist = ['apple', 'mango', 'carrot', 'banana']# mylist 只是指向同一对象的另一种名称mylist = shoplist #注意这个引用声明的方式# 我购买了第一项项目，所以我将其从列表中删除del shoplist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到 shoplist 和 mylist 二者都# 打印出了其中都没有 apple 的同样的列表，以此我们确认# 它们指向的是同一个对象print('Copy by making a full slice')# 通过生成一份完整的切片制作一份列表的副本 mylist = shoplist[:]# 删除第一个项目del mylist[0]print('shoplist is', shoplist)print('mylist is', mylist)# 注意到现在两份列表已出现不同 输出：123456Simple Assignmentshoplist is [&apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]mylist is [&apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]Copy by making a full sliceshoplist is [&apos;carrot&apos;, &apos;banana&apos;]mylist is [&apos;carrot&apos;, &apos;banana&apos;] 注意：记住，如果希望创建一份诸如序列等复杂对象的副本(而非整数这种简单的对象 (Object))，你必须使用切片操作来制作副本。如果你仅仅是将一个变量名赋予给另一个名称，那么它们都将“查阅”同一个对象，也就是相当于声明了一个原对象的引用！ 如果需要拷贝序列等复杂对象，应该像下面这样：1mylist1=shoplist[:] 面向对象编程一个类(Class)能够创建一种新的类型 (Type)，其中对象(Object)就是类的实例(Instance)。可以这样来类比:你可以拥有 类型 int 的变量，也就是说存储整数的变量是 int 类的实例(对象)。 对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 (Field)。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 (Method)。 字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量(Instance Variables)与类变量(Class Variables)。通过 class 关键字可以创建一个类。这个类的字段与方法可以在缩进代码块中以列出。 self类的方法（大概相当于类的成员函数）与普通函数只有一种特定的区别——前者必须多加一个参数在参数列表开头，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。这种特定的变量引用的是对象本身，按照惯例，它被赋予self 这一名称。尽管你可以为这一参数赋予任何名称，但是强烈推荐你使用 self 这一名称——其它的任何一种名称绝对会引人皱眉。也就是说，类的成员函数在普通参数之外还必须放一个虚的参数在参数列表最前面，实际调用的时候并不需要提供这个参数 Python 中的 self 相当于 C++ 中的 this 指针以及 Java 与 C# 中的 this 引用。 类最简单的类：1234class Person:pass # 一个空的代码块p = Person()print(p) 通过使用 class 语句与这个类的名称来创建一个新类。在它之后是一个缩进的语句块，代表这个类的主体。 我们已经在前面讨论过类与对象一如函数那般都可以带有方法(Method)，唯一的不同在于我们还拥有一个额外的 self 变量（虚的变量）。现在让我们来看看下面的例子:1234567class Person: def say_hi(self):#注意这个函数并没有正在的参数，只有一个self参数 print('Hello, how are you?')p = Person()p.say_hi()Person().say_hi()# 前面两行同样可以写作Person().say_hi() 这里我们就能看见 self 是如何行动的了。要注意到 say_hi 这一方法不需要参数，但是依旧在函数定义中拥有 self 变量。 类的初始化函数类似于CPP的初始化函数：在 Python 的类中，有不少方法的名称具有着特殊的意义。比如，__init__ 方法会在类的对象被实例化(Instantiated)时立即运行。这一方法可以对任何你想 进行操作的目标对象进行初始化(Initialization)操作。这里要注意在 init 前后加上的双下划线。例子：123456789class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello, my name is', self.name)p = Person('Swaroop')p.say_hi()# 前面两行同时也能写作# Person('Swaroop').say_hi() 在本例中，我们定义一个接受 name 参数(当然还有 self 参数)的__init__ 方法。在这里，我们创建了一个字段，同样称为 name 。要注意到尽管它们的名字都是“name”，但这是两个不相同的变量。虽说如此，但这并不会造成任何问题，因为 self.name 中的点号意味着 这个叫作“name”的东西是某个叫作“self”的对象的一部分，而另一个 name 则是一个局部变量。由于我们已经如上这般明确指出了我们所指的是哪一个名字，所以它不会引发混乱。 当我们在 Person 类下创建新的实例 p 时，我们采用的方法是先写下类的名称，后跟括在 括号中的参数，形如: p = Person(&apos;Swaroop&apos;) 。 我们不会显式地调用 __init__ 方法。 这正是这个方法的特殊之处所在。]]></content>
      <categories>
        <category>Python</category>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233]]></title>
    <url>%2Farticle%2F233%2F</url>
    <content type="text"><![CDATA[23323323312345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl; return 0;&#125; 2333 test ss s $233+34+A^3+A_5^4$ 2333 $A_5^4+A+23$ 233333333 哈哈哈 test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Farticle%2Ftest%2F</url>
    <content type="text"><![CDATA[233 test]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farticle%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[蒟蒻的Linux随笔]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FLinux%2Fe8-92-9f-e8-92-bb-e7-9a-84linux-e9-9a-8f-e7-ac-94%2F</url>
    <content type="text"><![CDATA[最近突然开始研究了一下Linux，随手记录一下一些用过的看起来比较有意思的命令吧QAQ Shell的几个快捷键Ctrl+a 光标移动到行头 Ctrl+e光标移动到行末 Ctrl+k删除从光标位置到行末 文件浏览&amp;常用乱七八糟编译命令： g++ a+b.cpp -o a+b+c -std=c++11 a+b.cpp是cpp文件名，a+b+c则是可执行文件名，后面则可以选择编译标准。 ls 浏览当前文件夹下的所有文件（不包含隐藏文件 ls -a 显示所有文件（包括隐藏文件） man ls man后面加东西，显示该命令的帮助，上下/空格浏览，q退出 cal 显示日历。cal 5 2018可显示指定月份。 文件打开&amp;新建&amp;删除 cd name 打开文件 cd/cd ~ 回到根目录 cd .. 回到上一级目录 pwd 显示当前路径 mkdir name 新建文件夹 mkdir -p name/name/name 按路径建立多个新文件夹 rmdir name 删除此文件夹（被删除文件夹必须为空） rm -r name 干翻name目录下所有文件（删库跑路？） 文件复制，移动，删除文件复制 cp ~/testpdf.pdf ~/test 将根目录下的文件copy到空格后的目录中，~/不填则默认为当前目录下的文件 可以在复制的同时对复制后的文件进行重命名： cp ~/testpdf.pdf ~/test/notest.pdf 复制过去的pdf名字就变了 可以加上-i选项，这样有同名文件覆盖前会询问是否覆盖： cp -i ~/testpdf.pdf ~/test 如果要复制一个目录，或者说是文件夹，那么需要加上指令 -r cp -r test1 test2 如果要强制执行，还可以使用-f指令；同时，多个指令可以叠加使用，例如： cp -rf test1 test2 强制复制目录 文件删除使用指令rm以达到目的，同样，删除目录需要使用-r，这是递归删除命令； rm -r test1 -i则会在删除前确认，-f表示强制执行。同时，还可以使用指令 rm test* 通过加上 “* ” 来删除此目录下所有文件名以test为前缀的文件； 文件移动使用mv指令来达成目的。mv指令可以移动普通文件和目录，因此不存在-r-f 强制，-i：如果存在同名文件，询问是否覆盖； -u：如果目标文件已存在，且当前来源较新才会更新 mv a+b ~/test/test2/ 将当前目录中的可执行文件a+b移动到指定文件夹中； mv a+b ~/test/test2/a+c 移动文件的同时进行名称变更； mv a+b a+c ~/test/ 同时移动多个文件；注意此时最后一个一定是目录！！！ 文件建立 touch file_name 建立文件 touch file_name{1..number}_txt 括号中写好数字，就会批量建立相应文件]]></content>
      <categories>
        <category>乱搞</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 18 (rated, Div. 1 + Div. 2)]]></title>
    <url>%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fmanthan-codefest-18-rated-div-1-div-2%2F</url>
    <content type="text"><![CDATA[1w年没更新了QAQ A. 傻逼题二进制分解一下即可 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=0;;i++){ if(n&lt;=(1&lt;&lt;i))break; n-=(1&lt;&lt;i); } cout&lt;&lt;i+1&lt;&lt;endl; return 0; } B. 排个序贪心搞搞就行，自己zz了还wa了3发… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { int num[200005],n,s,i,j,k; ll ans=0; cin&gt;&gt;n&gt;&gt;s; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); sort(num+1,num+1+n); int mid=(n+1)&gt;&gt;1; if(num[mid]==s){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(num[mid]&gt;s){ for(i=mid;i;i--){ if(num[i]&lt;=s)break; ans+=num[i]-s; } } else{ for(i=mid;i&lt;=n;i++){ if(num[i]&gt;=s)break; ans+=s-num[i]; //cout&lt;&lt;ans&lt;&lt;endl; } } //cout&lt;&lt;mid&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 除非相邻位置刚好要交换，否则都没有交换意义，随便搞搞即可 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k;string str1,str2; int ans=0; cin&gt;&gt;n; cin&gt;&gt;str1&gt;&gt;str2; for(i=0;i&lt;str1.size();i++){ if(str1[i]!=str2[i]){ if(i&lt;str1.size()-1&amp;&amp;str1[i+1]!=str2[i+1]&amp;&amp;str1[i]!=str1[i+1]){ ans++;i++; } else{ ans++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 其实就是一个二叉树的层次遍历，但是还有一点要注意的就是父亲层的遍历顺序决定了下一层的遍历顺序，所以这也要考虑。解决方案是每个点建一个map记录边，然后检测序列的时候弄两个指针，一个指示当前节点，另一个指示当前节点的儿子。如果是非法序列，最后第二个指针肯定没法走完所有的节点。同时还要注意特判根节点是否为1 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt;mp1[200005]; int main() { int n,i,j,k,x,y; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y);mp1[x][y]=1;mp1[y][x]=1; } int num[200005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); for(i=1,j=2;i&lt;=n;i++) while(mp1[num[i]][num[j]]) j++; if(j==n+1&amp;&amp;num[1]==1){//注意这里是j==n+1!! cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; //cout&lt;&lt;j&lt;&lt;endl; return 0; } E. 难点在于怎么去检测一个人是否有至少k个朋友，并且这些朋友也都有至少k个可以去旅游的朋友…标算很精妙… #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; set&lt;int&gt;s,G[maxn]; int k,a[maxn],b[maxn],ans[maxn],n,m; void check(int x) { if(G[x].size()&lt;k&amp;&amp;s.erase(x)){//如果这个人的朋友小于k,他肯定要滚蛋,同时在s里面也要删去此人 for(auto a:G[x]){ G[a].erase(x);check(a);//他的朋友也要check一发 } } } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); G[a[i]].insert(b[i]);G[b[i]].insert(a[i]);//建立朋友关系 } for(i=1;i&lt;=n;i++)s.insert(i); for(i=1;i&lt;=n;i++)check(i);//检查每一个人的朋友关系 for(i=m;i;i--){ ans[i]=s.size();//此时集合中的所有人都满足要求 G[a[i]].erase(b[i]);G[b[i]].erase(a[i]);//删去这天才成为朋友的人 check(a[i]);check(b[i]); } for(i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]); return 0; }]]></content>
      <categories>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意瑞法之旅——咕咕咕系列]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%97%85%E6%B8%B8%2Fe6-84-8f-e7-91-9e-e6-b3-95-e4-b9-8b-e6-97-85-e5-92-95-e5-92-95-e5-92-95-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[8.26一大早5点钟就滚去机场了，飞机倒是没延误，但是南航的这班飞机真心不敢恭维——首先飞机在远机位，坐摆渡车跑了半天，然后大概是飞机比较陈旧的缘故吧，连个人娱乐系统都没有，无聊得不行，要是飞国际线乘客估计能无聊死。餐食就更加无语了，面条非常难吃，还每人发了半个番薯…说起来番薯好像还是最好吃的。幸好航程不长，睡一觉也就到了。不过下降的时候飞越了广州市区倒是好评，第一次如此完整的在空中俯瞰广州——我甚至清晰地拍到了小蛮腰。 滚回家就12点了，睡了一觉起来5点了…搞了搞吃了个饭又愉快地去机场了，新航站楼的空调真的好冷QAQ。航班其实是凌晨00：35的…登机的时候前面有俩蛮帅的小哥哥，不过似乎是俩资本主义的国民，一直在哇哩哇啦不知道说啥😂 投奔资本主义~ 然后，南航不得不再吐槽一发…虽然说787一排343也是航空公司常态了…但是您这个前后间距敢不敢再窄一点，感觉我TM一路蹲到了罗马…作为5年的老787，WiFi自然没有，娱乐系统的分辨率…大概只有联想的垃圾泛白tn屏才能与之一战。飞了12个半小时，真的挺漫长的… 罗马机场WiFi界面倒是好评…估计也是为了讨好一下各位爆买的金主大妈吧… 8.27在罗马机场过海关队伍真的超级长…刚好排到了一个特别严肃的海关大姐把守的关卡，我前面的一个穆斯林小姐姐似乎被遣返了…还好后来换了个大叔来审核，这哥们倒是贼松散，上来一看中国游客直接就过了… 前面这个妹子被遣返了，左边那个大妈真的… 讲道理，罗马机场给我的感觉其实也挺一般的，跟北京的t2一个水平吧，略旧。 然后第一天就先滚去梵蒂冈了，看了看圣彼得大教堂，里面各种什么名画雕塑，埋了各种名人…不过对于对艺术一窍不通的我来说，感觉都是一堆石膏像，看不出什么大区别…倒是外面的瑞士雇佣兵蛮有意思，感觉像动物园里的动物被人疯狂拍照：-D 接着就滚去了斗兽场跟许愿池转了转，感觉还行，就是人略多（谁说只有中国人多来着，资本主义一样人挤人…)吃了个所谓意大利雪糕，个人感觉并没有麦当劳的新地好吃（呸 不过，罗马老建筑的保护还是普遍比国内好…这个不得不承认 似乎还是跨国大公司麦爸爸的东西最好吃：-D 然后就滚回酒店啦，吃了个麦爸爸，8点就睡着了（于是第二天4点就醒了） 8.288.31今天早上在琉森湖游了一会船，但是雾太大感觉啥都看不见，最有意思的似乎是湖里还能正常行驶的明轮蒸汽船。接着就是在卢塞恩（琉森）的自由活动时间了。考虑到对手表毫无兴趣（其实是买不起），又恰好发现附近有一个The Swiss Museum of Transport,于是就很开心的坐了4站公交过去看。买票的时候发现没有足够的硬币，上车跟司机聊了半天也没有解决问题，于是最后就逃了一波票。不得不说资本主义的公交坐起来还是挺舒服的，而且车上人贼好，还主动问我是不是去博物馆（大概是脸上写着“游客”两字？） 博物馆跟中国的相比其实并不是很大，但是维护得非常好，展品保养得也非常棒，更重要的是，]]></content>
      <categories>
        <category>生活</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 10]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E8%B5%9B%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-multi-university-training-contest-10%2F</url>
    <content type="text"><![CDATA[HDU6426~6437 G考虑使用容斥原理进行计数. 包含至少一个形如 $[i, i + 1] $或 $[n, 1] $这样的子串的环排列个数是 $\binom{n}{1} (n - 2)! $个; 可以推广为包含至少$ k (0 \leq k &lt; n)$个的环排列个数是 $\binom{n}{k} (n - k - 1)!$, 同时注意到包含 $n$ 个的环排列个数一定是 1个. 所以最终答案就是$ (-1)^n + \sum_{k = 0}^{n - 1} (-1)^k \binom{n}{k} (n - k - 1)!$ 或者，直接暴力打表找出前几项，推公式或者面向OEIS编程，得出公式： $a_n=(n-2)\times a_{n-1}+(n-1)\times a_{n-2}-(-1)^n$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=998244353; ll f[100005]; int main() { f[1]=1;f[2]=0;f[3]=1;f[4]=1; int i,j; for(i=5;i&lt;=100000;i++){ f[i]=((i-2)*f[i-1]%mod+(i-1)*f[i-2]%mod-(i&amp;1?-1:1))%mod; } int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; cout&lt;&lt;f[n]&lt;&lt;endl; } return 0; } Hprintf(“%.0f\n”, pow(2, n)); #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 10000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } int main() { int t,i,j,k; cin&gt;&gt;t; while(t--){ int n;cin&gt;&gt;n; bign ans=1; for(i=1;i&lt;=n;i++){ ans=ans*2; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } I.令 $a=i-j$, 先枚举$ i$ 再枚举 $a$ $ \sum_{i=1}^n \sum_{j=1}^{i-1} [\gcd(i+j,i-j)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i-a,a)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i,a)=1]$ 即对于每个 $i$, 求有多少个小于它的 $a$ 满足$ \gcd(i,a)=1 $且$ a $是奇数. 当 $i$ 是奇数时, 答案为$ \frac{\varphi(i)}{2}.$ （此时，所求就是$(n,1),(n,3),(n,5)…(n,n)$中$\gcd$为1的个数，也就是求 $(n,n-1),(n,n-3),…(n,n-n)$,即$(n,2),(n,4),(n,6)…(n,n-1)$,所以有 $\sum(1,3,…,n)=\frac{1}{2}\sum(1,2,…n)[gcd(n,i)=1]=\frac{phi(n)}{2}$ 当 $i$ 是偶数时, 答案为$\varphi(i).$ (显然a是偶数的时候gcd不会是1，所以直接求欧拉函数即可) 注意 $i=1$ 时, 答案为 0. 记个前缀和就好了, 复杂度为 $O(N+T)$. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e7+10; vector&lt;int&gt;prime; bool isnotprime[maxn+50]; long long phi[maxn+50]; void check(void) { int i,j,k; for(i=2;i&lt;=maxn;i++){ if(!isnotprime[i]){ prime.push_back(i);//[ptop++]=i; phi[i]=i-1; } for(j=0;j&lt;prime.size();j++){ int pi=prime[j]*i; if(pi&gt;maxn)break; isnotprime[pi]=true; if(i%prime[j]==0){ phi[pi]=prime[j]*phi[i]; break; } phi[pi]=(prime[j]-1)*phi[i]; } } for(i=1;i&lt;=maxn;i++) { if(i&amp;1)phi[i]&gt;&gt;=1; phi[i] += phi[i - 1]; } } int main() { int t,i,j; check(); cin&gt;&gt;t; while(t--){ int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,phi[n]); } return 0; } J.K 不大于 5, 仅是常数级别, 所以可以搞事情 我们发现 $|x_{MW}[i]-x_{SW}[i]| = max(x_{MW}[i]-x_{SW}[i],x_{SW}[i]-x_{MW}[i])$ 也就是说对于每一个维度只有两种选择, 同时$ 2^K \le 32$ 也不大, 所以可以枚举每一维的大小情况, 分别取主武器与副武器的最大值就好了, 复杂度 $O(2^Kn).$ 具体来说，对于每一个武器，枚举他的每一个x前面取+/-号的情况，然后更新$num[j]$数组，也就是记录在一种+/-取值状况下的最大值，然后我们枚举主副武器的num数组，当然枚举的时候要确保主武器的取值状况与副武器刚好是取反的状态，这样就可以求出最大值。当然会出现一些正负号不甚正确的情况，可是这些情况显然不会是最优解，所以不必担心。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=-(1ll&lt;&lt;60); const int maxn=100005; int S[maxn],s[maxn],X[maxn][6],x[maxn][6]; ll numm[60],numn[60]; int main() { int t,i,j,n,m,k; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=0;i&lt;(1&lt;&lt;5);i++) numm[i]=numn[i]=INF; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;S[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;X[i][j]); for(;j&lt;=5;j++) X[i][j]=0; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;s[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;x[i][j]); for(;j&lt;=5;j++) x[i][j]=0; } for(i=1;i&lt;=n;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=S[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?X[i][a+1]:-X[i][a+1]; } numm[j]=max(numm[j],temp); } } for(i=1;i&lt;=m;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=s[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?x[i][a+1]:-x[i][a+1]; } numn[j]=max(numn[j],temp); } } ll ans=0; for(i=0;i&lt;(1&lt;&lt;5);i++){ int pos=((1&lt;&lt;5)-1)&amp;(~i); ans=max(ans,numm[i]+numn[pos]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } L.咋一看以为是dp，后来发现是网络流…这里需要最大的满意值，而我们的模板是最小费用流，所以我们可以把满意值都弄成负的，这样求出来以后取个相反数就是满意值了… 考虑到每个video只能被一个人看，因此显然要拆点，流量1费用0，然后为了限制总流量也就是人数，起点向虚拟起点连边,限制总流量k。为了保证最大流，（有的人可以没video看），虚拟起点向终点连边,流量k费用0，确保最大流量（因为video费用为负，可流的情况下显然更优）。然后起点向每个点video的第一个点连边，以及每个video的第二个点向终点连边。对于每个video，枚举所有的video，下个video的起始时间晚于当前video的结束时间才可以连边，流量1，费用为下个video的w，并且要考虑类型带来的惩罚值。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=550; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } struct movie{ int s,t,w,op; }M[250]; int main() { int t,i,j,k,n,m,w,W; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;W; for(i=0;i&lt;=520;i++)G[i].clear(); for(i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;M[i].s,&amp;M[i].t,&amp;M[i].w,&amp;M[i].op); int s1=505,s2=506,t=510; add(s1,s2,k,0);//起点向虚拟起点连边,限制总流量 add(s2,t,k,0);//虚拟起点向终点连边,确保最大流量 flow=cost=0; for(i=1;i&lt;=m;i++) add(i+200,t,1,0);//每个video向终点连边 for(i=1;i&lt;=m;i++){ add(s2,i,1,-M[i].w);//起点向每个video连边 add(i,i+200,1,0);//每个video拆成两个点 for(j=1;j&lt;=m;j++){ if(i==j)continue; if(M[i].t&lt;=M[j].s){//下个video的起始时间晚于当前video的结束时间才可以连边 if(M[i].op!=M[j].op){//类型不同直接连 add(i+200,j,1,-M[j].w); } else{//减去惩罚值 add(i+200,j,1,-(M[j].w-W)); } } } } mincostmaxflow(s1,t); cout&lt;&lt;-cost&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>网络赛</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>网络赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 34 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-34-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.数据范围那么小直接暴力枚举啊 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x; cin&gt;&gt;n; while(n--){ cin&gt;&gt;x; for(i=0;3*i&lt;=x;i++){ if((x-i*3)%7==0){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;&apos;\n&apos;;break; } } if(3*i&gt;x) puts(&quot;NO&quot;); } return 0; } B.弱智* 2 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int h1,a1,c1,h2,a2,cnt=0; vector&lt;int&gt;ans; cin&gt;&gt;h1&gt;&gt;a1&gt;&gt;c1&gt;&gt;h2&gt;&gt;a2; while(h2&gt;0){ cnt++; if(h2-a1&lt;=0){ ans.push_back(1);break; } else{ if(h1-a2&lt;=0){ ans.push_back(0);h1=h1-a2+c1; } else { ans.push_back(1);h1-=a2;h2-=a1; } } } cout&lt;&lt;cnt&lt;&lt;endl; for(auto a:ans) if(a) puts(&quot;STRIKE&quot;); else puts(&quot;HEAL&quot;); return 0; } C.从大到小排序，然后维护一个大根堆，每次如果堆顶的箱子能放下当前箱子，就把当前箱子丢进去并更新箱子大小，否则这个箱子就得单独放。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,box[5005]; priority_queue&lt;int&gt;que; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;box[i]; sort(box+1,box+1+n); for(i=n;i;i--){ if(que.empty()||que.top()&lt;=box[i]){ que.push(box[i]); } else{ que.pop();que.push(box[i]); } } cout&lt;&lt;que.size()&lt;&lt;endl; return 0; } D.其实我的想法很简单：首先搞个map统计每个数的出现次数，再搞个后缀和。然后从前往后扫，对于每个数，先在map里对这个数–，然后看看在这个数-1~这个数+1的范围内还有多少个数（用map查询），然后处理一下后缀和就行了。然而这个万恶的题目卡long long…于是我就抄了个400行的高精度模板… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //最大长度，可以修改 using namespace std; class bign { public: int len, s[MAX_L];//数的长度，记录数组 //构造函数 bign(); bign(const char *); bign(int); bool sign;//符号 1正数 0负数 string toStr() const;//转化为字符串，主要是便于输出 friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//重载输入流 friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//重载输出流 //重载复制 bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //重载各种比较 bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //重载四则运算 bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //四则运算的衍生运算 bign operator%(const bign &amp;) const;//取模（余数） bign factorial() const;//阶乘 bign Sqrt() const;//整数开根（向下取整） bign pow(const bign &amp;) const;//次方 //一些乱乱的函数 void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005]; int main() { int n,i,j,k,num[200005]; bign ans=0; cin&gt;&gt;n; map&lt;int,int&gt;mp1; for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;num[i]),mp1[num[i]]++; for(i=n;i;i--){ sum[i]=num[i];sum[i]+=sum[i+1]; } for(i=1;i&lt;=n;i++){ mp1[num[i]]--; int tot=n-i; if(mp1[num[i]]==0)mp1.erase(num[i]); bign temp;temp=num[i]; sum[i]-=temp; if(mp1.count(num[i]-1)){ temp=(ll)mp1[num[i]-1]*(num[i]-1); sum[i]-=temp; tot-=mp1[num[i]-1]; } if(mp1.count(num[i])){ temp=(ll)mp1[num[i]]*(num[i]); sum[i]-=temp; tot-=mp1[num[i]]; } if(mp1.count(num[i]+1)){ temp=(ll)mp1[num[i]+1]*(num[i]+1); sum[i]-=temp; tot-=mp1[num[i]+1]; } temp=(ll)tot*num[i]; ans-=temp;ans+=sum[i]; } //ans*=-1; cout&lt;&lt;ans&lt;&lt;endl; return 0; } 然后我看提交记录的时候发现了一个简单得多的做法…其实也可能是因为拿long double代替了高精度所以显得比较简单。 首先从前往后扫，对于每一位数a[i]，我们拿a[i]* i减去前缀和就是没有相减为0条件下的答案，然后对于那些绝对值相差1 的数，我们先拿一个map cnt统计迄今为止各个数的出现次数，然后加上cnt[a[i]+1]-cnt[a[i]-1]即可。long double居然能搞过去… #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt; cnt; int main() { int n; long double ans=0,sum=0,num; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++){ scanf(&quot;%Lf&quot;,&amp;num); ans+=num*i-sum+cnt[(int)num+1]-cnt[(int)num-1]; sum+=num; cnt[(int)num]++; } printf(&quot;%.0Lf&quot;,ans+0.000000001); return 0; } E. 给定一堆字符串，问能不能构造一个字符串使得所有的字符串在交换自己的某两个字符之后都与构造出来的字符一模一样。 首先，如果所有的字符串长得都一样，那随便换两个字母的位置输出即可。 否则，我们找到两个不同的字符串（第一个不妨就是输入的第一个字符串），然后把他们所有不相同的位置的下标都保存在diff数组里。如果diff的size&gt;4，那么显然，无解（每个字符串最多交换2个字符，不可能使得5个以上不同的位置变得相同）。 然后，对于每个不同的下标，我们都尝试拿第一个字符串中不同位置的字符去与之交换，看看换完的字符串能不能是答案。 如何检查一个交换完的字符串是不是答案呢？ 对于所有的字符串（当然自己跟自己除外），我们都统计不同的位置的下标并保存在dif数组中，如果有任意一个字符串的dif数组的size!=0&amp;&amp;size!=2，显然这个换完的字符串是不能成为答案的。如果size=0，那么那个字符串如果所有的字符都是不一样的，也不行（因为每个字符串都要交换两个字符，全部不同的话换完就不可能满足当前答案了）。如果size=2，那么那个字符串交换完这俩位置之后必须与当前答案一样。 扫完所有可能以后，如果还没有找到答案，输出-1即可。 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(string str) { int cnt[30]={0}; for(auto a:str) cnt[a-&apos;a&apos;]++; for(int i=0;i&lt;26;i++) if(cnt[i]&gt;=2) return true; return false; } int main() { set&lt;string&gt;s; int k,n,i,j,a,b,len; cin&gt;&gt;n&gt;&gt;len; string str[2505],str1,str2; for(i=1;i&lt;=n;i++){ cin&gt;&gt;str[i];s.insert(str[i]); } if(s.size()==1){ swap(str[1][0],str[1][1]); cout&lt;&lt;str[1]&lt;&lt;endl;return 0; } str1=str[1]; for(i=2;i&lt;=n;i++) if(str[i]!=str[1]) { str2 = str[i];break; } vector&lt;int&gt;diff; for(i=0;i&lt;len;i++) if(str1[i]!=str2[i]) diff.push_back(i); if(diff.size()&gt;4){ puts(&quot;-1&quot;);return 0; } for(auto a:diff){ for(i=0;i&lt;len;i++){ if(i==a)continue; bool isok=true; string str3=str1;swap(str3[i],str3[a]); for(j=2;j&lt;=n;j++){ vector&lt;int&gt;dif; for(k=0;k&lt;len;k++){ if(str3[k]!=str[j][k]) dif.push_back(k); } if(dif.size()!=0&amp;&amp;dif.size()!=2){ isok=false; break; } if(dif.empty()){ if(!check(str[j])){ isok=false;break; } } else{ string str4=str[j];swap(str4[dif[0]],str4[dif[1]]); if(str4!=str3){ isok=false;break; } } } if(isok){ cout&lt;&lt;str3&lt;&lt;endl;return 0; } } } puts(&quot;-1&quot;); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 49 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-49-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.小心处理z与a的问题，以及注意每个字母都必须发生变化即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { string str1,str2; int n,i,j,k; int t; cin&gt;&gt;t; while(t--){ bool isok=true; cin&gt;&gt;n&gt;&gt;str1;str2=str1;reverse(str2.begin(),str2.end()); for(i=0;i&lt;str1.size();i++){ if(abs((int)(str1[i]-str2[i]))==1||abs((int)(str1[i]-str2[i]))&gt;2){ isok=false;break; } } if(isok)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } B.注意n为奇数的时候需要特别讨论,每两行为一组刚好n个数，然后可能多一行得单独讨论一下。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n, q, x, y; cin &gt;&gt; n &gt;&gt; q; int i,j,k; for (i = 1; i &lt;= q; i++) { cin &gt;&gt; x &gt;&gt; y; ll ans = 0; if ((x + y) &amp;1) { ans += (n * n - 1) / 2 + 1; } if (n &amp;1) { ans += (x - 1) / 2 * n; if ((x + y) % 2 == 1) ans += (x - 1) % 2 * (n / 2); else ans += (x - 1) % 2 * (n / 2 + 1); ans += (y + 1) / 2; } else if (n % 2 == 0) { ans += (x - 1) * n / 2; ans += (y + 1) / 2; } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } C.注意到取到的最小值的组合肯定是那些比较相邻长度的木棍，因此我们可以将木棍排序，然后暴力枚举相邻长度且根数&gt;=2的木棍。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 50; long double minnum; int num[maxn]; int main() { int i,j,k, t, n; int q1, q2, P1, P2; cin&gt;&gt;t; while(t--){ minnum = 1ll &lt;&lt; 60;P1 = P2 = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); } sort(num + 1, num + n + 1); for (i = 1; i &lt;= n; i++) { if (P1 == num[i]) { if (P2 != 0) { long double x(P1), y(P2); long double temp = (x + x + y + y)*(x + x + y + y) / (x*y); if (temp &lt; minnum) { q1 = P2; q2 = P1; minnum = temp; } } P2 = P1;P1 = 0; } else { P1 = num[i]; } } printf(&quot;%d %d %d %d\n&quot;,q1,q1,q2,q2); //cout &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; endl; } return 0; } D.每个房间都有出度…所以最后每个房间都可以归结于某个连通分量之中，求出这个连通分量中的最小的c就是这个连通分量的答案，但是还要注意那些a[i]=i的点，这种房间一定要在自己那里放一个。跑跑tarjan就完了。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; int dfn[maxn],low[maxn],scccnt=0,sccindex=0,belong[maxn]; bool instack[maxn]; stack&lt;int&gt;sta; vector&lt;int&gt;G[maxn]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v); } } int outdegree[maxn],c[maxn]; int minn[maxn],size1[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i]); long long ans=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);outdegree[i]++; if(j==i)ans+=c[i]; } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) size1[belong[i]]++; memset(minn,0x3f,sizeof(minn)); for(i=1;i&lt;=n;i++){ if(size1[belong[i]]&lt;=1)continue; minn[belong[i]]=min(minn[belong[i]],c[i]); } for(i=1;i&lt;=n;i++){ if(minn[i]!=0x3f3f3f3f) ans+=minn[i]; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. 题意大概是构造一个n* n的矩阵，要求满足相邻行与相邻列之间要么完全相同，要么完全相反。且不存在面积大于等于k的子矩阵颜色完全相同。 首先可以发现一个事实：一旦第一行第一列确定了，那么整个图的染色方案也就确定了。那么我们就可以设法去求第一行的染色方案（第一列跟第一行是一样的） 这可以用dp来求 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 510; const int mod = 998244353; ll f[maxn][maxn][2];//位置，连续数量，颜色； ll num[maxn]; int main() { //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, k,i,j,q; cin &gt;&gt; n &gt;&gt; k; for (q = 1; q &lt;= n; q++) { memset(f, 0, sizeof(f)); f[1][1][0] = f[1][1][1] = 1; for (i = 2; i &lt;= n; i++) {//位置 for (j = 1; j &lt;= min(i,q); j++) {//连续数量 f[i][1][1] += f[i - 1][j][0];//连续长度为1,那么前一个位置的颜色一定与这个位置不同 f[i][1][0] += f[i - 1][j][1]; f[i][j][1] += f[i - 1][j - 1][1];//与前一个位置颜色相同 f[i][j][0] += f[i - 1][j - 1][0]; f[i][1][0] %= mod; f[i][1][1] %= mod; f[i][j][0] %= mod; f[i][j][1] %= mod; } } for (i = 1; i &lt;= q; i++) { num[q] += f[n][i][0] + f[n][i][1]; num[q] %= mod; } } for (i = n; i &gt;= 2; i--) { num[i] = num[i] - num[i - 1] + mod;//减去不是这个长度的 数量 num[i] %= mod; } ll ans = 0; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { if (i*j &gt;= k)break;//如果这个矩形的面积大于等于k ans += num[i] * num[j]; ans %= mod; } } if (ans % 2 == 1)ans = (ans + mod) / 2;//答案是要除以2的(重复), // 但是模数是奇数且之前多次取模,因此如果答案是奇数,应该变成偶数再除以2 else ans /= 2; cout &lt;&lt; ans &lt;&lt; endl; return 0; } F. 有n个考试，每个考试有两个可以通过的日期，每天只能通过一个考试，问如何安排可以尽早完成所有考试。 暴力二分网络流是没错的，但是会t。但是可以从中得到启发，我们可以对每个考试的两天，先选择那个比较小的天，然后从比较小的天向比较大的天连一条边，表示选择的这一天也可以换成比较大的那一天。如果某个考试即使转移了以后也没法完成的话，就是没有可行解了。代码中利用了类似并查集的方式来维护转移； #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+50; struct e{ int x,y; }G[maxn]; bool cmp1(e a,e b) { return a.x&lt;b.x; } bool cmp2(e a,e b) { return a.y&lt;b.y; } int anotherchoice[maxn*2]; int find(int x) { return x==anotherchoice[x]?x:anotherchoice[x]=find(anotherchoice[x]); } int main() { int cnt=0,i,j,k,n; cin&gt;&gt;n; int ys[maxn*2]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;G[i].x,&amp;G[i].y);ys[++cnt]=G[i].x;ys[++cnt]=G[i].y; } sort(ys+1,ys+1+cnt); cnt=unique(ys+1,ys+1+cnt)-ys;int pos; sort(G+1,G+n+1,cmp1);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].x==ys[i])G[pos++].x=i; sort(G+1,G+n+1,cmp2);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].y==ys[i])G[pos++].y=i;//离散化,同时保证原大小关系不会改变 for(i=1;i&lt;=cnt;i++)anotherchoice[i]=i;//开始的时候每个日期的选择都只有自己 int ans=0; for(i=1;i&lt;=n;i++){ int ch1,ch2; ch1=find(G[i].x);ch2=find(G[i].y); if(!ch1&amp;&amp;!ch2){//如果这个考试的两个日期都没有选择了,那么显然无法完成 puts(&quot;-1&quot;);return 0; } else if(ch1==ch2||!ch1||!ch2){//如果这个考试只有一个可用的日期,那么显然只能唯一选择 ans=max(ans,max(ch1,ch2));anotherchoice[ch1]=anotherchoice[ch2]=0; } else{//考试有两个选择,那么先选那个日期比较小的,同时标记一下日期比较小的那题还有一个日期比较大的选择 ans=max(ans,min(ch1,ch2));anotherchoice[min(ch1,ch2)]=max(ch1,ch2); } } cout&lt;&lt;ys[ans]&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）快速读入]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e8-af-bb-e5-85-a5%2F</url>
    <content type="text"><![CDATA[与scanf，cin冲突（输出没问题），可返回EOF。 const int BufferSize=1&lt;&lt;16; char buffer[BufferSize],*fronthead,*fronttail; inline char GET_CHAR(){ if(fronthead==fronttail){ int l=fread(buffer,1,BufferSize,stdin); fronttail=(fronthead=buffer)+l; if(fronthead==fronttail)return EOF; } return *fronthead++; } inline int READ(){ int x=0,f=1;char c=GET_CHAR(); for(;!isdigit(c);c=GET_CHAR()){ if(c==EOF)return EOF; if(c==&apos;-&apos;)f=-1; } for(;isdigit(c);c=GET_CHAR())x=(((x&lt;&lt;2)+x)&lt;&lt;1)+c-&apos;0&apos;; return x*f; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #5]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-5%2F</url>
    <content type="text"><![CDATA[A.Gym - 101606L Lizard Lounge其实就是算出各个点位于哪条直线上，然后对每条直线算算LIS的问题…（就是把同一条直线上的蜥蜴丢到一起。我们用斜率来判断他们是不是在同一条直线上。之后要把他们按照在房间里的次序来排序，也就是按到显示器的距离来排序。）但是写起来有坑，首先斜率相同的点可能在tx，ty的两侧，他们是互不影响的。其次，直接算斜率会有精度问题。最后，算完斜率以后点的排序也要注意。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;P; const int maxn=1e6+10; map&lt;P,int&gt; mp1; vector&lt;P&gt;G[maxn]; int cnt=0; int gcd(int a,int b) { return b?gcd(b,a%b):a; } ll lenth(int x,int y) { return (ll)x*x+(ll)y*y; } void sit(int x, int y, int h) { ll d = lenth(x, y); if (x == 0) y /= abs(y); else if (y == 0) x /= abs(x); else { int z = gcd(abs(x), abs(y)); x /= z, y /= z; } if (mp1.count(P(x, y)) == 0) mp1[P(x, y)] = ++cnt; G[mp1[P(x, y)]].push_back(P(d, h)); } int main() { int tx, ty, n, i, j, k, x, y, h; cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; n; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;h); x -= tx;y -= ty; sit(x, y, h); } int ans = 0; int f[maxn], a[maxn]; for (i = 1; i &lt;= cnt; i++) { sort(G[i].begin(), G[i].end()); int len = G[i].size(); for (j = 0; j &lt; len; j++) a[j] = G[i][j].second, f[j + 1] = 1 &lt;&lt; 30; for (j = 0; j &lt; len; j++) { *lower_bound(f + 1, f + 1 + len, a[j]) = a[j]; } ans += lower_bound(f + 1, f + 1 + len, 1 &lt;&lt; 30) - f - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } B.CodeForces - 977D如果一个数是另一个数的两倍，或者是另一个数除以3的结果，那么就可以从那个数引一条边指向这个数，将问题转为一个有向图拓扑排序的问题即可解决了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { vector&lt;int&gt;G[105];int indegree[105]={0}; int n,i,j,k; cin&gt;&gt;n; ll num[105]; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;num[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ if(i==j)continue; if(num[j]==num[i]*2||(num[i]%3==0&amp;&amp;num[j]==num[i]/3)){ G[i].push_back(j);indegree[j]++; } } queue&lt;int&gt;que; for(i=1;i&lt;=n;i++)if(indegree[i]==0)que.push(i); int cnt=0; while(!que.empty()){ i=que.front();que.pop(); cout &lt;&lt; num[i] &lt;&lt; &apos; &apos;; for (j = 0; j &lt; G[i].size(); j++) { k = G[i][j]; indegree[k]--; if(!indegree[k])que.push(k); } } return 0; } D.CodeForces - 959D首先，不管b中的数字怎么放，要使得b中的数两两互质，那么每次往b里面丢一个数，这个数的约数的所有倍数都必须从可选集里滚蛋。因为b的字典序必须大于a且最小，所以如果有一个位置b比a大，那么后面的位置中尽量放最小的可放的数即可。基于这种考虑，我们首先使用类似埃氏筛的方法预处理出所有数的约数，然后每次先查找大于等于a的字典序最小的可选数，然后把这个数的所欲约数的倍数干掉。如果这个数&gt;a,那么GG，后面只要放最小的可放的数即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e6+5; bool isnot[N],erase1[N]; set&lt;int&gt;s; vector&lt;int&gt;G[N]; void getys(void) { for(int i=2;i&lt;N;i++){ //if(isnot[i])continue; if(!isnot[i]) { for (int j = i; j &lt; N; j += i) { isnot[j] = true; G[j].push_back(i); } } s.insert(i); } } int main() { int n,i,j,k; cin&gt;&gt;n; getys();bool islarge=false; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d&quot;,&amp;a);b=*s.begin(); if(!islarge) { b = *s.lower_bound(a); if(b!=a)islarge=true; } cout&lt;&lt;b&lt;&lt;&apos; &apos;; for(int j:G[b]){ if(erase1[j])continue; for(k=j;k&lt;N;k+=j){ if(!erase1[k]){ s.erase(k);erase1[k]=true; } } } } return 0; } E.CodeForces - 931B签到 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,a,b,cnt,i,j; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(i=0;;i++){ if(!(n&gt;&gt;i))break; } cnt=i-1;int cnt1=0; while(a!=b){ a=(a+1)&gt;&gt;1;b=(b+1)&gt;&gt;1;cnt1++; } if(cnt1==cnt)cout&lt;&lt;&quot;Final!&quot;&lt;&lt;endl; else cout&lt;&lt;cnt1&lt;&lt;endl; return 0; } F.CodeForces - 731F一个前缀和sum[i]记录小于等于I的个数，将序列排序，去重。枚举每一个数为“基数”，判断他[n倍—-(n+1) )倍（左闭右开，n从1开始）之间数的个数，这些数是要变成n* 基数的。记录和，记录最大值。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sum[200005],a[200005]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum[a[i]]++; } sort(a+1,a+1+n); int cnt=unique(a+1,a+1+n)-a-1; for(i=1;i&lt;=200000;i++) sum[i]+=sum[i-1];//记得变成前缀和 ll ans=0; for(i=1;i&lt;=cnt;i++){ ll val=0; for(j=1;a[i]*j&lt;=200000;j++){ int t1=a[i]*j,t2=a[i]*(j+1)&gt;200000?200000:a[i]*(j+1)-1;//注意区间的问题 int tot=sum[t2]-sum[t1-1]; val+=(ll)tot*t1; } ans=max(ans,val); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } G.CodeForces - 570D题目的朴素写法还是很好写的…但是数据规模过大导致必t无疑… 于是我们想到了离线处理，一次dfs… 但是依然不好做，这里我们处理的做法是利用异或…每次搜索到一个点的时候先把各个答案要问的深度的字母情况给保存起来，然后搜索这个节点下面子树各个深度的字母情况，最后再给每个答案异或一下，就可以得出这个节点下面的情况….emm,感觉不太好描述，总之还是挺巧妙的… #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500005; char node[maxn]; vector&lt;int&gt;G[maxn],query[maxn]; int dep[maxn],ans[maxn],tardep[maxn]; void dfs(int x,int depth) { for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//首先先把这个深度的字母个数情况保存起来 for (auto b:G[x]) dfs(b, depth + 1);//然后统计在当前节点下各个深度的字母情况,并更新dep数组 dep[depth] ^= (1 &lt;&lt; (int) (node[x] - &apos;a&apos;)); for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//新的dep数组异或旧的dep数组,就可以得出当前节点的子树中各个深度的字母情况 } bool check(int x) { int cnt=0; while(x){ cnt++;x-=x&amp;-x; } if(cnt&gt;1)return false; return true; } int main() { int n, m,i,j; cin&gt;&gt;n&gt;&gt;m; for (i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); G[j].push_back(i);//保存树 } scanf(&quot;%s&quot;, node + 1); for (i = 1; i &lt;= m; i++) { int v,h; scanf(&quot;%d%d&quot;, &amp;v, &amp;h); query[v].push_back(i);//离线处理问询 tardep[i] = h;//保存问询深度 } dfs(1, 1); for (i = 1; i &lt;= m; i++) { if(!check(ans[i]))//如果ans的二进制表示中有超过一个位置是1 printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #4]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-4%2F</url>
    <content type="text"><![CDATA[A.CodeForces 791D首先，先考虑一个问题：如何计算一棵树中所有点对之间的距离和。对于任意一个点，我们可以发现，如果这个点的子树的大小为$s$的话，那么这个点与其祖先之间的那条边在计算总和的过程中一定会被计算$(n-s)\times s$次（n为总的节点数）。但是目前有一个问题，就是每次只能走k步，比如说k=4，而距离为10，那就需要3步，此时如果直接求出总的距离之和去除以k，答案肯定是错误的。因此我们在dfs到每个节点的时候，还要计算他的各个子节点之间的距离，然后把所有mod k有余数的距离与k的倍数的差值都给补上。最后距离总和除以k即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5 + 50; ll n,k,ans=0,size[maxn][5],cntsub[maxn];//size代表节点x的距离它的距离为i的子节点的个数,cnt则为节点想的子树个数和 vector&lt;int&gt;G[maxn]; void dfs(ll x,ll fa,ll sit)//x为节点ID,fa为节点祖先,sit为当前节点到顶点的距离mod k { cntsub[x] = size[x][sit % k] = 1; ll i, j; for (auto a : G[x]) { if (a == fa)continue; dfs(a, x, sit + 1); for (i = 0; i &lt; k; i++) {//枚举到子节点的距离 for (j = 0; j &lt; k; j++) { ll t = (k - (i + j - 2 * (sit % k)) % k) % k; ans += t * size[x][i] * size[a][j]; } } for (i = 0; i &lt; k; i++)size[x][i] += size[a][i]; cntsub[x] += cntsub[a]; } ans += cntsub[x] * (n - cntsub[x]);//x与祖先连边被计算的次数 } int main() { int i, j, u, v; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, 0, 0); cout &lt;&lt; ans / k &lt;&lt; endl; return 0; } B.CodeForces - 2B求矩阵路径上数字的积末尾最少的0个数。那么其实就是统计路径上最少的2个数与5个数，取其中比较小的即可。有个问题就是路径中如果有0，那么就需要特判答案到底是1还是0了。路径输出的时候稍微要点小技巧，没了。 #include&lt;bits/stdc++.h&gt; using namespace std; int get2(int x) { int cnt=0; while(x&amp;&amp;x%2==0){ cnt++;x/=2; } return cnt; } int get5(int x) { int cnt=0; while(x&amp;&amp;x%5==0){ cnt++;x/=5; } return cnt; } int num[1005][1005]; typedef pair&lt;int,char&gt;P; P dp2[1005][1005],dp5[1005][1005]; int main() { int i,j,k,n; cin&gt;&gt;n; memset(dp2,0x3f, sizeof(dp2));memset(dp5,0x3f,sizeof(dp5)); int move1[2][2]={1,0,0,1}; bool haszero=false;int zerox,zeroy; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) { scanf(&quot;%d&quot;, &amp;num[i][j]); if(!num[i][j]){ haszero=true;zerox=i,zeroy=j; } } if(num[1][1]) { dp2[1][1].first = get2(num[1][1]), dp5[1][1].first = get5(num[1][1]); } else{ dp2[1][1].first=dp5[1][1].first=1; } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ //if(i==1&amp;&amp;j==1)continue; for(k=0;k&lt;2;k++){ int a=i+move1[k][0],b=j+move1[k][1]; if(num[a][b]==0){ dp2[a][b].first=0;dp5[a][b].first=0; } else { if (dp2[a][b].first &gt; dp2[i][j].first + get2(num[a][b])) { dp2[a][b].first = dp2[i][j].first + get2(num[a][b]); if (k)dp2[a][b].second = &apos;R&apos;; else dp2[a][b].second = &apos;D&apos;; } if (dp5[a][b].first &gt; dp5[i][j].first + get5(num[a][b])) { dp5[a][b].first = dp5[i][j].first + get5(num[a][b]); if (k)dp5[a][b].second = &apos;R&apos;; else dp5[a][b].second = &apos;D&apos;; } } } } int ans=1&lt;&lt;30; int sit=0; //cout&lt;&lt;dp2[n][n].first&lt;&lt;&apos; &apos;&lt;&lt;dp5[n][n].first&lt;&lt;endl; if(haszero&amp;&amp;dp2[n][n].first&gt;1&amp;&amp;dp5[n][n].first&gt;1){ ans=1;sit=1; } else{ if(dp2[n][n].first&gt;dp5[n][n].first){ ans=dp5[n][n].first;sit=3; } else{ ans=dp2[n][n].first;sit=2; } } cout&lt;&lt;ans&lt;&lt;endl; vector&lt;char&gt;way; if(sit==1){ for(i=1;i&lt;zerox;i++)way.push_back(&apos;D&apos;); for(j=1;j&lt;n;j++)way.push_back(&apos;R&apos;); for(i=zerox;i&lt;n;i++)way.push_back(&apos;D&apos;); } else if(sit==2){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp2[i][j].second); if(dp2[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } else if(sit==3){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp5[i][j].second); if(dp5[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } for(auto a:way) cout&lt;&lt;a; return 0; } C.CodeForces - 527A签到 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll ans=0; void cal(ll x,ll y) { if(!y)return; ans+=x/y;x%=y; cal(y,x); } int main() { ll a,b; cin&gt;&gt;a&gt;&gt;b; cal(a,b); cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.CodeForces - 785B主要考察英语阅读理解能力，注意先上哪个课程是不确定的。傻逼题* 2 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,ans,i,j,a,b,amin=0,amax=1&lt;&lt;30,bmin=0,bmax=1&lt;&lt;30; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); amin = max(amin, a); amax = min(amax, b); } cin&gt;&gt;m; for(i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); bmin = max(bmin, a); bmax = min(bmax, b); } ans=max(amin-bmax,bmin-amax); cout&lt;&lt;(ans&gt;=0?ans:0)&lt;&lt;endl; return 0; } F.CodeForces - 57C首先，注意到一点：每一个不下降数列反过来就是一个不上升数列，因此我们只要计算出不下降数列的个数，乘2，减去n（所有数字相同的数列个数），就是答案了。 然后，第一位肯定是要放一个数的，我们姑且不管。那么在后面的n-1个位置上，我们可以任意取若干个“上升点”，也就是这个点放的数比前面的数要来的大，相邻“上升点”之间的数字的值是相同的。在n-1个位置中选k个上升点，方案数是$C_{n-1}^{k}$,然后，选定k个上升点，那么我们这个数列中就需要k+1个不同的数（还记得第一位么？），会发现，任意选择1~n中的k+1个数，他都对应着唯一的一种排列方案，所以，总的答案就是$\sum_{i=0}^{n-1}C_{n-1}^{i}\times C_n^{i+1}$,算算组合数算算逆元就ok了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; const int maxn=1e5+10; ll c1[maxn],inv[maxn],jc[maxn],c2[maxn]; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int i,j,k,n; cin&gt;&gt;n; jc[1]=1;inv[1]=1,inv[0]=1; for(i=2;i&lt;=n;i++) jc[i]=jc[i-1]*i%mod,inv[i]=pow(jc[i],mod-2,mod); for(i=1;i&lt;=n;i++) { c1[i] = (jc[n - 1] * inv[i] % mod * inv[n - 1 - i]) % mod; c2[i] = (jc[n] * inv[i] % mod * inv[n - i]) % mod; } c1[0]=1;c2[0]=1; ll ans=0; for(i=0;i&lt;n;i++) ans=(ans+c1[i]*c2[i+1])%mod; ans=(ans+ans-n)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } I.HackerRank - game-with-cells傻逼题* 3 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; if(n&amp;1)n=n/2+1; else n&gt;&gt;=1; if(m&amp;1)m=m/2+1; else m&gt;&gt;=1; cout&lt;&lt;n*m&lt;&lt;endl; return 0; } J.CodeForces - 145C 给出一个长度为n的序列ai，问其长度为k的子序列中，同一个幸运数字至多出现一次的子序列个数，幸运数字即为全部由4和7组成的数字 假设有$res$个不同的幸运数字，有$sum$个非幸运数字，第$i$个幸运数字在原序列中出现了$num[i]$次，用$dp[i][j]$表示从前$i$个幸运数字中选$j$个的方案数，那么易得转移方程$dp[i][j]=dp[i−1][j]+num[i]⋅dp[i−1][j−1]$，之后枚举子序列中非幸运数字个数即可得到答案$ans=\sum_{i=0}^{min(k,sum)}C_{sum}^{i}\times dp[res][k-i]$。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+10; const int mod=1e9+7; ll fac[maxn],dp[3000][3000]; bool islucky(int v)//判断是否lucky number { while (v) { if (v % 10 != 4 &amp;&amp; v % 10 != 7) return false; v /= 10; } return true; } ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } ll C(ll v, ll u) { if (v &lt; u) return 0; ll x = (fac[u] * fac[v - u]) % mod; return (fac[v] * pow(x, mod - 2,mod)) % mod; } int main() { int i, j, n, k,sum=0;ll ans=0; cin&gt;&gt;n&gt;&gt;k; map&lt;int,int&gt;mp1; fac[0] = 1; for (i = 1; i &lt;= n; i++) fac[i] = (fac[i - 1] * i) % mod; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); if (islucky(j)) mp1[j]++;//统计幸运数个数 else sum++; } dp[0][0] = 1;i = 1; for (auto it = mp1.begin(); it != mp1.end(); it++, i++) for (j = 0; j &lt; i; j++) { dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod; dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j] * it-&gt;second) % mod; } int cnt = mp1.size(); for (i = 0; i &lt;= cnt &amp;&amp; i &lt;= k; i++) ans = (ans + (dp[cnt][i] * C(sum, k - i)) % mod) % mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } K.CodeForces - 691B难点在于如何找出所有对称的字符，傻逼题* 4 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(char x, char y) { if (x == &apos;A&apos; &amp;&amp; y == &apos;A&apos;||x == &apos;H&apos; &amp;&amp; y == &apos;H&apos;||x == &apos;I&apos; &amp;&amp; y == &apos;I&apos;||x == &apos;M&apos; &amp;&amp; y == &apos;M&apos;||x == &apos;O&apos; &amp;&amp; y == &apos;O&apos;) return true; if (x == &apos;T&apos; &amp;&amp; y == &apos;T&apos;||x == &apos;U&apos; &amp;&amp; y == &apos;U&apos;||x == &apos;V&apos; &amp;&amp; y == &apos;V&apos;||x == &apos;W&apos; &amp;&amp; y == &apos;W&apos;||x == &apos;X&apos; &amp;&amp; y == &apos;X&apos;) return true; if (x == &apos;Y&apos; &amp;&amp; y == &apos;Y&apos;||x == &apos;v&apos; &amp;&amp; y == &apos;v&apos;||x == &apos;w&apos; &amp;&amp; y == &apos;w&apos;||x == &apos;x&apos; &amp;&amp; y == &apos;x&apos;||x == &apos;o&apos; &amp;&amp; y == &apos;o&apos;) return true; if (x == &apos;p&apos; &amp;&amp; y == &apos;q&apos;||x == &apos;q&apos; &amp;&amp; y == &apos;p&apos;||x == &apos;b&apos; &amp;&amp; y == &apos;d&apos;||x==&apos;d&apos;&amp;&amp;y==&apos;b&apos;) return true; return false; } int main() { string str1,str2; cin&gt;&gt;str1;str2=str1; reverse(str2.begin(),str2.end()); for(int i=0;i&lt;str1.size();i++){ if(!check(str1[i],str2[i])){ cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Tarjan]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2FTarjan%2Fe6-a8-a1-e6-9d-bf-ef-bc-89tarjan%2F</url>
    <content type="text"><![CDATA[要注意的就是那些单独的点每个点都会被当做自身一个强联通分量，也就是有不少的强连通分量里面可能只有一个元素…… int dfn[105],low[105],scccnt=0,sccindex=0,belong[105]; bool instack[105]; stack&lt;int&gt;sta; vector&lt;int&gt;G[105]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i;//理论上用c++11的特性会比G[v].size()快一些; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v);//一定要注意这里并不是要把整个栈清空,只是要把属于当前联通分量的元素全部清空 } } 主函数中调用： int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ while(cin&gt;&gt;j&amp;&amp;j) G[i].push_back(j); } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小路径覆盖]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b7-af-e5-be-84-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[对于一个给定的有向无环图（DAG），求其最小路径覆盖。题目可参见洛谷P2764。 【问题分析】 有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 【建模方法】 构造二分图，把原图每个顶点i拆分成二分图X，Y集合中的两个顶点Xi和Yi。对于原图中存在的每条边(i,j)，在二分图中连接边(Xi,Yj)。然后把二分图最大匹配模型转化为网络流模型，求网络最大流。 最小路径覆盖的条数，就是原图顶点数，减去二分图最大匹配数。沿着匹配边查找，就是一个路径上的点，输出所有路径即可。 【建模分析】 对于一个路径覆盖，有如下性质： 1、每个顶点属于且只属于一个路径。 2、路径上除终点外，从每个顶点出发只有一条边指向路径上的另一顶点。所以我们可以把每个顶点理解成两个顶点，一个是出发，一个是目标，建立二分图模型。该二分图的任何一个匹配方案，都对应了一个路径覆盖方案。如果匹配数为0，那么显然路径数=顶点数。每增加一条匹配边，那么路径覆盖数就减少一个，所以路径数=顶点数 - 匹配数。要想使路径数最少，则应最大化匹配数，所以要求二分图的最大匹配。注意，此建模方法求最小路径覆盖仅适用于有向无环图，如果有环或是无向图，那么有可能求出的一些环覆盖，而不是路径覆盖。 洛谷题目参考代码： // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; struct edge { int to, cap, rev; }; vector&lt;edge&gt;G[500]; int level[500], iter[500]; int n, m; void addedge(int from, int to, int cap) { edge e; e.to = to; e.cap = cap; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.rev = G[from].size() - 1;//一定要小心反向边的cap为0！！！ G[to].push_back(e); } void bfs(int s) { memset(level, -1, sizeof(level));//每次bfs的时候构图都不同，要memset queue&lt;int&gt;que; level[s] = 0; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;level[e.to] &lt; 0) { level[e.to] = level[t] + 1; que.push(e.to); } } } } int dfs(int v, int t, int f) { if (v == t) return f; for (int &amp;i = iter[v]; i &lt; G[v].size(); i++) {//因为每次dfs的时候如果找到解就return了，所以有必要记录上次这个点搜到哪了 edge &amp;e = G[v][i]; if (e.cap&amp;&amp;level[e.to] &gt; level[v]) { int d = dfs(e.to, t, min(f, e.cap)); if (d) { e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } return 0; } int maxflow(int s, int t) { int flow = 0; for (;;) { bfs(s); if (level[t] &lt; 0)//说明此时已经不存在没有搜过的路了 return flow; memset(iter, 0, sizeof(iter)); int f; while (f = dfs(s, t, 1 &lt;&lt; 30))//要搜完当期状况下的所有可能 flow += f; } } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m ; for (i = 1; i &lt;= m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); addedge(a, b+150, 1); } for (i = 1; i &lt;= n; i++) { addedge(0, i, 1); addedge(i+150, 400, 1); } int ans = n - maxflow(0, 400); bool vis[500]; memset(vis, 0, sizeof(vis)); for (i = 1; i &lt;= n; i++) { if (!vis[i]) { cout &lt;&lt; i; int k = i; for (;;) { bool find = false; for (j = 0; j &lt; G[k].size(); j++) { if (G[k][j].cap == 0&amp;&amp;G[k][j].to&gt;150) { cout &lt;&lt; &quot; &quot; &lt;&lt; G[k][j].to-150; k = G[k][j].to - 150; vis[k] = true; find = true; break; } } if (!find)break; } cout &lt;&lt; endl; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小生成树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[Kruskal最重要的还是记得并查集要初始化！！ // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=1e6,M=1e6; int par[N]; struct edge{ int from,to,len; bool operator&lt;(const edge&amp;v)const{ return len&lt;v.len; } }G[M]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } bool unite(int x,int y) { x=find(x);y=find(y); if(x==y)return false; par[x]=y;return true; } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)par[i]=i; for(i=1;i&lt;=m;i++){ cin&gt;&gt;G[i].from&gt;&gt;G[i].to&gt;&gt;G[i].len; } sort(G+1,G+1+m); int cnt=0,ans=0; for(i=1;i&lt;=m;i++){ if(unite(G[i].from,G[i].to)) cnt++,ans+=G[i].len; if(cnt==n-1)break; } if(cnt&lt;n-1)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; return 0; } Prim算法跟Dijkstra很像 ，但是要特别注意两点： 1.最好使用一个额外的数组来保证每个点只被访问一次，否则的话应该保证在35行处使用e.dis&gt;=dis[e.num]而不仅是&gt;，否则会造成一些相等的额外相加。 2.40行的地方要注意与Dijkstra的区别！！不是加而是直接换！！！ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); G[b].push_back(edge{a,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[1]=0; priority_queue&lt;d&gt;que;que.push(d{1,0}); int ans=0; while(!que.empty()){ d t=que.top();que.pop(); if(vis[t.num])continue;//如果不用额外数组这里要注意 ans+=t.dis;vis[t.num]=true; for(i=0;i&lt;G[t.num].size();i++){ edge e=G[t.num][i]; if(dis[e.to]&gt;e.cost){ dis[e.to]=e.cost;//注意这里与Dijkstra的区别 que.push(d{e.to,dis[e.to]}); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>最小生成树</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）SPFA]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89spfa%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; bool inque[maxn]; int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; int dis[maxn]; for(i=1;i&lt;=n;i++)dis[i]=(1&lt;&lt;31)-1; dis[s]=0; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } queue&lt;int&gt;que;que.push(s);//inque[s]=true; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Dijkstra]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89dijkstra%2F</url>
    <content type="text"><![CDATA[自定义结构体#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{//记录各种被松弛后的点 int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[s]=0; priority_queue&lt;d&gt;que; que.push(d{s,0}); while(!que.empty()){ d e=que.top();que.pop(); if(e.dis&gt;dis[e.num])continue;//这里也可以利用一个额外的数组来保证每个点只被访 //问一次，或者说最短距离已经确定的点不再被更改 for(int i=0;i&lt;G[e.num].size();i++){ edge eg=G[e.num][i]; if(dis[eg.to]&gt;dis[e.num]+eg.cost){ dis[eg.to]=dis[e.num]+eg.cost; que.push(d{eg.to,dis[eg.to]}); } } } return 0; } using pair#include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; using namespace std; const int maxn=1e5+5; typedef struct { int to, cost; }Edge; vector&lt;Edge&gt;edge[maxn]; typedef pair&lt;int, int&gt;P; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;q;//从小到大的优先队列 int book[maxn], dis[maxn]; int main(void) { int n, m, s, i, j; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); fill(dis, dis + n+1, 2147483647); dis[s] = 0; for (i = 1; i &lt;= m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge temp; temp.to = b; temp.cost = c; edge[a].push_back(temp); } P p; p.first = 0; p.second = s; q.push(p); while (!q.empty()) { P p = q.top(); q.pop(); if (book[p.second] == 1) continue; book[p.second] = 1; for (i = 0; i &lt; edge[p.second].size(); i++) { Edge temp = edge[p.second][i]; if (dis[temp.to] &gt; dis[p.second] + temp.cost) { dis[temp.to] = dis[p.second] + temp.cost; P p1; p1.first = dis[temp.to]; p1.second = temp.to; q.push(p1); } } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）Floyd算法（多源最短路）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89floyd-e7-ae-97-e6-b3-95-ef-bc-88-e5-a4-9a-e6-ba-90-e6-9c-80-e7-9f-ad-e8-b7-af-ef-bc-89%2F</url>
    <content type="text"><![CDATA[需要注意的就是因为每次是拿一个点出来考虑能否把别的路变短，所以k一定是最外层循环。以及要记得初始化为无穷大或无穷小。 可以通过检查是否有dis[i][i]&lt;0来判定是否有负环存在 int dis[105][105]; memset(dis,0x7f,sizeof(dis)); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;dis[i][j]; for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）并查集]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-b9-b6-e6-9f-a5-e9-9b-86%2F</url>
    <content type="text"><![CDATA[两件事：记得初始化par，以及，路径压缩别写错了… int par[1005];//记得初始化！ int find(int x) { return par[x]==x?x:par[x]=find(par[x]);//后面这一块不要漏了par[x],否则就是不带路径压缩! } bool unite(int x,int y) { x=find(x),y=find(y); if(x==y)return false; par[x]=y; return true; } 按秩合并： int find(int x) { if (x == par[x]) return x; else return par[x] = find(par[x]);//后面这一块不要漏了par[x]!!!否则就是不带路径压缩(有时候有用） } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) { par[x] = y; } else { par[y] = x; if (rank[x] == rank[y]) rank[x]++; } } 一定要加上： for(i=1;i&lt;=n;i++){ par[i]=i; }!!!!!!]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）SG函数小结]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89sg-e5-87-bd-e6-95-b0-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[说是小结，其实我并没有怎么弄懂QAQ，简单写写概念跟板子吧… Sprague-Grundy函数给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有Impartial Combinatorial Games的抽象模型。也就是说，任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。 基本概念下面我们就在有向无环图的顶点上定义Sprague-Garundy函数。 首先定义$mex$(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如$mex[0,1,2,4]=3,mex[2,3,5]=0,mex[]=0$。 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数$g$如下：$g(x)=mex[ g(y) | y是x的后继 ]$。 SG函数的性质首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。 对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。 对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。 P 以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了。 我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。 再考虑一个性质：任何一个ICG都可以抽象成一个有向图游戏。所以“SG函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每个ICG的每个position定义SG值，也可以定义n个ICG的和。所以说当我们面对由n个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个局面的SG值的方法，就可以把这些SG值全部看成Nim的石子堆，然后依照找Nim的必胜策略的方法来找这个游戏的必胜策略了！（Nim其实就是n个从一堆中拿石子的游戏求SG的变型，总SG=n个sg的异或）。 模板1.把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的异或。即$sg(G)=sg(G1)\oplus sg(G2)\oplus …\oplus sg(Gn)$。 2.分别考虑没一个子游戏，计算其SG值。1.可选步数为1~m的连续整数，直接取模即可，$SG(x) = x \ mod\ (m+1)$; 2.可选步数为任意步，$SG(x) = x$; 3.可选步数为一系列不连续的数，用模板计算。 模板1：打表 #include&lt;bits/stdc++.h&gt; using namespace std; //f[]：可以取走的石子个数 //sg[]:0~n的SG函数值 //Mex[]:mex{} int f[N],sg[N],Mex[N]; void getSG(int n) { int i, j; memset(sg, 0, sizeof(sg)); for (i = 1; i &lt;= n; i++) { memset(Mex, 0, sizeof(Mex)); for (j = 1; f[j] &lt;= i; j++) Mex[sg[i - f[j]]] = 1; for (j = 0; j &lt;= n; j++) //求mes{}中未出现的最小的非负整数 { if (Mex[j] == 0) { sg[i] = j; break; } } } } 模板2：dfs //注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍 //n是集合s的大小 S[i]是定义的特殊取法规则的数组 int s[110],sg[10010],n; int SG_dfs(int x) { int i; if(sg[x]!=-1) return sg[x]; bool vis[110];//bool数组一定要放在里面 memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) { if(x&gt;=s[i]) { SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; } } int e; for(i=0;;i++) if(!vis[i]) { e=i; break; } return sg[x]=e; } 一般DFS只在打表解决不了的情况下用，首选打表预处理。 还有一种dfs，题目给出的不是移动次数，而是可以移动的操作，类似于给定一幅有向图，知道下一步有哪些操作是可选的（参见HDU1524） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[1005]; int sg[1005]; int dfs(int x) { if(sg[x]!=-1) return sg[x]; bool vis[1005]={false}; for(int i=0;i&lt;G[x].size();i++){ vis[dfs(G[x][i])]=true; } for(int i=0;;i++) if(!vis[i]) return sg[x]=i; } int main() { int n,i,j,k,x,m; while(cin&gt;&gt;n){ for(i=0;i&lt;=1000;i++)G[i].clear(); memset(sg,-1,sizeof(sg)); for(i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;x); while(x--){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);//加边,下一步可以做的操作 } } while(scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m){ int ans=0; for(i=0;i&lt;m;i++){ scanf(&quot;%d&quot;,&amp;j); if(sg[j]!=-1) ans^=sg[j]; else ans^=dfs(j); } if(ans)puts(&quot;WIN&quot;); else puts(&quot;LOSE&quot;); } } return 0; } 3.计算$sg(G)=sg(G1)\oplus sg(G2)\oplus …\oplus sg(Gn)$，若$sg(G)=0$,即P-Position,即先手比败。]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #450 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-450-div-2%2F</url>
    <content type="text"><![CDATA[A.弱智题 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x,y,cnt[2]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&lt;0)cnt[0]++; else cnt[1]++; } if(cnt[0]&lt;=1||cnt[1]&lt;=1){ puts(&quot;Yes&quot;); } else puts(&quot;No&quot;); return 0; } B.首先要知道一个结论：对于$a/b$,他的小数部分的循环节长度不会超过$b$，所以我们只要检查小数点后的最多$b$位就可以知道$c$是否有出现过了。然后关键就是如何求小数点后的位数了。这个可以用长除法来做，具体思想其实就是不断把被除数乘10然后除以除数获得下一位小数位（相当于不断地将小数点右移一位），写写就明白了。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c,i,j,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=1;i&lt;=b;i++){ if(a*10/b==c){ cout&lt;&lt;i&lt;&lt;endl;return 0; } a=a*10%b; } cout&lt;&lt;-1&lt;&lt;endl; return 0; } C.其实很容易想到一个贪心的想法，就是从前往后扫一遍，对于每个数，如果前面恰好有一个数大于等于当前数，那么那个数的“删除值”就应该+1，然后找出”删除值“最大的数即可。但是还有一个问题就是每个数同时可能本身也是一个”record”，所以对于每个数，如果他是”record”，那么他的删除值就是1，然后每次找到一个后面的数要删除这个数，那么他的删除值就-1，最后找出删除值最小的数即可（初始删除值都为0） #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k,maxn=0,ans=0,premaxn=0; cin&gt;&gt;n; int num[100005],pos[100005]={0}; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]&gt;maxn){ pos[i]=1; premaxn=maxn;maxn=num[i];k=i; } else if(num[i]&gt;premaxn){ pos[k]--;premaxn=num[i]; } } int minn=2; for(i=1;i&lt;=n;i++){ if(pos[i]&lt;minn){ ans=num[i];minn=pos[i]; } else if(pos[i]==minn){ ans=min(ans,num[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.首先，如果x不能整除y，那么就可以直接滚蛋了。 令$f(t)$表示若干个数和为$t$，$gcd$为1。那么答案就是$f(\frac{y}{x})$. 令$g(t)$表示若干个数和为$t$,那么显然有$g(t)=2^{t-1}$:想象一下，把t分成t个1，那么相邻的1之间分开与否都是不同的（本题的序列是有序的）。 注意到有$g(t)=\sum_{i=1}^{t_i}f(\frac{t}{t_i})$($t_i$是$t$的约数)， 所以有$f(t)=g(t)-\sum_{i=2}^{sz}f(\frac{t}{t_i})$. 于是先把y除以x，然后求出y的所有约数，从小到大排序后，从大到小枚举每个约数，对于每个约数，我们可以先算出他的$g(i)$,然后枚举所有比他大的约数，如果某个约数能整除他，那么那个约数对应的$f(i)$就应该被减去。最后输出$f(1)$即可。以及，注意取模的问题，要用快速幂&amp;小心负数。 #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; typedef long long ll; ll mod_pow(ll x,ll y) { ll res=1; while(y){ if(y&amp;1){ res=res*x%mod; } y&gt;&gt;=1;x=x*x%mod; } return res; } ll f[100000]; int main() { int x,y,i,j,k; cin&gt;&gt;x&gt;&gt;y; if(y%x){ puts(&quot;0&quot;);return 0; } y/=x;vector&lt;int&gt;ys; for(i=1;i*i&lt;=y;i++){ if(y%i==0){ ys.push_back(i); if(i*i!=y) ys.push_back(y/i); } } sort(ys.begin(),ys.end()); for(i=ys.size()-1;~i;i--){ f[i]=mod_pow(2,y/ys[i]-1); for(j=ys.size()-1;j&gt;i;j--) if(ys[j]%ys[i]==0) f[i]=(f[i]-f[j]+mod)%mod; } cout&lt;&lt;(f[0]+mod)%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #502（Div. 1 + Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-502-ef-bc-88div-1-div-2%2F</url>
    <content type="text"><![CDATA[A.签到 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct mark{ int id,sum; bool operator&lt;(const mark&amp;v)const{ if(sum==v.sum) return id&lt;v.id; return sum&gt;v.sum; } }G[1005]; int main() { int n,i,j,k,a,b,c,d; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;G[i].sum+=a+b+c+d;G[i].id=i; } sort(G+1,G+1+n); for(i=1;i&lt;=n;i++){ if(G[i].id==1){ cout&lt;&lt;i&lt;&lt;endl;return 0; } } } B.首先，可以发现一个事实：第二个串的某个位置如果是1，那么第一个串是什么是不重要的，因为换完还是1.否则，第一个串如果是0，我们就研究有多少个1可以换。但是这样就会带来一个重复的问题，对此，我们可以做一个预处理，对于每个1，相当于要换0，而相应前面的0的位置必然要换1，那么我们就可以统计一下这个重复的问题。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string str1,str2;int n,i,j,k,cnt[2]={0},cnt1[2]={0}; cin&gt;&gt;n&gt;&gt;str1&gt;&gt;str2; for(auto a:str1)cnt[a-&apos;0&apos;]++; long long ans=0; for(i=0;i&lt;n;i++){ if(str2[i]==&apos;0&apos;){ if(str1[i]==&apos;1&apos;){ ans+=cnt[0];ans-=cnt1[1];cnt1[0]++; } else{ ans+=cnt[1];ans-=cnt1[0];cnt1[1]++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C.不太会证明…利用了一点类似分块的思想，反正平方分割肯定是对的… #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,pos; cin&gt;&gt;n;pos=n; int len=sqrt(n); while(pos&gt;=len){ for(i=pos-len+1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; pos-=len; } for(i=1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; } D.比赛的时候总觉得是建树，然后就t得怀疑人生了… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; struct node{ int son[2]; int cnt=0; bool tag; }ch[1&lt;&lt;14];//数组大小由所要插入字符的总长度决定 void insert(char*str,int n) { int now=0; ch[now].tag=true; for(int i=0;i&lt;n;i++){ int c=str[i]-&apos;0&apos;; now=ch[now].son[c]; ch[now].tag=true; } ch[now].cnt++; ch[now].tag=true; } int w[15],k;int cnt,n; void query(string str,int id,int quan,int ceng) { if(!ch[id].tag)return; if(ceng) { if ((id &amp; 1) != str[ceng - 1] - &apos;0&apos;) quan += w[ceng]; if (quan &gt; k)return; if (ceng == n) { cnt += ch[id].cnt; return; } } query(str,id&lt;&lt;1|1,quan,ceng+1); query(str,(id&lt;&lt;1)+2,quan,ceng+1); } int main() { int i,j; for(i=0;i&lt;(1&lt;&lt;12);i++){ //ch[i].cnt++; ch[i].son[0]=i&lt;&lt;1|1;ch[i].son[1]=(i&lt;&lt;1)+2; } int m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;=m;i++){ char str[15];scanf(&quot;%s&quot;,str); insert(str,n); } while(q--){ string str;cin&gt;&gt;str&gt;&gt;k; cnt=0; query(str,0,0,0); printf(&quot;%d\n&quot;,cnt); } return 0; } 正解是利用类似bitset的思想，因为两串相与只可能是0~2^12，所以我们可以预处理所有的情况，把他们转10进制表示，然后查询的时候就是$O(1)$的了. 有一点要注意的就是因为两个串都是0或者都是1 的时候权值都是有效的，为了方便统计，我们可以把set里面的串全部取反，然后查询的时候两个串异或一下，是1的位置就是权值有效的位置了。ans[i][j]代表模式串为i的时候两串相与为j的情况数。 以及，string会tle #include&lt;bits/stdc++.h&gt; using namespace std; int w[5000],s[5000],ans[5000][105],f[5000];//s是将字符串转化为数字串,ans存答案,f预处理 int main() { int n,m,q; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;w[n - i]);//注意这里层级要倒着来,不然没法从前往后匹配 for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j))//f[i]代表两个数相与等于i时的权值 f[i] += w[j]; for (int i = 1; i &lt;= m; i++) { char ss[15];scanf(&quot;%s&quot;,ss); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + 1 - (ss[j] - &apos;0&apos;);//注意这里是与原数取反的!!! //a=a*2+(ss[j]-&apos;0&apos;); s[a]++;//统计串个数 } for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; (1 &lt;&lt; n); j++) if (f[i ^ j] &lt;= 100)//题意:k&lt;=100才有效 ans[i][f[i ^ j]] += s[j];//ans[i][j]统计模式串为i时相与答案为j的个数 //ans[i][f[i&amp;j]]+=s[j]; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 1; j &lt;= 100; j++) ans[i][j] += ans[i][j - 1];//因为&lt;=j都可以,所以,要加成前缀和 for (int i = 1; i &lt;= q; i++) { char ss[15];scanf(&quot;%s&quot;,ss);int k;scanf(&quot;%d&quot;,&amp;k); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + (ss[j] - &apos;0&apos;); printf(&quot;%d\n&quot;, ans[a][k]); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training 网络流]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F%E5%9B%BE%E8%AE%BA%2F2018-bupt-summer-training-e7-bd-91-e7-bb-9c-e6-b5-81%2F</url>
    <content type="text"><![CDATA[A - Drainage Ditches POJ - 1273板子题，没什么好说的 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[210]; int level[205],iter[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ for(i=1;i&lt;=200;i++)G[i].clear(); for(i=1;i&lt;=n;i++){ int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);addedge(a,b,c); } cout&lt;&lt;maxflow(1,m)&lt;&lt;endl; } return 0; } C - Reactor Cooling ZOJ - 2314无源汇可行流模板题 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//记录边的id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//存答案 for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//反向边或者连向附加汇点的边无视 as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//这条边的反向边的容量+这条边的下界 } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } D - Number HYSBZ - 3275注意题目条件是同时满足两个条件的数才不能一起选。对于每个点a，我们拆成$a_x$和$a_y$,源点连接$a_x$,容量为数值，$a_y$连接汇点，容量为数值。如果两个数a，b不能同时选，那么我们就将$a_x$连接$b_y$,$b_x$ 连接$a_y$,容量为INF。那么答案就是所有数的和-maxflow/2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//记录边的id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//存答案 for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//反向边或者连向附加汇点的边无视 as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//这条边的反向边的容量+这条边的下界 } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } E - 软件开发 HYSBZ - 1221非常类似餐巾计划问题。唯一的不同就是洗的时间，第i天的毛巾在i+1天才开始洗，所以在第i+k+1天才洗好，其他就没什么区别了。 关于构图： 这是一道最小费用（费用指单价）最大流的题目。 首先，我们拆点，将一天拆成晚上和早上，每天晚上会受到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从原点获得），每天早上又有干净的餐巾（来源：购买、快洗店、慢洗店）。（本题中对应两种清洗方式，其实就是换了个名字而已） 1.从原点向每一天晚上连一条流量为当天所用餐巾x，费用为0的边，表示每天晚上从起点获得x条脏餐巾。 2.从每一天早上向汇点连一条流量为当天所用餐巾x，费用为0的边，每天白天,表示向汇点提供x条干净的餐巾,流满时表示第i天的餐巾够用 。 3.从每一天晚上向第二天晚上连一条流量为INF，费用为0的边，表示每天晚上可以将脏餐巾留到第二天晚上（注意不是早上，因为脏餐巾在早上不可以使用）。 4.从每一天晚上向这一天+快洗所用天数t1的那一天早上连一条流量为INF，费用为快洗所用钱数的边，表示每天晚上可以送去快洗部,在地i+t1天早上收到餐巾 。 5.同理，从每一天晚上向这一天+慢洗所用天数t2的那一天早上连一条流量为INF，费用为慢洗所用钱数的边，表示每天晚上可以送去慢洗部,在地i+t2天早上收到餐巾 。 6.从起点向每一天早上连一条流量为INF，费用为购买餐巾所用钱数的边，表示每天早上可以购买餐巾 。 注意，以上6点需要建反向边！3~6点需要做判断（即连向的边必须&lt;=n） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[5010]; int dis[5010],prevv[5010],preve[5010],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边 bool inque[5010]; const int INF=1&lt;&lt;30; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f) return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int n,a,b,f,fa,fb,i,j,k; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;fa&gt;&gt;fb; int peo[1005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;peo[i]); for(i=1;i&lt;=n;i++) add(0,i,peo[i],0); for(i=1;i&lt;=n;i++) add(i+n,2005,peo[i],0); for(i=1;i&lt;n;i++) add(i,i+1,INF,0); for(i=1;i+a+1&lt;=n;i++) add(i,i+a+n+1,INF,fa); for(i=1;i+b+1&lt;=n;i++) add(i,i+b+n+1,INF,fb); for(i=1;i&lt;=n;i++) add(0,i+n,INF,f); mincostmaxflow(0,2005); cout&lt;&lt;cost&lt;&lt;endl; return 0; } F - 修车 HYSBZ - 1070题目的难点在于怎么去计算总的等待时间。方法是把修车人员拆成n个点，每个人的第i个点分别表示这个人在倒数第i个对某辆车进行修理，那么等待修的车连向这个点的边就应该是 修车时间* i，因为还有i个人在等这个修车师傅。然后跑最小费用流即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int m,n,i,j,k,a,b; cin&gt;&gt;m&gt;&gt;n; for(i=1;i&lt;=n;i++) add(0,n*m+i,1,0); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ cin&gt;&gt;a; for(k=1;k&lt;=n;k++){ add(n*m+i,(j-1)*n+k,1,a*k); } } for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) add((i-1)*n+j,900,1,0); mincostmaxflow(0,900); printf(&quot;%.2f\n&quot;,(double)cost/n); return 0; } G - Firing POJ - 2987最大权闭合图的模板题 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } long long maxflow(int s,int t){ long long flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; } H - Being a Hero HDU - 3251添加汇点T，原图上的单向边依次建边，容量为花费，允许选择的f个点向汇点T连边，容量为点上权值。跑一遍最小割得到花费值cost，然后用总的能获得利润（就是f个点的权值之和）减去cost 从源点S在残留网络中dfs遍历能走到的点，那么这些点就是属于S集，其他剩下的点就属于T集了， 然后判断边的两个点所属的集合，如果属于不同的集合那么这条边就是割边。 对于原图上的边如果被割到，那么这条边就是要破坏的，需要特别注意的是一定要标记每条边是不是原图中的边，否则很可能反向边会被误判为割边！！！ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,rev,id; bool iscor; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap,int id) { G[from].push_back(edge{to,cap,(int)G[to].size(),id,true}); G[to].push_back(edge{from,0,(int)G[from].size()-1,id,false});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[1005]; void dfs(int x) { vis[x]=true; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]){ dfs(G[x][i].to); } } } int main() { int t,i,j,k,n,m,f; cin&gt;&gt;t;int case1=0; while(t--){ case1++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;f; for(i=1;i&lt;=1001;i++)G[i].clear(); //int ava[1005]={0}; for(i=1;i&lt;=m;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w,i);//连边 } long long sum=0; while(f--){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w);sum+=w;//ava[u]=1; addedge(u,1001,w,0);//1001为汇点 } printf(&quot;Case %d: &quot;,case1); cout&lt;&lt;sum-maxflow(1,1001)&lt;&lt;endl; memset(vis,0,sizeof(vis)); dfs(1); vector&lt;int&gt;road;//破坏的边 for(i=1;i&lt;=n;i++){ for(j=0;j&lt;G[i].size();j++){ edge e=G[i][j]; if(vis[i]&amp;&amp;!vis[e.to]&amp;&amp;e.id&amp;&amp;e.iscor){ road.push_back(e.id); } } } cout&lt;&lt;road.size(); //sort(road.begin(),road.end()); for(i=0;i&lt;road.size();i++) cout&lt;&lt;&apos; &apos;&lt;&lt;road[i]; cout&lt;&lt;endl; } return 0; } I - 志愿者招募 HYSBZ - 1061源点连第一天，最后一天（n+1）连汇点，容量为INF费用为0 这样跑网络流是沿时间流的（就是依次解决每一天的问题） 然后每一天向后一天连一条容量为INF-a[i]，费用为0的边（这其实是本题精髓） 为什么容量为INF-a[i]？这就相当于少了a[i]，得用带权边也就是招来的志愿者补全INF 这就是志愿者连续干时沿这条边跑，因为连续干不花钱，所以优先选这种边 然后将每一类志愿者s[i]与t[i]+1连一条容量为INF花费为c[i]的边，当连续干的人不够时，就得充钱使劲往里塞人，补全INF。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int INF = (1 &lt;&lt; 31) - 1; struct edge { int to, cap, cost, rev; }; vector&lt;edge&gt;G[2010]; int dis[2010], prevv[2010], preve[2010], n, m, flow = 0, cost = 0; bool inque[2010]; void add(int from, int to, int cap, int cost) { edge e; e.to = to; e.cap = cap; e.cost = cost; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.cost = -cost; e.rev = G[from].size() - 1;//-cost! G[to].push_back(e); } bool Spfa(int s, int t) { fill(dis, dis + 2000, 1 &lt;&lt; 30); memset(inque, 0, sizeof(inque)); queue&lt;int&gt;que; dis[s] = 0; inque[s] = true; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); inque[t] = false; for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;dis[e.to] &gt; dis[t] + e.cost) { dis[e.to] = dis[t] + e.cost; prevv[e.to] = t; preve[e.to] = i;//一个边一个点不要混淆！ if (!inque[e.to]) { que.push(e.to); inque[e.to] = true; } } } } if (dis[t] == 1 &lt;&lt; 30)//如果已经无法增广，返回 return false; int d = 1 &lt;&lt; 30; for (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);//此次可增广容量是全路径中容量最小的那个 flow += d; cost += d * dis[t];//dis是路径中单位费用和 for (int v = t; v != s; v = prevv[v]) {//更改容量 edge &amp;e = G[prevv[v]][preve[v]]; e.cap -= d; G[v][e.rev].cap += d;//v或者e.to都可以 } return true; } void mincostmaxflow(int s, int t) { while (Spfa(s, t)&amp;&amp;flow&lt;INF); } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m; add(0, 1, INF, 0); add(n + 1, 1500, INF, 0); for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); add(i, i + 1, INF - j, 0); } for (i = 1; i &lt;= m; i++) { int s, t, c; scanf(&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;c); add(s, t + 1, INF, c); } mincostmaxflow(0, 1500); cout &lt;&lt; cost &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）有上下界的网络流 总结]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-9c-89-e4-b8-8a-e4-b8-8b-e7-95-8c-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b5-81-e5-81-9a-e6-b3-95-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[无源汇可行流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 （上面在连每一条边的时候建一个cur数组记一下输入输出即可） 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) ，同时期望的流量值sum+=d（i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) 求解方法 在新图上跑ss到tt的最大流 若新图满流（流量等于sum），那么一定存在一种可行流 此时，原图中每一条边的流量应为新图中对应的边的流量+这条边的流量下界 EX：LOJ115 这是一道模板题。 n个点，m条边，每条边 e有一个流量下界 $lower(e) $ 和流量上界 $upper(e)$，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[310]; int level[305],iter[305],cur[305],lower[30500]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,flow; bool operator&lt;(const ans&amp;a)const{ return id&lt;a.id; } }; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int s,t,l,u; scanf(&quot;%d%d%d%d&quot;,&amp;s,&amp;t,&amp;lower[i],&amp;u); cur[s]-=lower[i];cur[t]+=lower[i]; addedge(s,t,u-lower[i]);G[s].back().id=i; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]); sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,250,-cur[i]); } } int flow=maxflow(0,250); if(flow!=sum){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return 0; } vector&lt;ans&gt;as; for(i=1;i&lt;=n;i++){ for(auto a:G[i]){ if(!a.id)continue; as.push_back(ans{a.id,lower[a.id]+G[a.to][a.rev].cap}); } } sort(as.begin(),as.end()); cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(auto a:as){ cout&lt;&lt;a.flow&lt;&lt;endl; } return 0; } 有源汇可行流建图方法在原图中添加一条边t-&gt;s，流量为inf 即让源点和汇点也满足流量平衡条件 这样就改造成了无源汇的网络流图，其余建图方法与无源汇可行流相同。 有源汇有上下界最大流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) （以上与无源汇可行流相同） 在原图中添加一条边t-&gt;s，流量为inf 即让源点和汇点也满足流量平衡条件 这样就改造成了无源汇的网络流图 （以上与有源汇可行流相同） 在新图上跑ss到tt的最大流 若新图满流，那么一定存在一种可行流 记此时$∑f(s,i)=sum1$ ，即此时t-&gt;s的最大流，也就是求反向边s-&gt;t的流量 将t-&gt;s这条边拆掉，在新图上跑s到t的最大流 记此时$∑f(s,i)=sum2 $，即maxflow（s，t） 最终答案即为sum1+sum2 EX:LOJ116 这是一道模板题。 n个点，m条边，每条边 e有一个流量下界$ lower(e) $和流量上界 $upper(e) $，给定源点 s与汇点 t，求源点到汇点的最大流。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; bool tag; }; vector&lt;edge&gt;G[410]; int level[405],iter[405],cur[405],lower[10005]; void addedge(int from,int to,int cap,int s) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! if(from==s)G[from].back().tag=true; } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,t,up; scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;t,&amp;lower[i],&amp;up); addedge(from,t,up-lower[i],s);cur[from]-=lower[i];cur[t]+=lower[i]; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i],s);sum+=cur[i]; } else{ addedge(i,250,-cur[i],s); } } addedge(t,s,(1&lt;&lt;31)-1,s); int flow=maxflow(0,250); if(sum!=flow){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } int ans=G[s].back().cap; G[s].pop_back();G[t].pop_back(); ans+=maxflow(s,t); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 有源汇有上下界最小流建图方法将有上下界的网络流图转化成普通的网络流图 首先建立附加源点ss和附加汇点tt 对于原图中的边x-&gt;y，若限制为[b,c]，那么连边x-&gt;y，流量为c-b 对于原图中的某一个点i，记d(i)为流入这个点的所有边的下界和减去流出这个点的所有边的下界和 若d(i)&gt;0，那么连边ss-&gt;i，流量为d(i) 若d(i)&lt;0，那么连边i-&gt;tt，流量为-d(i) （以上与无源汇可行流相同) 求res=ss-&gt;tt最大流 连边t-&gt;s,inf 求res+=ss-&gt;tt最大流 如果res！=sum也就是期望中的满流，那么就没有可行解。 需要格外注意最小流判断是否有可行解的位置与时机与另外几种上下界网络流的不同！！！ 否则，输出G[s].back().cap也就是从t到s inf边的实际流量，即为所求。 EX:LOJ117 n 个点，m条边，每条边 e有一个流量下界 $lower(e) $和流量上界 $upper(e)$，给定源点 s与汇点 t，求源点到汇点的最小流。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; struct edge{ int to;ll cap;int rev; }; vector&lt;edge&gt;G[50210]; int level[50205],iter[50205],low[125050];ll cur[50205]; void addedge(int from,int to,ll cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } ll dfs(int v,int t,ll f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ ll d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } ll maxflow(int s,int t){ ll flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); ll f; while(f=dfs(s,t,0x7f7f7f7f7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,to,up;scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;to,&amp;low[i],&amp;up); cur[from]-=low[i];cur[to]+=low[i];addedge(from,to,up-low[i]); } ll sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]);sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,50050,-cur[i]); } } ll flow=maxflow(0,50050); addedge(t,s,(1LL&lt;&lt;63)-1); flow+=maxflow(0,50050); if(flow!=sum){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } cout&lt;&lt;G[s].back().cap&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #452 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-452-div-2%2F</url>
    <content type="text"><![CDATA[A.#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,cnt[3]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);cnt[j]++; } //cout&lt;&lt;min(cnt[1],cnt[2])&lt;&lt;endl; if(cnt[1]&lt;=cnt[2]){ cout&lt;&lt;cnt[1]&lt;&lt;endl; } else{ if(cnt[1]-cnt[2]&lt;3) cout&lt;&lt;cnt[2]&lt;&lt;endl; else cout&lt;&lt;cnt[2]+(cnt[1]-cnt[2])/3&lt;&lt;endl; } return 0; } B.就是打表暴力 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int init[15]={31,31,28,31,30,31,30,31,31,30,31,30,31},days[5][50]; int i,j,n,tar[30],k; for(i=1;i&lt;=4;i++) for(j=1;j&lt;=36;j++){ days[i][j]=init[j%12]; } days[1][2]=29;days[2][14]=29;days[3][26]=29; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;tar[i]); bool isok=false; for(i=1;i&lt;=4;i++){ for(j=1;j&lt;=36-n+1;j++){ for(k=1;k&lt;=n;k++){ if(tar[k]!=days[i][j+k-1]) break; } if(k&gt;n){ isok=true;break; } } } if(isok){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } C.如果数字不是1~n的话似乎是一个np问题…当然这里是连续的，因此其实是有规律可循的。讨论n模4的余数，然后就会发现当余数为0或2的时候都是可以构造出来差为0的，其他就只能差为1了。 构造房主要思想就是首位配对，因为这样配出来的每对的和都是相等的。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; vector&lt;int&gt;ans; cin&gt;&gt;n; int y=n%4; if(y==0){ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; } else if(y==1){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2+1&lt;&lt;&apos; &apos;&lt;&lt;1; for(i=2;i&lt;=n/4+1;i++) cout&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+2; } else if(y==2){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; cout&lt;&lt;n/2&lt;&lt;endl; } else{ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;endl; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; for(i=n-n/4;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; } return 0; } D.首先，如果在范围内最大的两个数加起来恰好是9999…99的形式的话，那么并不需要再讨论了，答案就是1.否则所求的9的位数就是最大两个数的和的位数-1； 然后我们就试着在目标个数的9前面依次填上0~8，看看有多少种方式能加起来等于我们当前构造的和。需要注意的是当和p比较小的时候，方式就是p/2，但是和比较大的时候就是n-p/2… 以及，如果n&lt;5的时候并不能构造出9，那就要特判… #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,i,j,k; cin&gt;&gt;n; ll maxn=n+n-1; int cnt=0; ll t=maxn; while(t){ cnt++;t/=10; } if(maxn==(ll)pow(10,cnt)-1){ cout&lt;&lt;1&lt;&lt;endl;return 0; } ll ans=0,nine=pow(10,cnt-1)-1;//ans1=n-n/2; for(i=0;i&lt;9;i++){ ll p=(ll)pow(10,cnt-1)*i+nine; if(p&gt;maxn)break; //ans+=((ll)pow(10,cnt-1)*i+nine)/2; ans+=min(n-p/2,p/2); } cout&lt;&lt;(n&lt;5?n*(n-1)/2:ans)&lt;&lt;endl; return 0; } E.题目做法就是模拟，关键在于删去一个区间之后，他左右的区间可能会因为数字相同而造成合并。为了解决这个问题，我们用两个set，两个set中都存放pair，第一个set的第一元存放连续数字的长度*-1，第二元则存放连续数字的起始位置。第二个set的第一元存放连续数字的起始位置，第二元存放连续数字的长度。 然后每次我们把第一个set中的第一个pair找出来，他就是要被删除的，然后我们用lowerbound在第二个set中找出他前后的两个pair，看看他们是否需要合并即可。小心set访问非法位置… #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k; set&lt;P&gt;len,seg; //int pre=0,sum=0; cin&gt;&gt;n;int num[200005]={0},sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i]; if(num[i]!=num[i-1]){ if(i&gt;1){ len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); } sum=1; } else sum++; } len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); int ans=0; while(!len.empty()){ ans++; P p=*len.begin();len.erase(len.begin()); auto a=seg.lower_bound(P(p.second,0)); if(seg.size()&gt;=3&amp;&amp;a!=seg.begin()&amp;&amp;a!=--seg.end()){ auto b=a,c=a;b--,c++; if(num[b-&gt;first]==num[c-&gt;first]){ len.erase(P((b-&gt;second)*-1,b-&gt;first)); len.erase(P((c-&gt;second)*-1,c-&gt;first)); len.insert(P((b-&gt;second+c-&gt;second)*-1,b-&gt;first)); seg.insert(P(b-&gt;first,b-&gt;second+c-&gt;second)); seg.erase(b);seg.erase(c); } } seg.erase(a); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } F.其实做法也挺暴力的…我们建一堆set，每个里面都存这个字符出现所有位置，然后对于每次询问，我们找出l，r在原字符串中的位置，这个可以类似树状数组去维护一下，但是有点不同，需要好好理解一下…然后去这个字符对应的set里面lowerbound一下找出l，r对应原位置区间范围内的所有这些位置然后标记一下…最后从前往后，如果没有被标记过就输出即可。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e5+10; int bit[maxn],A; void add(int pos,int x) { while(pos&lt;=A){ bit[pos]+=x; pos+=pos&amp;-pos; } } int find(int x) { int s=0,j=A&gt;&gt;1; for(;j;j&gt;&gt;=1) if(x&gt;bit[s+j]) x-=bit[s+j],s+=j; return s+1; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str;cin&gt;&gt;str; set&lt;int&gt;s[150]; for(i=0;i&lt;str.size();i++) s[str[i]].insert(i+1); for(A=1;A&lt;n;A&lt;&lt;=1); for(i=1;i&lt;=n;i++)add(i,1); while(m--){ int l,r;char c[5];scanf(&quot;%d%d%s&quot;,&amp;l,&amp;r,c); l=find(l),r=find(r); //add() for(auto a=s[c[0]].lower_bound(l);a!=s[c[0]].end()&amp;&amp;(*a)&lt;=r;){ vis[*a]=true; add(*a,-1);s[c[0]].erase(a++); } } for(i=1;i&lt;=n;i++) if(!vis[i]) cout&lt;&lt;str[i-1]; cout&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）ST表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FRMQ%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89st-e8-a1-a8%2F</url>
    <content type="text"><![CDATA[概念ST表就是一个用来解决rmq（区间最值）问题的算法. ST表不支持在线修改 预处理时间复杂度$O(nlogn)$，查询时间$O(1)$ 算法详解（求最小值）：用$mn[i][j]$表示从$i$到$i+2^j-1$的最小值（长度显然为$2^i$）。 任意一段的最小值显然等于min（前半段最小值，后半段最小值）。 那么$mn[i][j]$如何用其他状态来继承呢？ $i$到$i+2^j-1$的长度为$2^j$，那么一半的长度就等于$2^{j-1}$。 那么前半段的状态表示为$mn[i][j-1]$。 后半段的长度也为$2^{j-1}$，起始位置为$i+2^{(j-1)}$。 那么后半段的状态表示为$mn[i+2^{j-1}][j-1]$。 所以： $mn[i][j]=min(mn[i][j-1],mn[i+2^{j-1}][j-1]$。 模板注意修改数组大小！ (洛谷P3865) #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=100010; int a[MAXN],dp[MAXN][50];//第二个括号内要根据最大数据范围改成2的幂次能大于最大的数据 //int Min(int x,int y)//有时候可以用于自定义一些特殊类型的比较 //{ // return a[x]&lt;=a[y]?x:y; //} void st_init(int n)//n为原始数组的长度 { for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); //dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } int query(int l,int r) { int k = log2(r - l + 1); return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); //return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); st_init(n); int l,r; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%dn&quot;,query(l,r)); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>数据结构</category>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #3]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-3%2F</url>
    <content type="text"><![CDATA[A.HackerRank array-partition首先注意到一点，如果有两个数a，b，$gcd(a,b)\geq 1$,那么a，b显然是要放在一组的。考虑到数组中的数字过多，因此我们并不能进行两两的枚举，但是数据的范围都非常有限。因此我们可以考虑枚举所有的质数，然后枚举质数的倍数，如果同一个质数存在一些倍数是数组中的数的话，就把这些数都合并起来（显然用并查集效率最高）。然后最后求出连通块的数量k。注意，因为数字1的特殊性，所以每个1都可以算一个单独的连通块，这个要额外统计。那么方案数就是$2^k-2$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; bool notprime[1000005]; vector&lt;int&gt;prime; void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(notprime[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++) notprime[j*i]=true; } } ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } bool s[1000005]; int par[1000005]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } void unite(int x,int y) { x=find(x),y=find(y); if(x==y) return; par[x]=y; } int main() { int t,i,j,k; checkprime(1000000); cin&gt;&gt;t; int num[100005]; while(t--){ int n;cin&gt;&gt;n; int num1=0; int maxn=0; memset(s,0,sizeof(s)); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);s[num[i]]=true; if(num[i]==1)num1++;maxn=max(maxn,num[i]); } for(i=1;i&lt;=maxn;i++)par[i]=i; for(auto a:prime){ int t=0; for(i=1;i*a&lt;=maxn;i++){ if(s[i*a]){ if(!t)t=i*a; else unite(t,i*a); } } } int cnt=1;find(num[1]);set&lt;int&gt;s; for(i=1;i&lt;=n;i++) s.insert(find(num[i])); cnt=s.size(); if(num1&gt;1)cnt+=num1-1; ll ans=mod_pow(2,cnt,mod); ans=(ans-2+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } B.CodeChef - F2NDMAX这道题其实是一幅图…设想一下，对于两个数a，b，如果$a&gt;b$,那么从a连边指向b，那么当满足题意的询问完成后，我们一定能得到一幅图，其中只有一个点入度为0，即最大的那个点，那么第二大的点应当就是它的一个直接的儿子。 于是我们可以先统计所有入度为0的点，对于这cnt个点，我们至少要询问cnt-1次才能明确其中最大的数，然后为了使总次数最少，我们把这些入度为0的点的儿子中当前入度为1的数量丢进一个小根堆，然后每次询问都应当找出堆顶最大的两个数a，b，那么至少要询问max(a,b)+1次才能找出合并这两组之后第二大的数。（似乎有点混乱？） #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn=3e5+5; int indegree[maxn], outdegree[maxn]; int main() { int t; cin &gt;&gt; t; int n,m,i,j,k; while(t--){ cin &gt;&gt; n &gt;&gt; m; memset(indegree, 0, sizeof(indegree));memset(outdegree, 0, sizeof(outdegree)); vector&lt;int&gt; adj[maxn]; while(m--) { int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adj[u].push_back(v); indegree[v]++; } for(i=1; i&lt;=n; i++) for(auto j : adj[i]) outdegree[i]+=(indegree[j]==1); int cnt=0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; for(i=1; i&lt;=n; i++) { cnt+=indegree[i]==0?1:0; if(!indegree[i]) que.push(outdegree[i]); } cnt--; while(que.size()&gt;1) { int a=que.top();que.pop(); int b=que.top();que.pop(); que.push(max(a, b)+1); } cout &lt;&lt; cnt+que.top()-1 &lt;&lt; endl; } return 0; } J.CodeChef - RIN首先，我们把分数进行转化，得到的分数变成100-得到的分数，也就是亏损的分数。如果分数是-1那么亏损无限大。那么我们的问题其实就变成了如何选择使得亏损尽可能的小。我们把每个课的每个学期都建成点，从源点向所有课的第一学期连权值为该亏损的课，从第一学期向第二学期连第二学期亏损的课…依次类推，最后一学期向汇点连容量无穷的边。那么，如果不考虑前置课程的要求，我们现在的问题其实就是在求图的最小割。 考虑到前置课程，假设a是b的前置课程，那么对于a的每个学期，我们都向b的下一学期连一条无限的边确保b的割不会发生在a之前。注意的是b的第一学期的肯定不能选的，因此从源点向该学期连权值INF的边。 答案就是$(n* 100-maxflow)/n$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e4+50; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } int main() { int n,m,k,i,j; int x[105][105]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ int mar; scanf(&quot;%d&quot;,&amp;mar); if(mar==-1)x[i][j]=1&lt;&lt;30; else x[i][j]=100-mar; } for(i=1;i&lt;=n;i++){ addedge(0,(i-1)*m+1,x[i][1]); for(j=2;j&lt;=m;j++){ addedge((i-1)*m+j-1,(i-1)*m+j,x[i][j]); } addedge((i-1)*m+m,10005,1&lt;&lt;30); } while(k--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(i=1;i&lt;m;i++) addedge((a-1)*m+i,(b-1)*m+i+1,1&lt;&lt;30); addedge(0,(b-1)*m+1,1&lt;&lt;30); //addedge((a-1)*m+m,10005,1&lt;&lt;30); } double ans=n*100-maxflow(0,10005); printf(&quot;%.2f\n&quot;,ans/n); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 48 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-48-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.明显签到，随便写 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; ll pre=0; long long sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;sum+=j; ll d=sum/m;;cout&lt;&lt;d-pre&lt;&lt;&apos; &apos;; pre=d; } return 0; } B.正解应该是想让你预处理字符串匹配，然后搞个前缀和去对付每个询问。然而串实在太短了以至于对于每次询问暴力kmp就可以轻松过。 暴力kmp： #include&lt;bits/stdc++.h&gt; using namespace std; int next1[1000005]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); while(q--) { int cnt=0; int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); string str3=str1.substr(l-1,r-l+1); int i = 0, j = 0; while (i &lt; str3.size()) { if (j == -1 || str3[i] == str2[j]) { if (j == str2.size() - 1) { cnt++;j = next1[j]; continue; } i++;j++; } else { while (j &gt;= 0 &amp;&amp; str2[j] != str3[i]) j = next1[j]; } } printf(&quot;%d\n&quot;,cnt); } return 0; } 预处理前缀和版：(数据有坑，不保证l&gt;=1) #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; int next1[1050]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int sum[1050]; int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); int i=0,j=0; while(i&lt;str1.size()){ if(j==-1||str1[i]==str2[j]){ if(j==str2.size()-1){ sum[i-str2.size()+2]++; j=next1[j];continue; } i++;j++; } else{ while(j&gt;=0&amp;&amp;str2[j]!=str1[i]) j=next1[j]; } } for(i=1;i&lt;=1000;i++)sum[i]+=sum[i-1]; int len=str2.size(); while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(r-len+1&gt;=l&amp;&amp;l&gt;=1) printf(&quot;%d\n&quot;,sum[r-len+1]-sum[l-1]); else printf(&quot;0\n&quot;); } return 0; } C.其实就是一个复杂版的前缀和问题。我们会发现其实走的方法就是样例里的那两种，当然第一种可以先走下面再走上面。最后的结果一定是先走第二种然后走第一种中的一种。那么我们就可以预处理每种走法的前缀和。第二种显然从左往右递推走到每个位置的前缀和即可。而第一种则要分上下讨论，并且从不同的列开始第一种，他后面的前缀和还要加上走第二种的时候所带来的系数(sum3). sum1是第二种的前缀和，sum2，sum4是第一种的两种前缀和。 最后枚举每个位置为第二，第一种的分界点求最值即可。 注意：第一个位置的系数是0不是1！ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+5; ll sum1[maxn],sum2[maxn],a[maxn],b[maxn],sum3[maxn],sum4[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]); for(i=1;i&lt;=n;i++){ //ll t=0; if(i&amp;1){ sum1[i]=(i*2-2)*a[i]+(i*2-1)*b[i]; } else{ sum1[i]=(i*2-2)*b[i]+(i*2-1)*a[i]; } sum1[i]+=sum1[i-1]; } for(i=n;~i;i--){ sum3[i]+=a[i]+b[i]; sum3[i]+=sum3[i+1]; } for(i=n;i;i--){ sum2[i]+=sum2[i+1]+sum3[i+1]; sum2[i]+=b[i]*((n-i+1)*2-1); sum4[i]+=sum4[i+1]+sum3[i+1]; sum4[i]+=a[i]*((n-i+1)*2-1); } ll ans=0; // for(i=1;i&lt;=n;i++) // cout&lt;&lt;sum2[i]&lt;&lt;&apos; &apos;&lt;&lt;sum4[i]&lt;&lt;endl; for(i=0;i&lt;=n;i++){ ll t=sum1[i]; if(i&amp;1){ t+=sum4[i+1]+sum3[i+1]*(i)*2; } else t+=sum2[i+1]+sum3[i+1]*i*2; ans=max(ans,t); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.其实只要$a_1\oplus a_2\oplus …a_n=b_1\oplus b_2\oplus…b_n$就是一定可以的。 然后除了最后一列及最后一行之外的所有位置其实都可以随便放。根据放的情况推最后一行最后一列即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int ma[105][105]; int a[105],b[106]; int main() { int n,m,i,j,k,sum1=0,sum2=0; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum1^=a[i]; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;b[i]);sum2^=b[i]; } if(sum1!=sum2){ puts(&quot;NO&quot;);return 0; } for(i=1;i&lt;n;i++){ for(j=1;j&lt;m;j++){ ma[i][j]=1; } if((m-1)&amp;1) sum1=1; else sum1=0; ma[i][m]=a[i]^sum1; } for(i=1;i&lt;=m;i++){ sum1=0; for(j=1;j&lt;n;j++) sum1^=ma[j][i]; ma[j][i]=b[i]^sum1; } puts(&quot;YES&quot;); for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,ma[i][j],j==m?&apos;\n&apos;:&apos; &apos;); } //cout&lt;&lt;(4^2^15)&lt;&lt;&apos; &apos;&lt;&lt;(2^15)&lt;&lt;endl; return 0; } E.对于每个点，我们连接它与a,b. 这两条线与x轴的交点可以构成一条线段len，那么，这个点在shade中的时长就是： |len中栅栏的长度|* |ab的长度|/|len的长度| 计算中用lowerbound找相交点，然后用相似三角形求解。 代码中用 |右端点的栅栏前缀和|-|左端点的栅栏前缀和| 求解栅栏长度。 #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;double&gt;v; const int maxn=2e5+5; double s[maxn]; int main() { double sy,a,b,l[maxn],r[maxn]; int n,i,j,k,q; scanf(&quot;%lf%lf%lf&quot;,&amp;sy,&amp;a,&amp;b); cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf&quot;,&amp;l[i],&amp;r[i]);s[i]+=s[i-1]+r[i]-l[i];//s为预处理的栅栏长的前缀和 v.push_back(l[i]);v.push_back(r[i]); } cin&gt;&gt;q; while(q--){ double x,y;scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); double pos=a-sy/(y-sy)*(x-a);//利用相似三角形求线与x轴的交点 int p=lower_bound(v.begin(),v.end(),pos)-v.begin();//求交点落在哪个位置 double ans=-s[p/2];//左端点前缀和,要减去所以带负号 if(p&amp;1)ans-=pos-v[p-1];//如果交点在在栅栏中间,那么这个栅栏在交点左边的一部分也是要减去的 pos=b-sy/(y-sy)*(x-b); p=lower_bound(v.begin(),v.end(),pos)-v.begin(); ans+=s[p/2]; if(p&amp;1)ans+=pos-v[p-1];//同理算右端点 ans=ans/y*(y-sy); printf(&quot;%.7f\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最大权闭合图]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-9d-83-e9-97-ad-e5-90-88-e5-9b-be%2F</url>
    <content type="text"><![CDATA[所谓闭合图，指的是图中每个点的后续都在图中。最大权闭合图，指的是点的权值之和最大的闭合图。 最大权闭合图的求解方法1.先构造网络流N，添加源点s，从s到正权值点做一条边，容量为点的权值。 2.添加汇点t，从负权值点到t做一条边，容量为点的权值的绝对值。 3.原来的边的容量统统设为无穷大 4.求解最小割，最大权=正权值之和-最小割权值 5.最小割所产生的两个集合中，其源点S所在集合(除去S)为最大权闭合图。（也就是POJ2987所求的裁员） EX:POJ2987 公司官僚成风，盘根错节，办实事的码农没几个。老板决定大裁员，每开除一个人，同时要将其下属一并开除，如果该下属还有下属，照斩不误。给出每个人的贡献值（可为负）和从属关系，求最小裁员数及最大贡献值和。 模板题，记得开longlong即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } long long maxflow(int s,int t){ long long flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最小费用流]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b4-b9-e7-94-a8-e6-b5-81%2F</url>
    <content type="text"><![CDATA[最大流+SPFA #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,cost,rev;//终点,容量,费用,反向边 }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边, // 小心cost爆int,多组数据时记得清零 bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//小心爆int的情况 return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制 flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//更新路径信息 e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int a,b,c,d; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); add(a,b,c,d); } mincostmaxflow(s,t); cout&lt;&lt;flow&lt;&lt;&apos; &apos;&lt;&lt;cost&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）最大流与二分图的一些结论]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-b5-81-e4-b8-8e-e4-ba-8c-e5-88-86-e5-9b-be-e7-9a-84-e4-b8-80-e4-ba-9b-e7-bb-93-e8-ae-ba%2F</url>
    <content type="text"><![CDATA[匹配，边覆盖，独立集合顶点覆盖概念：$V$：全集 匹配——在图中两两没有公共顶点的边的集合 注意，图中的匹配有很多，一条边也可以算一个匹配。但是最大匹配却是可以确定的。最大匹配也就是要让选出尽可能多的边使得它们两两之间都没有交点（端点）。 边覆盖——图中的任意顶点都至少是集合$F$中某条边的的端点，满足这样条件的集合的最少的边的集合$F$称为最小边覆盖 独立集——在图中两两不相连的顶点集合 比如一条边$S$的顶点是$S_a,S_b$,那么这两个点就不能同时在一个独立集中。事实上，独立集中的任意两个点之间都不存在有边之间相连。 顶点覆盖——图中的任意边都至少有一个端点属于集合$S$的集合叫做顶点覆盖 结论(a)对于不存在孤立点的图，|最大匹配|+|最小边覆盖|=|$V$|（边的全集）（即任意一个顶点都至少在某条边中） （b）|最大独立集|+|最小顶点覆盖|=|$V$|（点的全集） （c）在二分图中，有：|最大匹配|=|最小顶点覆盖|（可用于求解二分图的最大独立集和最小顶点覆盖） （d）|图的最大流|=|图的最小割|（图有源汇）]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）网络流最大流(Dinic)]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-bd-91-e7-bb-9c-e6-b5-81-e6-9c-80-e5-a4-a7-e6-b5-81dinic%2F</url>
    <content type="text"><![CDATA[模板结论：图的最小割=图的最大流（最大流最小割定理）（图是有源汇的） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//反向容量为0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//注意传引用! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//不要漏了这个,很多时候可能是无法增广的 } int maxflow(int s,int t){ int flow=0;//小心爆int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//注意如果爆int这里初始最大值要更改最大值 flow+=f; } } int main() { return 0; }]]></content>
      <categories>
        <category>网络流</category>
        <category>算法</category>
        <category>模板</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）后缀数组]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-90-8e-e7-bc-80-e6-95-b0-e7-bb-84%2F</url>
    <content type="text"><![CDATA[定义字符串$s$连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 1开始，长度为$length(s)$ 。 后缀： $suffix(i)$表示字符串$s$从第$i$个位置开始的后缀，即由 $s[i]-s[n] $组成的子串。 字符串的比较： 两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小； 如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小； 如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。 注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件长度相同。 后缀数组： $sa$是一个一维数组，保存了对字符串$s$的所有后缀排序后的结果。 表示第$i$小的后缀在原串中的起始位置。 名次数组： $rank$是一个一维数组，按起始位置保存了每个后缀在 $sa$中的排名。 表示$suffix(i)$的排名，即 $rank[sa[i]]=i$（第$i$小的后缀的排名为$i$）。 高度数组： 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。 $height[i]=LCP(suffix(sa[i]),suffix[sa[i-1]))$(i&gt;0) 即$height[i]$表示在位置$i$存在最大的$x$,满足$\forall k \in [0,x)$有$s[sa[i]+k]=s[sa[i-1]+k]$ 最长公共前缀 通过高度数组$height$ ，我们可以得到排名相邻的两个后缀的最长公共前缀。 对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度一定不会比这两个后缀在后缀数组中确定的一段区间中任意两个相邻后缀的最长公共前缀长度更长。 所以，求出这段区间内最小的$height$值即为这两个不相邻后缀的最长公共前缀长度。 问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）**算法解决。该算法在$O(n\ logn)$ 的时间内预处理，并在 $O(1) $的时间内完成每个询问。 代码字符串/数组保存在s数组中，maxn是字符串/数组的最大长度，rk是$rank$数组，sa就是$sa$数组，ht是$height$数组。 （按照洛谷P3809的要求） #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+5; char s[maxn]; int rk[maxn],sa[maxn],ht[maxn]; inline void suffixArray() { int n=strlen(s+1); static int set[maxn + 1], a[maxn + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; static int fir[maxn + 1], sec[maxn + 1], tmp[maxn + 1], buc[maxn + 1]; for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; for (int t = 1; t &lt;= n; t *= 2) { for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; } for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;,s+1);int n=strlen(s+1); suffixArray(); for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,sa[i],i==n?&apos;\n&apos;:&apos; &apos;); return 0; } 详细参考：后缀数组学习笔记]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training 组合数学]]></title>
    <url>%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-e7-bb-84-e5-90-88-e6-95-b0-e5-ad-a6%2F</url>
    <content type="text"><![CDATA[D.组合数学+容斥原理 这个每个人必须要拿一个的限制条件非常讨厌…所以我们先不管他。 由于各种特产相互独立，所以可以先算一种特产的分配方法… 这样的话就相当于把m个相同的小球放入n个不同的盒子里(盒子就是人)，答案是$C_{m+n-1}^{\ n-1}$，然后把各个特产的这个值相乘得到答案。 非常科学，非常优雅对不对… 接下来考虑限制条件，每个人至少拿一个，我们把限制去掉后得到的是至少0人没有特产的方案数。 根据容斥原理 $ans=C_n^0 ans[至少0人没有特产]-C_n^1 ans[至少1人没有特产]+C_n^2 ans[至少2人没有特产]-……+……+/- C_m^m ans[至少m人没有特产]$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int mod=1e9+7; ll c[2005][2005]; int main() { int n,m,i,j,k; c[1][1]=c[1][0]=c[0][0]=1; for(i=2;i&lt;=2000;i++) { c[i][0]=1; for (j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//预处理组合数 } } cin&gt;&gt;n&gt;&gt;m; int tc[1005]; for(i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;tc[i]);//特产数量 ll ans=0;int cur=1; for(i=0;i&lt;=n;i++){ ll temp=cur;//容斥原理的系数(决定加减) for(j=1;j&lt;=m;j++){ temp=(temp*c[tc[j]+n-i-1][n-i-1])%mod; } ans+=temp*c[n][i]%mod;ans%=mod; cur*=-1; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0; } E.我们把左右区间分别处理： $ r = r / k; \ l = (l - 1) / k + 1$; 这样问题就转化为求[l,r] 区间内，选n个数其最大公约数为1的方案数 因为$r-l&lt;=10^5$, 所以这个区间内任意两个不相等的数的最大公约数最大不超过$10^5$ 证明很好证：因为两个数p &gt; q的最大公约数如果为x,那么$p / x - q / x \geq 1$,那么$p - q \geq x$ 所以可以暴力枚举所有的最大公约数,设[l,r]中选n个不完全相同的数其最大公约数为i的方案数为dp[i] 那么[l,r]中有多少含i因子的数呢？ 显然有$t = r / i - (l - 1) / i$个数 那么$dp[i] = t_n$ 种方案，但是这里面肯定有n个数都相同的方案一共有t个（这时候他们的GCD就不仅仅是i了），所以$dp[i] = (tn - t) mod\ p$种方案 但是这个时候求出的是所有n个数中有i因子的方案数，而不是gcd=i的方案数，所以$\forall j\ dp[i] = dp[i] - dp[j](j &lt;= r - l \ and\ j | i)$ 然后这样dp[1]就是正解了 但是我们注意到，我们的dp[1]是在[l,r]中选n个不完全相同的数其最大公约数为i的方案数，但是实际上,如果n个数都等于k的话，那么其实也是满足要求的。 所以当$k∈[l,r]时，dp[1] = dp[1] + 1$; #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int maxn=(100000 + 10); typedef long long ll; int dp[maxn]; int p = 1e9+7; ll mod_pow(ll n, ll k, ll mod) { ll re = 1; n = n % mod; while(k) { if(k &amp; 1) re = re * n % mod; k = k &gt;&gt; 1; n = n * n % mod; } return re; } int main() { int l,r,n,k; bool flag = false; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;l,&amp;r); if(k &gt;= l &amp;&amp; k &lt;= r)flag = true; r = r / k; l = (l - 1) / k; for(int i = r - l; i &gt;= 1; i --) { int t = r / i - l / i; dp[i] = (mod_pow(t, n, p) - t + p) % p; for(int j = 2; j * i &lt;= r - l; j ++) dp[i] = (dp[i] - dp[i * j] + p) % p; } if(flag == true) dp[1]++; printf(&quot;%d\n&quot;,dp[1] % p); return 0; } F.非常套路的题目，其实就是要你快速求1~x中有多少个数跟给定的n互质，那么把n分解一下质因数然后用容斥原理求一下这些质因数的倍数的总和就可以了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum(ll x,ll n) { vector&lt;ll&gt;prime; ll i,j,y=x; for(i=2;i*i&lt;=n;i++){//注意分解要从2开始!! if(n%i==0){ prime.push_back(i); } while(n%i==0) n/=i; } ll res=0; if(n&gt;1)prime.push_back(n); for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){//注意一定要从1开始!!! ll val=1,cnt=0;//二进制枚举每个因数是否要选 for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1LL){ res+=y/val; } else res-=y/val; } //cout&lt;&lt;res&lt;&lt;endl; return x-res; } int main() { int t;ll a,b,n; cin&gt;&gt;t;int cnt=0; while(t--){ cnt++; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;n); printf(&quot;Case #%d: %lld\n&quot;,cnt,sum(b,n)-sum(a-1,n)); } return 0; } G.题目求的其实就是$\forall a_i\ a_ix=b(mod\ m )$中b的和。 那么显然b必须满足$GCD(a_i,m)|b$,那么所有的这样的b显然都是m的某个约数的倍数（ m除外，因为$b\leq m-1$)。于是，对于每个ai，我们枚举其与m的gcd与各个约数的关系，如果它的gcd能整除某个约数，那么这个约数的所有倍数都是可行的，并且和可以用等差数列求和公式求出。但是这显然就带来了一个重复的问题，那么我们在求和的过程中还要统计每个数被求和的次数，然后进行处理。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; bool vis[10005]; int cnt[10005]; int gcd(int x,int y) { return y?gcd(y,x%y):x; } int main() { int t,i,j,k; cin&gt;&gt;t;int case1=0; while(t--){ case1++; int n,m;vector&lt;int&gt;ys; memset(vis,0,sizeof(vis));memset(cnt,0,sizeof(cnt)); cin&gt;&gt;n&gt;&gt;m; for(i=1;i*i&lt;=m;i++){//求m的约数 if(m%i==0){ ys.push_back(i); if(i*i!=m)ys.push_back(m/i); } } sort(ys.begin(),ys.end());ys.pop_back();//使约数从小到大排列方便后面求重复的问题 for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;k);// k=gcd(k,m); for(j=0;j&lt;ys.size();j++){ if(ys[j]%k==0) vis[j]=1;//这个约数及其倍数都是可行的 } } ll ans=0; for(i=0;i&lt;ys.size();i++){ if(vis[i]&amp;&amp;cnt[i]!=1){ int last1=(m-1)/ys[i]*ys[i],num=(m-1)/ys[i]+1; ans+=(ll)(0+last1)*num/2*(1-cnt[i]); for(j=i+1;j&lt;ys.size();j++) if(ys[j]%ys[i]==0)//所有是这个约数的倍数的约数都被重复计数了,标记一下 cnt[j]+=1-cnt[i]; } } printf(&quot;Case #%d: %lld\n&quot;,case1,ans); //cout&lt;&lt;ans&lt;&lt;endl; } return 0; } H.题目可以比较暴力的求解，因为有个结论：如果a和m互质，那么$k* m+a$和$m$也互质，于是我们暴力求1~m的范围内与m互质的数的个数n，然后每m个数中就有n个数与m互质。需要注意的就是当$n|k$时要特判一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } int main() { ll n,m,i,j,k; while(cin&gt;&gt;m&gt;&gt;k){ vector&lt;ll&gt;rp; for(i=1;i&lt;=m;i++){ if(gcd(i,m)==1) rp.push_back(i); } ll xs=k/rp.size(); ll ans; if(k%rp.size()) ans=m*xs+rp[k%rp.size()-1]; else ans=m*(xs-1)+rp[rp.size()-1];//注意特判 printf(&quot;%lld\n&quot;,ans); } return 0; } I.非常套路的题，枚举集合内的数然后求一下他们的LCM，然后容斥原理搞一搞他们的倍数的个数就ok了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } ll sum(ll x,vector&lt;int&gt;v) { ll res=0,i,j; for(i=1;i&lt;(1&lt;&lt;v.size());i++){ ll val=1,cnt=0; for(j=0;j&lt;v.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val=val*v[j]/gcd(val,v[j]);//一定要求LCM!集合里的数不见得两两互质 cnt++; } } if(cnt&amp;1LL)res+=x/val; else res-=x/val; } return res; } int main() { ll n,m; int i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ vector&lt;int&gt;v;//bool haszero=false; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);if(j)v.push_back(j); } printf(&quot;%lld\n&quot;,sum(n-1,v)); //else cout&lt;&lt;0&lt;&lt;endl; } return 0; } J.其实就是求1~b/k跟1~d/k中有多少对互质的数。假设b&gt;d，我可以认为从后一个集合中挑的数一定都是比较小的数（避免重复），那么对于互质对(x,y),x&gt;=y,当x&lt;=d/k时，其实y的取值就是x的欧拉函数值。而当d/k&lt;=x&lt;=b/k时，就用之前题目中求过的那种方式求1~d/k中与x互质的数的个数即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll eular(ll x) { ll res = x, a = x; for (ll i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } ll sum(ll x,ll n) { ll i,j; vector&lt;ll&gt;prime; for(i=2;i*i&lt;=n;i++){ if(n%i==0){ prime.push_back(i); while(n%i==0) n/=i; } } if(n&gt;1)prime.push_back(n); ll res=0; for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){ ll val=1;ll cnt=0; for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1){ res+=x/val; } else res-=x/val; } return x-res; } ll phi[1000005]; void phi_table(ll n)///欧拉函数值表 { phi[1]=1; for(ll i=2; i&lt;=n; i++) { if(!phi[i]) { for(ll j=i; j&lt;=n; j+=i) { if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); } } } } int main() { int t;ll a,b,c,d,i,j,k; cin&gt;&gt;t; phi_table(100010); for(ll i=2; i&lt;=100000; i++) phi[i]+=phi[i-1];///前缀和 int cnt=0; while(t--){ ll ans=0; cnt++; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0 || k &gt; b || k &gt; d) { printf(&quot;Case %d: 0\n&quot;, cnt); continue; } if(b&lt;d)swap(b,d); b/=k;d/=k; // for(i=1;i&lt;=d;i++) // ans+=eular(i); for(i=d+1;i&lt;=b;i++) ans+=sum(d,i); printf(&quot;Case %d: %lld\n&quot;,cnt,ans+phi[d]); } return 0; }]]></content>
      <categories>
        <category>组合数学</category>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）最小圆覆盖]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e5-9c-86-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[算法目的：在线性时间复杂度内求出覆盖n个点的最小圆算法步骤：①首先现将所有点随机排列 ②按顺序把点一个一个的加入（一步一步的求前i个点的最小覆盖圆），每加入一个点就进入③ ③如果发现当前i号点在当前的最小圆的外面，那么说明点i一定在前i个点的最小覆盖圆边界上，我们转到④来进一步确定这个圆，否则前i个点的最小覆盖圆与前i-1个点的最小覆盖圆是一样的，则不需要更新，返回② ④此时已经确认点i一定在前i个点的最小覆盖圆的边界上了，那么我们可以把当前圆的圆心设为第i个点，半径为0，然后重新把前i-1个点加入这个圆中（类似上面的步骤，只不过这次我们提前确定了点i在圆上，目的是一步一步求出包含点i的前j个点的最小覆盖圆），每加入一个点就进入⑤ ⑤如果发现当前j号点在当前的最小圆的外面，那么说明点j也一定在前j个点（包括i）的最小覆盖圆边界上，我们转到⑥来再进一步确定这个圆，否则前j个点（包括i）的最小覆盖圆与前i-1个点（包括i）的最小覆盖圆是一样的，则不需要更新，返回④ ⑥此时已经确认点i，j一定在前j个点（包括i）的最小覆盖圆的边界上了，那么我们可以把当前圆的圆心设为第i个点与第j的点连线的中点，半径为到这两个点的距离（就是找一个覆盖这两个点的最小圆），然后重新把前j-1个点加入这个圆中（还是类似上面的步骤，只不过这次我们提前确定了两个点在圆上，目的是求出包含点i，j的前k个点的最小覆盖圆），每加入一个点就进入⑦ ⑦如果发现当前k号点在当前的最小圆的外面，那么说明点k也一定在前k个点（包括i，j）的最小覆盖圆边界上，我们不需要再进一步确定这个圆了（因为三个点能确定一个圆！），直接求出这三点共圆，否则前k个点（包括i，j）的最小覆盖圆与前k-1个点（包括i，j）的最小覆盖圆是一样的，则不需要更新。 时间复杂度：O(N) 空间复杂度：O(N) 注意事项: 以上时间复杂度的证明全部基于点的排列随机，如果点的排列不随机，那么时间复杂度将有可能达到O(N3) 所以最小圆覆盖算法只能在O(N)时间内求出N的点的最小覆盖圆，而不能在O(N)的时间内求出所有的前i个点的最小覆盖圆 代码 给定n个点求最小覆盖圆圆心及半径 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; const int N=505; using namespace std; struct node { double x, y; }b[N]; node O; double R; double sqr(double x) { return x * x; } double dis(node x,node y)//距离 { return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y)); } bool incircle(node x)//判断点是否在圆内 { if(dis(O,x)&lt;=R) return true; return false; } node solve(double a,double b,double c,double d,double e,double f) { node t; t.y=(f*a-c*d)/(b*d-e*a); t.x=(f*b-c*e)/(a*e-b*d); return t; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int i, j, k; for (i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;b[i].x, &amp;b[i].y); random_shuffle(b + 1, b + n + 1); R = 0;O.x=O.y=0; for (i = 1; i &lt;= n; i++) if (!incircle(b[i])) { O.x = b[i].x; O.y = b[i].y; R = 0; for (j = 1; j &lt; i; j++) if (!incircle(b[j])) { O.x = (b[i].x + b[j].x) / 2; O.y = (b[i].y + b[j].y) / 2; R = dis(O, b[i]); for (k = 1; k &lt; j; k++) if (!incircle(b[k])) { O = solve( b[i].x - b[j].x, b[i].y - b[j].y, (sqr(b[j].x) + sqr(b[j].y) - sqr(b[i].x) - sqr(b[i].y)) / 2, b[i].x - b[k].x, b[i].y - b[k].y, (sqr(b[k].x) + sqr(b[k].y) - sqr(b[i].x) - sqr(b[i].y)) / 2 ); R = dis(b[i], O); } } } printf(&quot;%.2f %.2f %.2f\n&quot;, O.x, O.y,R);//坐标,半径 } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）任意多边形的重心]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e4-bb-bb-e6-84-8f-e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e9-87-8d-e5-bf-83%2F</url>
    <content type="text"><![CDATA[计算多边形重心方法：（1）划分多边形为三角形： 以多边形的一个顶点V为源点（V可取输入的第一个顶点），作连结V与所有非相邻顶点的线段，即将原N边形或分为（N-2）个三角形； （2）求每个三角形的重心和面积： 设某个三角形的重心为$G（c_x，c_y）$，顶点坐标分别为$A_1（x_1，y_1），A_2（x_2，y_2），A_3（x_3，y_3）$，则有$C_x = \frac{(x_1 + x_2 + x_3)}{3}$.同理求得cy。求面积的方法是 $S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$，当$A_1,A_2,A_3$顺时针排列时取-，否则取正（叉积）。事实上，在求每个三角形时不需要辨别正负，之后有方法抵消负号。 （3）求原多边形的重心： 公式：$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ，其中$C_{xi},C_{yi},S_i$分别是所划分三角形的重心坐标和面积；注意如果在求各个三角形重心的时候没有除以3则最后要统一除以3； 总结每个三角形重心：$C_x = \frac{(x_1 + x_2 + x_3)}{3}$；cy同理。 每个三角形面积：$S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$； 多边形重心：$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ 代码 给定一个n边形，求重心坐标 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;double,double&gt;P; P node[105]; P mass_node(P a,P b,P c)//求重心 { return P((a.first+b.first+c.first)/3,(a.second+b.second+c.second)/3); } double square(P a,P b,P c)//求面积 { double s = ((b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second)) / 2; return s; } int main() { int n,i,j,k;int cnt=0; while(cin&gt;&gt;n&amp;&amp;n){ cnt++; for(i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].first,&amp;node[i].second); vector&lt;P&gt;mass;vector&lt;double&gt;s; double tots=0; for(i=2;i&lt;n;i++){ P t=mass_node(node[1],node[i],node[i+1]);mass.push_back(t);//划分三角形求重心 double s1=square(node[1],node[i],node[i+1]);s.push_back(s1);//求面积 tots+=s1; } double cx=0,cy=0; for(i=0;i&lt;mass.size();i++){ cx+=mass[i].first*s[i];cy+=mass[i].second*s[i];//求多边形重心 } cout&lt;&lt;&quot;Stage #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;; printf(&quot;%.6f %.6f\n&quot;,cx/tots,cy/tots); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #2]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-2%2F</url>
    <content type="text"><![CDATA[A. 有两个数组A，B，每次可以选择一个A，B中出现过的数字x并将它替换为另一个随意的数y，一次操作会把A，B中的所有的x都换成y，并且，最后应当使得A，B完全相等，即对应位上的数一样。同时，问在操作数最少时有多少种操作的方法。 首先，应该想到的一点是因为一个数可能重复出现很多次，而他在不同位置出现时与他同一位置的不同数组的数很可能是不一样的，这就意味着所有的这些数最后是要变成一个相同的数的。那么为了确定有多少组这样最后要变成一样的数，可以搜素或者并查集搞一波。注意的是每一组里面如果有n个数，那么他只需要做n-1次变换。 对于第二问，首先我们假设这一组中有n个数（相同的数搜索的时候会被合并，所以计算的时候肯定不会有重复），那么最后变成的数就有n种选择，这个数确定了以后，对于其余n-1个数而言，他们先后变换一次（不一定一次就变为选定的这个数），那么可能有$(n-1)!$种。同时，每个数变换的时候一定是变为这一组中剩下数中的一个（每当一个数发生了变换，他就永久从数组中消失了，因为我们要求总操作次数最少），所以对于第一个变的数而言，它的选择是$n-1$，第二个数是$n-2$…，因此，每一组大小为n的数的可能是$n\times (n-1)!\times (n-1)!$种。而对于全体数而言，我们的先后顺序是无所谓的，所以可能数应该是$m!$,但是因为对于每一组数，其内部的顺序已经计算过了一次，根据除法原理，每一组大小为n的数都会带来$(n-1)!$的重复，所以应当除去。所以最后总的可能数就是$\prod {n!}\ \times m!$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int mod=1e9+7; vector&lt;int&gt; G[maxn]; bool vis[maxn]; ll fac[maxn]; int cnt; void dfs(int u) { vis[u]=true;cnt++; for(auto a:G[u]) if(!vis[a]) dfs(a); } int main() { fac[0] = 1;int t; cin &gt;&gt; t; while (t--) { for (int i = 0; i &lt; maxn; i++) { G[i].clear(); } memset(vis,0,sizeof(vis)); for (int i = 1; i &lt; maxn; i++) fac[i] = (fac[i - 1] * i) % mod; int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = 0; ll a[maxn], b[maxn]; for (int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;,&amp;b[i]); if (b[i] != a[i]) { G[a[i]].push_back(b[i]);G[b[i]].push_back(a[i]); } } ll ans1 = 1; for (int i = 0; i &lt; n; i++) { if (vis[a[i]])continue; cnt = 0;dfs(a[i]); ans += (cnt - 1); ans1 = ans1 * fac[cnt] % mod; } ans1 = ans1 * fac[ans] % mod; cout &lt;&lt; ans &lt;&lt; &quot; &quot;; if (k == 2)cout &lt;&lt; ans1; cout &lt;&lt; endl; } return 0; } D.画画图大胆猜结论啊，其实我们会发现如果一个图形能被分割为有限个平行四边形的话，那么它一定可以被分割为随意数量的更多的平行四边形（在分割好的平行四边形里面不断做平行线不就好了）。因此就是要判断一个图形能不能分成若干个平行四边形。 猜结论：每条边至少有另外一条边与其平行且长度相等。 计算斜率的时候为了避免分母为0要注意一下。 代码#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,ll&gt;P; const double eps=1e-6; int main() { int n,i,j,k; cin&gt;&gt;n; vector&lt;P&gt;v; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b);v.push_back(P(a,b));//边 } vector&lt;P&gt;xl;vector&lt;double&gt;len; for(i=0;i&lt;v.size();i++){ xl.push_back(P(v[(i+1)%n].first-v[i].first, v[(i+1)%n].second-v[i].second));//斜率(防止分母0没有直接除) len.push_back(sqrt((v[(i+1)%n].first-v[i].first) * (v[(i+1)%n].first-v[i].first) + (v[(i+1)%n].second-v[i].second)*(v[(i+1)%n].second-v[i].second)));//边长度 } for(i=0;i&lt;xl.size();i++){ bool isok=false; for(j=0;j&lt;xl.size();j++){//暴力枚举 if(i==j)continue; if(xl[i].first*xl[j].second==xl[i].second*xl[j].first&amp;&amp;fabs(len[i]-len[j])&lt;eps){ isok=true;break; } } if(!isok){ puts(&quot;no&quot;);return 0; } } puts(&quot;yes&quot;); return 0; } H.首先明确一点，即题目中给的函数$f(l,r)$他的值是唯一确定的（$（l，r）$代表其左右边界位置），但是我们要求的是在$(l,r)$范围内的所有$f(l_1,r_1)$的最大值，这就不确定了。因此想法很简单：先算出所有的$f$，然后区间dp求答案。 当然，首先要简单写写，推出公式： $f(l,r)=f(l,r-1)\ \oplus\ f(l+1,r)=f(l,r-2)\ \oplus\ f(l+2,r)$（拿哪个公式来推都没问题） 代码#include&lt;bits/stdc++.h&gt; using namespace std; int num[5005][5005],f[5005][5005]; int main() { int n,i,j,k,len; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i][i];f[i][i]=num[i][i]; num[i-1][i]=num[i-1][i-1]^num[i][i]; } for(len=2;len&lt;n;len++) for(i=1;i+len&lt;=n;i++){ num[i][i+len]=num[i][i+len-2]^num[i+2][i+len]; } for(len=1;len&lt;n;len++){ for(i=1;i+len&lt;=n;i++){ f[i][i+len]=max(num[i][i+len],max(f[i+1][i+len],f[i][i+len-1]));//注意这里的比较 } } int q,l,r; cin&gt;&gt;q; while(q--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\n&quot;,f[l][r]); } return 0; } I. 给定两个等长数组A，B，要求对于每个$a_i$,在B中找一个数与其异或，并且B中每个数只能用一次，求异或后字典序最小的A数组 显然就是对A从前往后找它异或后最小的b就行了呀，为了找出最小的b，建立一棵二进制trie树即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn=3e6+5; struct node{ int sum; node*next1[2]; bool tag,ask; node(){//新建函数 sum=0;tag=false;ask=false;next1[0]=next1[1]=NULL; } }*root=new node(); void add(int x) { int i,j; struct node*p=root; for(i=30;~i;i--) { if((1&lt;&lt;i)&amp;x){ if(!p-&gt;next1[1]) { node*t=new node(); p-&gt;next1[1] = t; } p=p-&gt;next1[1]; } else { if(!p-&gt;next1[0]) { node*t=new node(); p-&gt;next1[0] = t; } p=p-&gt;next1[0]; } p-&gt;sum++; } } int query(int x) { int i,j;node*p=root,*pre; int res=0; for(i=30;~i;i--){ pre=p; if((1&lt;&lt;i)&amp;x){ if(p-&gt;next1[1]&amp;&amp;p-&gt;next1[1]-&gt;sum) p=p-&gt;next1[1],res=res&lt;&lt;1|1; else p=p-&gt;next1[0],res&lt;&lt;=1; } else{ if(p-&gt;next1[0]&amp;&amp;p-&gt;next1[0]-&gt;sum) p=p-&gt;next1[0],res&lt;&lt;=1; else p=p-&gt;next1[1],res=res&lt;&lt;1|1; } p-&gt;sum--; } return res; } int main() { int n,i,j,k; cin&gt;&gt;n;int a[maxn]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);add(j); } for(i=1;i&lt;=n;i++){ int ans=query(a[i]);ans^=a[i]; cout&lt;&lt;ans&lt;&lt;&apos; &apos;; } return 0; } J. 给定n个形如$y=(x-a_i)^2+b_i$的抛物线，求它们划分平面的区域数。 注意到给定的抛物线都是同一种形式的，当$a_i\neq a_j$时，这两个抛物线就有一个交点，否则没有。因此可以类比直线划分平面来做：对于每一条新的抛物线，我们计算它与之前抛物线的交点数，它划分出来的新区域数就是（交点数+1）。注意查重，即交点重复问题。 #include&lt;bits/stdc++.h&gt; using namespace std; pair&lt;int,int&gt; p[1010]; pair&lt;double,double&gt; s[1010]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second); sort(p + 1, p + n + 1); n = unique(p + 1, p + n + 1) - p - 1; int ans = 1; for (int i = 1; i &lt;= n; i++) { int tot = 0; for (int j = 1; j &lt; i; j++) if (p[i].first != p[j].first) { double x = (double) (p[i].first * p[i].first + p[i].second - p[j].first * p[j].first - p[j].second) / (2 * (p[i].first - p[j].first)); double y = (double) (x - p[i].first) * (x - p[i].first) + p[i].second; s[++tot] = make_pair(x, y); } sort(s + 1, s + tot + 1); tot = unique(s + 1, s + tot + 1) - s - 1; ans += tot + 1; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>比赛杂集</category>
        <category>暑假训练</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>比赛杂集</tag>
        <tag>暑假训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）矩阵快速幂]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-9f-a9-e9-98-b5-e5-bf-ab-e9-80-9f-e5-b9-82%2F</url>
    <content type="text"><![CDATA[矩阵乘法的计算公式：（第一个矩阵为m s,第二个为s n，结果为m* n矩阵） $C_{ij}=\sum a_{ik}\times b_{kj}$ 暴力计算代码（模拟）： const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N { memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } 矩阵快速幂 给定$n\times n$的矩阵$A$，求$A^k$ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; const int maxn=105; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//暴力计算矩阵乘法,N为矩阵大小 { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////n是幂，N是矩阵大小 { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01矩阵 while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn],k; cin&gt;&gt;n&gt;&gt;k;//n为矩阵大小,k为幂次 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;matrci[i][j]; Pow(matrci,k,n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,res[i][j],j==n?&apos;\n&apos;:&apos; &apos;); return 0; } 应用主要通过把数放到矩阵的不同位置，然后把普通递推式变成”矩阵的等比数列”，最后快速幂求解递推式； POJ3070 题目：斐波那契数列f(n),给一个n，求f(n)%10000,n&lt;=1e9; (这题是可以用fibo的循环节去做的，不过这里不讲，反正是水题) 矩阵快速幂是用来求解递推式的，所以第一步先要列出递推式: $ f(n)=f(n-1)+f(n-2)$ 第二步是建立矩阵递推式，找到转移矩阵: $\binom{1\ 1}{1\ 0}\times \binom{f_{n-1}}{f_{n-2}}=\binom{f_n}{f_{n-1}}$ 所以通项就是：$A_n=T^{n-1}\times A_1\ $,$\ T$就是那个转移矩阵。 那么我们要求的其实就是res[1][1]; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int mod=1e4; const int maxn=5; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//暴力计算矩阵乘法,N为矩阵大小 { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////n是幂，N是矩阵大小 { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01矩阵 while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn]={0},k; while(cin&gt;&gt;n&amp;&amp;n!=-1){ if(n==0){ cout&lt;&lt;0&lt;&lt;endl;continue; } matrci[1][1]=1,matrci[1][2]=1,matrci[2][1]=1,matrci[2][2]=0; Pow(matrci,n-1,2); ll fibo[5][5]={0};fibo[1][1]=1; multi(res,fibo,2); cout&lt;&lt;res[1][1]&lt;&lt;endl; } return 0; } 简单递推式： $1.\ f(n)=a\times f(n-1)+b\times f(n-2)+c\ $ (a,b,c为常数) $\binom{a\ b\ 1}{\binom{1\ 0\ 0}{0\ 0\ 1}}\times \binom{f_{n-1}}{\binom{f_{n-2}}{c}}=\binom{f_{n}}{\binom{f_{n-1}}{c}}$(因为矩阵有点问题所以暂时这样) $2.f(n)=c^n-f(n-1)$（c是常数） $\binom{-1\ c}{0\ \ c}\times \binom{f_{n-1}}{c^{n-1}}=\binom{f_n}{c^n}$]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）线性同余方程组（中国剩余定理）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b-e7-bb-84-ef-bc-88-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86-ef-bc-89%2F</url>
    <content type="text"><![CDATA[中国剩余定理求同余方程组 $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $…$ $x\equiv c_k(mod\ m_k)$ 其中，$\forall i,j$有$gcd(m_i,m_j)=1$, 的最小正整数（非负整数）解； 结论令$M=m_1\times m_2\times …\times m_k$， 则$x=(\sum c_i\times \frac{M}{m_i}\times inv(\frac{M}{m_i},m_i))$; 其中,$inv(\frac{M}{m_i},m_i)$即$\frac{M}{m_i}$相对于$m_i$的乘法逆元。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; ll extgcd(ll a,ll b,ll&amp;x,ll&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } ll d=extgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d; } int main() { ll n,a,b,i,j,m[20],k[20];//m为各个模数,k为余数 cin&gt;&gt;n; ll M=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;m[i]&gt;&gt;k[i]; M*=m[i];//求M } ll x,y;ll X=0; for(i=1;i&lt;=n;i++){ ll a=M/m[i];ll b=m[i]; extgcd(a,b,x,y); x=(x+b)%b; if(!x)x+=b; X+=k[i]*a*x; } X%=M; } 模板题 扩展中国剩余定理求同余方程组 $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $…$ $x\equiv c_k(mod\ m_k)$ 的最小正整数（非负整数）解；（即删去了模数互质的条件） 结论对于两个方程 $x\equiv c_1(mod\ m_1)$及$x\equiv c_2(mod\ m_2)$，将其合并为一个方程，有解条件为$gcd(m_1,m_2)|(c_2-c_1)$. 那么（有解时），$m=\frac{m_1\times m_2}{gcd(m_1,m_2)}$, $c=(inv(\frac{m_1}{gcd(m_1,m_2)},\frac{m_2}{gcd(m_1,m_2)})\times \frac{c_2-c_1}{gcd(m_1,m_2)}\ mod \ \frac{m_2}{gcd(m_1,m_2)}\times m_1+c_1$， 如此从前往后递推下去，直到求出一个式子： $x\equiv c(mod\ m)$， 那么原方程组的一个解即为$x=c\ mod\ m$ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int N=1005; int k; ll c[N],m[N],c1,c2,m1,m2,t;//c为余数,m为模数 bool flag; ll gcd(ll a,ll b) { if (!b) return a; else return gcd(b,a%b); } void exgcd(ll a,ll b,ll &amp;x,ll &amp;y) { if (!b) x=1LL,y=0LL; else exgcd(b,a%b,y,x),y-=a/b*x; } ll inv(ll a,ll b) { ll x=0LL,y=0LL; exgcd(a,b,x,y); x=(x%b+b)%b; if (!x) x+=b; return x; } int main() { while (~scanf(&quot;%d&quot;,&amp;k))//同余方程个数 { flag=true; for (int i=1;i&lt;=k;i++) scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;c[i]); for (int i=2;i&lt;=k;i++) { m1=m[i-1],m2=m[i],c1=c[i-1],c2=c[i]; t=gcd(m1,m2); if ((c2-c1)%t!=0) { flag = false; break;//不整除则无解 } m[i]=m1*m2/t; c[i]=inv(m1/t,m2/t)*((c2-c1)/t)%(m2/t)*m1+c1; c[i]=(c[i]%m[i]+m[i])%m[i]; } if (!flag) puts(&quot;-1&quot;); else printf(&quot;%lld\n&quot;,c[k]); } return 0; } 此时的最小正整数解就是$c[k]$（小于0就加上$m_1\times m_2$) 模板运行过程中似乎会遇到取模时值为负数导致出错的问题，解决方法如下： a[i] = m1 * m2 / t; ll temp=(c2 - c1) / t; if(temp&lt;0){ ll t1=abs(temp)/(m2/t);temp+=(m2/t)*(t1+1); } ll temp2=inv(m1 / t, m2 / t); if(temp2&lt;0){ ll t1=abs(temp2)/(m2/t);temp2+=(m2/t)*(t1+1); } c[i] = (temp2)%(m2 / t) * ((temp) % (m2 / t)) % (m2 / t)* m1 + c1; c[i] = (c[i] % a[i] + a[i]) % a[i]; 模板题：POJ2891]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）线性同余方程]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[定义:a,b是整数，形如$ax≡b(mod \ m)$，且x是未知整数的同余式称为一元线性同余方程。 定理：a,b,m是整数且m&gt;0,$gcd(a,m)=d$,如果$d|b$，则方程恰好有d个模m不同余的解，否则方程无解。 由同余方程的定义式可得$ax+my=b$，这个方程称为二元一次不定方程。 由扩展欧几里得算法可求出方程$ax+my=gcd(a,m)$的特解，则原方程的通解为 $ x = x_0 \times \frac{b}{gcd(a,m)}+ \frac{m}{gcd(a,m)}\times t$ $ y = y_0 \times \frac{b}{gcd(a,m)}– \frac{a}{gcd(a,m)}\times t$ $t=0,1,2,3…$ 扩展欧几里得： int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } x，y即为$ax+my=gcd(a,m)$的特解。 例子：NOIP2012 同余方程 求关于 x 的同余方程 $ax≡1(mod\ b) $的最小正整数解。 因为题目保证了一定有解，所以直接求即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } int main() { int a,b,x,y; cin&gt;&gt;a&gt;&gt;b; extgcd(a,b,x,y); x=(x+b)%b; cout&lt;&lt;x&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）高精度算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[__int128最简单粗暴的做法。 这种类型只有部分GCC编译器支持。经测试，正常运算与普通int无异，但是输入输出时无论是cin，cout还是printf都会报错，所以必须自己写输入输出函数。 定义时与别的数据类型并没有什么区别 eg: __int128 a,b,c; 输入暂时采用字符串读入方式。 方法一：重载输出 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, __int128 T) { if (T&lt;0) os&lt;&lt;&quot;-&quot;;if (T&gt;=10 ) os&lt;&lt;T/10;if (T&lt;=-10) os&lt;&lt;(-(T/10)); return os&lt;&lt;( (int) (T%10) &gt;0 ? (int) (T%10) : -(int) (T%10) ) ; } 方法二：变为字符串式输入输出 输入： void scan(__int128 &amp;x)//输入 { x = 0; int f = 1; char ch; if((ch = getchar()) == &apos;-&apos;) f = -f; else x = x*10 + ch-&apos;0&apos;; while((ch = getchar()) &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) x = x*10 + ch-&apos;0&apos;; x *= f; } 输出： void print(__int128 x) { if(x &lt; 0) { x = -x; putchar(‘-‘); } if(x &gt; 9) print(x/10); putchar(x%10 + ‘0‘); } 简单模板（不支持负数）#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 1000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } 更完善的模板支持负数之类的操作。需要注意的是如果涉及bign与常规类型的数值之间的之间计算，比如一个bign+ll，可能需要额外新增重载运算符，因为默认的似乎只有bign+int的重载，否则可能溢出出错。 以及，大数的长度需要额外注意，开太大容易爆内存。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //最大长度，可以修改 using namespace std; class bign { public: int len, s[MAX_L];//数的长度，记录数组 //构造函数 bign(); bign(const char *); bign(int); bool sign;//符号 1正数 0负数 string toStr() const;//转化为字符串，主要是便于输出 friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//重载输入流 friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//重载输出流 //重载复制 bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //重载各种比较 bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //重载四则运算 bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //四则运算的衍生运算 bign operator%(const bign &amp;) const;//取模（余数） bign factorial() const;//阶乘 bign Sqrt() const;//整数开根（向下取整） bign pow(const bign &amp;) const;//次方 //一些乱乱的函数 void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005];]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）欧拉函数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e6-8b-89-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[1~n中与n互质的数的个数称为欧拉函数 int eular(int x) { int res = x, a = x; for (int i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } 性质1：1~n中与n互质的数的和为$n\times eular（n）\div2$; 性质2：若a，b互质，则$eular（a\times b）=eular（a）\times eular（b）$；]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）质数筛法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-b4-a8-e6-95-b0-e7-ad-9b-e6-b3-95%2F</url>
    <content type="text"><![CDATA[埃拉托斯特尼筛法#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; bool notprime[10000005]; void checkprime(int n) { for(int i=2;i&lt;=n;i++){//注意线性筛法做完以后1是没有被标记的... if(notprime[i])continue;//如果已经被标记为合数,那就滚蛋 for(int j=i;j&lt;=n/i;j++)//注意这里一定要小心j*i可能爆int的事实，写成 //j=i*i的时候也是一样要小心！！！最好用long long notprime[j*i]=true;//标记合数 } } int main() { int n,m,i; cin&gt;&gt;n&gt;&gt;m; checkprime(n);notprime[1]=true;//特别注意要标记1 for(i=1;i&lt;=m;i++){ int t; scanf(&quot;%d&quot;,&amp;t); if(notprime[t])cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } return 0; } 线性筛（似乎不大常用） #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int v[10000005],prime[10000000],cnt=0;//v记录每个数的最小质因数,prime记录素数 void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(v[i]==0){//如果i是素数 v[i]=i; prime[++cnt]=i; } for(int j=1;j&lt;=cnt;j++){ if(prime[j]&gt;v[i]||prime[j]&gt;n/i)//如果当前的质数已经比I的最小质因数大了,那么就没有必要再继续下去了,因为后面的i*prime[j] break;//肯定已经被v[i]或者其他更小的质数标记过了;同时,超过n自然也是不用管了 v[i*prime[j]]=prime[j];//标记最小质因数 } } } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; checkprime(n); for(int i=1;i&lt;=m;i++){ int t;scanf(&quot;%d&quot;,&amp;t); if(v[t]==t)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）求乘法逆元]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-b1-82-e4-b9-98-e6-b3-95-e9-80-86-e5-85-83%2F</url>
    <content type="text"><![CDATA[乘法逆元$x\times x^{-1}=1\ (mod\ p)$ 费马小定理前提是模数必须是质数；因为$a^{p-1}\ mod\ p=1$,所以a模p的乘法逆元就是$a^{p-2}$ 运用快速幂: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int n,p,i,j; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt;ans; for(i=1;i&lt;=n;i++){ ll t=pow(i,p-2,p); ans.push_back(t); } for(i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; } 扩展欧几里得算法给定模数m，求a的逆相当于求解$ax=1(mod \ m) $ 这个方程可以转化为$ax-my=1 $ 然后套用求二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd 检查$gcd(a,m)$是否为1 gcd不为1则说明逆元不存在 若为1，则调整 x0 到0~m-1的范围中即可 void exgcd (ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return ; } exgcd (b, a % b, x, y); ll tmp = x; x = y; y = tmp - a / b * y; } //主函数部分调用 ll x, y; exgcd (a, b, x, y);//求a在模b意义下的乘法逆元 x = (x + p) % p; printf (&quot;%d\n&quot;, x); 递推求逆元用于求连续很多数的乘法逆元，时间复杂度基本上是线性 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; int main() { ll n,p,i,j; cin&gt;&gt;n&gt;&gt;p; ll inv[3000005]; inv[1]=1; for(i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p;//关键 for(i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,inv[i]); return 0; } 求连续阶乘的乘法逆元先求出$n!$的逆元，倒序递推。 $inv_i = (inv_{i+1}* (i+1))mod\ p$]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）欧几里得算法]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e5-87-a0-e9-87-8c-e5-be-97-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[欧几里得算法（GCD）： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;gcd(x,y)&lt;&lt;endl; return 0; } 扩展欧几里得算法： int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//返回的是初始时a,b的最大公约数 } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } 扩欧求出的$x$,$y$ 是$a x + b y = gcd(a,b)$的一个特解，我们就可以用 x0 和 y0 表示出整个不定方程的通解： $ x = x_0 + (b/gcd) t$ $ y = y_0 – (a/gcd) t$]]></content>
      <categories>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）快速幂与快速乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e5-b9-82-e4-b8-8e-e5-bf-ab-e9-80-9f-e4-b9-98-e6-b3-95%2F</url>
    <content type="text"><![CDATA[快速幂对于任何一个整数的模幂运算 $a^b\ mod \ c$ 对于b我们可以拆成二进制的形式 $b=b_0+b_1 2+b_2 2^2+…+b_n* 2^n$ 这里我们的$b_0$对应的是b二进制的第一位 ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } 快速乘法 由于计算机底层设计的原因，做加法往往比乘法快的多，因此将乘法转换为加法计算将会大大提高（大数，比较小的数也没必要）乘法运算的速度，除此之外，当我们计算a* b%mod的时候，往往较大的数计算a＊b会超出long long int的范围，这个时候使用快速乘法方法也能解决上述问题． 快速乘法的原理就是利用乘法分配率来将a＊b转化为多个式子相加的形式求解（注意这时使用乘法分配率的时候后面的一个乘数转化为二进制的形式计算）． EX：$ 20＊ 14 ＝ 20＊ (1110)_2 = 20 ＊ (2^3)＊1 + 20＊(2^2)＊1+20＊(2^1)＊１+20＊ (2^0)＊ 0 = 160+80+40=280$ 上面即为快速乘法的基本原理 ll quick_mul(ll a, ll b, ll c) { ll ans = 0; a %= c; b %= c; while (b) { if (b &amp; 1)//如果对应位为1 ans = (ans + a) % c; a &lt;&lt;= 1; a %= c;//对应b的位每次的幂次会增加，加在a上 b &gt;&gt;= 1; } return ans; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）计算几何]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-ae-a1-e7-ae-97-e5-87-a0-e4-bd-95%2F</url>
    <content type="text"><![CDATA[模板如下，解释见注释： #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 100000; const double EPS = 1e-8; // 带误差比较 inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } /* * 向量（Vector）或点 * * 使用原点到一个点 (x, y) 的有向线段表示向量 * 从点 A 到点 B 的向量表示为 A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // 相加 Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // 相减 Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // 数乘（伸长、缩短） Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // 范数，用来比较长度，等于长度的平方 double norm() const { return x * x + y * y; } } Pt; // 点乘 double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // 叉乘 double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } // 线段（Segment），用两个点表示 struct Seg { Pt a, b; Seg(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} // 线段包含点（点在线段上） bool include(const Pt &amp;p) { // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上 // PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } }; // 直线，用两个点表示 struct Line { Pt a, b; Line() {} // 提供一个不需要参数的构造函数 Line(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } // 两直线关系（交点个数） // 0 表示平行（无交点） // 1 表示相交（一个交点） // -1 表示重合（无数个交点） static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } // 求两直线交点（需要保证两直线有交点） static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } }; // 求凸包用的点 int n; Pt a[MAXN + 1]; // 凸包极角排序的比较函数 inline bool compare(const Pt &amp;a, const Pt &amp;b) { // 两个向量 Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB 是逆时针，则 A 极角序在先 else return va.norm() &lt; vb.norm(); // norm 较小的长度较小 } struct Poly { std::vector&lt;Pt&gt; pts; //如果不求凸包的话,把多边形的点直接保存在这里,否则把多边形的点保存在外面的a数组中 bool include(const Pt &amp;p) const { int cnt = 0; // 判断与每条边有没有交点 for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举相邻的每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // 如果点 P 在边 AB 上 if (Seg(a, b).include(p)) return true; // 详见图 double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // 奇数的交点 return cnt % 2 == 1; } // 多边形面积（有向面积） double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } // 求凸包（Convex），结果储存在自身 pts 中 void convex() { // 找出最左下角的点 int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // 排序 std::sort(a + 2, a + n + 1, &amp;compare); // 极角序扫描 pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // 比较，如果最后一个点需要被删掉则弹出（pop_back） while (pts.size() &gt;= 2 &amp;&amp; cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) &gt;= 0) pts.pop_back(); pts.push_back(a[i]); } } }; 旋转卡壳（在原有模板上求出凸包后增加以下代码即可）：注意：模板里的ans没有开方！返回的是最远点对距离的平方！解释：http://www.cnblogs.com/Booble/archive/2011/04/03/2004865.html double cross(Pt a,Pt b,Pt c)//求叉积 { return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x); } double dist2(Pt a,Pt b)//求距离 { Pt x=a-b; return (x.norm());//因为本题只要求求距离的平方所以没有开方 } double rotating_calipers(Poly p)//旋转卡壳 { int j=1,n=p.pts.size();p.pts.push_back(p.pts[0]); double ans=0; for(int i=0;i&lt;n;i++) { while(cross(p.pts[i],p.pts[i+1],p.pts[j])&lt;cross(p.pts[i],p.pts[i+1],p.pts[j+1])) j=(j+1)%n; ans=max(ans,max(dist2(p.pts[i],p.pts[j]),dist2(p.pts[i+1],p.pts[j+1]))); } return ans; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(模板）Splay维护区间翻转]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fe6-a8-a1-e6-9d-bf-ef-bc-89splay-e7-bb-b4-e6-8a-a4-e5-8c-ba-e9-97-b4-e7-bf-bb-e8-bd-ac%2F</url>
    <content type="text"><![CDATA[您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1 输入输出格式输入格式：第一行为n,m n表示初始序列有n个数，这个序列依次是 $(1,2,…n-1,n)$ ,m表示翻转操作次数 接下来m行每行两个数$ [l,r][l,r]$ 数据保证 $1≤l≤r≤n$ 输出格式：输出一行n个数字，表示原始序列经过m次变换后的结果 类似线段树的lazytab操作. Splay可以用来维护序列。这样的话是把Splay当作一棵区间树。 所谓区间树和权值树的区别，大概就是区间树每个节点代表的是一段区间（典型代表就是一般的线段树） 权值树好理解一点，就是每个点真的代表一个点。 至于翻转操作，我们可以利用Splay的过程实现。 #include&lt;bits/stdc++.h&gt; #define N 100005 using namespace std; int n,m; int fa[N],ch[N][2],size[N],rev[N],rt; inline void pushup(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; } void pushdown(int x){ if(rev[x]){ swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0; } } void rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],kind; if(ch[y][0]==x)kind=1;else kind=0; if(y==k)k=x; else{if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} ch[y][kind^1]=ch[x][kind];fa[ch[y][kind^1]]=y; ch[x][kind]=y;fa[y]=x;fa[x]=z; pushup(x);pushup(y); } void splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } void build(int l,int r,int f){ if(l&gt;r)return; int mid=(l+r)/2; if(mid&lt;f)ch[f][0]=mid;else ch[f][1]=mid; fa[mid]=f;size[mid]=1; if(l==r)return; build(l,mid-1,mid);build(mid+1,r,mid); pushup(mid); } int find(int x,int k){ pushdown(x);int s=size[ch[x][0]]; if(k==s+1)return x; if(k&lt;=s)return find(ch[x][0],k); else return find(ch[x][1],k-s-1); } void rever(int l,int r){ int x=find(rt,l),y=find(rt,r+2); splay(x,rt);splay(y,ch[x][1]);int z=ch[y][0]; rev[z]^=1; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt=(n+3)/2;build(1,n+2,rt); for(int i=1;i&lt;=m;i++){ int L,R;scanf(&quot;%d%d&quot;,&amp;L,&amp;R); rever(L,R); } for(int i=2;i&lt;=n+1;i++)printf(&quot;%d &quot;,find(rt,i)-1); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #499 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-499-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力搞搞就行 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int main() { int n,k,i,j; string str; cin&gt;&gt;n&gt;&gt;k&gt;&gt;str; vector&lt;char&gt;v; for(auto a:str)v.push_back(a); sort(v.begin(),v.end()); int pre=0;int cnt=0,w=0; for(i=0;i&lt;v.size();i++){ if(v[i]-pre&lt;2)continue; else{ cnt++;pre=v[i];w+=v[i]-&apos;a&apos;+1; } if(cnt==k)break; } if(cnt&lt;k){ puts(&quot;-1&quot;); } else{ cout&lt;&lt;w&lt;&lt;endl; } return 0; } B. 比赛的时候傻逼了，写了半天优先队列，数据那么小骑士暴力枚举每个人能分多少个就可以了，数据要是大一点二分也行。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int cnt[105], b[105]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; cnt[i]; b[cnt[i]]++; } for (int i = 100; i &gt;= 1; i--) { int t = 0; for (int j = 1; j &lt;= 100; j++) { t += b[j] / i; } if (t &gt;= n) { cout &lt;&lt; i; return 0; } } cout &lt;&lt; 0; return 0; } C. 感觉这题非常签到呀，直接递推就行了 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,m,i,j,k,a[1005],b[1005]; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; if(a[i]==1){ puts(&quot;-1&quot;);return 0; } } for(i=1;i&lt;=n;i++){ cin&gt;&gt;b[i]; if(b[i]==1){ puts(&quot;-1&quot;);return 0; } } double w=m; w+=w/(b[1]-1); for(i=n;i&gt;1;i--){ w+=w/(a[i]-1); w+=w/(b[i]-1); } w+=w/(a[1]-1); printf(&quot;%.10f\n&quot;,w-m); return 0; } D. 题目比较长，难度主要是在读题上还有输出flush上。其实本身不太难，首先我们不知道真假序列是什么的话显然是无从下手的，因此我们只要问n次最大值m或者n次1就可以了，因为我们知道这种情况下的答案（如果返回0的话那直接结束程序就行了），这样就可以求出整个序列了。然后因为m的范围有限，而我们知道任何一个正整数都可以用2的若干个幂次的和表现出来，因此我们可以二分一下。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int wrong[31], poww[31]; int main() { int m, n, q1,i,j,k; cin &gt;&gt; m &gt;&gt; n; poww[0] = 1; for (i = 1; i &lt; 31; i++) { poww[i] = poww[i - 1] &lt;&lt; 1;//预处理2的幂次方 } for (i = 0; i &lt; n; i++) { printf(&quot;%d\n&quot;, m);//询问n次m fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (q1 == -1) wrong[i] = 1; else if (q1 == 1) wrong[i] = 0; else return 0;//如果是0直接返回 } int ans = 0;int num = 0; for (i = 29; ~i ; i--) { if (ans + poww[i]&gt;m)continue; printf(&quot;%d\n&quot;, ans + poww[i]); fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (wrong[num%n] == 0)q1 *= -1;//根据预处理真假序列改变 if (q1 == 1) { ans += poww[i]; } else if (q1 == 0) { return 0; } num++; } printf(&quot;%d\n&quot;, ans); return 0; } E. 题目真的挺难懂的。其实就是给定n种数及k，每个数可以用无限次，问这些数随意组合的和%k有多少种可能，并输出所有可能。 其实就是求同余方程$a_1 x_1+a_2 x_2+…+a_n* x_n=m (mod k)$中所有的m。 根据贝祖定理可以知道，这等价于问有多少个m满足$gcd(a_1,a_2,a_3…a_n)|m$ 那么其实就很好求了。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; //set&lt;int&gt;s; int d=k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); d=gcd(d,j%k); } int cnt=0; for(i=0;i&lt;k;i+=d) cnt++; cout&lt;&lt;cnt&lt;&lt;endl; for(i=0;i&lt;k;i+=d) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2486 树链剖分（区间更改，区间查重）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fp2486-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8c-ba-e9-97-b4-e6-9b-b4-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-9f-a5-e9-87-8d-ef-bc-89%2F</url>
    <content type="text"><![CDATA[树剖，用线段树维护： 数组a[N]表示此时的颜色段数。 数组left1[N]表示此时最左边的节点的颜色。 数组right1[N]表示此时最右边的节点的颜色。 则： 首先我们要明确，线段树的叶子节点一定只有一种颜色，也就是一条颜色段。 a[父亲]=a[左儿子]+a[右儿子]； if (left1[右儿子]==right1[左儿子]) {a[父亲]–;} 即如果右儿子的最左边颜色和左儿子的最右边颜色相同，那么肯定有中间部分属于同一颜色段。 以及往上跳的时候重链连接处颜色是否相同的问题，相同的话也要减。 #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=100000+10; vector&lt;int&gt;G[maxn]; //int mod; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],left1[maxn&lt;&lt;2],right1[maxn&lt;&lt;2]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 //int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void pushdown(int rt) { a[rt&lt;&lt;1]=a[rt&lt;&lt;1|1]=1; lazytab[rt&lt;&lt;1]=lazytab[rt&lt;&lt;1|1]=left1[rt&lt;&lt;1]=right1[rt&lt;&lt;1]=left1[rt&lt;&lt;1|1]=right1[rt&lt;&lt;1|1]=lazytab[rt]; lazytab[rt]=0; } void pushup(int r) { a[r]=a[r&lt;&lt;1]+a[r&lt;&lt;1|1]; left1[r]=left1[r&lt;&lt;1];right1[r]=right1[r&lt;&lt;1|1]; if(right1[r&lt;&lt;1]==left1[r&lt;&lt;1|1])a[r]--; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=1; left1[rt]=right1[rt]=wt[l]; //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); //a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); pushup(rt); } inline int query(int rt,int l,int r,int L,int R) { int ans=0; if(L&lt;=l&amp;&amp;r&lt;=R){ return a[rt]; } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))ans+=query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)ans+=query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); if(L&lt;=((l+r)&gt;&gt;1)&amp;&amp;R&gt;(l+r)&gt;&gt;1&amp;&amp;right1[rt&lt;&lt;1]==left1[rt&lt;&lt;1|1])ans--;//这里也要注意的两边都有的情况下才要减 } return ans; } inline void update(int rt,int l,int r,int L,int R,int color) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]=color;left1[rt]=right1[rt]=color;a[rt]=1; return; //a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,color); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,color); pushup(rt); } } //---------------------------------以上为线段树 int QAQ(int rt, int l, int r, int p) { if (l==r) return left1[rt]; if (lazytab[rt]) pushdown(rt); if (p&gt;(l+r&gt;&gt;1)) return QAQ((rt &lt;&lt; 1 | 1), (l + r &gt;&gt; 1) + 1, r, p); else return QAQ((rt &lt;&lt; 1), l, (l + r &gt;&gt; 1), p); }//返回重链顶点的颜色 inline int queryrange(int x, int y,int n)//查询从x到y最短路径上的点的权值之和,n就是节点的总数 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 //res=0; ans+=query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 int nc= QAQ(1, 1, n, id[top[x]]);//往顶端跳的时候还要留意一个问题,就是不同重链之间的连接处颜色是否相同的问题 int fc= QAQ(1, 1, n, id[fa[top[x]]]); if(nc==fc) ans--; x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 //res=0; ans+=query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 //ans+=res; return ans?ans:1;//%mod; } inline void addrange(int x, int y, int color,int n)//x到y最短路径上的点都加上k {//同上 //color%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],color); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],color); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;n;i++){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); G[x].push_back(y);G[y].push_back(x); } dfs1(1,0,1);dfs2(1,1);build(1,1,n); for(i=1;i&lt;=m;i++){ char con;cin&gt;&gt;con; if(con==&apos;C&apos;){ int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); addrange(a,b,c,n); } else{ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,queryrange(a,b,n)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2590 树链剖分（单点修改，区间求和and单点查询）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-b4-9b-e8-b0-b7p2590-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8d-95-e7-82-b9-e4-bf-ae-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-b1-82-e5-92-8cand-e5-8d-95-e7-82-b9-e6-9f-a5-e8-af-a2-ef-bc-89%2F</url>
    <content type="text"><![CDATA[一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。 我们将以下面的形式来要求你对这棵树完成一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 III. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身 在板子的基础上类似线段树那样修改即可，注意n的位置！！定义在了所有函数前面 #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int n,m,r; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],mx[maxn]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l];mx[rt]=wt[l];//增加max数组 //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);//更新时更新max } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];return;//求和的询问 } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } int query1(int rt,int l,int r,int L,int R) { int q1=-99999999,q2=-99999999;//初始化不能为0!可能有很多负数! if(L&lt;=l&amp;&amp;r&lt;=R){ return mx[rt];//求最大值的询问 } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))q1=query1(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)q2=query1(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } return max(q1,q2); } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ //lazytab[rt]+=k; a[rt]=k;mx[rt]=k; } else{ //if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]); } } //---------------------------------以上为线段树 inline int queryrange(int x, int y)//查询从x到y最短路径上的点的权值之和 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 res=0; query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 ans+=res; //ans%=mod;//按题意取模 x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 res=0; query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 ans+=res; return ans;//%mod; } inline int querymax(int x, int y)//查询从x到y最短路径上的点的最大权值 { int ans=-99999999;//初始化! while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 //res=0; ans=max(ans,query1(1,1,n,id[top[x]],id[x]));//ans加上x点到x所在链顶端 这一段区间的最大权值 x=fa[top[x]];//把x跳到x所在链顶端的那个点 的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 //res=0; ans=max(ans,query1(1,1,n,id[x],id[y])); //ans+=res; //return ans%mod; return ans; } inline void addrange(int x, int y, int k)//x到y最短路径上的点变为k {//同上 //k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); dfs1(1,0,1);dfs2(1,1);build(1,1,n); int q;cin&gt;&gt;q; while(q--){ string str;int u,t; cin&gt;&gt;str&gt;&gt;u&gt;&gt;t; if(str==&quot;CHANGE&quot;){ addrange(u,u,t); } else if(str==&quot;QMAX&quot;){ printf(&quot;%d\n&quot;,querymax(u,t)); } else{ printf(&quot;%d\n&quot;,queryrange(u,t)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分（模板）]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89%2F</url>
    <content type="text"><![CDATA[先来回顾两个问题： 1，将树从x到y结点最短路径上所有节点的值都加上z 这也是个模板题了吧 我们很容易想到，树上差分可以以O(n+m)的优秀复杂度解决这个问题 2，求树从x到y结点最短路径上所有节点的值之和 lca大水题，我们又很容易地想到，dfs O(n)预处理每个节点的dis（即到根节点的最短路径长度） 然后对于每个询问，求出x,y两点的lca，利用lca的性质distance ( x , y ) = dis ( x ) + dis ( y ) - 2 * dis ( lca )求出结果 时间复杂度O(mlogn+n) 现在来思考一个bug： 如果刚才的两个问题结合起来，成为一道题的两种操作呢？ 模板要求： 如题，已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作： 操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z 操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和 操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z 操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和 以下模板请务必注意： 不需要mod的时候请注意特殊处理！！！以及每个函数里基本都有的n这个参数，就是读入的时候节点的总数！！！#include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int mod; //见题意 int w[maxn],wt[maxn]; //w[]、wt[]初始点权数组 int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2]; //线段树数组、lazy操作 int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大小,top[]当前链顶端节点 int res=0; //查询答案 //-------------------------------------- 以下为线段树 inline void pushdown(int rt,int lenn) { lazytab[rt&lt;&lt;1]+=lazytab[rt]; lazytab[rt&lt;&lt;1|1]+=lazytab[rt]; a[rt&lt;&lt;1]+=lazytab[rt]*(lenn-(lenn&gt;&gt;1)); a[rt&lt;&lt;1|1]+=lazytab[rt]*(lenn&gt;&gt;1); a[rt&lt;&lt;1]%=mod; a[rt&lt;&lt;1|1]%=mod; lazytab[rt]=0; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l]; if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];res%=mod;return; } else{ if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]+=k; a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } } //---------------------------------以上为线段树 inline int queryrange(int x, int y,int n)//查询从x到y最短路径上的点的权值之和,n就是节点的总数 { int ans=0; while(top[x]!=top[y]){//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 res=0; query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 ans+=res; ans%=mod;//按题意取模 x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 } //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 res=0; query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 ans+=res; return ans%mod; } inline void addrange(int x, int y, int k,int n)//x到y最短路径上的点都加上k {//同上 k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline int qSon(int x,int n)//查询x的子树的权值和 { res=0; query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 return res; } inline void updSon(int x,int k,int n)//x的子树中的点都加上k {//同上 update(1,1,n,id[x],id[x]+siz[x]-1,k); } inline void dfs1(int x,int f,int deep) {//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 } } inline void dfs2(int x,int topf) {//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 } } int main() { int n,m,r; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } dfs1(r,0,1); dfs2(r,r); build(1,1,n);//建树 while(m--){ int k,x,y,z; cin&gt;&gt;k; if(k==1){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addrange(x, y, z,n); } else if(k==2){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\n&quot;, queryrange(x, y, n)); } else if(k==3){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); updSon(x,y,n); } else{ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\n&quot;,qSon(x,n)); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>树链剖分</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>树链剖分</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #455 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-455-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力枚举即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;set&gt; using namespace std; int main() { set&lt;string&gt;s; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int i,j; for(i=0;i&lt;str1.size();i++){ string str11=str1.substr(0,i+1); for(j=0;j&lt;str2.size();j++){ string str22=str2.substr(0,j+1); s.insert(str11+str22); } } cout&lt;&lt;*s.begin()&lt;&lt;endl; return 0; } B. 结论题。首先想象对于一个区间[i,i+1],所有覆盖这个区间的线段都必然属于不同的层，否则任意两个线段都会相交，显然不行。那么我们有一个大胆的想法：枚举所有的i，找出(i+1)* (n-i)中最大的即是答案。事实上确实如此。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,i,j,ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++){ ans=max(ans,(i+1)*(n-i)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 题意：f代表for语句，它后面的语句至少有一句是它内部的，其他语句要么在内部要么在外部，s语句是普通语句。给一个没有缩进的f, s代码，求一共有多少种满足上述的缩进方案，结果模1e9+7。 令f[i][j]代表第i行有j个缩进的可能数。那么对于每一行的语句，如果他是f的话，那么显然，这一行的缩进只能++；但如果这一行是s的话，那么其实这一个语句可以是上面任意一个f的缩进。因此对于j=1…cnt,有f[i][j]+=f[i-1]k，因此我们可以趁机压缩一维（前缀和dp），对于j=1..cnt，有f[j]+=f[j-1]即可，当然要取模； 最后一行如果不是紧接着f的，那么f[cnt]就是前缀和dp，否则就是f在有cnt个缩进下的情况，因此输出f[cnt]即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; long long f[5005]; const int mod=1e9+7; int main() { int n,i,j,cnt=0;char c; cin&gt;&gt;n; f[0]=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;c; if(c==&apos;f&apos;) cnt++; else{ for(j=1;j&lt;=cnt;j++) f[j]=(f[j]+f[j-1])%mod; } } cout&lt;&lt;f[cnt]&lt;&lt;endl; return 0; } D. 我们可以设想，如果我们把这些点按照相邻的相同颜色为标准分为连续的一组组的话，那么每次操作后被删去的点肯定都是每一组左右两端的两个点，因为这两个点与不同颜色的段接壤（当然第一段与最后一段除外，他们每次只减1）。那么我们可以重复此操作，直到至少有一段被删光，这时，他的左右两个区间可能因为颜色相同变成一个区间，这时候就必要重新安排了。写法还是挺精妙的 。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef pair&lt;char,int&gt;P; const int maxn=1e6+5; char s[maxn]; int main() { int cnt,i,j,ans=0,tot=0; scanf(&quot;%s&quot;,s+1); P pa[maxn]; int n=strlen(s+1); for(i=1;i&lt;=n;i++) { if (s[i] != s[i - 1]) pa[++tot] = P(s[i], 1);//预处理段 else pa[tot].second++; } for(;tot&gt;1;tot=cnt,ans++){ pa[1].second--;pa[tot].second--;//处理头尾 for(i=2;i&lt;tot;i++)//中间各段-=2 pa[i].second-=2; for(cnt=0,i=1;i&lt;=tot;i++){ if(pa[i].second&gt;0) {//如果这一段还没有被删完 if (pa[i].first != pa[cnt].first)//如果他跟前面接壤的区间颜色不相同,记为新的区间 pa[++cnt]=pa[i]; else pa[cnt].second += pa[i].second;//否则重新计量该区间 } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. 可以想象，是什么情况下分给副核的任务需要分成几次？显然是因为副核依赖一个主核的任务，而这个主核的任务又依赖于一个副核的任务。除此之外，其余任务都是可以一次丢进核中完成的。因此，我们采用两个队列，每次把所有可以一次完成的任务分别丢进主副核的队列中（类似拓扑排序的思想），直到队列为空。 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int N=100050; vector&lt;int&gt; E[N]; queue&lt;int&gt; q[2]; int c=0,in[N],col[N],sol=0; int main() { int n,m,u,v,i; scanf(&quot;%i %i&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;col[i]); while(m--) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); E[v].push_back(u); in[u]++;//入度 } for(i=0;i&lt;n;i++) if(!in[i]) q[col[i]].push(i); while(!q[0].empty() || !q[1].empty()) { if(q[c].empty()) {//此队列空了而另一个队列未空,说明需要换队列执行任务了 if (!c) sol++;//副核清空而主核未清空,显然副核需要次数++ c ^= 1;//换核 } u=q[c].front(); q[c].pop(); for(i=0;i&lt;E[u].size();i++) { v=E[u][i]; in[v]--; if(!in[v]) q[col[v]].push(v); } } printf(&quot;%d\n&quot;,sol); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Flucas-e5-ae-9a-e7-90-86%2F</url>
    <content type="text"><![CDATA[Lucas定理是用来解决大组合数取模的，即求$C_n ^m \ mod\ p$,其中$p$为质数。 公式：$C_n ^m\ mod\ p=C_{n/p}^{m/p}\times C_{n\ mod\ p}^{m\ mod\ p}\ mod\ p$ 当模数p在变化时运用暴力方法计算组合数：#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; ll Power_mod(ll a, ll b, ll p)//快速幂 { ll res = 1; while(b!=0) { if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; } return res; } ll Comb(ll a,ll b, ll p)//暴力计算组合数 { if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b;//组合数的性质,C(m,n)=C(m,m-n); ll ans = 1, ca = 1, cb = 1; for(ll i=0; i&lt;b; ++i) {//暴力计算阶乘 ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; } ans = (ca*Power_mod(cb, p-2, p))%p; return ans; } ll Lucas(int n, int m, int p)//Lucas { ll ans = 1; while(n &amp;&amp; m &amp;&amp; ans) { ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; } return ans; } int main() { int n,m,p; while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p) !=EOF) { printf(&quot;%lld\n&quot;, Lucas(n, m, p)); } return 0; } 当模数p固定时则对组合数进行预处理，递推求逆元；#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1e5+5; typedef long long ll; ll inv[maxn],fac[maxn];ll p; void init() { fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=fac[i-1]*i%p;//求阶乘 inv[0] = inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (p - p / i) * inv[p % i] % p;//递推求逆元 } ll C(ll n,ll m) { if (n&lt;m) return 0; return fac[n]*inv[fac[m]]*inv[fac[n-m]]%p;//利用逆元求组合数 } ll lucas(ll n,ll m) { if (!m) return 1ll; return C(n%p,m%p)*lucas(n/p,m/p)%p;//Lucas } int main() { return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe7-bb-84-e5-90-88-e6-95-b0%2F</url>
    <content type="text"><![CDATA[组合数公式： $C_{m}^{n}=\frac{m!}{n!(m-n)!}$ 方法一：利用公式 $C_m^n=C_{m-1}^{n-1}+C_{m-1}^{n}$ 从m个元素里挑n个元素，针对第一个元素要么是n个里的要么不是，如果是的,那么就从剩下的m-1个里挑n-1个 就是c(m-1,n-1);如果第一个元素不是n里的，就从剩下的m-1个元素里挑n个，就是c(m-1,n)。 递归求法： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long comb(int m,int n) { if(n==0) return 1; if(n==1) return m; if(n&gt;m/2) return comb(m,m-n); if(n&gt;1) return (comb(m-1,n-1)+comb(m-1,n)); } int main() { int m,n; while(cin&gt;&gt;m&gt;&gt;n) cout&lt;&lt;comb(m,n)&lt;&lt;endl; return 0; } 方法二： 1、求取1到n的阶乘对 mod 取模的结果存入数组 JC 中； 2、求取 C(n,r) 时， 先利用“拓展欧几里得算法”或者“费马小定理+快速幂”求 JC[r]的逆元存入临时变量 x1 ; 3、然后计算 JC[n] ∗ x1 % mod 存入临时变量 x2;（x2 即为n!/r! %mod 的值） 4、求取JC[n - r] 的逆元存入临时变量 x3; 5、则可以得到 C(n,r)=x2∗x3%mod]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 35 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-35-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 暴力扫即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } B. 最大化最小值，一看就可以二分。注意每个蛋糕都要有去处…所以要注意如果有一种蛋糕非常少的话也是要单独占一盘的…玄学二分居然没死循环，开心 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 说白了就是枚举找规律，会发现有1的时候，或者有俩2，或者3个都是3，又或者一个2配俩4是可以的，其他都是不行的 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int k,cnt[1505]={0},i; for(i=1;i&lt;=3;i++){ cin&gt;&gt;k;cnt[k]++; } if(cnt[1]||cnt[2]&gt;=2||cnt[3]==3||(cnt[2]==1&amp;&amp;cnt[4]==2)){ puts(&quot;YES&quot;); } else puts(&quot;NO&quot;); return 0; } D. 给出一个含有 n 个数的序列，让你求每次反转区间 [ l , r ] 后整个序列的逆序数是奇是偶。 首先有一个朴素的想法就是暴力枚举，当然就算用归并排序去计算逆序对也是会tle的… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int cnt; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } int main() { int n,i,j,a[1600],a1[1600],t[1600],m,l,r; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); cin&gt;&gt;m; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);cnt=0; reverse(a+l,a+r+1); memcpy(a1,a,sizeof(a)); mergesort(a1,1,n,t); //cout&lt;&lt;cnt&lt;&lt;endl; if(cnt&amp;1) puts(&quot;odd&quot;); else puts(&quot;even&quot;); } return 0; } 当将区间$ [ l , r ]$ 反转后，只有该区间内的逆序数产生了变化，其他的不变。具体变化是该区间之前是正序的变成了逆序，之前是逆序的变成了正序。如果我们知道反转前逆序数是奇是偶，再加上知道反转后逆序对相差是奇是偶就可以知道结果了。 设该区间长度为 len，则该区间共有 $len (len-1)/2$ 个数对，设反转后逆序的有 num 个，则正序的有 $len(len-1)/2 - num$ 个，反转前后逆序对相差 $num-( len(len-1)/2 - num )$ 个，化简得 $num 2 - len(len-1)/2$ 个，$num 2$ 一定为偶数，不影响奇偶性，所以只看 $len(len-1)/2 $的奇偶性就可以了。 判断奇偶可以用异或来做 #include&lt;cstdio&gt; int main() { int n,i,j,a[1505],m,l,r,x=0; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); for(i=1;i&lt;n;++i) for(j=i+1;j&lt;=n;++j) x^=a[i]&gt;a[j]; scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);i=r-l+1; x^=(i*(i-1)&gt;&gt;1)&amp;1; puts(x?&quot;odd&quot;:&quot;even&quot;); } return 0; } E. 对于给定的前k个，其实没什么好说的，就是模拟，看里面有对少个数能够直接放到b里面，扫完这k个之后，如果栈里还有那么肯定是那些缺乏小的数以致于无法放进b的，这时候我们为了能够把这些数顺利放进b，肯定是要逐步补齐栈顶项到b中已有项之间缺失的项的，这同时肯定也是字典序最大值。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; const int N=2e5+1; int n,k,a[N],t=1; stack&lt;int&gt;s; int main() { cin&gt;&gt;n&gt;&gt;k; s.push(n+1);//先置入一个n+1以防栈空re for(int i=0;i&lt;n;i++){ if(i&lt;k)cin&gt;&gt;a[i]; else a[i]=s.top()-1;//剩下的都是缺小项无法出栈的 s.push(a[i]); while(s.size()&amp;&amp;s.top()==t)s.pop(),t++; } if(s.size())puts(&quot;-1&quot;);//如果还有剩余说明原来的顺序有问题 else for(int i=0;i&lt;n;i++)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[复习一波，发现都快忘光了QAQ… 利用二分的思想，不断分割排序区间。 void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++]; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i];//这里要注意前面数组的下标 } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } 归并排序课用于计算逆序对，因为如果是非逆序的数，那么在mergearray的时候前面的肯定比后面的小，如果出现一个比后面大的，那么这个数后面的所有前面的数都一定比后面的数大。 int cnt=0; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1;//其实只有这里不同 } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim 游戏]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fnim-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[Nim游戏是组合游戏(Combinatorial Games)的一种，准确来说，属于“Impartial Combinatorial Games”（以下简称ICG）。满足以下条件的游戏是ICG（可能不太严谨）：1、有两名选手；2、两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动；3、对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； 4、如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。根据这个定义，很多日常的游戏并非ICG。例如象棋就不满足条件3，因为红方只能移动红子，黑方只能移动黑子，合法的移动集合取决于轮到哪名选手操作。 经典Nim游戏通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。 我们定义Position: P：表示当前局面下先手必败 N：表示当前局面下先手必胜 结论：(Bouton’s Theorem)： 对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position（后手必胜）当且仅当 a1^a2^…^an=0，其中^表示异或(xor)运算。 可以利用二进制来证明，详细证明过程：https://blog.csdn.net/Summer\_\_show\_/article/details/70185470 如果Nim游戏中的规则稍微变动一下,每次最多只能取K个,怎么处理? Ans：将每堆石子数mod (k+1). Nim的各种变形Moore’s Nimk n堆石子，每次从不超过k堆中取任意多个石子，最后不能取的人失败。 这是一个nim游戏的变形，也是有结论的。 结论为：把n堆石子的石子数用二进制表示，统计每个二进制位上1的个数，若每一位上1的个数mod(k+1)全部为0，则必败，否则必胜。 anti-nim(反Nim游戏) 正常的nim游戏是取走最后一颗的人获胜，而反nim游戏是取走最后一颗的人输。 一个状态为必胜态，当且仅当： 1）所有堆的石子个数为1，且NIM_sum=0 2）至少有一堆的石子个数大于1，且 NIM_sum≠0 例子：Bzoj1022 : https://www.lydsy.com/JudgeOnline/problem.php?id=1022 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int t,i,j,k,n; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; bool onlyone=true; int sum=0; while(n--){ scanf(&quot;%d&quot;,&amp;j); if(j!=1)onlyone=false; sum^=j; } if((onlyone&amp;&amp;!sum)||(!onlyone&amp;&amp;sum)){ puts(&quot;John&quot;); } else puts(&quot;Brother&quot;); } return 0; } 威佐夫博弈 两堆石子，每次可以从一堆或两堆中取任意数目的石子，从两堆中取得时候,从不同堆取的石子个数必须相同，先取完的获胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 奇异局势的3条性质： 1.任何自然数都包含在一个且仅有一个奇异局势中。 2.任意操作都可将奇异局势变为非奇异局势。 3.采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b）： 1.若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）； 2.如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局势； 3.如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab – ak个物体,变为奇异局 势（ ab – ak , ab – ak+ b – ak）； 4.如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余的数量a – ak 即可； 5.如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – aj 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜 ；反之，（面对奇异局势）则后拿者取胜。 任给一个局势（a，b），判断它是不是奇异局势（先手负）： $a_k =[k\times \frac{（1+√5）}{2}]， b_k= a_k + k $ （k=0，1，2，…,n ，方括号表示向下取整函数) 其中k由bk-ak求得，如果两个数不符合这样的形式，则不是奇异局势 注意一定要满足a&lt;=b，不满足时对调a，b 例子：http://poj.org/problem?id=1067 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double t=(1+sqrt(5.0))/2;//系数 int a,b,k; while(cin&gt;&gt;a&gt;&gt;b){ if(a&gt;b)swap(a,b); k=b-a; if(a==(int)(k*t)){//计算a是否符合该形式 cout&lt;&lt;0&lt;&lt;endl; } else cout&lt;&lt;1&lt;&lt;endl; } return 0; } 巴什博奕 只有一堆石子共n个。每次从最少取1个，最多取m个，最后取光的人取胜。 如果$n=(m+1)* k+s (s!=0)$ 那么先手一定必胜，因为第一次取走s个，接下来无论对手怎么取，我们都能保证取到所有(m+1)倍数的点，那么循环下去一定能取到最后一个。(也就是说只要n不是m+1的倍数先手必胜) staircase nim 顾名思义就是在阶梯上进行，每层有若干个石子，每次可以选择任意层的任意个石子&gt;将其移动到该层的下一层。最后不能操作的人输。 （这个博弈的解释不是特别明白QAQ） 阶梯博弈经过转换可以变为Nim，把所有奇数阶梯看成N堆石子做nim。把石子从奇数堆移动到偶数堆可以理解为拿走石子，就相当于几个奇数堆的石子在做Nim。 结论：所有奇数阶梯（奇数堆）的石子的Nim sum如果不为0，先手胜，否则后手胜 （以下仅供参考，没太看懂） 假设我们是先手，所给的阶梯石子状态的奇数堆做Nim先手能必胜.我就按照能赢的步骤将奇数堆的石子移动到偶数堆.如果对手也是移动奇数堆，我们继续移动奇数堆.如果对手将偶数堆的石子移动到了奇数堆..那么我们紧接着将对手所移动的这么多石子从那个奇数堆移动到下面的偶数堆.两次操作后.相当于偶数堆的石子向下移动了几个。而奇数堆依然是原来的样子，即为必胜的状态。就算后手一直在移动偶数堆的石子到奇数堆，我们就一直跟着他将石子继续往下移，保持奇数堆不变。我可以跟着后手把偶数堆的石子最终移动到0，然后对手就不能移动这些石子了.所以整个过程.将偶数堆移动到奇数堆不会影响奇数堆做Nim博弈的过程..整个过程可以抽象为奇数堆的Nim博弈. 为什么是只对奇数堆做Nim就可以而不是偶数堆呢？因为如果是对偶数堆做Nim，对手移动奇数堆的石子到偶数堆，我们跟着移动这些石子到下一个奇数堆。那么最后是对手把这些石子移动到了0，我们不能继续跟着移动，就只能去破坏原有的Nim而导致胜负关系的不确定。所以只要对奇数堆做Nim判断即可知道胜负情况。 例子：http://poj.org/problem?id=1704 （ POJ1704） （可参考挑战程序设计竞赛P312） 本题的做法与上面描述的又不完全一致。我们把棋子按位置升序排列后（没有保证一定按升序给出），从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。 在同一对棋子中，如果对手移动前一个，你总能对后一个移动相同的步数，所以一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。于是我们只需要考虑同一对的两个棋子之间有多少空位。 这样一来就成了N堆取石子游戏了. #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,k; int s[1010]; int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;s[i]); sort(s+1, s+n+1); int ans; if(n%2 == 0) { ans = s[2]-s[1]-1; for(int i=4; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } else { ans = s[1]-1; for(int i=3; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Good Bye 2017]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-good-bye-2017%2F</url>
    <content type="text"><![CDATA[A. 模拟即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str;int cnt=0; cin&gt;&gt;str; for(auto a:str){ if(a==&apos;a&apos;||a==&apos;i&apos;||a==&apos;o&apos;||a==&apos;e&apos;||a==&apos;u&apos;||a==&apos;1&apos;||a==&apos;3&apos;||a==&apos;5&apos;||a==&apos;7&apos;||a==&apos;9&apos;) cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. 暴力枚举24种映射的情况即可….题目很简单，但是不是很好写 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; using namespace std; typedef pair&lt;int,int&gt;P; vector&lt;int&gt;per; void rotate(P*a,P*b) { for(int i=0;i&lt;4;i++) a[i]=b[per[i]]; } int main() { P mps[4]={ {0,1},{-1,0},{0,-1},{1,0}},mp[4]; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str; for(i=0;i&lt;4;i++)per.push_back(i); char mp1[55][55]; int x,y; for(i=1;i&lt;=n;i++){ cin&gt;&gt;mp1[i]+1; for(j=1;j&lt;=m;j++){ if(mp1[i][j]==&apos;S&apos;){ x=j,y=i;break; } } } cin&gt;&gt;str;int ans=0; for(int r=1;r&lt;=24;r++){ if(r&gt;1)next_permutation(per.begin(),per.end()); rotate(mp,mps); int x1=x,y1=y; for(auto a:str){ int p=a-&apos;0&apos;; x1+=mp[p].first;y1+=mp[p].second; if(x1&lt;1||x1&gt;m||y1&lt;1||y1&gt;n||mp1[y1][x1]==&apos;#&apos;)break; if(mp1[y1][x1]==&apos;E&apos;){ ans++;break; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. 本来想着对于每个新加入的圆找出所有可能跟他冲突的圆进行计算的，但是边界不太好把握…后来发现这个数据范围…直接暴力枚举之前加入的所有圆与这圆冲突的可能即可… #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int n,r,x[1005]={0},t,i,j;double y[1005]={0}; scanf(&quot;%d%d&quot;,&amp;n,&amp;r); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x[i]);y[i]=r; for(j=1;j&lt;i;j++) { t = x[i] - x[j], y[i] = max(y[i], y[j] + sqrt(4 * r * r - t * t)); } printf(&quot;%.10f &quot;,y[i]); } return 0; } F. 我们可以用绿色的点把整个线段分开，那么对于每一个区间（两端是绿色的点），有两种选择：1.两个绿色的点不连接，那么就需要把里面所有的红色点蓝色点都连接起来，长度是2 区间长度 2.连接绿色点，那么长度就是区间长度 3-长度最长的连接红点的边-长度最长的连接蓝点的边 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,x,pr,pb,pg,mr,mb,ans=0; char s[10]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%s&quot;,&amp;x,s); if(s[0]==&apos;R&apos;||s[0]==&apos;G&apos;){ if(pr){ ans+=x-pr; mr=max(mr,x-pr); } pr=x; } if(s[0]==&apos;B&apos;||s[0]==&apos;G&apos;){ if(pb){ ans+=x-pb; mb=max(mb,x-pb); } pb=x; } if(s[0]==&apos;G&apos;){ if(pg)ans+=min(0,x-pg-mr-mb); pg=x;mr=0;mb=0; } } printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #498 (Div. 3)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-498-div-3%2F</url>
    <content type="text"><![CDATA[A. 弱智题 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&amp;1)cout&lt;&lt;j&lt;&lt;&apos; &apos;; else cout&lt;&lt;j-1&lt;&lt;&apos; &apos;; } return 0; } B. 从大到小排序，前k大就是所求 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;set&gt; using namespace std; bool cmp(int x,int y) { return x&gt;y; } int main() { int n,k,i,j; int num[2005],num1[2005]; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);num1[i]=num[i]; } sort(num1+1,num1+1+n,cmp); map&lt;int,int&gt;mp1; int sum=0; for(i=1;i&lt;=k;i++)mp1[num1[i]]++,sum+=num1[i]; int pre=1; cout&lt;&lt;sum&lt;&lt;endl; for(i=1;i&lt;=n;i++){ if(mp1.count(num[i])){ k--; if(k)cout&lt;&lt;i-pre+1&lt;&lt;&apos; &apos;; else cout&lt;&lt;n-pre+1&lt;&lt;endl; pre=i+1;mp1[num[i]]--; if(mp1[num[i]]==0)mp1.erase(num[i]); } } return 0; } C. 前后求前缀和即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum[200005]; int main() { int n,i,j,k,d[200005]; cin&gt;&gt;n; map&lt;ll,int&gt;mp1; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;d[i]); sum[i]+=sum[i-1]+d[i]; mp1[sum[i]]=i; } ll ans=0,sum1=0; for(i=n;i;i--){ sum1+=d[i]; if(mp1.count(sum1)){ if(mp1[sum1]&gt;=i) break; else{ ans=sum1; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 注意只能换a中的字母！！ 分析一下可以发现a[i],a[n-i+1],b[i],b[n-i+1]这几个字母之间的位置是可以随便换的，因此只要枚举所有这样的字母组即可。 当4个字母全都不同的时候，a里面两个字母肯定要换； 当有两个相同时，另两个不同（也就是有3种字母），如果两个相同的在a，那么就要两个都换，否则的话都是换1个就够了。 当有3个相同时，换一个即可。 如果4个都相同或者两两相同，不用换。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; int main() { char a[100005],b[100005]; int i,j,k,n; cin&gt;&gt;n&gt;&gt;a+1&gt;&gt;b+1; int sum=0; for(i=1;i&lt;=n/2;i++){ map&lt;char,int&gt;mp1; mp1[a[i]]++;mp1[a[n-i+1]]++;mp1[b[i]]++;mp1[b[n-i+1]]++; if(mp1.size()==4){ sum+=2; } else if(mp1.size()==2){ if(mp1.begin()-&gt;second==2); else{ sum+=1; } } else if(mp1.size()==1); else{ if(a[i]==a[n-i+1])sum+=2; else sum+=1; } } if(n&amp;1){ if(a[n/2+1]!=b[n/2+1])sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; } E. 题目很长，但其实就是一个很简单的dfs。因为他的dfs顺序是固定的，所以我们会发现其实只要从根开始dfs一遍，并把结果保存起来即可，以后每次询问查询一下即可。完全模拟会tle，每个节点保存自己的子树则会mle，所以只能在根那里保存结果。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N=2e5+5; vector&lt;int&gt;G[N]; vector&lt;int&gt;ans; int child[N]; int pos[N]; int dfs(int x) { ans.push_back(x); pos[x]=ans.size()-1; child[x]++; for(auto a:G[x]){ child[x]+=dfs(a); } return child[x]; } int main() { int n,q,i,j,k,u; cin&gt;&gt;n&gt;&gt;q; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); for(i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;k); if(child[u]&lt;k){ printf(&quot;-1\n&quot;); } else{ printf(&quot;%d\n&quot;,ans[pos[u]+k-1]); } } return 0; } F. 有一个非常simple的dp做法，但是会mle，即使换成滚动数组也会tle… #include &lt;bits/stdc++.h&gt; using namespace std; long long n,m,k; map&lt;long long,long long&gt; a[25][25]; long long b[25][25]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) cin&gt;&gt;b[i][j]; a[1][1][b[1][1]]++; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { for (auto k:a[i-1][j]) { a[i][j][k.first^b[i][j]]+=k.second; } for (auto k:a[i][j-1]) { a[i][j][k.first^b[i][j]]+=k.second; } } cout&lt;&lt;a[n][m][k]; } 正解的话，是人为的划了一条线，即i+j==n+1，这是一条斜对角线，我们分别从（1，1）和（n，m）处开始搜索，如果能够到达中线，就做一个记录，然后统计答案。 #include &lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll num[25][25]; map&lt;ll,ll&gt;mp[25]; ll n,m,k; void dfs1(int i,int j,ll v) { v^=num[i][j]; if(i+j==n+1){ mp[i][v]++;return;//如果到达中线就不用再搜下去了 } if(i&lt;n)dfs1(i+1,j,v); if(j&lt;m)dfs1(i,j+1,v); } ll ans=0; void dfs2(int i,int j,ll v) { if(i+j==n+1) { ans += mp[i][v ^ k];return;//到达中线,我们希望遇到的中线处的值是v^k, // 因为在中线下半部分的xor和为v,v^k^v=k,满足题意 } v^=num[i][j]; if(i&gt;1)dfs2(i-1,j,v); if(j&gt;1)dfs2(i,j-1,v); } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf(&quot;%lld&quot;,&amp;num[i][j]); dfs1(1,1,0);dfs2(n,m,0); cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 47 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-47-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 按照题意模拟即可 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;deque&gt; using namespace std; int main() { deque&lt;int&gt;a; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; int c[1005]; for(i=1;i&lt;=n;i++)cin&gt;&gt;c[i]; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);a.push_back(j); } int cnt=0; for(i=1;i&lt;=n;i++){ if(!a.empty()&amp;&amp;a.front()&gt;=c[i]){ a.pop_front();cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. 首先我们注意到1是可以任意移动的，也就是说1可以移动到任何一个位置，而2是比较麻烦的，因此我们从前往后扫描，每扫描到一个2就记录一下当前扫描到的这段0 的数目，然后丢进vector里记录下来。注意：要记得特判没有2 的情形！ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string s; int num0(0), num1(0); vector &lt;int&gt; v; bool pd(false); int main() { cin &gt;&gt; s; for (auto i : s) { if (i == &apos;0&apos;)num0++;//统计0 else if (i == &apos;1&apos;)num1++;//统计1 else {//遇到2 v.push_back(num0); num0 = 0; } } for (auto i : v) {//2把连续的0分成了很多段 for (int j = 1; j &lt;= i; j++)cout &lt;&lt; 0; if (!pd) for (int j = 1; j &lt;= num1; j++)cout &lt;&lt; 1;//1可以全部移到第一个之前 cout &lt;&lt; 2; pd = true; } for (int j = 1; j &lt;= num0; j++)cout &lt;&lt; 0; if(!pd){//一定要特判没有2的情形 for(int i=1;i&lt;=num1;i++)cout&lt;&lt;1; } return 0; } C. 其实这题看懂之后似乎是挺简单的…?显然d如果是正的，我们 就希望dist之和最大，可以发现是放数列的两端最佳，否则的话就选在数列的中间可以使得dist之和最小。记得开longlong即可。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; int main() { ll n, m; ll ans=0, x, d; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; d; ans += x * n; if (d &gt; 0) { ans += d * n * (n - 1) / 2; } else { ans += ((n % 2 == 0) ? (n / 2 * n / 2 * d) : ((n + 1) / 2 * (n - 1) / 2 * d)); } } printf(&quot;%.20lf&quot;,(double)ans / n); return 0; } D. 要注意一点，就是构造的图必须是联通的。虽然题目范围看似很大，理论是暴力枚举复杂度1e10,但是m小哇，暴力从小到大枚举成对的互质的数，其实很快就够了，如果impossible的话只可能是n比较小m比较大的情况。然后注意m如果小于n-1的话那么这幅图怎么看都不可能的联通的（要求是每个点都必须在这个图里面，所以一个行之有效的办法就是每个电脑都跟1连接起来）； #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int gcd(int x,int y) { return y?gcd(y,x%y):x; } typedef pair&lt;int,int&gt;P; int main() { int n,m,i,j,k,cnt=0; cin&gt;&gt;n&gt;&gt;m; vector&lt;P&gt;ans; if(m&lt;n-1){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } for(i=1;i&lt;n;i++) for(j=i+1;j&lt;=n;j++){ if(gcd(i,j)==1){ m--;ans.push_back(P(i,j)); if(!m)goto step; } } if(m){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } step:cout&lt;&lt;&quot;Possible&quot;&lt;&lt;endl; for(auto a:ans) printf(&quot;%d %d\n&quot;,a.first,a.second); return 0; } E. 某人从x=0旅行至x=n，在上次休息过后走当前公里的疲劳值为ai，休息点的位置不确定，求疲劳值之和的数学期望。 对于某个位置x=i，疲劳值为ai的可能休息点情况数为2^(n-i)种，疲劳值为aj(j&lt;i)的可能休息点情况数为2^(n-i-1)种。处理过后发现对于某个疲劳值ai，其总的出现情况数为2^(n-i)+2^(n-i-1)* (n-i)。之后直接套公式即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int mod=998244353; long long a[1000005],b[1000005]; int main() { int n,i,j,k; cin&gt;&gt;n; b[0]=1; for(i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); b[i]=(b[i-1]&lt;&lt;1)%mod; } long long ans=0; for(i=1;i&lt;=n;i++){ ans+=a[i]*b[n-i]%mod; ans+=a[i]*b[n-i-1]%mod*(n-i)%mod;//注意多mod防止爆int } cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F20172018%2F</url>
    <content type="text"><![CDATA[过去的一年前几天考完了这学期的最后一科，那么，大一也就算是结束了吧，回想过去的一年，总想写点什么，却又不知道如何入手，那现在就纯当流水账随便写写吧。 去年，2017，是相当奇幻的，一场高考将一年横劈为二。刚考完那天下午拿出了尘封已久的iPad，打了一会wotb，但是似乎应了那句话——游戏还是考试前的好玩，考完之后变得有些索然无味起来。4天之后剁了个游戏本，然后开启了暑假的沉迷游戏之旅。不过后来开学后很快就后悔买了个如此厚重的游戏本，当然这是后话了。 暑假先是跟同学一起去了趟贵州，现在想想这趟旅程其实是有些令人失望的。贵州本身并不太好玩，花在路上的时间奇长无比。更重要的是高中的一群同学，似乎总有些说不清的隔阂感吧，也许是一群清北聚聚实在跟我这种裸考弱渣差别过大吧。而且感觉起来，高中同学总体还是比较奇特的，整个班级总是缺少些凝聚力，或许是大家都太有个性了，也可能是大家高中都忙，总而言之，并没有非常好的体验。 回来之后填了个志愿。我也不知道为什么我就想报计算机，也许是被某乎洗脑了吧，自己也看起来是有点兴趣。 记得当时还跟父母吵了一架，因为不知道选哪个学校。当时也不知道为何就选定了小破邮，不过现在想想哈深的计算机我还不够分来着，当时如果填了现在可能就在学机械了（摔）。现在想想似乎倒也不算什么错误的决定——小破邮虽破，但是偏远的沙河倒也能让人专心下来学习，而且说实话吧，基本上该有的设施也都算有了，更重要的是，小破邮的同学总体上感觉还是挺好的~总体而言学风良好，而且也有非常多在我看起来非常厉害的同学，让我感觉自己非常的蒟蒻QAQ。 后来的假期基本上就是打游戏，学架子鼓，踢足球，健身几样之间轮换。不得不说我还是挺难去坚持一些爱好的…现在除了偶尔去去健身房，其他几项基本都荒废了，虽说这一年来确实忙碌，但是难以持之以恒似乎也成为了我一贯以来的坏毛病吧。8月去了趟新疆，总体而言，景色是优美的，但是暑假浩浩荡荡的人流实在是令人难以提起任何游玩的兴致。而后又去西安搞了趟疯狂之旅，现在想想是有些后悔的，浪费钱，浪费时间。 打游戏的假期还是过得挺快的，一转眼就开学了。两周的军训令人印象深刻，大概是这辈子迄今为止过得最难受的两周了，生活质量奇差，而且毫无意义。用一句政治不正确的话来说，就是两周的参军劝退课，除了没拔草，部队里可以干的无聊事似乎都体验的差不多了。反正，个人是非常反感这种毫无意义的官僚性课程的。 回来以后就开学，不过国庆前基本上啥都没看，每天就是玩一玩，看一看，倒也悠哉悠哉。加了学生会的一个部门，现在想想这个还是挺有意义的…因为没进这部门的话，|没认识某菊苣的话，我可能已经被编程劝退了，更不会混进实验班了…也就没有很多故事了233…中间也没啥事，直到9.27——那一天，我突然开始研究了一波C Primer Plus，写了第一个C程序，啥内容不记得了，总之，感觉挺好玩的，也让我对这玩意儿突然感兴趣起来。现在想想，除了一开始的兴趣以外，大概也跟程序的反馈性有关吧——即时的输出，虽然只是控制台那个黑框框。以及后来的各种OJ，AC，WA，TLE，其实都令人刺激，不像那艹蛋的高数，至今都提不起什么兴趣。 后面大概就是上课，上课，其实印象都不是很深，因为第一个学期其实只有一件事令我感兴趣，那就是编程。当时花了大概一个月大致看了看C的基本语法，然后就开始对算法有了些兴趣——大概跟头几次机考的时候激动人心的排行榜也有点关系吧。总之期中之后，除了研究新算法写OJ，当时啥都不想干，连游戏都没碰过，导致我寒假把游戏本给卖了（笑）。不过平心而论，研究一个算法，试着用它去套一些简单模板题，获得一个个AC，真的是挺有意思的，让我大半个学期乐此不疲。第一学期怎么说呢，其实自我感觉还是挺认真的，可惜就是对课内的事情不太上心，最后成绩也不怎么好看，高数学得乱七八糟某种意义上也影响了第二学期的高数。当时想着第二学期一定要好好做人，不能忽视课内的东西，然而一连串的意外还是让这个设想落空了…事实上，这学期总体而言依然的挺糟糕的。 寒假过的其实不是很妙。回家前去了趟天津，其实并不好玩，不过一起去的小伙伴还是挺有意思的。回家之后实在是有点颓，本来想好好研究一波算法的，但是现在想想好像当时也没干什么，后来日子也就过去了。年后去了趟埃及，当时的日程安排的不是特别好，当然这个国家不一样的风情还是挺有意思的。总而言之，寒假延续了我一贯以来放假颓废的作风。 开学就是新生赛，最后结果还是ok的，毕竟一群OI菊苣们压阵，一个小白也就这样了吧。然后就是校赛的网络赛，第一次组队搞了一波，也算是认识了第一波队友吧。再后面就是实验班的选拔，不得不说这事还是挺糟心的，不知道是谁加的报名限制——智育前40%。反正就记得那周挺难受的，平心而论学院这么定其实也无可厚非，但我还是非常的郁闷。毕竟一个机考选拔，如果连参加的机会都没有的话，还是令人挺难以接受的。幸好后来好像并没有人记得有这么一回事，机考也顺利的参加了。不过那段时间大概状态不太好吧，加上内心忧郁，所以机考的的时候纯粹是靠罚时少把排名拉了上来。然后就是面试，忐忑地邓结果。当时面试的时候被老师问了一堆课内成绩的情况，感觉自己快凉了，幸好最后还是过了。校赛的话我们队感觉都不在状态，罚时爆炸混了个铜，不过当时想想，也算是混进实验班了，也不能太希望一切都很顺利吧。 不过，开学那会忙于准备各种赛，之后又是糟心的选拔，然后转班又是一片混乱，某种意义上也很大的影响了这学期后续的课程。特别是模电，转过去之后发现他们已经上完了，于是到最后我也没怎么学这玩意儿，期末也是不明不白混过去了。期末的半个月其实也努力了一下希望拯救一下课内，但其实最后也就那样了，积重难返。 应该说，这个班牛人还是很多的，比起来我其实啥都不行——代码不如OI党，课内成绩一塌糊涂，我也不知道说什么好了QAQ，希望可以在众多菊苣的刺激下以后做的更好吧…然后这半个学期也有幸遇到了几位挺好的同学，几位菊苣愿意搭理我这个蒟蒻，其实还是挺开心的，也算有些感谢吧…之前还有点担心会不会混成孤家寡人的感觉…. 流水账写了写，发现时间还是过得很快的。总体上来说，这一年还是挺忙的，每天都过得很快，也算是挺充实了。当然后来还是有点颓了，而且绩点应该算是挺糟糕了……一年换了两个班，认识了一大波新同学，还是蛮开心的。希望暑假的训练，以及后面的大二，可以吸取经验，过得更顺利一些吧，也争取混个更好的成绩。加油！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #456 (Div. 2) D.Fishes]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-456-div-2-d-fishes%2F</url>
    <content type="text"><![CDATA[显然，暴力模拟每个r* r的框覆盖是会tle的，我们不妨换一种思路，即计算每个cell被多少个框所覆盖。 可以发现，在位置x，y的cell的框覆盖数为： 因此，总的框覆盖数就是 注意到无论是怎么样的情况，位于(n+1)/2,(m+1)/2处的cell的框覆盖数一定是最大的之一，因此我们可以从这个cell开始bfs，但是这里的queueu采用有限队列，即以框覆盖数为优先值。最后注意一下重复的问题即可（写的时候用set判了一下重）。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;set&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt;P; struct cell{ int x,y;ll f; bool operator&lt;(const cell&amp;v)const{ return f&lt;v.f; } }; int n,m,r,k; ll cal(int x,int y) { return (ll)(min(n+1,x+r)-max(x,r))*(min(m+1,y+r)-max(y,r)); } bool ch(int x,int y) { if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return false; return true; } int main() { int i,j; int move1[4][2]={-1,0,1,0,0,-1,0,1}; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;k; priority_queue&lt;cell&gt;que; set&lt;P&gt;ck; ll sum=0; que.push(cell{(n+1)/2,(m+1)/2,cal((n+1)/2,(m+1)/2)}); ck.insert(P((n+1)/2,(m+1)/2)); while(!que.empty()){ k--; cell t=que.top();que.pop(); sum+=t.f; for(i=0;i&lt;4;i++){ int x1=t.x+move1[i][0],y1=t.y+move1[i][1]; if(ch(x1,y1)&amp;&amp;!ck.count(P(x1,y1))){ que.push(cell{x1,y1,cal(x1,y1)});ck.insert(P(x1,y1)); } } if(!k)break; } printf(&quot;%.10f\n&quot;,(double)sum/((ll)(n-r+1)*(m-r+1))); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Hello 2018]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-hello-2018%2F</url>
    <content type="text"><![CDATA[A. 2的幂次比较大的时候显然直接输出m就行了，比较小的时候暴力算一下就行。 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { long long n,m; cin&gt;&gt;n&gt;&gt;m; if(n&gt;=63){ cout&lt;&lt;m&lt;&lt;endl; } else{ cout&lt;&lt;m%(1LL&lt;&lt;n)&lt;&lt;endl; } return 0; } B. dfs判断一下即可。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;G[1005]; bool dfs(int x) { if(G[x].empty()) return true; if(G[x].size()&amp;&amp;G[x].size()&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } int cnt=0; for(auto a:G[x]) if(dfs(a)) cnt++; if(cnt&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } return false; } int main() { int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; return 0; } C. 咋一看感觉是个完全背包，然而1e9的范围加上可以超过L，使得背包不太可能。 因为容量都是2的幂次，因此一个显然的优化就是，如果ci+1&gt;ci * 2，那么显然买i+1不如买两个i，因此可以把i+1给换掉。 做完这个替换之后，有一点显然的就是如果最终买的总容量不超过L的话，那么显然是买小容量的不如买大容量的。但是还有一个问题就是有可能买超出L的总容量会更划算，所以我们从大容量枚举到小容量，对于每个容量，我们都考虑如果最小的容量就是他的情况，并用此去更新答案。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;c; typedef long long ll; int main() { int n,i,j,k,l; cin&gt;&gt;n&gt;&gt;l; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;c.push_back(j); } for(i=0;i&lt;c.size()-1;i++){ c[i+1]=min(c[i+1],c[i]&lt;&lt;1); } ll sum=0,ans=1LL&lt;&lt;62; for(i=n-1;~i;i--){ int need=l/(1&lt;&lt;i); sum+=(ll)need*c[i]; l-=need*(1&lt;&lt;i); ans=min(ans,sum+(l?c[i]:0)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. 这是一个比较复杂的排序问题。 首先我们将考试按a从大到小排序，a相同时按t从小到大排序。然后依次拿出每个考试，用一个大根堆维护我们选择的考试，大根堆根据每个考试的t排序。对于每个从序列中拿出的考试，如果它的门数==堆中的考试数，那么只有这个考试的t比堆顶的考试的t小的时候我们才有必要把他丢进去。如果拿出的考试的a&gt;=堆中门数+1，那么如果堆中总和+拿出的t&lt;=总时长，就直接丢进堆。否则把拿出的考试与堆顶考试中t比较小的放进去即可。最后堆中考试即为所求。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct test{ int id,a,t; bool operator&lt;(const test&amp;v)const{ return t&lt;v.t; } }T[200005]; bool cmp(test a,test b) { if(a.a==b.a) return a.t&lt;b.t; return a.a&gt;b.a; } int main() { int n,t,i,j,cnt=0; cin&gt;&gt;n&gt;&gt;t; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;T[i].a,&amp;T[i].t);T[i].id=i; } sort(T+1,T+1+n,cmp); priority_queue&lt;test&gt;que; for(i=1;i&lt;=n;i++){ if(T[i].a==que.size()){ if(!que.empty()){ if(que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } else if(T[i].a&gt;=que.size()+1){ if(cnt+T[i].t&lt;=t){ que.push(T[i]);cnt+=T[i].t; } else{ if(!que.empty()&amp;&amp;que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } } cout&lt;&lt;que.size()&lt;&lt;endl&lt;&lt;que.size()&lt;&lt;endl; while(!que.empty()){ cout&lt;&lt;que.top().id&lt;&lt;&apos; &apos;;que.pop(); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mash up占坑]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2Fmash-up-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Life 占坑]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2Flife-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 36 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-educational-codeforces-round-36-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. 签到题不解释 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; bool cmp(int a,int b) { return a&gt;b; } int main() { int n,k,i,j; //cin&gt;&gt;n; vector&lt;int&gt;v; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(k%j==0)v.push_back(j); } sort(v.begin(),v.end(),cmp); cout&lt;&lt;k/v[0]&lt;&lt;endl; return 0; } B. 总共只有两种情况：先关左边再关右边，或者反过来，讨论一下特殊边界情形即可，签到*2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,pos,l,r,i,j,k; cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r; if(l==1&amp;&amp;r==n){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(l==1&amp;&amp;r!=n){ cout&lt;&lt;abs(pos-r)+1&lt;&lt;endl; } else if(l!=1&amp;&amp;r==n){ cout&lt;&lt;abs(pos-l)+1&lt;&lt;endl; } else{ int a=abs(pos-l)+1+abs(r-l)+1; int b=abs(pos-r)+1+abs(l-r)+1; cout&lt;&lt;min(a,b)&lt;&lt;endl; } return 0; } C. 显然我们是想求一个满足条件的字典序最大的排列，那么对于每一位，我们从可放置的最大数出发，找出在当前状况下后续能排出的最小序列，跟b剩下的位数比较，如果最小序列比b小，那么这一位就可以放最大的数。否则这一位就必须放比较小的数。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; int cnt[15]; string build(void) { string res; for(int i=0;i&lt;10;i++){ for(int j=1;j&lt;=cnt[i];j++) res+=char(i+&apos;0&apos;); } return res; } int main() { string a,b;int i,j,k; cin&gt;&gt;a&gt;&gt;b; int num[25]; for(i=0;i&lt;b.size();i++) num[i]=b[i]-&apos;0&apos;;//每位数字,便于比较 for(i=0;i&lt;a.size();i++)//统计每种数字的个数 cnt[a[i]-&apos;0&apos;]++; if(a.size()&lt;b.size()){//如果位数少直接输出最大排列 for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl;return 0; } string ans;bool ismall=false; for(i=0;i&lt;a.size();i++){ if(ismall)break; for(j=num[i];~j;j--){//寻找这一位最大的可能 if(cnt[j]){ cnt[j]--; if(j&lt;num[i]){//如果这一位已经比b小了,直接输出后续最大排列即可 ismall=true;ans+=char(j+&apos;0&apos;);break; } string minn=build();string bnow=b.substr(i+1);//寻找在当前情况下后续能排出的最小排列 if(minn&lt;=bnow){ ans+=char(j+&apos;0&apos;); break; } cnt[j]++; } } } cout&lt;&lt;ans; for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl; return 0; } D. 给定一幅有向图，问是否可以最多去掉一条边使得该有向图无环？ 题目的做法比较神奇。一开始的想法是先求一波强连通分量，然后特判一下强连通分量为1的情况，然而test56 GG了。 看到一种做法，即从1~n，每次以不同的起点开始dfs找环，判断图中是否可能存在只去掉一条边就无环的情况（当然要是本来就没环那就是废话）。 为什么从不同的点开始dfs结果会不一样？因为这道题中会有一种比较奇特的情形，有可能有多个环都依赖于一条有向边而存在，比如样例1（如图） 在这里会发现2-&gt;3的边是一条关键边，从3开始搜索时因为先到2，再开始搜索1，因此vis[2]=1而不会被1搜索到，于是cnt只有1.因此这就是“YES”。 看起来似乎还是挺奇妙的233 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[505]; int cnt; int vis[505]; void dfs(int x) { vis[x]=2;//正在当前搜索序列中的标记为2 for(auto a:G[x]){ if(vis[a]==2) cnt++;//每找到一个环cnt++ else if(!vis[a]) dfs(a); } vis[x]=1;//已经访问过但不是当前搜索序列中的标记为1 } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); } for(i=1;i&lt;=n;i++){ memset(vis,0,sizeof(vis));cnt=0; dfs(i); for(j=1;j&lt;=n&amp;&amp;cnt&lt;=1;j++) if(!vis[j]) dfs(j); if(cnt&lt;=1){//如果从这个点出发只找到一个环(关建边) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } E. 给定一个初始全为1的序列，不停地给出一个比较短的序列(l,r),将(l,r)范围内数全部变为1或0（根据k的值决定）。序列范围较大。 一眼看下去感觉线段树能搞，一看范围1e9…事实上这道题又是一个用map维护区间信息的典例…我们将连续的工作日区间按右端点为关键值插入map中，map的第二个键值就是区间的左端点。那么初始时有range[n]=1 对于每次询问，我们找出大于l的的最小的在map中的工作区间，把它与这次询问的区间相交的部分全部删去，然后依次类推直至map中的区间不与询问区间相交。如果k=2，那么答案加上r-l+1即可。为什么不讨论k=1？因为即使是k=1，询问的空间也可能是支离破碎的，并不容易统计，不如把他们全部删掉重置。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int main() { map&lt;int,int&gt;range;//标记周期 int n,i,j,k,q; cin&gt;&gt;n&gt;&gt;q; range[n]=1;int ans=n; for(i=1;i&lt;=q;i++){ int l,r,k; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); auto a=range.lower_bound(l);//找出大于等于询问区间的第一个map的右端点 while(a!=range.end()){ int cl=a-&gt;second,cr=a-&gt;first; if(cl&gt;r)break;//如果区间的左端点已经大于询问区间的右端点,显然没有交集了 ans-=(min(cr,r)-max(cl,l)+1);//除去询问区间的所有工作日 range.erase(a++);//删去重叠区间 if(cr&gt;r)range[cr]=r+1;//如果大区间被询问区间肢解了,加入小的未涉及区间 if(cl&lt;l)range[l-1]=cl; } if(k==2){ range[r]=l;ans+=r-l+1;//k=2时加入询问区间 } printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（模板）Splay 平衡树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fsplay%2F</url>
    <content type="text"><![CDATA[您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 1.插入 xx 数 2.删除 xx 数(若有多个相同的数，因只删除一个) 3.查询 xx 数的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，因输4.出最小的排名) 5.查询排名为 xx 的数 6.求 xx 的前驱(前驱定义为小于 xx ，且最大的数) 7.求 xx 的后继(后继定义为大于 xx ，且最小的数) 洛谷P3369 不讲解，直接上代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int MAXN=1000000; int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN]; int nodecnt,root; void clear(int x)//清除(当这个点被删除之后) { ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0; } bool get(int x)//判断是父节点的左节点还是右节点 { return ch[f[x]][1]==x; } void update(int x)//更新当前点以下的元素个数(发生修改以后更新) { if (x){ size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; } } void rotate(int x)//旋转 { int old=f[x],oldf=f[old],whichx=get(x); ch[old][whichx]=ch[x][whichx^1]; f[ch[old][whichx]]=old; ch[x][whichx^1]=old; f[old]=x; f[x]=oldf; if (oldf) ch[oldf][ch[oldf][1]==old]=x; update(old); update(x); } void splay(int x)//splay,不停地rotate直到满足要求 { for (int fa;fa=f[x];rotate(x)) if (f[fa]) rotate((get(x)==get(fa))?fa:x); root=x; } void insert(int x)//插入 { if (root==0) { nodecnt++; ch[nodecnt][0] = ch[nodecnt][1] = f[nodecnt] = 0; root = nodecnt; size[nodecnt] = cnt[nodecnt] = 1; key[nodecnt] = x; return; } int now=root,fa=0; while(1){ if (x==key[now]){ cnt[now]++; update(now); update(fa); splay(now); break; } fa=now; now=ch[now][key[now]&lt;x]; if (now==0){ nodecnt++; ch[nodecnt][0]=ch[nodecnt][1]=0; f[nodecnt]=fa; size[nodecnt]=cnt[nodecnt]=1; ch[fa][key[fa]&lt;x]=nodecnt; key[nodecnt]=x; update(fa); splay(nodecnt); break; } } } int find(int x)//查询x的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，应输出最小的排名) { int now=root,ans=0; while(1){ if (x&lt;key[now]) now=ch[now][0]; else{ ans+=(ch[now][0]?size[ch[now][0]]:0); if (x==key[now]){ splay(now); return ans+1; } ans+=cnt[now]; now=ch[now][1]; } } } int findx(int x)//寻找排名为x的数 { int now=root; while(1){ if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else{ int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp; now=ch[now][1]; } } } int pre()//求 xx 的前驱(前驱定义为小于 xx ，且最大的数),注意这个数不一定在树中 { int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now; } //注意,查找某个数的前驱后驱时,要先把这个数插进树中,然后把这个数转到根节点(insert中已集成), //求x的前驱其实就是求x的左子树的最右边的一个结点，后继是求x的右子树的左边一个结点,求完后要删除这个点 int next1()//求 xx 的后继(后继定义为大于 xx ，且最小的数) { int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now; } void del(int x)//删除值为x的节点 { int whatever=find(x);//主要作用就是把x旋转到根节点...不能省略 if (cnt[root]&gt;1) { cnt[root]--; update(root); return; } if (!ch[root][0]&amp;&amp;!ch[root][1]) { clear(root); root = 0; return; } if (!ch[root][0]) { int oldroot = root; root = ch[root][1]; f[root] = 0; clear(oldroot); return; } else if (!ch[root][1]) { int oldroot = root; root = ch[root][0]; f[root] = 0; clear(oldroot); return; } int leftbig=pre(),oldroot=root; splay(leftbig); ch[root][1]=ch[oldroot][1]; f[ch[oldroot][1]]=root; clear(oldroot); update(root); } int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k); if(j==1){ insert(k); } else if(j==2){ del(k); } else if(j==3){ cout&lt;&lt;find(k)&lt;&lt;endl; } else if(j==4){ cout&lt;&lt;findx(k)&lt;&lt;endl; } else if(j==5){ insert(k);cout&lt;&lt;key[pre()]&lt;&lt;endl;del(k); } else if(j==6){ insert(k);cout&lt;&lt;key[next1()]&lt;&lt;endl;del(k); } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>模板</category>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2FUncategorized%2Ftest-1%2F</url>
    <content type="text"><![CDATA[testtesttest#include&lt;iostream&gt; int main() { std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; return 0; } hjsfkwhfkhfh fsdfggs hkjhka jhhhj njhkkjk $f^2+2f+4$ ~hjkahfh~ 中文测试 测试测试]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2FUncategorized%2Fe4-bd-a0-e5-a5-bd-e4-b8-96-e7-95-8c%2F</url>
    <content type="text"><![CDATA[Welcome to WordPress. This is your first post. Edit or delete it, then start writing!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
</search>
