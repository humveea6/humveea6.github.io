<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cppé˜…è¯»ç¬”è®°-ç±»]]></title>
    <url>%2FCpp%2FCpp%E8%AF%AD%E6%B3%95%2FCPP%E7%B1%BB%2FCpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[# ç±»çš„åŸºæœ¬æ¦‚å¿µ é¦–å…ˆæ˜¯ä¸€æ®µè‡ªå®šä¹‰ç±»çš„ä»£ç ï¼š \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212\#include&lt;bits/stdc++.h&gt; using namespace std; class Screen&#123; public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; string pr()const; Screen &amp;move(pos r,pos c); void move(pos r,pos c,int sit); Screen &amp;set(char); Screen &amp;set(pos,pos,char); Screen &amp;display(ostream &amp;os)&#123; do_display(os);return *this; &#125; const Screen &amp;display(ostream &amp;os)const&#123; do_display(os);return *this; &#125; friend class window_mgr; //friend void window_mgr::clear(Screenindex); private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125; &#125;; Screen &amp;Screen::move(pos r,pos c) &#123; pos row=r*width; cursor=row+c; return *this; &#125; void Screen::move(pos r,pos c,int sit) &#123; pos row=r*width; cursor=row+c; //return *this; &#125; char Screen::get(pos r,pos c)const &#123; pos row=r*width; return contents[row+c]; &#125; Screen &amp;Screen::set(char c) &#123; contents[cursor]=c; return *this; &#125; Screen &amp;Screen::set(pos r,pos col,char ch) &#123; contents[r*width+col]=ch; return *this; &#125; string Screen::pr() const &#123; return contents; &#125; class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,' ')&#125;; &#125;; void window_mgr::clear(window_mgr::Screenindex i) &#123; Screen &amp;s=screens[i]; s.contents.clear(); &#125; window_mgr::Screenindex window_mgr::addscreen(const Screen &amp;s) &#123; screens.push_back(s); return screens.size()-1; &#125; int main() &#123; int x=10; Screen screen1; Screen screen2(10, 10, 'a');screen2.sit=3; cout&lt;&lt;screen1.sit&lt;&lt;endl; //screen1.move(2,3); screen1.move(2,3,1); screen1.move(3,4).sit=screen2.sit; // cout &lt;&lt; x &lt;&lt; " " &lt;&lt; screen1.getH() &lt;&lt; endl; // cout&lt;&lt;screen1.sit&lt;&lt;endl; screen2.set(5,5,'d'); // cout&lt;&lt;screen2.get(5,5)&lt;&lt;endl; // cout&lt;&lt;screen2.pr()&lt;&lt;endl; screen2 .display(cout); window_mgr w1; // w1.screens[0].display(cout); w1.clear(0); return 0; &#125; \``` **æˆå‘˜å‡½æ•°ï¼ˆç±»ä¼¼Screen1.set()è¿™ç§ï¼‰çš„å£°æ˜å¿…é¡»åœ¨ç±»çš„å†…éƒ¨ï¼Œå®šä¹‰åˆ™å¯ä»¥åœ¨ç±»å†…éƒ¨ä¹Ÿå¯ä»¥åœ¨ç±»å¤–éƒ¨ã€‚è€Œæ¥å£ç»„æˆéƒ¨åˆ†çš„å‡½æ•°æˆ–è€…è¯´åªæ˜¯ä½¿ç”¨äº†ç±»çš„å‡½æ•°ï¼Œæ¯”å¦‚è¯´ç”¨ä¸¤ä¸ªç±»ä½œä¸ºè‡ªå·±çš„å‚æ•°çš„å‡½æ•°ï¼Œå£°æ˜å’Œå®šä¹‰éƒ½åœ¨ç±»å¤–éƒ¨** \### this å®ä¾‹å‡½æ•°ï¼š std::string isbn() const{return bookNo;}123456**æˆå‘˜å‡½æ•°é€šè¿‡åä¸º`this`çš„éšå¼å‚æ•°æ¥è®¿é—®è°ƒç”¨å®ƒçš„é‚£ä¸ªå¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè°ƒç”¨`total.isbn()`ï¼Œç¼–è¯‘å™¨ä¼šæŠŠtotalçš„åœ°å€ä¼ é€’ç»™isbnçš„éšå¼å½¢å‚thisï¼Œç›¸å½“äº `Sales_data::isbn(&amp;total)`** thiså½¢å‚æ˜¯éšå¼å®šä¹‰çš„ï¼Œ**ä»»ä½•è‡ªå®šä¹‰åä¸ºthisçš„å‚æ•°æˆ–å˜é‡çš„è¡Œä¸ºéƒ½æ˜¯éæ³•çš„**ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æˆå‘˜å‡½æ•°ä½“å†…éƒ¨ä½¿ç”¨thisï¼Œè™½ç„¶æ²¡æœ‰å¿…è¦ã€‚ä¾‹ï¼šisbnè¿˜èƒ½å¦‚ä¸‹å®šä¹‰ï¼š std::string isbn() const{return this-&gt;bookNo;}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180isbnå‡½æ•°å‚æ•°åˆ—è¡¨åçš„constçš„ä½œç”¨æ˜¯ä¿®æ”¹thisæŒ‡é’ˆçš„ç±»å‹ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œthisçš„ç±»å‹æ˜¯æŒ‡å‘ç±»ç±»å‹çš„**éå¸¸é‡ç‰ˆæœ¬**çš„**å¸¸é‡æŒ‡é’ˆ**ã€‚è¿™å°±æ„å‘³ç€åœ¨é»˜è®¤æƒ…å†µä¸‹æˆ‘ä»¬ä¸èƒ½æŠŠthisç»‘å®šåœ¨ä¸€ä¸ªå¸¸é‡å¯¹è±¡ä¸Šã€‚ \### ç±»ä½œç”¨åŸŸå’Œæˆå‘˜å‡½æ•° ç¼–è¯‘å™¨å¤„ç†ç±»æ—¶ï¼Œ **é¦–å…ˆç¼–è¯‘æˆå‘˜å£°æ˜ï¼Œç„¶åæ‰è½®åˆ°æˆå‘˜å‡½æ•°ä½“ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰**å› æ­¤ï¼Œæˆå‘˜å‡½æ•°ä½“å¯ä»¥éšæ„ä½¿ç”¨ç±»ä¸­çš„å…¶ä»–æˆå‘˜å‡½æ•°è€Œä¸å¿…åœ¨æ„è¿™äº›æˆå‘˜å‡ºç°çš„å…ˆåé¡ºåºï¼ˆå³ä½¿å‡ºç°åœ¨å‡½æ•°å£°æ˜ä¹‹åä¹Ÿæ²¡æœ‰é—®é¢˜ï¼‰ã€‚ ä½œç”¨åŸŸè¿ç®—ç¬¦ï¼šç±»ä¼¼äº`Sales_data::avg_price`è¿™æ ·çš„ï¼šï¼šï¼Œè¯´æ˜äº†ä»¥ä¸‹äº‹å®ï¼š æœ‰ä¸€ä¸ªåä¸ºavg_priceçš„å‡½æ•°ï¼Œå¹¶ä¸”è¯¥å‡½æ•°è¢«å£°æ˜åœ¨ç±»Sales_dataçš„ä½œç”¨åŸŸå†…ã€‚ \##### å…³äºå‡½æ•°å¼•ç”¨IOç±»å‹ä½œä¸ºå‚æ•° IOç±»å±äºä¸èƒ½è¢«æ‹·è´çš„ç±»å‹ï¼Œå› æ­¤åªèƒ½é€šè¿‡å¼•ç”¨æ¥ä¼ é€’ä»–ä»¬ã€‚ \### æ„é€ å‡½æ•° **æ„é€ å‡½æ•°çš„åç§°ä¸ç±»çš„åç§°ç›¸åŒ** åªè¦ç±»çš„å¯¹è±¡è¢«åˆ›é€ ï¼Œå°±ä¼šæ‰§è¡Œæ„é€ å‡½æ•°ã€‚æ³¨æ„ï¼šæ„é€ å‡½æ•°æ²¡æœ‰è¿”å›ç±»å‹ ä¸€ä¸ªç±»å¯ä»¥åŒ…å«å¤šä¸ªæ„é€ å‡½æ•°ï¼Œå’Œå…¶ä»–é‡è½½å‡½æ•°ç±»ä¼¼ã€‚**ä½†æ˜¯ï¼Œæ„é€ å‡½æ•°ä¸èƒ½è¢«å£°æ˜æˆconstçš„ã€‚** å¦‚æœä¸€ä¸ªç±»æ²¡æœ‰æ˜¾å¼å®šä¹‰æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¼šéšå¼åœ°æŒ‡å®šä¸€ä¸ªé»˜è®¤æ„é€ å‡½æ•°ï¼ˆå³åˆæˆçš„é»˜è®¤æ„é€ å‡½æ•°ï¼‰ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå®¹å™¨éƒ½ä¸ºç©ºï¼Œæ•°æ®éƒ½ä¸º0ï¼Œbooléƒ½ä¸ºfalseã€‚åœ¨C++11ä¸­ï¼Œå¦‚æœéœ€è¦é»˜è®¤è¡Œä¸ºï¼Œå¯ä»¥åœ¨å‚æ•°åˆ—è¡¨åå†™ä¸Š=defaultæ¥è¦æ±‚ç¼–è¯‘å™¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•° æ„é€ å‡½æ•°ä¸¾ä¾‹ï¼š \```cpp Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125; Sales_data(const std::string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125; \``` å†’å·ä¸èŠ±æ‹¬å·ä¹‹é—´çš„éƒ¨åˆ†ç§°ä¸º**æ„é€ å‡½æ•°åˆå§‹å€¼åˆ—è¡¨**ï¼Œå®ƒè´Ÿè´£ä¸ºæ–°åˆ›å»ºå¯¹è±¡çš„ä¸€ä¸ªæˆ–è€…å‡ ä¸ªæ•°æ®æˆå‘˜èµ‹å€¼ã€‚å¦‚æœæœ‰æ•°æ®æˆå‘˜è¢«åˆå§‹åŒ–åˆ—è¡¨æ‰€å¿½ç•¥ï¼Œé‚£ä¹ˆå®ƒå°†è¢«ä»¥ä¸é»˜è®¤æ„é€ å‡½æ•°ç›¸åŒçš„æ–¹å¼éšå¼åˆå§‹åŒ–ã€‚ æ³¨æ„ï¼šä¸Šé¢çš„å‡½æ•°ä¸­çš„å‡½æ•°ä½“ä¸­è¿˜å¯ä»¥æ‰§è¡Œå…¶ä»–çš„ä»»åŠ¡æˆ–ç©ºç½®ã€‚ \### æ‹·è´ï¼Œèµ‹å€¼å’Œææ„ é€šä¿—æ¥è¯´ï¼Œä¸€ä¸ªç±»çš„å¯¹è±¡å¯ä»¥ç›´æ¥è¢«èµ‹äºˆå¦ä¸€ä¸ªå¯¹è±¡çš„å€¼ï¼Œä¾‹å¦‚`total=trans`,å…¶ä¸­totalè·Ÿtranséƒ½æ˜¯ç±»å¯¹è±¡ã€‚**ä½†æ˜¯ï¼Œç®¡ç†åŠ¨æ€å†…å­˜çš„ç±»é€šå¸¸ä¸èƒ½è¿™ä¹ˆåš**ã€‚ ä¸è¿‡ä½¿ç”¨vectorè·Ÿstringçš„ç±»å¹¶ä¸å—æ­¤å½±å“ã€‚ \# è®¿é—®æ§åˆ¶ä¸å°è£… è®¿é—®è¯´æ˜ç¬¦ï¼špublicä¸private å®šä¹‰åœ¨privateä¹‹åçš„æˆå‘˜å¯ä»¥è¢«ç±»çš„æˆå‘˜å‡½æ•°ä»¥åŠå‹å…ƒè®¿é—®ï¼Œä½†ä¸èƒ½è¢«ä½¿ç”¨è¯¥ç±»çš„å‡½æ•°è®¿é—®ã€‚æ³¨æ„ï¼Œstructé»˜è®¤ä¸ºpublicï¼Œclassé»˜è®¤ä¸ºprivate \### å‹å…ƒ ç±»å¯ä»¥å…è®¸å…¶ä»–ç±»æˆ–è€…å‡½æ•°è®¿é—®ä»–çš„privateæˆå‘˜ï¼Œåªè¦ç»™å…¶ä»–ç±»æˆ–è€…å‡½æ•°åŠ ä¸Šfriendï¼ˆå‹å…ƒï¼‰çš„å£°æ˜å³å¯ã€‚ ä¾‹å¦‚ï¼š \```cpp class Screen&#123; public: typedef std::string::size_type pos; int sit=0; Screen()= default; //screen() &#123;&#125; Screen(pos ht,pos wd,char c):height(ht),width(ht),contents(ht*wd,c),sit(0)&#123;&#125;; char get()const&#123;return contents[cursor];&#125; inline char get(pos ht,pos wd)const; int getH() &#123; return cursor; &#125; friend class window_mgr;//å°†window_mgrå£°æ˜ä¸ºScreençš„å‹å…ƒ //friend void window_mgr::clear(Screenindex); private: pos cursor=0;pos height=0,width=0; string contents; void do_display(ostream &amp;os)const&#123; os&lt;&lt;contents&lt;&lt;endl; &#125; &#125;; class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,&apos; &apos;)&#125;; &#125;; \``` è¿™æ ·ä¸€æ¥ï¼Œwindow_mgrå°±å¯ä»¥è®¿é—®Screenç±»çš„ç§æœ‰æ•°æ®æˆå‘˜äº†ã€‚ **å‹å…ƒå£°æ˜åªèƒ½å‡ºç°åœ¨ç±»çš„å†…éƒ¨ï¼Œä½†æ˜¯ç±»å†…éƒ¨å‡ºç°çš„å…·ä½“ä½ç½®ä¸é™** **å‹å…ƒçš„å£°æ˜ä»…ä»…æä¾›äº†ä¸€ä¸ªè®¿é—®æƒé™ï¼Œè¦æƒ³çœŸçš„ä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œåœ¨ç±»çš„å¤–éƒ¨éœ€è¦å†ä¸“é—¨å£°æ˜ä¸€æ¬¡** \# ç±»çš„å…¶ä»–ç‰¹æ€§ï¼ˆç±»æˆå‘˜ï¼‰ é™¤äº†å®šä¹‰æ•°æ®å’Œå‡½æ•°æˆå‘˜ä»¥å¤–ï¼Œç±»è¿˜å¯ä»¥è‡ªå®šä¹‰æŸç§ç±»å‹åœ¨ç±»ä¸­çš„åˆ«åï¼Œç”±ç±»å®šä¹‰çš„ç±»å‹åå­—å’Œå…¶ä»–æˆå‘˜ä¸€æ ·å­˜åœ¨è®¿é—®é™åˆ¶ï¼Œå¯ä»¥æ˜¯publicæˆ–è€…privateä¸­çš„ä¸€ç§ã€‚ å’Œéæˆå‘˜å‡½æ•°ä¸€æ ·ï¼Œæˆå‘˜å‡½æ•°ä¹Ÿå¯ä»¥è¢«é‡è½½ï¼Œåªè¦å‡½æ•°ä¹‹é—´åœ¨å‚æ•°æ•°é‡æˆ–è€…ç±»å‹ä¸Šæœ‰æ‰€åŒºåˆ«å³å¯ã€‚ \##### ç±»æ•°æ®æˆå‘˜çš„åˆå§‹å€¼ å¯ä»¥ç»™ç±»çš„æ•°æ®æˆå‘˜æ·»åŠ ä¸€ä¸ªé»˜è®¤çš„åˆå§‹å€¼ \```cpp class window_mgr&#123; public: using Screenindex=vector&lt;Screen&gt;::size_type; void clear(Screenindex); Screenindex addscreen(const Screen&amp;); private: vector&lt;Screen&gt;screens&#123;Screen(10,20,&apos; &apos;)&#125;; &#125;; \``` \### è¿”å›*thisçš„æˆå‘˜å‡½æ•° \```cpp Screen &amp;Screen::set(pos r,pos col,char ch) &#123; contents[r*width+col]=ch; return *this; &#125; \``` è¿”å›å¼•ç”¨çš„å‡½æ•°æ˜¯**å·¦å€¼**çš„ï¼Œæ„å‘³ç€è¿™äº›å‡½æ•°è¿”å›çš„æ˜¯å¯¹è±¡æœ¬èº«è€Œä¸æ˜¯å¯¹è±¡çš„å‰¯æœ¬ï¼›å¦‚æœè¿™ä¸ªå‡½æ•°æ˜¯ä¸æ˜¯å·¦å€¼çš„ï¼Œé‚£ä¹ˆè¿”å›çš„æ•°æ®åªæ˜¯å‡½æ•°ä¸­è°ƒç”¨å¯¹è±¡çš„ä¸€ä¸ªcopyï¼› ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæœ‰è¿™ä¹ˆä¸€ç³»åˆ—æ“ä½œï¼š`myscreen.move(4,0).set(&apos;#&apos;);` è¿™äº›æ“ä½œä¼šåœ¨åŒä¸€ä¸ªå¯¹è±¡ä¸Šæ‰§è¡Œï¼Œå› ä¸º`move()` å’Œ`set()`å‡½æ•°éƒ½æ˜¯å·¦å€¼çš„ï¼› ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªå‡½æ•°ç­‰ä»·äº`myscreen.move(4,0);myscreen.set(&apos;#&apos;);` å¦‚æœ`move()` å’Œ`set()`å‡½æ•°ä¸æ˜¯å·¦å€¼çš„ï¼Œé‚£ä¹ˆä¸Šè¿°è¯­å¥å°†ä¼šå˜æˆï¼š Screen temp=myscreen.move(4,0);temp,set(â€˜#â€™); ä¹Ÿå°±æ˜¯è¯´ï¼Œç¬¬2æ­¥å¹¶ä¸ä¼šæ”¹å˜åŸæ¥myscreenä¸­çš„contentsï¼ˆå†…å®¹ï¼‰ï¼› **æ³¨æ„ï¼šä¸€ä¸ªconstæˆå‘˜å‡½æ•°å¦‚æœä»¥å¼•ç”¨çš„å½¢å¼è¿”å›*thisï¼Œé‚£ä¹ˆå®ƒçš„è¿”å›ç±»å‹å°†æ˜¯å¸¸é‡å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå¸¸é‡** \##### åŸºäºconstçš„é‡è½½ é€šè¿‡åŒºåˆ†æˆå‘˜å‡½æ•°æ˜¯å¦æ˜¯constçš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹å…¶è¿›è¡Œé‡è½½ ä¾‹å¦‚ï¼š \```cpp Screen &amp;display(ostream &amp;os){ do_display(os);return *this; } const Screen &amp;display(ostream &amp;os)const{ do_display(os);return *this; } \ å½“æˆ‘ä»¬åœ¨æŸä¸ªå¯¹è±¡ä¸Šè°ƒç”¨displayå‡½æ•°æ—¶ï¼Œè¯¥å¯¹è±¡æ˜¯å¦æ˜¯constå†³å®šäº†åº”è¯¥è°ƒç”¨displayçš„å“ªä¸ªç‰ˆæœ¬ï¼› ä¾‹å¦‚ï¼š `cpp Screen myscreen(5,3); const Screen blank(5,3); myscreen.set(â€˜#â€™).display(cout);//è°ƒç”¨éå¸¸é‡ç‰ˆæœ¬ blank.display(cout);//è°ƒç”¨å¸¸é‡ç‰ˆæœ¬ ` #### ç±»ç±»å‹ æ³¨æ„ï¼šå³ä½¿ä¸¤ä¸ªç±»çš„æˆå‘˜åˆ—è¡¨å®Œå…¨ä¸€è‡´ï¼Œå®ƒä»¬ä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ã€‚å¯¹äºä¸€ä¸ªç±»è€Œè¨€ï¼Œå®ƒçš„æˆå‘˜å’Œå…¶ä»–ä»»ä½•ç±»çš„æˆå‘˜éƒ½æ˜¯ä¸ä¸€æ ·çš„ã€‚ ##### ç±»çš„å£°æ˜ æˆ‘ä»¬å¯ä»¥ä»…å£°æ˜ç±»è€Œæš‚æ—¶ä¸å®šä¹‰å®ƒï¼›è¿™å°±æ˜¯æ‰€è°“çš„å‰å‘å£°æ˜ï¼Œåœ¨å£°æ˜ä¹‹åå®šä¹‰ä¹‹å‰çš„ç±»å‹è¢«ç§°ä¸ºä¸å®Œå…¨ç±»å‹ï¼› ä¸å®Œå…¨ç±»å‹åªèƒ½åœ¨éå¸¸æœ‰é™çš„åœºæ™¯ä¸‹ä½¿ç”¨ï¼šå¯ä»¥å®šä¹‰æŒ‡å‘è¿™ç§ç±»å‹çš„æŒ‡é’ˆå’Œå¼•ç”¨ï¼Œä¹Ÿå¯ä»¥å£°æ˜ï¼ˆä½†ä¸èƒ½å®šä¹‰ï¼‰ä»¥ä¸å®Œå…¨ç±»å‹ä½œä¸ºå‚æ•°æˆ–è¿”å›ç±»å‹çš„å‡½æ•°ï¼› å¯¹äºä¸€ä¸ªç±»è€Œè¨€ï¼Œæˆ‘ä»¬åœ¨åˆ›é€ å®ƒçš„å¯¹è±¡ä¹‹å‰å¿…é¡»å°†å…¶å®šä¹‰ï¼ˆä¸ç„¶ç¼–è¯‘å™¨å“ªçŸ¥é“æ€ä¹ˆåˆå§‹åŒ–233ï¼‰ã€‚ä½†æ˜¯ä¸€ä¸ªç±»ä¸€æ—¦åå­—å‡ºç°åï¼Œå®ƒå°±è¢«è®¤ä¸ºæ˜¯å£°æ˜è¿‡äº†ï¼Œå› æ­¤ç±»å…è®¸åŒ…å«æŒ‡å‘å®ƒè‡ªèº«ç±»å‹çš„å¼•ç”¨æˆ–æŒ‡é’ˆã€‚]]></content>
      <categories>
        <category>Cpp</category>
        <category>Cppè¯­æ³•</category>
        <category>CPPç±»</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Cppè¯­æ³•</tag>
        <tag>CPPç±»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonåŸºæœ¬è¯­æ³•]]></title>
    <url>%2FPython%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[æ³¨é‡Š# ### åŸºæœ¬æ•°æ®ç±»å‹ intå¯ä»¥æ˜¯ä»»ä½•å¤§å°çš„æ•´æ•° å˜é‡åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯å­—æ¯æˆ–ä¸‹åˆ’çº¿ï¼›å˜é‡ååŒºåˆ†å¤§å°å†™ï¼› ä½¿ç”¨å•/åŒå¼•å·æŒ‡å®šå­—ç¬¦ä¸²ï¼Œæ‰€æœ‰å¼•å·å†…çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬ç©ºæ ¼ä¸åˆ¶è¡¨ç¬¦éƒ½å°†åŸæ ·ä¿ç•™ã€‚ä¸¤ç§å¼•å·å·¥ä½œæœºåˆ¶ç›¸åŒ ### è¾“å‡ºæ ¼å¼ ä¸‰å¼•å·ç”¨äºæŒ‡å®šå¤šè¡Œå­—ç¬¦ä¸²ï¼ˆ&quot;&quot;&quot;æˆ–&#39;&#39;&#39;å‡å¯ä»¥ï¼‰ ä¾‹å¦‚ï¼š `python print(â€˜â€™â€™this is the first line and this is the second hhahahahâ€™â€™â€™) ` å°±ä¼šåŸæ ·è¾“å‡º3è¡Œ æœ‰æ—¶å€™æˆ‘ä»¬ä¼šæƒ³è¦ä»å…¶ä»–ä¿¡æ¯ä¸­æ„å»ºå­—ç¬¦ä¸²ã€‚è¿™æ­£æ˜¯ format() æ–¹æ³•å¤§æœ‰ç”¨æ­¦ä¹‹åœ°çš„åœ°æ–¹ã€‚ ä¾‹å¦‚ï¼š `python age = 20 name = â€˜Swaroopâ€™ print(â€˜{} was {} years old when he wrote this bookâ€™.format(name, age)) print(â€˜Why is {} playing with that python?â€™.format(name)) ` Python ä¸­ format æ–¹æ³•æ‰€åšçš„äº‹æƒ…ä¾¿æ˜¯å°†æ¯ä¸ªå‚æ•°å€¼æ›¿æ¢è‡³æ ¼å¼æ‰€åœ¨çš„ä½ç½®ã€‚è¿™ä¹‹ä¸­å¯ä»¥æœ‰ æ›´è¯¦ç»†çš„æ ¼å¼ï¼Œä¾‹å¦‚: `python # å¯¹äºæµ®ç‚¹æ•° â€˜0.333â€™ ä¿ç•™å°æ•°ç‚¹(.)åä¸‰ä½ print(â€˜{0:.3f}â€™.format(1.0/3)) # æˆ–è€…çœç•¥èŠ±æ‹¬å·é‡Œé¢é‚£ä¸ª0ä¹Ÿæ˜¯å¯ä»¥çš„ print(â€˜{:.3f}â€™.format(1.0/3)) # ä½¿ç”¨ä¸‹åˆ’çº¿å¡«å……æ–‡æœ¬ï¼Œå¹¶ä¿æŒæ–‡å­—å¤„äºä¸­é—´ä½ç½® # ä½¿ç”¨ (^) å®šä¹‰ â€˜helloâ€˜å­—ç¬¦ä¸²é•¿åº¦ä¸º 11 print(â€˜{0:_^11}â€™.format(â€˜helloâ€™)) # åŸºäºå…³é”®è¯è¾“å‡º â€˜Swaroop wrote A Byte of Pythonâ€™ print(â€˜{name} wrote {book}â€™.format(name=â€™Swaroopâ€™, book=â€™A Byte of Pythonâ€™)) ` ç”±äºæˆ‘ä»¬æ­£åœ¨è®¨è®ºæ ¼å¼é—®é¢˜ï¼Œå°±è¦æ³¨æ„ print æ€»æ˜¯ä¼šä»¥ä¸€ä¸ªä¸å¯è§çš„â€œæ–°ä¸€è¡Œâ€å­—ç¬¦( \n ) ç»“å°¾ï¼Œå› æ­¤é‡å¤è°ƒç”¨ print å°†ä¼šåœ¨ç›¸äº’ç‹¬ç«‹çš„ä¸€è¡Œä¸­åˆ†åˆ«æ‰“å°ã€‚ä¸ºé˜²æ­¢æ‰“å°è¿‡ç¨‹ä¸­å‡ºç°è¿™ä¸€ æ¢è¡Œç¬¦ï¼Œä½ å¯ä»¥é€šè¿‡ end æŒ‡å®šå…¶åº”ä»¥ç©ºç™½ç»“å°¾: `python print(â€˜aâ€™, end=â€™â€™) print(â€˜bâ€™, end=â€™ â€˜)#ä»¥ç©ºæ ¼ç»“å°¾ ` ##### è½¬ä¹‰åºåˆ— å¦‚æœå¸Œæœ›ç”Ÿæˆä¸€ä¸²åŒ…å«å•å¼•å·( â€˜ )çš„å­—ç¬¦ä¸²ï¼Œä½ åº”è¯¥å¦‚ä½•æŒ‡å®šè¿™ä¸²å­—ç¬¦ä¸²? ä¾‹å¦‚ï¼Œä½ æƒ³è¦çš„å­—ç¬¦ä¸²æ˜¯ â€œWhatâ€™s your name?â€ ã€‚ä½ ä¸èƒ½æŒ‡å®š â€˜Whatâ€™s your name?â€™ ï¼Œå› ä¸ºè¿™ ä¼šä½¿ Python å¯¹äºä½•å¤„æ˜¯å­—ç¬¦ä¸²çš„å¼€å§‹ã€ä½•å¤„åˆæ˜¯ç»“æŸè€Œæ„Ÿåˆ°å›°æƒ‘ã€‚æ‰€ä»¥ï¼Œä½ å¿…é¡»æŒ‡å®šè¿™ä¸ªå•å¼•å·ä¸ä»£è¡¨è¿™ä¸²å­—ç¬¦ä¸²çš„ç»“å°¾ã€‚è¿™å¯ä»¥é€šè¿‡è½¬ä¹‰åºåˆ—(Escape Sequence) æ¥å®ç°ã€‚ä½ é€šè¿‡\ æ¥æŒ‡å®šå•å¼•å·:è¦æ³¨æ„å®ƒå¯æ˜¯åæ–œæ ã€‚ç°åœ¨ï¼Œä½ å¯ä»¥å°†å­—ç¬¦ä¸²æŒ‡å®šä¸º â€˜What\â€™s your name?â€™ å¦ä¸€ç§æŒ‡å®šè¿™ä¸€ç‰¹åˆ«çš„å­—ç¬¦ä¸²çš„æ–¹å¼æ˜¯è¿™æ ·çš„: â€œWhatâ€™s your name?â€ ï¼Œå¦‚è¿™ä¸ªä¾‹å­èˆ¬ä½¿ç”¨ åŒå¼•å·ã€‚ç±»ä¼¼åœ°ï¼Œ ä½ å¿…é¡»åœ¨ä½¿ç”¨åŒå¼•å·æ‹¬èµ·çš„å­—ç¬¦ä¸²ä¸­å¯¹å­—ç¬¦ä¸²å†…çš„åŒå¼•å·ä½¿ç”¨è½¬ä¹‰åºåˆ—ã€‚ åŒæ ·ï¼Œä½ å¿…é¡»ä½¿ç”¨è½¬ä¹‰åºåˆ— \ æ¥æŒ‡å®šåæ–œæ æœ¬èº«ã€‚ å¦‚æœä½ æƒ³æŒ‡å®šä¸€ä¸²åŒè¡Œå­—ç¬¦ä¸²è¯¥æ€ä¹ˆåŠ?ä¸€ç§æ–¹å¼å³ä½¿ç”¨å¦‚å‰æ‰€è¿°çš„ä¸‰å¼•å·å­—ç¬¦ä¸²ï¼Œæˆ–è€…ä½  å¯ä»¥ä½¿ç”¨ä¸€ä¸ªè¡¨ç¤ºæ–°ä¸€è¡Œçš„è½¬ä¹‰åºåˆ—â€”â€”\n æ¥è¡¨ç¤ºæ–°ä¸€è¡Œçš„å¼€å§‹ã€‚ï¼ˆä¸cppç±»ä¼¼ï¼‰ åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ï¼Œä¸€ä¸ªæ”¾ç½®åœ¨æœ«å°¾çš„åæ–œæ è¡¨ç¤ºå­—ç¬¦ä¸²å°†åœ¨ä¸‹ä¸€è¡Œç»§ç»­ï¼Œä½†ä¸ä¼šæ·»åŠ æ–°çš„ä¸€è¡Œã€‚æ¥çœ‹çœ‹ä¾‹å­: `python â€œThis is the first sentence. \ This is the second sentence.â€ ` ç›¸å½“äº&quot;This is the first sentence. This is the second sentence.&quot; ### åŸºç¡€è¯­æ³• æ‰€è°“ç‰©ç†è¡Œ(Physical Line)æ˜¯ä½ åœ¨ç¼–å†™ç¨‹åºæ—¶ ä½ æ‰€çœ‹åˆ°çš„å†…å®¹ã€‚æ‰€è°“é€»è¾‘è¡Œ(Logical Line)æ˜¯ Python æ‰€çœ‹åˆ° çš„å•ä¸ªè¯­å¥ã€‚Python ä¼šå‡å®šæ¯ä¸€ç‰©ç†è¡Œä¼šå¯¹åº”ä¸€ä¸ªé€»è¾‘è¡Œã€‚å¦‚æœä½ å¸Œæœ›åœ¨ä¸€è¡Œç‰©ç†è¡Œä¸­æŒ‡å®šå¤šè¡Œé€»è¾‘è¡Œï¼Œé‚£ä¹ˆä½ å¿…é¡»é€šè¿‡ä½¿ç”¨åˆ†å·( ; )æ¥æ˜ç¡®è¡¨æ˜é€»è¾‘è¡Œæˆ–è¯­å¥çš„ç»“æŸã€‚ ç©ºç™½åŒºåœ¨ Python ä¸­ååˆ†é‡è¦ã€‚å®é™…ä¸Šï¼Œç©ºç™½åŒºåœ¨å„è¡Œçš„å¼€å¤´éå¸¸é‡è¦ã€‚è¿™è¢«ç§°ä½œ ç¼©è¿› (Indentation)ã€‚åœ¨é€»è¾‘è¡Œçš„å¼€å¤´ç•™ä¸‹ç©ºç™½åŒº(ä½¿ç”¨ç©ºæ ¼æˆ–åˆ¶è¡¨ç¬¦)ç”¨ä»¥ç¡®å®šå„é€»è¾‘è¡Œçš„ç¼© è¿›çº§åˆ«ï¼Œè€Œåè€…åˆå¯ç”¨äºç¡®å®šè¯­å¥çš„åˆ†ç»„ã€‚è¿™æ„å‘³ç€æ”¾ç½®åœ¨ä¸€èµ·çš„è¯­å¥å¿…é¡»æ‹¥æœ‰ç›¸åŒçš„ç¼©è¿›ã€‚æ¯ä¸€ç»„è¿™æ ·çš„è¯­å¥è¢«ç§°ä¸º å—(block)ã€‚ Attentionï¼šä½¿ç”¨å››ä¸ªç©ºæ ¼æ¥ç¼©è¿›ã€‚è¿™æ˜¯æ¥è‡ª Python è¯­è¨€å®˜æ–¹çš„å»ºè®®ã€‚å¥½çš„ç¼–è¾‘å™¨ä¼šè‡ªåŠ¨ä¸ºä½ å®Œæˆè¿™ ä¸€å·¥ä½œã€‚è¯·ç¡®ä¿ä½ åœ¨ç¼©è¿›ä¸­ä½¿ç”¨æ•°é‡ä¸€è‡´çš„ç©ºæ ¼ï¼Œå¦åˆ™ä½ çš„ç¨‹åºå°†ä¸ä¼šè¿è¡Œï¼Œæˆ–å¼•å‘ä¸ æœŸæœ›çš„è¡Œä¸ºã€‚ ### è¿ç®—ç¬¦ä¸ä¼˜å…ˆçº§ #### éœ€è¦æ³¨æ„çš„è¿ç®—ç¬¦ ** (ä¹˜æ–¹) è¿”å› x çš„ y æ¬¡æ–¹ã€‚ 3**4 è¾“å‡º 81 (å³ 3 3 3* 3 )ã€‚ /(é™¤) x é™¤ä»¥ y 13 / 3 è¾“å‡º 4.333333333333333 ã€‚ // (æ•´é™¤) x é™¤ä»¥ y å¹¶å¯¹ç»“æœå‘ä¸‹å–æ•´è‡³æœ€æ¥è¿‘çš„æ•´æ•°ã€‚ 13 // 3 è¾“å‡º 4 ã€‚ -13 // 3 è¾“å‡º -5 ã€‚ &lt; (å°äº) &gt; (å¤§äº) è¿”å› x æ˜¯å¦å°äº yã€‚æ‰€æœ‰çš„æ¯”è¾ƒè¿ç®—ç¬¦è¿”å›çš„ç»“æœå‡ä¸º True æˆ– False ã€‚è¯·æ³¨æ„è¿™ äº›åç§°ä¹‹ä¸­çš„å¤§å†™å­—æ¯ã€‚ 5&lt;3 è¾“å‡º False ï¼Œ3&lt;6 è¾“å‡º True ã€‚ æ¯”è¾ƒå¯ä»¥ä»»æ„ç»„æˆé“¾æ¥: 3 &lt; 5 &lt; 7 è¿”å› True ã€‚ å¦‚æœä¸¤ä¸ªæ“ä½œæ•°å‡ä¸ºæ•°å­—ï¼Œå®ƒä»¬é¦–å…ˆå°†ä¼šè¢«è½¬æ¢è‡³ä¸€ç§å…±åŒçš„ç±»å‹ã€‚å¦åˆ™ï¼Œå®ƒå°†æ€»æ˜¯è¿”å› False ã€‚ not (å¸ƒå°”â€œéâ€) å¯¹åº”cppçš„ï¼ and (å¸ƒå°”â€œä¸â€) å¯¹åº”cppçš„&amp; or (å¸ƒå°”â€œæˆ–â€) å¯¹åº”cppçš„| å…¶ä½™è¿ç®—ç¬¦ä¸cppåŸºæœ¬ä¸€è‡´ #### ä¼˜å…ˆçº§ ä»¥ä¸‹è¿ç®—ç¬¦ä¼˜å…ˆçº§ç”±ä½è‡³é«˜æ’åº lambda :Lambda è¡¨è¾¾å¼ if - else :æ¡ä»¶è¡¨è¾¾å¼ or :å¸ƒå°”â€œæˆ–â€ and:å¸ƒå°”â€œä¸â€ not x :å¸ƒå°”â€œéâ€ in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == :æ¯”è¾ƒï¼ŒåŒ…æ‹¬æˆå‘˜èµ„æ ¼æµ‹è¯• (Membership Tests)å’Œèº«ä»½æµ‹è¯•(Identity Tests)ã€‚ | :æŒ‰ä½æˆ– ^ :æŒ‰ä½å¼‚æˆ– &amp; :æŒ‰ä½ä¸ &lt;&lt;, &gt;&gt; :ç§»åŠ¨ +, -:åŠ ä¸å‡ *, /, //, %:ä¹˜ã€é™¤ã€æ•´é™¤ã€å–ä½™ +x, -x, ~x :æ­£ã€è´Ÿã€æŒ‰ä½å–å ** :æ±‚å¹‚ x[index], x[index:index], x(arguments...), x.attribute :ä¸‹æ ‡ã€åˆ‡ç‰‡ã€è°ƒç”¨ã€å±æ€§å¼• ç”¨ (expressions...), [expressions...], {key: value...}{expressions...}:è¡¨ç¤ºç»‘å®šæˆ–å…ƒ ç»„ã€è¡¨ç¤ºåˆ—è¡¨ã€è¡¨ç¤ºå­—å…¸ã€è¡¨ç¤ºé›†åˆ]]></content>
      <categories>
        <category>Python</category>
        <category>PythonåŸºæœ¬è¯­æ³•</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonåŸºæœ¬è¯­æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233]]></title>
    <url>%2Farticle%2F233%2F</url>
    <content type="text"><![CDATA[23323323312345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl; return 0;&#125; 2333 test ss s $233+34+A^3+A_5^4$ 2333 $A_5^4+A+23$ 233333333 å“ˆå“ˆå“ˆ test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Farticle%2Ftest%2F</url>
    <content type="text"><![CDATA[233 test]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farticle%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[è’Ÿè’»çš„Linuxéšç¬”]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2FLinux%2Fe8-92-9f-e8-92-bb-e7-9a-84linux-e9-9a-8f-e7-ac-94%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘çªç„¶å¼€å§‹ç ”ç©¶äº†ä¸€ä¸‹Linuxï¼Œéšæ‰‹è®°å½•ä¸€ä¸‹ä¸€äº›ç”¨è¿‡çš„çœ‹èµ·æ¥æ¯”è¾ƒæœ‰æ„æ€çš„å‘½ä»¤å§QAQ æ–‡ä»¶æµè§ˆ&amp;å¸¸ç”¨ä¹±ä¸ƒå…«ç³Ÿç¼–è¯‘å‘½ä»¤ï¼š g++ a+b.cpp -o a+b+c -std=c++11 a+b.cppæ˜¯cppæ–‡ä»¶åï¼Œa+b+cåˆ™æ˜¯å¯æ‰§è¡Œæ–‡ä»¶åï¼Œåé¢åˆ™å¯ä»¥é€‰æ‹©ç¼–è¯‘æ ‡å‡†ã€‚ ls æµè§ˆå½“å‰æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼ˆä¸åŒ…å«éšè—æ–‡ä»¶ ls -a æ˜¾ç¤ºæ‰€æœ‰æ–‡ä»¶ï¼ˆåŒ…æ‹¬éšè—æ–‡ä»¶ï¼‰ man ls manåé¢åŠ ä¸œè¥¿ï¼Œæ˜¾ç¤ºè¯¥å‘½ä»¤çš„å¸®åŠ©ï¼Œä¸Šä¸‹/ç©ºæ ¼æµè§ˆï¼Œqé€€å‡º cal æ˜¾ç¤ºæ—¥å†ã€‚cal 5 2018å¯æ˜¾ç¤ºæŒ‡å®šæœˆä»½ã€‚ æ–‡ä»¶æ‰“å¼€&amp;æ–°å»º&amp;åˆ é™¤ cd name æ‰“å¼€æ–‡ä»¶ cd/cd ~ å›åˆ°æ ¹ç›®å½• cd .. å›åˆ°ä¸Šä¸€çº§ç›®å½• pwd æ˜¾ç¤ºå½“å‰è·¯å¾„ mkdir name æ–°å»ºæ–‡ä»¶å¤¹ mkdir -p name/name/name æŒ‰è·¯å¾„å»ºç«‹å¤šä¸ªæ–°æ–‡ä»¶å¤¹ rmdir name åˆ é™¤æ­¤æ–‡ä»¶å¤¹ï¼ˆè¢«åˆ é™¤æ–‡ä»¶å¤¹å¿…é¡»ä¸ºç©ºï¼‰ rm -r name å¹²ç¿»nameç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼ˆåˆ åº“è·‘è·¯ï¼Ÿï¼‰ æ–‡ä»¶å¤åˆ¶ï¼Œç§»åŠ¨ï¼Œåˆ é™¤æ–‡ä»¶å¤åˆ¶ cp ~/testpdf.pdf ~/test å°†æ ¹ç›®å½•ä¸‹çš„æ–‡ä»¶copyåˆ°ç©ºæ ¼åçš„ç›®å½•ä¸­ï¼Œ~/ä¸å¡«åˆ™é»˜è®¤ä¸ºå½“å‰ç›®å½•ä¸‹çš„æ–‡ä»¶ å¯ä»¥åœ¨å¤åˆ¶çš„åŒæ—¶å¯¹å¤åˆ¶åçš„æ–‡ä»¶è¿›è¡Œé‡å‘½åï¼š cp ~/testpdf.pdf ~/test/notest.pdf å¤åˆ¶è¿‡å»çš„pdfåå­—å°±å˜äº† å¯ä»¥åŠ ä¸Š-ié€‰é¡¹ï¼Œè¿™æ ·æœ‰åŒåæ–‡ä»¶è¦†ç›–å‰ä¼šè¯¢é—®æ˜¯å¦è¦†ç›–ï¼š cp -i ~/testpdf.pdf ~/test å¦‚æœè¦å¤åˆ¶ä¸€ä¸ªç›®å½•ï¼Œæˆ–è€…è¯´æ˜¯æ–‡ä»¶å¤¹ï¼Œé‚£ä¹ˆéœ€è¦åŠ ä¸ŠæŒ‡ä»¤ -r cp -r test1 test2 å¦‚æœè¦å¼ºåˆ¶æ‰§è¡Œï¼Œè¿˜å¯ä»¥ä½¿ç”¨-fæŒ‡ä»¤ï¼›åŒæ—¶ï¼Œå¤šä¸ªæŒ‡ä»¤å¯ä»¥å åŠ ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š cp -rf test1 test2 å¼ºåˆ¶å¤åˆ¶ç›®å½• æ–‡ä»¶åˆ é™¤ä½¿ç”¨æŒ‡ä»¤rmä»¥è¾¾åˆ°ç›®çš„ï¼ŒåŒæ ·ï¼Œåˆ é™¤ç›®å½•éœ€è¦ä½¿ç”¨-rï¼Œè¿™æ˜¯é€’å½’åˆ é™¤å‘½ä»¤ï¼› rm -r test1 -iåˆ™ä¼šåœ¨åˆ é™¤å‰ç¡®è®¤ï¼Œ-fè¡¨ç¤ºå¼ºåˆ¶æ‰§è¡Œã€‚åŒæ—¶ï¼Œè¿˜å¯ä»¥ä½¿ç”¨æŒ‡ä»¤ rm test* é€šè¿‡åŠ ä¸Š â€œ* â€ æ¥åˆ é™¤æ­¤ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶åä»¥testä¸ºå‰ç¼€çš„æ–‡ä»¶ï¼› æ–‡ä»¶ç§»åŠ¨ä½¿ç”¨mvæŒ‡ä»¤æ¥è¾¾æˆç›®çš„ã€‚mvæŒ‡ä»¤å¯ä»¥ç§»åŠ¨æ™®é€šæ–‡ä»¶å’Œç›®å½•ï¼Œå› æ­¤ä¸å­˜åœ¨-r-f å¼ºåˆ¶ï¼Œ-iï¼šå¦‚æœå­˜åœ¨åŒåæ–‡ä»¶ï¼Œè¯¢é—®æ˜¯å¦è¦†ç›–ï¼› -uï¼šå¦‚æœç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨ï¼Œä¸”å½“å‰æ¥æºè¾ƒæ–°æ‰ä¼šæ›´æ–° mv a+b ~/test/test2/ å°†å½“å‰ç›®å½•ä¸­çš„å¯æ‰§è¡Œæ–‡ä»¶a+bç§»åŠ¨åˆ°æŒ‡å®šæ–‡ä»¶å¤¹ä¸­ï¼› mv a+b ~/test/test2/a+c ç§»åŠ¨æ–‡ä»¶çš„åŒæ—¶è¿›è¡Œåç§°å˜æ›´ï¼› mv a+b a+c ~/test/ åŒæ—¶ç§»åŠ¨å¤šä¸ªæ–‡ä»¶ï¼›æ³¨æ„æ­¤æ—¶æœ€åä¸€ä¸ªä¸€å®šæ˜¯ç›®å½•ï¼ï¼ï¼]]></content>
      <categories>
        <category>ä¹±æ</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ä¹±æ</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 18 (rated, Div. 1 + Div. 2)]]></title>
    <url>%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fmanthan-codefest-18-rated-div-1-div-2%2F</url>
    <content type="text"><![CDATA[1wå¹´æ²¡æ›´æ–°äº†QAQ A. å‚»é€¼é¢˜äºŒè¿›åˆ¶åˆ†è§£ä¸€ä¸‹å³å¯ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=0;;i++){ if(n&lt;=(1&lt;&lt;i))break; n-=(1&lt;&lt;i); } cout&lt;&lt;i+1&lt;&lt;endl; return 0; } B. æ’ä¸ªåºè´ªå¿ƒææå°±è¡Œï¼Œè‡ªå·±zzäº†è¿˜waäº†3å‘â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { int num[200005],n,s,i,j,k; ll ans=0; cin&gt;&gt;n&gt;&gt;s; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); sort(num+1,num+1+n); int mid=(n+1)&gt;&gt;1; if(num[mid]==s){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(num[mid]&gt;s){ for(i=mid;i;i--){ if(num[i]&lt;=s)break; ans+=num[i]-s; } } else{ for(i=mid;i&lt;=n;i++){ if(num[i]&gt;=s)break; ans+=s-num[i]; //cout&lt;&lt;ans&lt;&lt;endl; } } //cout&lt;&lt;mid&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. é™¤éç›¸é‚»ä½ç½®åˆšå¥½è¦äº¤æ¢ï¼Œå¦åˆ™éƒ½æ²¡æœ‰äº¤æ¢æ„ä¹‰ï¼Œéšä¾¿ææå³å¯ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k;string str1,str2; int ans=0; cin&gt;&gt;n; cin&gt;&gt;str1&gt;&gt;str2; for(i=0;i&lt;str1.size();i++){ if(str1[i]!=str2[i]){ if(i&lt;str1.size()-1&amp;&amp;str1[i+1]!=str2[i+1]&amp;&amp;str1[i]!=str1[i+1]){ ans++;i++; } else{ ans++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. å…¶å®å°±æ˜¯ä¸€ä¸ªäºŒå‰æ ‘çš„å±‚æ¬¡éå†ï¼Œä½†æ˜¯è¿˜æœ‰ä¸€ç‚¹è¦æ³¨æ„çš„å°±æ˜¯çˆ¶äº²å±‚çš„éå†é¡ºåºå†³å®šäº†ä¸‹ä¸€å±‚çš„éå†é¡ºåºï¼Œæ‰€ä»¥è¿™ä¹Ÿè¦è€ƒè™‘ã€‚è§£å†³æ–¹æ¡ˆæ˜¯æ¯ä¸ªç‚¹å»ºä¸€ä¸ªmapè®°å½•è¾¹ï¼Œç„¶åæ£€æµ‹åºåˆ—çš„æ—¶å€™å¼„ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªæŒ‡ç¤ºå½“å‰èŠ‚ç‚¹çš„å„¿å­ã€‚å¦‚æœæ˜¯éæ³•åºåˆ—ï¼Œæœ€åç¬¬äºŒä¸ªæŒ‡é’ˆè‚¯å®šæ²¡æ³•èµ°å®Œæ‰€æœ‰çš„èŠ‚ç‚¹ã€‚åŒæ—¶è¿˜è¦æ³¨æ„ç‰¹åˆ¤æ ¹èŠ‚ç‚¹æ˜¯å¦ä¸º1 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt;mp1[200005]; int main() { int n,i,j,k,x,y; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y);mp1[x][y]=1;mp1[y][x]=1; } int num[200005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;num[i]); for(i=1,j=2;i&lt;=n;i++) while(mp1[num[i]][num[j]]) j++; if(j==n+1&amp;&amp;num[1]==1){//æ³¨æ„è¿™é‡Œæ˜¯j==n+1!! cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; //cout&lt;&lt;j&lt;&lt;endl; return 0; } E. éš¾ç‚¹åœ¨äºæ€ä¹ˆå»æ£€æµ‹ä¸€ä¸ªäººæ˜¯å¦æœ‰è‡³å°‘kä¸ªæœ‹å‹ï¼Œå¹¶ä¸”è¿™äº›æœ‹å‹ä¹Ÿéƒ½æœ‰è‡³å°‘kä¸ªå¯ä»¥å»æ—…æ¸¸çš„æœ‹å‹â€¦æ ‡ç®—å¾ˆç²¾å¦™â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; set&lt;int&gt;s,G[maxn]; int k,a[maxn],b[maxn],ans[maxn],n,m; void check(int x) { if(G[x].size()&lt;k&amp;&amp;s.erase(x)){//å¦‚æœè¿™ä¸ªäººçš„æœ‹å‹å°äºk,ä»–è‚¯å®šè¦æ»šè›‹,åŒæ—¶åœ¨sé‡Œé¢ä¹Ÿè¦åˆ å»æ­¤äºº for(auto a:G[x]){ G[a].erase(x);check(a);//ä»–çš„æœ‹å‹ä¹Ÿè¦checkä¸€å‘ } } } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); G[a[i]].insert(b[i]);G[b[i]].insert(a[i]);//å»ºç«‹æœ‹å‹å…³ç³» } for(i=1;i&lt;=n;i++)s.insert(i); for(i=1;i&lt;=n;i++)check(i);//æ£€æŸ¥æ¯ä¸€ä¸ªäººçš„æœ‹å‹å…³ç³» for(i=m;i;i--){ ans[i]=s.size();//æ­¤æ—¶é›†åˆä¸­çš„æ‰€æœ‰äººéƒ½æ»¡è¶³è¦æ±‚ G[a[i]].erase(b[i]);G[b[i]].erase(a[i]);//åˆ å»è¿™å¤©æ‰æˆä¸ºæœ‹å‹çš„äºº check(a[i]);check(b[i]); } for(i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]); return 0; }]]></content>
      <categories>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ„ç‘æ³•ä¹‹æ—…â€”â€”å’•å’•å’•ç³»åˆ—]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%97%85%E6%B8%B8%2Fe6-84-8f-e7-91-9e-e6-b3-95-e4-b9-8b-e6-97-85-e5-92-95-e5-92-95-e5-92-95-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[8.26ä¸€å¤§æ—©5ç‚¹é’Ÿå°±æ»šå»æœºåœºäº†ï¼Œé£æœºå€’æ˜¯æ²¡å»¶è¯¯ï¼Œä½†æ˜¯å—èˆªçš„è¿™ç­é£æœºçœŸå¿ƒä¸æ•¢æ­ç»´â€”â€”é¦–å…ˆé£æœºåœ¨è¿œæœºä½ï¼Œåæ‘†æ¸¡è½¦è·‘äº†åŠå¤©ï¼Œç„¶åå¤§æ¦‚æ˜¯é£æœºæ¯”è¾ƒé™ˆæ—§çš„ç¼˜æ•…å§ï¼Œè¿ä¸ªäººå¨±ä¹ç³»ç»Ÿéƒ½æ²¡æœ‰ï¼Œæ— èŠå¾—ä¸è¡Œï¼Œè¦æ˜¯é£å›½é™…çº¿ä¹˜å®¢ä¼°è®¡èƒ½æ— èŠæ­»ã€‚é¤é£Ÿå°±æ›´åŠ æ— è¯­äº†ï¼Œé¢æ¡éå¸¸éš¾åƒï¼Œè¿˜æ¯äººå‘äº†åŠä¸ªç•ªè–¯â€¦è¯´èµ·æ¥ç•ªè–¯å¥½åƒè¿˜æ˜¯æœ€å¥½åƒçš„ã€‚å¹¸å¥½èˆªç¨‹ä¸é•¿ï¼Œç¡ä¸€è§‰ä¹Ÿå°±åˆ°äº†ã€‚ä¸è¿‡ä¸‹é™çš„æ—¶å€™é£è¶Šäº†å¹¿å·å¸‚åŒºå€’æ˜¯å¥½è¯„ï¼Œç¬¬ä¸€æ¬¡å¦‚æ­¤å®Œæ•´çš„åœ¨ç©ºä¸­ä¿¯ç°å¹¿å·â€”â€”æˆ‘ç”šè‡³æ¸…æ™°åœ°æ‹åˆ°äº†å°è›®è…°ã€‚ æ»šå›å®¶å°±12ç‚¹äº†ï¼Œç¡äº†ä¸€è§‰èµ·æ¥5ç‚¹äº†â€¦æäº†æåƒäº†ä¸ªé¥­åˆæ„‰å¿«åœ°å»æœºåœºäº†ï¼Œæ–°èˆªç«™æ¥¼çš„ç©ºè°ƒçœŸçš„å¥½å†·QAQã€‚èˆªç­å…¶å®æ˜¯å‡Œæ™¨00ï¼š35çš„â€¦ç™»æœºçš„æ—¶å€™å‰é¢æœ‰ä¿©è›®å¸…çš„å°å“¥å“¥ï¼Œä¸è¿‡ä¼¼ä¹æ˜¯ä¿©èµ„æœ¬ä¸»ä¹‰çš„å›½æ°‘ï¼Œä¸€ç›´åœ¨å“‡å“©å“‡å•¦ä¸çŸ¥é“è¯´å•¥ğŸ˜‚ æŠ•å¥”èµ„æœ¬ä¸»ä¹‰~ ç„¶åï¼Œå—èˆªä¸å¾—ä¸å†åæ§½ä¸€å‘â€¦è™½ç„¶è¯´787ä¸€æ’343ä¹Ÿæ˜¯èˆªç©ºå…¬å¸å¸¸æ€äº†â€¦ä½†æ˜¯æ‚¨è¿™ä¸ªå‰åé—´è·æ•¢ä¸æ•¢å†çª„ä¸€ç‚¹ï¼Œæ„Ÿè§‰æˆ‘TMä¸€è·¯è¹²åˆ°äº†ç½—é©¬â€¦ä½œä¸º5å¹´çš„è€787ï¼ŒWiFiè‡ªç„¶æ²¡æœ‰ï¼Œå¨±ä¹ç³»ç»Ÿçš„åˆ†è¾¨ç‡â€¦å¤§æ¦‚åªæœ‰è”æƒ³çš„åƒåœ¾æ³›ç™½tnå±æ‰èƒ½ä¸ä¹‹ä¸€æˆ˜ã€‚é£äº†12ä¸ªåŠå°æ—¶ï¼ŒçœŸçš„æŒºæ¼«é•¿çš„â€¦ ç½—é©¬æœºåœºWiFiç•Œé¢å€’æ˜¯å¥½è¯„â€¦ä¼°è®¡ä¹Ÿæ˜¯ä¸ºäº†è®¨å¥½ä¸€ä¸‹å„ä½çˆ†ä¹°çš„é‡‘ä¸»å¤§å¦ˆå§â€¦ 8.27åœ¨ç½—é©¬æœºåœºè¿‡æµ·å…³é˜Ÿä¼çœŸçš„è¶…çº§é•¿â€¦åˆšå¥½æ’åˆ°äº†ä¸€ä¸ªç‰¹åˆ«ä¸¥è‚ƒçš„æµ·å…³å¤§å§æŠŠå®ˆçš„å…³å¡ï¼Œæˆ‘å‰é¢çš„ä¸€ä¸ªç©†æ–¯æ—å°å§å§ä¼¼ä¹è¢«é£è¿”äº†â€¦è¿˜å¥½åæ¥æ¢äº†ä¸ªå¤§å”æ¥å®¡æ ¸ï¼Œè¿™å“¥ä»¬å€’æ˜¯è´¼æ¾æ•£ï¼Œä¸Šæ¥ä¸€çœ‹ä¸­å›½æ¸¸å®¢ç›´æ¥å°±è¿‡äº†â€¦ å‰é¢è¿™ä¸ªå¦¹å­è¢«é£è¿”äº†ï¼Œå·¦è¾¹é‚£ä¸ªå¤§å¦ˆçœŸçš„â€¦ è®²é“ç†ï¼Œç½—é©¬æœºåœºç»™æˆ‘çš„æ„Ÿè§‰å…¶å®ä¹ŸæŒºä¸€èˆ¬çš„ï¼Œè·ŸåŒ—äº¬çš„t2ä¸€ä¸ªæ°´å¹³å§ï¼Œç•¥æ—§ã€‚ ç„¶åç¬¬ä¸€å¤©å°±å…ˆæ»šå»æ¢µè’‚å†ˆäº†ï¼Œçœ‹äº†çœ‹åœ£å½¼å¾—å¤§æ•™å ‚ï¼Œé‡Œé¢å„ç§ä»€ä¹ˆåç”»é›•å¡‘ï¼ŒåŸ‹äº†å„ç§åäººâ€¦ä¸è¿‡å¯¹äºå¯¹è‰ºæœ¯ä¸€çªä¸é€šçš„æˆ‘æ¥è¯´ï¼Œæ„Ÿè§‰éƒ½æ˜¯ä¸€å †çŸ³è†åƒï¼Œçœ‹ä¸å‡ºä»€ä¹ˆå¤§åŒºåˆ«â€¦å€’æ˜¯å¤–é¢çš„ç‘å£«é›‡ä½£å…µè›®æœ‰æ„æ€ï¼Œæ„Ÿè§‰åƒåŠ¨ç‰©å›­é‡Œçš„åŠ¨ç‰©è¢«äººç–¯ç‹‚æ‹ç…§ï¼š-D æ¥ç€å°±æ»šå»äº†æ–—å…½åœºè·Ÿè®¸æ„¿æ± è½¬äº†è½¬ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼Œå°±æ˜¯äººç•¥å¤šï¼ˆè°è¯´åªæœ‰ä¸­å›½äººå¤šæ¥ç€ï¼Œèµ„æœ¬ä¸»ä¹‰ä¸€æ ·äººæŒ¤äººâ€¦)åƒäº†ä¸ªæ‰€è°“æ„å¤§åˆ©é›ªç³•ï¼Œä¸ªäººæ„Ÿè§‰å¹¶æ²¡æœ‰éº¦å½“åŠ³çš„æ–°åœ°å¥½åƒï¼ˆå‘¸ ä¸è¿‡ï¼Œç½—é©¬è€å»ºç­‘çš„ä¿æŠ¤è¿˜æ˜¯æ™®éæ¯”å›½å†…å¥½â€¦è¿™ä¸ªä¸å¾—ä¸æ‰¿è®¤ ä¼¼ä¹è¿˜æ˜¯è·¨å›½å¤§å…¬å¸éº¦çˆ¸çˆ¸çš„ä¸œè¥¿æœ€å¥½åƒï¼š-D ç„¶åå°±æ»šå›é…’åº—å•¦ï¼Œåƒäº†ä¸ªéº¦çˆ¸çˆ¸ï¼Œ8ç‚¹å°±ç¡ç€äº†ï¼ˆäºæ˜¯ç¬¬äºŒå¤©4ç‚¹å°±é†’äº†ï¼‰ 8.288.31ä»Šå¤©æ—©ä¸Šåœ¨ç‰æ£®æ¹–æ¸¸äº†ä¸€ä¼šèˆ¹ï¼Œä½†æ˜¯é›¾å¤ªå¤§æ„Ÿè§‰å•¥éƒ½çœ‹ä¸è§ï¼Œæœ€æœ‰æ„æ€çš„ä¼¼ä¹æ˜¯æ¹–é‡Œè¿˜èƒ½æ­£å¸¸è¡Œé©¶çš„æ˜è½®è’¸æ±½èˆ¹ã€‚æ¥ç€å°±æ˜¯åœ¨å¢å¡æ©ï¼ˆç‰æ£®ï¼‰çš„è‡ªç”±æ´»åŠ¨æ—¶é—´äº†ã€‚è€ƒè™‘åˆ°å¯¹æ‰‹è¡¨æ¯«æ— å…´è¶£ï¼ˆå…¶å®æ˜¯ä¹°ä¸èµ·ï¼‰ï¼Œåˆæ°å¥½å‘ç°é™„è¿‘æœ‰ä¸€ä¸ªThe Swiss Museum of Transport,äºæ˜¯å°±å¾ˆå¼€å¿ƒçš„åäº†4ç«™å…¬äº¤è¿‡å»çœ‹ã€‚ä¹°ç¥¨çš„æ—¶å€™å‘ç°æ²¡æœ‰è¶³å¤Ÿçš„ç¡¬å¸ï¼Œä¸Šè½¦è·Ÿå¸æœºèŠäº†åŠå¤©ä¹Ÿæ²¡æœ‰è§£å†³é—®é¢˜ï¼Œäºæ˜¯æœ€åå°±é€ƒäº†ä¸€æ³¢ç¥¨ã€‚ä¸å¾—ä¸è¯´èµ„æœ¬ä¸»ä¹‰çš„å…¬äº¤åèµ·æ¥è¿˜æ˜¯æŒºèˆ’æœçš„ï¼Œè€Œä¸”è½¦ä¸Šäººè´¼å¥½ï¼Œè¿˜ä¸»åŠ¨é—®æˆ‘æ˜¯ä¸æ˜¯å»åšç‰©é¦†ï¼ˆå¤§æ¦‚æ˜¯è„¸ä¸Šå†™ç€â€œæ¸¸å®¢â€ä¸¤å­—ï¼Ÿï¼‰ åšç‰©é¦†è·Ÿä¸­å›½çš„ç›¸æ¯”å…¶å®å¹¶ä¸æ˜¯å¾ˆå¤§ï¼Œä½†æ˜¯ç»´æŠ¤å¾—éå¸¸å¥½ï¼Œå±•å“ä¿å…»å¾—ä¹Ÿéå¸¸æ£’ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œ]]></content>
      <categories>
        <category>ç”Ÿæ´»</category>
        <category>æ—…æ¸¸</category>
      </categories>
      <tags>
        <tag>ç”Ÿæ´»</tag>
        <tag>æ—…æ¸¸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 10]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E8%B5%9B%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-multi-university-training-contest-10%2F</url>
    <content type="text"><![CDATA[HDU6426~6437 Gè€ƒè™‘ä½¿ç”¨å®¹æ–¥åŸç†è¿›è¡Œè®¡æ•°. åŒ…å«è‡³å°‘ä¸€ä¸ªå½¢å¦‚ $[i, i + 1] $æˆ– $[n, 1] $è¿™æ ·çš„å­ä¸²çš„ç¯æ’åˆ—ä¸ªæ•°æ˜¯ $\binom{n}{1} (n - 2)! $ä¸ª; å¯ä»¥æ¨å¹¿ä¸ºåŒ…å«è‡³å°‘$ k (0 \leq k &lt; n)$ä¸ªçš„ç¯æ’åˆ—ä¸ªæ•°æ˜¯ $\binom{n}{k} (n - k - 1)!$, åŒæ—¶æ³¨æ„åˆ°åŒ…å« $n$ ä¸ªçš„ç¯æ’åˆ—ä¸ªæ•°ä¸€å®šæ˜¯ 1ä¸ª. æ‰€ä»¥æœ€ç»ˆç­”æ¡ˆå°±æ˜¯$ (-1)^n + \sum_{k = 0}^{n - 1} (-1)^k \binom{n}{k} (n - k - 1)!$ æˆ–è€…ï¼Œç›´æ¥æš´åŠ›æ‰“è¡¨æ‰¾å‡ºå‰å‡ é¡¹ï¼Œæ¨å…¬å¼æˆ–è€…é¢å‘OEISç¼–ç¨‹ï¼Œå¾—å‡ºå…¬å¼ï¼š $a_n=(n-2)\times a_{n-1}+(n-1)\times a_{n-2}-(-1)^n$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=998244353; ll f[100005]; int main() { f[1]=1;f[2]=0;f[3]=1;f[4]=1; int i,j; for(i=5;i&lt;=100000;i++){ f[i]=((i-2)*f[i-1]%mod+(i-1)*f[i-2]%mod-(i&amp;1?-1:1))%mod; } int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; cout&lt;&lt;f[n]&lt;&lt;endl; } return 0; } Hprintf(â€œ%.0f\nâ€, pow(2, n)); #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 10000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } int main() { int t,i,j,k; cin&gt;&gt;t; while(t--){ int n;cin&gt;&gt;n; bign ans=1; for(i=1;i&lt;=n;i++){ ans=ans*2; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } I.ä»¤ $a=i-j$, å…ˆæšä¸¾$ i$ å†æšä¸¾ $a$ $ \sum_{i=1}^n \sum_{j=1}^{i-1} [\gcd(i+j,i-j)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i-a,a)=1] $ $= \sum_{i=1}^n \sum_{a=1}^{i-1} [\gcd(2i,a)=1]$ å³å¯¹äºæ¯ä¸ª $i$, æ±‚æœ‰å¤šå°‘ä¸ªå°äºå®ƒçš„ $a$ æ»¡è¶³$ \gcd(i,a)=1 $ä¸”$ a $æ˜¯å¥‡æ•°. å½“ $i$ æ˜¯å¥‡æ•°æ—¶, ç­”æ¡ˆä¸º$ \frac{\varphi(i)}{2}.$ ï¼ˆæ­¤æ—¶ï¼Œæ‰€æ±‚å°±æ˜¯$(n,1),(n,3),(n,5)â€¦(n,n)$ä¸­$\gcd$ä¸º1çš„ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯æ±‚ $(n,n-1),(n,n-3),â€¦(n,n-n)$,å³$(n,2),(n,4),(n,6)â€¦(n,n-1)$,æ‰€ä»¥æœ‰ $\sum(1,3,â€¦,n)=\frac{1}{2}\sum(1,2,â€¦n)[gcd(n,i)=1]=\frac{phi(n)}{2}$ å½“ $i$ æ˜¯å¶æ•°æ—¶, ç­”æ¡ˆä¸º$\varphi(i).$ (æ˜¾ç„¶aæ˜¯å¶æ•°çš„æ—¶å€™gcdä¸ä¼šæ˜¯1ï¼Œæ‰€ä»¥ç›´æ¥æ±‚æ¬§æ‹‰å‡½æ•°å³å¯) æ³¨æ„ $i=1$ æ—¶, ç­”æ¡ˆä¸º 0. è®°ä¸ªå‰ç¼€å’Œå°±å¥½äº†, å¤æ‚åº¦ä¸º $O(N+T)$. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e7+10; vector&lt;int&gt;prime; bool isnotprime[maxn+50]; long long phi[maxn+50]; void check(void) { int i,j,k; for(i=2;i&lt;=maxn;i++){ if(!isnotprime[i]){ prime.push_back(i);//[ptop++]=i; phi[i]=i-1; } for(j=0;j&lt;prime.size();j++){ int pi=prime[j]*i; if(pi&gt;maxn)break; isnotprime[pi]=true; if(i%prime[j]==0){ phi[pi]=prime[j]*phi[i]; break; } phi[pi]=(prime[j]-1)*phi[i]; } } for(i=1;i&lt;=maxn;i++) { if(i&amp;1)phi[i]&gt;&gt;=1; phi[i] += phi[i - 1]; } } int main() { int t,i,j; check(); cin&gt;&gt;t; while(t--){ int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,phi[n]); } return 0; } J.K ä¸å¤§äº 5, ä»…æ˜¯å¸¸æ•°çº§åˆ«, æ‰€ä»¥å¯ä»¥æäº‹æƒ… æˆ‘ä»¬å‘ç° $|x_{MW}[i]-x_{SW}[i]| = max(x_{MW}[i]-x_{SW}[i],x_{SW}[i]-x_{MW}[i])$ ä¹Ÿå°±æ˜¯è¯´å¯¹äºæ¯ä¸€ä¸ªç»´åº¦åªæœ‰ä¸¤ç§é€‰æ‹©, åŒæ—¶$ 2^K \le 32$ ä¹Ÿä¸å¤§, æ‰€ä»¥å¯ä»¥æšä¸¾æ¯ä¸€ç»´çš„å¤§å°æƒ…å†µ, åˆ†åˆ«å–ä¸»æ­¦å™¨ä¸å‰¯æ­¦å™¨çš„æœ€å¤§å€¼å°±å¥½äº†, å¤æ‚åº¦ $O(2^Kn).$ å…·ä½“æ¥è¯´ï¼Œå¯¹äºæ¯ä¸€ä¸ªæ­¦å™¨ï¼Œæšä¸¾ä»–çš„æ¯ä¸€ä¸ªxå‰é¢å–+/-å·çš„æƒ…å†µï¼Œç„¶åæ›´æ–°$num[j]$æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯è®°å½•åœ¨ä¸€ç§+/-å–å€¼çŠ¶å†µä¸‹çš„æœ€å¤§å€¼ï¼Œç„¶åæˆ‘ä»¬æšä¸¾ä¸»å‰¯æ­¦å™¨çš„numæ•°ç»„ï¼Œå½“ç„¶æšä¸¾çš„æ—¶å€™è¦ç¡®ä¿ä¸»æ­¦å™¨çš„å–å€¼çŠ¶å†µä¸å‰¯æ­¦å™¨åˆšå¥½æ˜¯å–åçš„çŠ¶æ€ï¼Œè¿™æ ·å°±å¯ä»¥æ±‚å‡ºæœ€å¤§å€¼ã€‚å½“ç„¶ä¼šå‡ºç°ä¸€äº›æ­£è´Ÿå·ä¸ç”šæ­£ç¡®çš„æƒ…å†µï¼Œå¯æ˜¯è¿™äº›æƒ…å†µæ˜¾ç„¶ä¸ä¼šæ˜¯æœ€ä¼˜è§£ï¼Œæ‰€ä»¥ä¸å¿…æ‹…å¿ƒã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=-(1ll&lt;&lt;60); const int maxn=100005; int S[maxn],s[maxn],X[maxn][6],x[maxn][6]; ll numm[60],numn[60]; int main() { int t,i,j,n,m,k; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=0;i&lt;(1&lt;&lt;5);i++) numm[i]=numn[i]=INF; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;S[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;X[i][j]); for(;j&lt;=5;j++) X[i][j]=0; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;s[i]); for(j=1;j&lt;=k;j++) scanf(&quot;%d&quot;,&amp;x[i][j]); for(;j&lt;=5;j++) x[i][j]=0; } for(i=1;i&lt;=n;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=S[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?X[i][a+1]:-X[i][a+1]; } numm[j]=max(numm[j],temp); } } for(i=1;i&lt;=m;i++){ for(j=0;j&lt;(1&lt;&lt;5);j++){ ll temp=s[i]; for(int a=0;a&lt;5;a++){ temp+=(1&lt;&lt;a)&amp;j?x[i][a+1]:-x[i][a+1]; } numn[j]=max(numn[j],temp); } } ll ans=0; for(i=0;i&lt;(1&lt;&lt;5);i++){ int pos=((1&lt;&lt;5)-1)&amp;(~i); ans=max(ans,numm[i]+numn[pos]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } L.å’‹ä¸€çœ‹ä»¥ä¸ºæ˜¯dpï¼Œåæ¥å‘ç°æ˜¯ç½‘ç»œæµâ€¦è¿™é‡Œéœ€è¦æœ€å¤§çš„æ»¡æ„å€¼ï¼Œè€Œæˆ‘ä»¬çš„æ¨¡æ¿æ˜¯æœ€å°è´¹ç”¨æµï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠæ»¡æ„å€¼éƒ½å¼„æˆè´Ÿçš„ï¼Œè¿™æ ·æ±‚å‡ºæ¥ä»¥åå–ä¸ªç›¸åæ•°å°±æ˜¯æ»¡æ„å€¼äº†â€¦ è€ƒè™‘åˆ°æ¯ä¸ªvideoåªèƒ½è¢«ä¸€ä¸ªäººçœ‹ï¼Œå› æ­¤æ˜¾ç„¶è¦æ‹†ç‚¹ï¼Œæµé‡1è´¹ç”¨0ï¼Œç„¶åä¸ºäº†é™åˆ¶æ€»æµé‡ä¹Ÿå°±æ˜¯äººæ•°ï¼Œèµ·ç‚¹å‘è™šæ‹Ÿèµ·ç‚¹è¿è¾¹,é™åˆ¶æ€»æµé‡kã€‚ä¸ºäº†ä¿è¯æœ€å¤§æµï¼Œï¼ˆæœ‰çš„äººå¯ä»¥æ²¡videoçœ‹ï¼‰ï¼Œè™šæ‹Ÿèµ·ç‚¹å‘ç»ˆç‚¹è¿è¾¹,æµé‡kè´¹ç”¨0ï¼Œç¡®ä¿æœ€å¤§æµé‡ï¼ˆå› ä¸ºvideoè´¹ç”¨ä¸ºè´Ÿï¼Œå¯æµçš„æƒ…å†µä¸‹æ˜¾ç„¶æ›´ä¼˜ï¼‰ã€‚ç„¶åèµ·ç‚¹å‘æ¯ä¸ªç‚¹videoçš„ç¬¬ä¸€ä¸ªç‚¹è¿è¾¹ï¼Œä»¥åŠæ¯ä¸ªvideoçš„ç¬¬äºŒä¸ªç‚¹å‘ç»ˆç‚¹è¿è¾¹ã€‚å¯¹äºæ¯ä¸ªvideoï¼Œæšä¸¾æ‰€æœ‰çš„videoï¼Œä¸‹ä¸ªvideoçš„èµ·å§‹æ—¶é—´æ™šäºå½“å‰videoçš„ç»“æŸæ—¶é—´æ‰å¯ä»¥è¿è¾¹ï¼Œæµé‡1ï¼Œè´¹ç”¨ä¸ºä¸‹ä¸ªvideoçš„wï¼Œå¹¶ä¸”è¦è€ƒè™‘ç±»å‹å¸¦æ¥çš„æƒ©ç½šå€¼ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=550; struct edge{ int to,cap,cost,rev;//ç»ˆç‚¹,å®¹é‡,è´¹ç”¨,åå‘è¾¹ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//æœ€çŸ­è·¯ä¸­å‰é©±èŠ‚ç‚¹å’Œå¯¹åº”çš„è¾¹, // å°å¿ƒcostçˆ†int,å¤šç»„æ•°æ®æ—¶è®°å¾—æ¸…é›¶ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//æ³¨æ„åå‘è¾¹çš„åŠ æ³•!!-costå’Œcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//å°å¿ƒçˆ†intçš„æƒ…å†µ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//å…¨æœ€çŸ­è·¯ä¸­çš„æœ€å°æµé‡é™åˆ¶å°±æ˜¯æœ¬æ¬¡æ€»çš„æµé‡é™åˆ¶ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//æ›´æ–°è·¯å¾„ä¿¡æ¯ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } struct movie{ int s,t,w,op; }M[250]; int main() { int t,i,j,k,n,m,w,W; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;W; for(i=0;i&lt;=520;i++)G[i].clear(); for(i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;M[i].s,&amp;M[i].t,&amp;M[i].w,&amp;M[i].op); int s1=505,s2=506,t=510; add(s1,s2,k,0);//èµ·ç‚¹å‘è™šæ‹Ÿèµ·ç‚¹è¿è¾¹,é™åˆ¶æ€»æµé‡ add(s2,t,k,0);//è™šæ‹Ÿèµ·ç‚¹å‘ç»ˆç‚¹è¿è¾¹,ç¡®ä¿æœ€å¤§æµé‡ flow=cost=0; for(i=1;i&lt;=m;i++) add(i+200,t,1,0);//æ¯ä¸ªvideoå‘ç»ˆç‚¹è¿è¾¹ for(i=1;i&lt;=m;i++){ add(s2,i,1,-M[i].w);//èµ·ç‚¹å‘æ¯ä¸ªvideoè¿è¾¹ add(i,i+200,1,0);//æ¯ä¸ªvideoæ‹†æˆä¸¤ä¸ªç‚¹ for(j=1;j&lt;=m;j++){ if(i==j)continue; if(M[i].t&lt;=M[j].s){//ä¸‹ä¸ªvideoçš„èµ·å§‹æ—¶é—´æ™šäºå½“å‰videoçš„ç»“æŸæ—¶é—´æ‰å¯ä»¥è¿è¾¹ if(M[i].op!=M[j].op){//ç±»å‹ä¸åŒç›´æ¥è¿ add(i+200,j,1,-M[j].w); } else{//å‡å»æƒ©ç½šå€¼ add(i+200,j,1,-(M[j].w-W)); } } } } mincostmaxflow(s1,t); cout&lt;&lt;-cost&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œèµ›</category>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
        <tag>ç½‘ç»œèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 34 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-34-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.æ•°æ®èŒƒå›´é‚£ä¹ˆå°ç›´æ¥æš´åŠ›æšä¸¾å•Š #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x; cin&gt;&gt;n; while(n--){ cin&gt;&gt;x; for(i=0;3*i&lt;=x;i++){ if((x-i*3)%7==0){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;&apos;\n&apos;;break; } } if(3*i&gt;x) puts(&quot;NO&quot;); } return 0; } B.å¼±æ™º* 2 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int h1,a1,c1,h2,a2,cnt=0; vector&lt;int&gt;ans; cin&gt;&gt;h1&gt;&gt;a1&gt;&gt;c1&gt;&gt;h2&gt;&gt;a2; while(h2&gt;0){ cnt++; if(h2-a1&lt;=0){ ans.push_back(1);break; } else{ if(h1-a2&lt;=0){ ans.push_back(0);h1=h1-a2+c1; } else { ans.push_back(1);h1-=a2;h2-=a1; } } } cout&lt;&lt;cnt&lt;&lt;endl; for(auto a:ans) if(a) puts(&quot;STRIKE&quot;); else puts(&quot;HEAL&quot;); return 0; } C.ä»å¤§åˆ°å°æ’åºï¼Œç„¶åç»´æŠ¤ä¸€ä¸ªå¤§æ ¹å †ï¼Œæ¯æ¬¡å¦‚æœå †é¡¶çš„ç®±å­èƒ½æ”¾ä¸‹å½“å‰ç®±å­ï¼Œå°±æŠŠå½“å‰ç®±å­ä¸¢è¿›å»å¹¶æ›´æ–°ç®±å­å¤§å°ï¼Œå¦åˆ™è¿™ä¸ªç®±å­å°±å¾—å•ç‹¬æ”¾ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,box[5005]; priority_queue&lt;int&gt;que; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;box[i]; sort(box+1,box+1+n); for(i=n;i;i--){ if(que.empty()||que.top()&lt;=box[i]){ que.push(box[i]); } else{ que.pop();que.push(box[i]); } } cout&lt;&lt;que.size()&lt;&lt;endl; return 0; } D.å…¶å®æˆ‘çš„æƒ³æ³•å¾ˆç®€å•ï¼šé¦–å…ˆæä¸ªmapç»Ÿè®¡æ¯ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ï¼Œå†æä¸ªåç¼€å’Œã€‚ç„¶åä»å‰å¾€åæ‰«ï¼Œå¯¹äºæ¯ä¸ªæ•°ï¼Œå…ˆåœ¨mapé‡Œå¯¹è¿™ä¸ªæ•°â€“ï¼Œç„¶åçœ‹çœ‹åœ¨è¿™ä¸ªæ•°-1~è¿™ä¸ªæ•°+1çš„èŒƒå›´å†…è¿˜æœ‰å¤šå°‘ä¸ªæ•°ï¼ˆç”¨mapæŸ¥è¯¢ï¼‰ï¼Œç„¶åå¤„ç†ä¸€ä¸‹åç¼€å’Œå°±è¡Œäº†ã€‚ç„¶è€Œè¿™ä¸ªä¸‡æ¶çš„é¢˜ç›®å¡long longâ€¦äºæ˜¯æˆ‘å°±æŠ„äº†ä¸ª400è¡Œçš„é«˜ç²¾åº¦æ¨¡æ¿â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //æœ€å¤§é•¿åº¦ï¼Œå¯ä»¥ä¿®æ”¹ using namespace std; class bign { public: int len, s[MAX_L];//æ•°çš„é•¿åº¦ï¼Œè®°å½•æ•°ç»„ //æ„é€ å‡½æ•° bign(); bign(const char *); bign(int); bool sign;//ç¬¦å· 1æ­£æ•° 0è´Ÿæ•° string toStr() const;//è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œä¸»è¦æ˜¯ä¾¿äºè¾“å‡º friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//é‡è½½è¾“å…¥æµ friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//é‡è½½è¾“å‡ºæµ //é‡è½½å¤åˆ¶ bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //é‡è½½å„ç§æ¯”è¾ƒ bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //é‡è½½å››åˆ™è¿ç®— bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //å››åˆ™è¿ç®—çš„è¡ç”Ÿè¿ç®— bign operator%(const bign &amp;) const;//å–æ¨¡ï¼ˆä½™æ•°ï¼‰ bign factorial() const;//é˜¶ä¹˜ bign Sqrt() const;//æ•´æ•°å¼€æ ¹ï¼ˆå‘ä¸‹å–æ•´ï¼‰ bign pow(const bign &amp;) const;//æ¬¡æ–¹ //ä¸€äº›ä¹±ä¹±çš„å‡½æ•° void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005]; int main() { int n,i,j,k,num[200005]; bign ans=0; cin&gt;&gt;n; map&lt;int,int&gt;mp1; for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;num[i]),mp1[num[i]]++; for(i=n;i;i--){ sum[i]=num[i];sum[i]+=sum[i+1]; } for(i=1;i&lt;=n;i++){ mp1[num[i]]--; int tot=n-i; if(mp1[num[i]]==0)mp1.erase(num[i]); bign temp;temp=num[i]; sum[i]-=temp; if(mp1.count(num[i]-1)){ temp=(ll)mp1[num[i]-1]*(num[i]-1); sum[i]-=temp; tot-=mp1[num[i]-1]; } if(mp1.count(num[i])){ temp=(ll)mp1[num[i]]*(num[i]); sum[i]-=temp; tot-=mp1[num[i]]; } if(mp1.count(num[i]+1)){ temp=(ll)mp1[num[i]+1]*(num[i]+1); sum[i]-=temp; tot-=mp1[num[i]+1]; } temp=(ll)tot*num[i]; ans-=temp;ans+=sum[i]; } //ans*=-1; cout&lt;&lt;ans&lt;&lt;endl; return 0; } ç„¶åæˆ‘çœ‹æäº¤è®°å½•çš„æ—¶å€™å‘ç°äº†ä¸€ä¸ªç®€å•å¾—å¤šçš„åšæ³•â€¦å…¶å®ä¹Ÿå¯èƒ½æ˜¯å› ä¸ºæ‹¿long doubleä»£æ›¿äº†é«˜ç²¾åº¦æ‰€ä»¥æ˜¾å¾—æ¯”è¾ƒç®€å•ã€‚ é¦–å…ˆä»å‰å¾€åæ‰«ï¼Œå¯¹äºæ¯ä¸€ä½æ•°a[i]ï¼Œæˆ‘ä»¬æ‹¿a[i]* iå‡å»å‰ç¼€å’Œå°±æ˜¯æ²¡æœ‰ç›¸å‡ä¸º0æ¡ä»¶ä¸‹çš„ç­”æ¡ˆï¼Œç„¶åå¯¹äºé‚£äº›ç»å¯¹å€¼ç›¸å·®1 çš„æ•°ï¼Œæˆ‘ä»¬å…ˆæ‹¿ä¸€ä¸ªmap cntç»Ÿè®¡è¿„ä»Šä¸ºæ­¢å„ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ï¼Œç„¶ååŠ ä¸Šcnt[a[i]+1]-cnt[a[i]-1]å³å¯ã€‚long doubleå±…ç„¶èƒ½æè¿‡å»â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int,int&gt; cnt; int main() { int n; long double ans=0,sum=0,num; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++){ scanf(&quot;%Lf&quot;,&amp;num); ans+=num*i-sum+cnt[(int)num+1]-cnt[(int)num-1]; sum+=num; cnt[(int)num]++; } printf(&quot;%.0Lf&quot;,ans+0.000000001); return 0; } E. ç»™å®šä¸€å †å­—ç¬¦ä¸²ï¼Œé—®èƒ½ä¸èƒ½æ„é€ ä¸€ä¸ªå­—ç¬¦ä¸²ä½¿å¾—æ‰€æœ‰çš„å­—ç¬¦ä¸²åœ¨äº¤æ¢è‡ªå·±çš„æŸä¸¤ä¸ªå­—ç¬¦ä¹‹åéƒ½ä¸æ„é€ å‡ºæ¥çš„å­—ç¬¦ä¸€æ¨¡ä¸€æ ·ã€‚ é¦–å…ˆï¼Œå¦‚æœæ‰€æœ‰çš„å­—ç¬¦ä¸²é•¿å¾—éƒ½ä¸€æ ·ï¼Œé‚£éšä¾¿æ¢ä¸¤ä¸ªå­—æ¯çš„ä½ç½®è¾“å‡ºå³å¯ã€‚ å¦åˆ™ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸¤ä¸ªä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆç¬¬ä¸€ä¸ªä¸å¦¨å°±æ˜¯è¾“å…¥çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰ï¼Œç„¶åæŠŠä»–ä»¬æ‰€æœ‰ä¸ç›¸åŒçš„ä½ç½®çš„ä¸‹æ ‡éƒ½ä¿å­˜åœ¨diffæ•°ç»„é‡Œã€‚å¦‚æœdiffçš„size&gt;4ï¼Œé‚£ä¹ˆæ˜¾ç„¶ï¼Œæ— è§£ï¼ˆæ¯ä¸ªå­—ç¬¦ä¸²æœ€å¤šäº¤æ¢2ä¸ªå­—ç¬¦ï¼Œä¸å¯èƒ½ä½¿å¾—5ä¸ªä»¥ä¸Šä¸åŒçš„ä½ç½®å˜å¾—ç›¸åŒï¼‰ã€‚ ç„¶åï¼Œå¯¹äºæ¯ä¸ªä¸åŒçš„ä¸‹æ ‡ï¼Œæˆ‘ä»¬éƒ½å°è¯•æ‹¿ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ä¸åŒä½ç½®çš„å­—ç¬¦å»ä¸ä¹‹äº¤æ¢ï¼Œçœ‹çœ‹æ¢å®Œçš„å­—ç¬¦ä¸²èƒ½ä¸èƒ½æ˜¯ç­”æ¡ˆã€‚ å¦‚ä½•æ£€æŸ¥ä¸€ä¸ªäº¤æ¢å®Œçš„å­—ç¬¦ä¸²æ˜¯ä¸æ˜¯ç­”æ¡ˆå‘¢ï¼Ÿ å¯¹äºæ‰€æœ‰çš„å­—ç¬¦ä¸²ï¼ˆå½“ç„¶è‡ªå·±è·Ÿè‡ªå·±é™¤å¤–ï¼‰ï¼Œæˆ‘ä»¬éƒ½ç»Ÿè®¡ä¸åŒçš„ä½ç½®çš„ä¸‹æ ‡å¹¶ä¿å­˜åœ¨difæ•°ç»„ä¸­ï¼Œå¦‚æœæœ‰ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²çš„difæ•°ç»„çš„size!=0&amp;&amp;size!=2ï¼Œæ˜¾ç„¶è¿™ä¸ªæ¢å®Œçš„å­—ç¬¦ä¸²æ˜¯ä¸èƒ½æˆä¸ºç­”æ¡ˆçš„ã€‚å¦‚æœsize=0ï¼Œé‚£ä¹ˆé‚£ä¸ªå­—ç¬¦ä¸²å¦‚æœæ‰€æœ‰çš„å­—ç¬¦éƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œä¹Ÿä¸è¡Œï¼ˆå› ä¸ºæ¯ä¸ªå­—ç¬¦ä¸²éƒ½è¦äº¤æ¢ä¸¤ä¸ªå­—ç¬¦ï¼Œå…¨éƒ¨ä¸åŒçš„è¯æ¢å®Œå°±ä¸å¯èƒ½æ»¡è¶³å½“å‰ç­”æ¡ˆäº†ï¼‰ã€‚å¦‚æœsize=2ï¼Œé‚£ä¹ˆé‚£ä¸ªå­—ç¬¦ä¸²äº¤æ¢å®Œè¿™ä¿©ä½ç½®ä¹‹åå¿…é¡»ä¸å½“å‰ç­”æ¡ˆä¸€æ ·ã€‚ æ‰«å®Œæ‰€æœ‰å¯èƒ½ä»¥åï¼Œå¦‚æœè¿˜æ²¡æœ‰æ‰¾åˆ°ç­”æ¡ˆï¼Œè¾“å‡º-1å³å¯ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; bool check(string str) { int cnt[30]={0}; for(auto a:str) cnt[a-&apos;a&apos;]++; for(int i=0;i&lt;26;i++) if(cnt[i]&gt;=2) return true; return false; } int main() { set&lt;string&gt;s; int k,n,i,j,a,b,len; cin&gt;&gt;n&gt;&gt;len; string str[2505],str1,str2; for(i=1;i&lt;=n;i++){ cin&gt;&gt;str[i];s.insert(str[i]); } if(s.size()==1){ swap(str[1][0],str[1][1]); cout&lt;&lt;str[1]&lt;&lt;endl;return 0; } str1=str[1]; for(i=2;i&lt;=n;i++) if(str[i]!=str[1]) { str2 = str[i];break; } vector&lt;int&gt;diff; for(i=0;i&lt;len;i++) if(str1[i]!=str2[i]) diff.push_back(i); if(diff.size()&gt;4){ puts(&quot;-1&quot;);return 0; } for(auto a:diff){ for(i=0;i&lt;len;i++){ if(i==a)continue; bool isok=true; string str3=str1;swap(str3[i],str3[a]); for(j=2;j&lt;=n;j++){ vector&lt;int&gt;dif; for(k=0;k&lt;len;k++){ if(str3[k]!=str[j][k]) dif.push_back(k); } if(dif.size()!=0&amp;&amp;dif.size()!=2){ isok=false; break; } if(dif.empty()){ if(!check(str[j])){ isok=false;break; } } else{ string str4=str[j];swap(str4[dif[0]],str4[dif[1]]); if(str4!=str3){ isok=false;break; } } } if(isok){ cout&lt;&lt;str3&lt;&lt;endl;return 0; } } } puts(&quot;-1&quot;); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 49 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-49-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.å°å¿ƒå¤„ç†zä¸açš„é—®é¢˜ï¼Œä»¥åŠæ³¨æ„æ¯ä¸ªå­—æ¯éƒ½å¿…é¡»å‘ç”Ÿå˜åŒ–å³å¯ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { string str1,str2; int n,i,j,k; int t; cin&gt;&gt;t; while(t--){ bool isok=true; cin&gt;&gt;n&gt;&gt;str1;str2=str1;reverse(str2.begin(),str2.end()); for(i=0;i&lt;str1.size();i++){ if(abs((int)(str1[i]-str2[i]))==1||abs((int)(str1[i]-str2[i]))&gt;2){ isok=false;break; } } if(isok)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } B.æ³¨æ„nä¸ºå¥‡æ•°çš„æ—¶å€™éœ€è¦ç‰¹åˆ«è®¨è®º,æ¯ä¸¤è¡Œä¸ºä¸€ç»„åˆšå¥½nä¸ªæ•°ï¼Œç„¶åå¯èƒ½å¤šä¸€è¡Œå¾—å•ç‹¬è®¨è®ºä¸€ä¸‹ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n, q, x, y; cin &gt;&gt; n &gt;&gt; q; int i,j,k; for (i = 1; i &lt;= q; i++) { cin &gt;&gt; x &gt;&gt; y; ll ans = 0; if ((x + y) &amp;1) { ans += (n * n - 1) / 2 + 1; } if (n &amp;1) { ans += (x - 1) / 2 * n; if ((x + y) % 2 == 1) ans += (x - 1) % 2 * (n / 2); else ans += (x - 1) % 2 * (n / 2 + 1); ans += (y + 1) / 2; } else if (n % 2 == 0) { ans += (x - 1) * n / 2; ans += (y + 1) / 2; } cout &lt;&lt; ans &lt;&lt; endl; } return 0; } C.æ³¨æ„åˆ°å–åˆ°çš„æœ€å°å€¼çš„ç»„åˆè‚¯å®šæ˜¯é‚£äº›æ¯”è¾ƒç›¸é‚»é•¿åº¦çš„æœ¨æ£ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†æœ¨æ£æ’åºï¼Œç„¶åæš´åŠ›æšä¸¾ç›¸é‚»é•¿åº¦ä¸”æ ¹æ•°&gt;=2çš„æœ¨æ£ã€‚ #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 50; long double minnum; int num[maxn]; int main() { int i,j,k, t, n; int q1, q2, P1, P2; cin&gt;&gt;t; while(t--){ minnum = 1ll &lt;&lt; 60;P1 = P2 = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); } sort(num + 1, num + n + 1); for (i = 1; i &lt;= n; i++) { if (P1 == num[i]) { if (P2 != 0) { long double x(P1), y(P2); long double temp = (x + x + y + y)*(x + x + y + y) / (x*y); if (temp &lt; minnum) { q1 = P2; q2 = P1; minnum = temp; } } P2 = P1;P1 = 0; } else { P1 = num[i]; } } printf(&quot;%d %d %d %d\n&quot;,q1,q1,q2,q2); //cout &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q1 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; &apos; &apos; &lt;&lt; q2 &lt;&lt; endl; } return 0; } D.æ¯ä¸ªæˆ¿é—´éƒ½æœ‰å‡ºåº¦â€¦æ‰€ä»¥æœ€åæ¯ä¸ªæˆ¿é—´éƒ½å¯ä»¥å½’ç»“äºæŸä¸ªè¿é€šåˆ†é‡ä¹‹ä¸­ï¼Œæ±‚å‡ºè¿™ä¸ªè¿é€šåˆ†é‡ä¸­çš„æœ€å°çš„cå°±æ˜¯è¿™ä¸ªè¿é€šåˆ†é‡çš„ç­”æ¡ˆï¼Œä½†æ˜¯è¿˜è¦æ³¨æ„é‚£äº›a[i]=içš„ç‚¹ï¼Œè¿™ç§æˆ¿é—´ä¸€å®šè¦åœ¨è‡ªå·±é‚£é‡Œæ”¾ä¸€ä¸ªã€‚è·‘è·‘tarjanå°±å®Œäº†ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+50; int dfn[maxn],low[maxn],scccnt=0,sccindex=0,belong[maxn]; bool instack[maxn]; stack&lt;int&gt;sta; vector&lt;int&gt;G[maxn]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v); } } int outdegree[maxn],c[maxn]; int minn[maxn],size1[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i]); long long ans=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);outdegree[i]++; if(j==i)ans+=c[i]; } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) size1[belong[i]]++; memset(minn,0x3f,sizeof(minn)); for(i=1;i&lt;=n;i++){ if(size1[belong[i]]&lt;=1)continue; minn[belong[i]]=min(minn[belong[i]],c[i]); } for(i=1;i&lt;=n;i++){ if(minn[i]!=0x3f3f3f3f) ans+=minn[i]; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. é¢˜æ„å¤§æ¦‚æ˜¯æ„é€ ä¸€ä¸ªn* nçš„çŸ©é˜µï¼Œè¦æ±‚æ»¡è¶³ç›¸é‚»è¡Œä¸ç›¸é‚»åˆ—ä¹‹é—´è¦ä¹ˆå®Œå…¨ç›¸åŒï¼Œè¦ä¹ˆå®Œå…¨ç›¸åã€‚ä¸”ä¸å­˜åœ¨é¢ç§¯å¤§äºç­‰äºkçš„å­çŸ©é˜µé¢œè‰²å®Œå…¨ç›¸åŒã€‚ é¦–å…ˆå¯ä»¥å‘ç°ä¸€ä¸ªäº‹å®ï¼šä¸€æ—¦ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—ç¡®å®šäº†ï¼Œé‚£ä¹ˆæ•´ä¸ªå›¾çš„æŸ“è‰²æ–¹æ¡ˆä¹Ÿå°±ç¡®å®šäº†ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è®¾æ³•å»æ±‚ç¬¬ä¸€è¡Œçš„æŸ“è‰²æ–¹æ¡ˆï¼ˆç¬¬ä¸€åˆ—è·Ÿç¬¬ä¸€è¡Œæ˜¯ä¸€æ ·çš„ï¼‰ è¿™å¯ä»¥ç”¨dpæ¥æ±‚ #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 510; const int mod = 998244353; ll f[maxn][maxn][2];//ä½ç½®ï¼Œè¿ç»­æ•°é‡ï¼Œé¢œè‰²ï¼› ll num[maxn]; int main() { //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n, k,i,j,q; cin &gt;&gt; n &gt;&gt; k; for (q = 1; q &lt;= n; q++) { memset(f, 0, sizeof(f)); f[1][1][0] = f[1][1][1] = 1; for (i = 2; i &lt;= n; i++) {//ä½ç½® for (j = 1; j &lt;= min(i,q); j++) {//è¿ç»­æ•°é‡ f[i][1][1] += f[i - 1][j][0];//è¿ç»­é•¿åº¦ä¸º1,é‚£ä¹ˆå‰ä¸€ä¸ªä½ç½®çš„é¢œè‰²ä¸€å®šä¸è¿™ä¸ªä½ç½®ä¸åŒ f[i][1][0] += f[i - 1][j][1]; f[i][j][1] += f[i - 1][j - 1][1];//ä¸å‰ä¸€ä¸ªä½ç½®é¢œè‰²ç›¸åŒ f[i][j][0] += f[i - 1][j - 1][0]; f[i][1][0] %= mod; f[i][1][1] %= mod; f[i][j][0] %= mod; f[i][j][1] %= mod; } } for (i = 1; i &lt;= q; i++) { num[q] += f[n][i][0] + f[n][i][1]; num[q] %= mod; } } for (i = n; i &gt;= 2; i--) { num[i] = num[i] - num[i - 1] + mod;//å‡å»ä¸æ˜¯è¿™ä¸ªé•¿åº¦çš„ æ•°é‡ num[i] %= mod; } ll ans = 0; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { if (i*j &gt;= k)break;//å¦‚æœè¿™ä¸ªçŸ©å½¢çš„é¢ç§¯å¤§äºç­‰äºk ans += num[i] * num[j]; ans %= mod; } } if (ans % 2 == 1)ans = (ans + mod) / 2;//ç­”æ¡ˆæ˜¯è¦é™¤ä»¥2çš„(é‡å¤), // ä½†æ˜¯æ¨¡æ•°æ˜¯å¥‡æ•°ä¸”ä¹‹å‰å¤šæ¬¡å–æ¨¡,å› æ­¤å¦‚æœç­”æ¡ˆæ˜¯å¥‡æ•°,åº”è¯¥å˜æˆå¶æ•°å†é™¤ä»¥2 else ans /= 2; cout &lt;&lt; ans &lt;&lt; endl; return 0; } F. æœ‰nä¸ªè€ƒè¯•ï¼Œæ¯ä¸ªè€ƒè¯•æœ‰ä¸¤ä¸ªå¯ä»¥é€šè¿‡çš„æ—¥æœŸï¼Œæ¯å¤©åªèƒ½é€šè¿‡ä¸€ä¸ªè€ƒè¯•ï¼Œé—®å¦‚ä½•å®‰æ’å¯ä»¥å°½æ—©å®Œæˆæ‰€æœ‰è€ƒè¯•ã€‚ æš´åŠ›äºŒåˆ†ç½‘ç»œæµæ˜¯æ²¡é”™çš„ï¼Œä½†æ˜¯ä¼štã€‚ä½†æ˜¯å¯ä»¥ä»ä¸­å¾—åˆ°å¯å‘ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ¯ä¸ªè€ƒè¯•çš„ä¸¤å¤©ï¼Œå…ˆé€‰æ‹©é‚£ä¸ªæ¯”è¾ƒå°çš„å¤©ï¼Œç„¶åä»æ¯”è¾ƒå°çš„å¤©å‘æ¯”è¾ƒå¤§çš„å¤©è¿ä¸€æ¡è¾¹ï¼Œè¡¨ç¤ºé€‰æ‹©çš„è¿™ä¸€å¤©ä¹Ÿå¯ä»¥æ¢æˆæ¯”è¾ƒå¤§çš„é‚£ä¸€å¤©ã€‚å¦‚æœæŸä¸ªè€ƒè¯•å³ä½¿è½¬ç§»äº†ä»¥åä¹Ÿæ²¡æ³•å®Œæˆçš„è¯ï¼Œå°±æ˜¯æ²¡æœ‰å¯è¡Œè§£äº†ã€‚ä»£ç ä¸­åˆ©ç”¨äº†ç±»ä¼¼å¹¶æŸ¥é›†çš„æ–¹å¼æ¥ç»´æŠ¤è½¬ç§»ï¼› #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+50; struct e{ int x,y; }G[maxn]; bool cmp1(e a,e b) { return a.x&lt;b.x; } bool cmp2(e a,e b) { return a.y&lt;b.y; } int anotherchoice[maxn*2]; int find(int x) { return x==anotherchoice[x]?x:anotherchoice[x]=find(anotherchoice[x]); } int main() { int cnt=0,i,j,k,n; cin&gt;&gt;n; int ys[maxn*2]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;G[i].x,&amp;G[i].y);ys[++cnt]=G[i].x;ys[++cnt]=G[i].y; } sort(ys+1,ys+1+cnt); cnt=unique(ys+1,ys+1+cnt)-ys;int pos; sort(G+1,G+n+1,cmp1);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].x==ys[i])G[pos++].x=i; sort(G+1,G+n+1,cmp2);pos=1; for(i=1;i&lt;=cnt;i++)while(pos&lt;=n&amp;&amp;G[pos].y==ys[i])G[pos++].y=i;//ç¦»æ•£åŒ–,åŒæ—¶ä¿è¯åŸå¤§å°å…³ç³»ä¸ä¼šæ”¹å˜ for(i=1;i&lt;=cnt;i++)anotherchoice[i]=i;//å¼€å§‹çš„æ—¶å€™æ¯ä¸ªæ—¥æœŸçš„é€‰æ‹©éƒ½åªæœ‰è‡ªå·± int ans=0; for(i=1;i&lt;=n;i++){ int ch1,ch2; ch1=find(G[i].x);ch2=find(G[i].y); if(!ch1&amp;&amp;!ch2){//å¦‚æœè¿™ä¸ªè€ƒè¯•çš„ä¸¤ä¸ªæ—¥æœŸéƒ½æ²¡æœ‰é€‰æ‹©äº†,é‚£ä¹ˆæ˜¾ç„¶æ— æ³•å®Œæˆ puts(&quot;-1&quot;);return 0; } else if(ch1==ch2||!ch1||!ch2){//å¦‚æœè¿™ä¸ªè€ƒè¯•åªæœ‰ä¸€ä¸ªå¯ç”¨çš„æ—¥æœŸ,é‚£ä¹ˆæ˜¾ç„¶åªèƒ½å”¯ä¸€é€‰æ‹© ans=max(ans,max(ch1,ch2));anotherchoice[ch1]=anotherchoice[ch2]=0; } else{//è€ƒè¯•æœ‰ä¸¤ä¸ªé€‰æ‹©,é‚£ä¹ˆå…ˆé€‰é‚£ä¸ªæ—¥æœŸæ¯”è¾ƒå°çš„,åŒæ—¶æ ‡è®°ä¸€ä¸‹æ—¥æœŸæ¯”è¾ƒå°çš„é‚£é¢˜è¿˜æœ‰ä¸€ä¸ªæ—¥æœŸæ¯”è¾ƒå¤§çš„é€‰æ‹© ans=max(ans,min(ch1,ch2));anotherchoice[min(ch1,ch2)]=max(ch1,ch2); } } cout&lt;&lt;ys[ans]&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰å¿«é€Ÿè¯»å…¥]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e8-af-bb-e5-85-a5%2F</url>
    <content type="text"><![CDATA[ä¸scanfï¼Œcinå†²çªï¼ˆè¾“å‡ºæ²¡é—®é¢˜ï¼‰ï¼Œå¯è¿”å›EOFã€‚ const int BufferSize=1&lt;&lt;16; char buffer[BufferSize],*fronthead,*fronttail; inline char GET_CHAR(){ if(fronthead==fronttail){ int l=fread(buffer,1,BufferSize,stdin); fronttail=(fronthead=buffer)+l; if(fronthead==fronttail)return EOF; } return *fronthead++; } inline int READ(){ int x=0,f=1;char c=GET_CHAR(); for(;!isdigit(c);c=GET_CHAR()){ if(c==EOF)return EOF; if(c==&apos;-&apos;)f=-1; } for(;isdigit(c);c=GET_CHAR())x=(((x&lt;&lt;2)+x)&lt;&lt;1)+c-&apos;0&apos;; return x*f; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #5]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-5%2F</url>
    <content type="text"><![CDATA[A.Gym - 101606L Lizard Loungeå…¶å®å°±æ˜¯ç®—å‡ºå„ä¸ªç‚¹ä½äºå“ªæ¡ç›´çº¿ä¸Šï¼Œç„¶åå¯¹æ¯æ¡ç›´çº¿ç®—ç®—LISçš„é—®é¢˜â€¦ï¼ˆå°±æ˜¯æŠŠåŒä¸€æ¡ç›´çº¿ä¸Šçš„èœ¥èœ´ä¸¢åˆ°ä¸€èµ·ã€‚æˆ‘ä»¬ç”¨æ–œç‡æ¥åˆ¤æ–­ä»–ä»¬æ˜¯ä¸æ˜¯åœ¨åŒä¸€æ¡ç›´çº¿ä¸Šã€‚ä¹‹åè¦æŠŠä»–ä»¬æŒ‰ç…§åœ¨æˆ¿é—´é‡Œçš„æ¬¡åºæ¥æ’åºï¼Œä¹Ÿå°±æ˜¯æŒ‰åˆ°æ˜¾ç¤ºå™¨çš„è·ç¦»æ¥æ’åºã€‚ï¼‰ä½†æ˜¯å†™èµ·æ¥æœ‰å‘ï¼Œé¦–å…ˆæ–œç‡ç›¸åŒçš„ç‚¹å¯èƒ½åœ¨txï¼Œtyçš„ä¸¤ä¾§ï¼Œä»–ä»¬æ˜¯äº’ä¸å½±å“çš„ã€‚å…¶æ¬¡ï¼Œç›´æ¥ç®—æ–œç‡ä¼šæœ‰ç²¾åº¦é—®é¢˜ã€‚æœ€åï¼Œç®—å®Œæ–œç‡ä»¥åç‚¹çš„æ’åºä¹Ÿè¦æ³¨æ„ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;P; const int maxn=1e6+10; map&lt;P,int&gt; mp1; vector&lt;P&gt;G[maxn]; int cnt=0; int gcd(int a,int b) { return b?gcd(b,a%b):a; } ll lenth(int x,int y) { return (ll)x*x+(ll)y*y; } void sit(int x, int y, int h) { ll d = lenth(x, y); if (x == 0) y /= abs(y); else if (y == 0) x /= abs(x); else { int z = gcd(abs(x), abs(y)); x /= z, y /= z; } if (mp1.count(P(x, y)) == 0) mp1[P(x, y)] = ++cnt; G[mp1[P(x, y)]].push_back(P(d, h)); } int main() { int tx, ty, n, i, j, k, x, y, h; cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; n; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;h); x -= tx;y -= ty; sit(x, y, h); } int ans = 0; int f[maxn], a[maxn]; for (i = 1; i &lt;= cnt; i++) { sort(G[i].begin(), G[i].end()); int len = G[i].size(); for (j = 0; j &lt; len; j++) a[j] = G[i][j].second, f[j + 1] = 1 &lt;&lt; 30; for (j = 0; j &lt; len; j++) { *lower_bound(f + 1, f + 1 + len, a[j]) = a[j]; } ans += lower_bound(f + 1, f + 1 + len, 1 &lt;&lt; 30) - f - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } B.CodeForces - 977Då¦‚æœä¸€ä¸ªæ•°æ˜¯å¦ä¸€ä¸ªæ•°çš„ä¸¤å€ï¼Œæˆ–è€…æ˜¯å¦ä¸€ä¸ªæ•°é™¤ä»¥3çš„ç»“æœï¼Œé‚£ä¹ˆå°±å¯ä»¥ä»é‚£ä¸ªæ•°å¼•ä¸€æ¡è¾¹æŒ‡å‘è¿™ä¸ªæ•°ï¼Œå°†é—®é¢˜è½¬ä¸ºä¸€ä¸ªæœ‰å‘å›¾æ‹“æ‰‘æ’åºçš„é—®é¢˜å³å¯è§£å†³äº†ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { vector&lt;int&gt;G[105];int indegree[105]={0}; int n,i,j,k; cin&gt;&gt;n; ll num[105]; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;num[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ if(i==j)continue; if(num[j]==num[i]*2||(num[i]%3==0&amp;&amp;num[j]==num[i]/3)){ G[i].push_back(j);indegree[j]++; } } queue&lt;int&gt;que; for(i=1;i&lt;=n;i++)if(indegree[i]==0)que.push(i); int cnt=0; while(!que.empty()){ i=que.front();que.pop(); cout &lt;&lt; num[i] &lt;&lt; &apos; &apos;; for (j = 0; j &lt; G[i].size(); j++) { k = G[i][j]; indegree[k]--; if(!indegree[k])que.push(k); } } return 0; } D.CodeForces - 959Dé¦–å…ˆï¼Œä¸ç®¡bä¸­çš„æ•°å­—æ€ä¹ˆæ”¾ï¼Œè¦ä½¿å¾—bä¸­çš„æ•°ä¸¤ä¸¤äº’è´¨ï¼Œé‚£ä¹ˆæ¯æ¬¡å¾€bé‡Œé¢ä¸¢ä¸€ä¸ªæ•°ï¼Œè¿™ä¸ªæ•°çš„çº¦æ•°çš„æ‰€æœ‰å€æ•°éƒ½å¿…é¡»ä»å¯é€‰é›†é‡Œæ»šè›‹ã€‚å› ä¸ºbçš„å­—å…¸åºå¿…é¡»å¤§äºaä¸”æœ€å°ï¼Œæ‰€ä»¥å¦‚æœæœ‰ä¸€ä¸ªä½ç½®bæ¯”aå¤§ï¼Œé‚£ä¹ˆåé¢çš„ä½ç½®ä¸­å°½é‡æ”¾æœ€å°çš„å¯æ”¾çš„æ•°å³å¯ã€‚åŸºäºè¿™ç§è€ƒè™‘ï¼Œæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ç±»ä¼¼åŸƒæ°ç­›çš„æ–¹æ³•é¢„å¤„ç†å‡ºæ‰€æœ‰æ•°çš„çº¦æ•°ï¼Œç„¶åæ¯æ¬¡å…ˆæŸ¥æ‰¾å¤§äºç­‰äºaçš„å­—å…¸åºæœ€å°çš„å¯é€‰æ•°ï¼Œç„¶åæŠŠè¿™ä¸ªæ•°çš„æ‰€æ¬²çº¦æ•°çš„å€æ•°å¹²æ‰ã€‚å¦‚æœè¿™ä¸ªæ•°&gt;a,é‚£ä¹ˆGGï¼Œåé¢åªè¦æ”¾æœ€å°çš„å¯æ”¾çš„æ•°å³å¯ #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e6+5; bool isnot[N],erase1[N]; set&lt;int&gt;s; vector&lt;int&gt;G[N]; void getys(void) { for(int i=2;i&lt;N;i++){ //if(isnot[i])continue; if(!isnot[i]) { for (int j = i; j &lt; N; j += i) { isnot[j] = true; G[j].push_back(i); } } s.insert(i); } } int main() { int n,i,j,k; cin&gt;&gt;n; getys();bool islarge=false; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d&quot;,&amp;a);b=*s.begin(); if(!islarge) { b = *s.lower_bound(a); if(b!=a)islarge=true; } cout&lt;&lt;b&lt;&lt;&apos; &apos;; for(int j:G[b]){ if(erase1[j])continue; for(k=j;k&lt;N;k+=j){ if(!erase1[k]){ s.erase(k);erase1[k]=true; } } } } return 0; } E.CodeForces - 931Bç­¾åˆ° #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,a,b,cnt,i,j; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(i=0;;i++){ if(!(n&gt;&gt;i))break; } cnt=i-1;int cnt1=0; while(a!=b){ a=(a+1)&gt;&gt;1;b=(b+1)&gt;&gt;1;cnt1++; } if(cnt1==cnt)cout&lt;&lt;&quot;Final!&quot;&lt;&lt;endl; else cout&lt;&lt;cnt1&lt;&lt;endl; return 0; } F.CodeForces - 731Fä¸€ä¸ªå‰ç¼€å’Œsum[i]è®°å½•å°äºç­‰äºIçš„ä¸ªæ•°ï¼Œå°†åºåˆ—æ’åºï¼Œå»é‡ã€‚æšä¸¾æ¯ä¸€ä¸ªæ•°ä¸ºâ€œåŸºæ•°â€ï¼Œåˆ¤æ–­ä»–[nå€â€”-(n+1) )å€ï¼ˆå·¦é—­å³å¼€ï¼Œnä»1å¼€å§‹ï¼‰ä¹‹é—´æ•°çš„ä¸ªæ•°ï¼Œè¿™äº›æ•°æ˜¯è¦å˜æˆn* åŸºæ•°çš„ã€‚è®°å½•å’Œï¼Œè®°å½•æœ€å¤§å€¼ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sum[200005],a[200005]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum[a[i]]++; } sort(a+1,a+1+n); int cnt=unique(a+1,a+1+n)-a-1; for(i=1;i&lt;=200000;i++) sum[i]+=sum[i-1];//è®°å¾—å˜æˆå‰ç¼€å’Œ ll ans=0; for(i=1;i&lt;=cnt;i++){ ll val=0; for(j=1;a[i]*j&lt;=200000;j++){ int t1=a[i]*j,t2=a[i]*(j+1)&gt;200000?200000:a[i]*(j+1)-1;//æ³¨æ„åŒºé—´çš„é—®é¢˜ int tot=sum[t2]-sum[t1-1]; val+=(ll)tot*t1; } ans=max(ans,val); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } G.CodeForces - 570Dé¢˜ç›®çš„æœ´ç´ å†™æ³•è¿˜æ˜¯å¾ˆå¥½å†™çš„â€¦ä½†æ˜¯æ•°æ®è§„æ¨¡è¿‡å¤§å¯¼è‡´å¿…tæ— ç–‘â€¦ äºæ˜¯æˆ‘ä»¬æƒ³åˆ°äº†ç¦»çº¿å¤„ç†ï¼Œä¸€æ¬¡dfsâ€¦ ä½†æ˜¯ä¾ç„¶ä¸å¥½åšï¼Œè¿™é‡Œæˆ‘ä»¬å¤„ç†çš„åšæ³•æ˜¯åˆ©ç”¨å¼‚æˆ–â€¦æ¯æ¬¡æœç´¢åˆ°ä¸€ä¸ªç‚¹çš„æ—¶å€™å…ˆæŠŠå„ä¸ªç­”æ¡ˆè¦é—®çš„æ·±åº¦çš„å­—æ¯æƒ…å†µç»™ä¿å­˜èµ·æ¥ï¼Œç„¶åæœç´¢è¿™ä¸ªèŠ‚ç‚¹ä¸‹é¢å­æ ‘å„ä¸ªæ·±åº¦çš„å­—æ¯æƒ…å†µï¼Œæœ€åå†ç»™æ¯ä¸ªç­”æ¡ˆå¼‚æˆ–ä¸€ä¸‹ï¼Œå°±å¯ä»¥å¾—å‡ºè¿™ä¸ªèŠ‚ç‚¹ä¸‹é¢çš„æƒ…å†µâ€¦.emm,æ„Ÿè§‰ä¸å¤ªå¥½æè¿°ï¼Œæ€»ä¹‹è¿˜æ˜¯æŒºå·§å¦™çš„â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500005; char node[maxn]; vector&lt;int&gt;G[maxn],query[maxn]; int dep[maxn],ans[maxn],tardep[maxn]; void dfs(int x,int depth) { for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//é¦–å…ˆå…ˆæŠŠè¿™ä¸ªæ·±åº¦çš„å­—æ¯ä¸ªæ•°æƒ…å†µä¿å­˜èµ·æ¥ for (auto b:G[x]) dfs(b, depth + 1);//ç„¶åç»Ÿè®¡åœ¨å½“å‰èŠ‚ç‚¹ä¸‹å„ä¸ªæ·±åº¦çš„å­—æ¯æƒ…å†µ,å¹¶æ›´æ–°depæ•°ç»„ dep[depth] ^= (1 &lt;&lt; (int) (node[x] - &apos;a&apos;)); for (auto a:query[x]) ans[a] ^= dep[tardep[a]];//æ–°çš„depæ•°ç»„å¼‚æˆ–æ—§çš„depæ•°ç»„,å°±å¯ä»¥å¾—å‡ºå½“å‰èŠ‚ç‚¹çš„å­æ ‘ä¸­å„ä¸ªæ·±åº¦çš„å­—æ¯æƒ…å†µ } bool check(int x) { int cnt=0; while(x){ cnt++;x-=x&amp;-x; } if(cnt&gt;1)return false; return true; } int main() { int n, m,i,j; cin&gt;&gt;n&gt;&gt;m; for (i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); G[j].push_back(i);//ä¿å­˜æ ‘ } scanf(&quot;%s&quot;, node + 1); for (i = 1; i &lt;= m; i++) { int v,h; scanf(&quot;%d%d&quot;, &amp;v, &amp;h); query[v].push_back(i);//ç¦»çº¿å¤„ç†é—®è¯¢ tardep[i] = h;//ä¿å­˜é—®è¯¢æ·±åº¦ } dfs(1, 1); for (i = 1; i &lt;= m; i++) { if(!check(ans[i]))//å¦‚æœansçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ‰è¶…è¿‡ä¸€ä¸ªä½ç½®æ˜¯1 printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training #4]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-bupt-summer-training-4%2F</url>
    <content type="text"><![CDATA[A.CodeForces 791Dé¦–å…ˆï¼Œå…ˆè€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•è®¡ç®—ä¸€æ£µæ ‘ä¸­æ‰€æœ‰ç‚¹å¯¹ä¹‹é—´çš„è·ç¦»å’Œã€‚å¯¹äºä»»æ„ä¸€ä¸ªç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå¦‚æœè¿™ä¸ªç‚¹çš„å­æ ‘çš„å¤§å°ä¸º$s$çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹ä¸å…¶ç¥–å…ˆä¹‹é—´çš„é‚£æ¡è¾¹åœ¨è®¡ç®—æ€»å’Œçš„è¿‡ç¨‹ä¸­ä¸€å®šä¼šè¢«è®¡ç®—$(n-s)\times s$æ¬¡ï¼ˆnä¸ºæ€»çš„èŠ‚ç‚¹æ•°ï¼‰ã€‚ä½†æ˜¯ç›®å‰æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æ¯æ¬¡åªèƒ½èµ°kæ­¥ï¼Œæ¯”å¦‚è¯´k=4ï¼Œè€Œè·ç¦»ä¸º10ï¼Œé‚£å°±éœ€è¦3æ­¥ï¼Œæ­¤æ—¶å¦‚æœç›´æ¥æ±‚å‡ºæ€»çš„è·ç¦»ä¹‹å’Œå»é™¤ä»¥kï¼Œç­”æ¡ˆè‚¯å®šæ˜¯é”™è¯¯çš„ã€‚å› æ­¤æˆ‘ä»¬åœ¨dfsåˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œè¿˜è¦è®¡ç®—ä»–çš„å„ä¸ªå­èŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œç„¶åæŠŠæ‰€æœ‰mod kæœ‰ä½™æ•°çš„è·ç¦»ä¸kçš„å€æ•°çš„å·®å€¼éƒ½ç»™è¡¥ä¸Šã€‚æœ€åè·ç¦»æ€»å’Œé™¤ä»¥kå³å¯ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5 + 50; ll n,k,ans=0,size[maxn][5],cntsub[maxn];//sizeä»£è¡¨èŠ‚ç‚¹xçš„è·ç¦»å®ƒçš„è·ç¦»ä¸ºiçš„å­èŠ‚ç‚¹çš„ä¸ªæ•°,cntåˆ™ä¸ºèŠ‚ç‚¹æƒ³çš„å­æ ‘ä¸ªæ•°å’Œ vector&lt;int&gt;G[maxn]; void dfs(ll x,ll fa,ll sit)//xä¸ºèŠ‚ç‚¹ID,faä¸ºèŠ‚ç‚¹ç¥–å…ˆ,sitä¸ºå½“å‰èŠ‚ç‚¹åˆ°é¡¶ç‚¹çš„è·ç¦»mod k { cntsub[x] = size[x][sit % k] = 1; ll i, j; for (auto a : G[x]) { if (a == fa)continue; dfs(a, x, sit + 1); for (i = 0; i &lt; k; i++) {//æšä¸¾åˆ°å­èŠ‚ç‚¹çš„è·ç¦» for (j = 0; j &lt; k; j++) { ll t = (k - (i + j - 2 * (sit % k)) % k) % k; ans += t * size[x][i] * size[a][j]; } } for (i = 0; i &lt; k; i++)size[x][i] += size[a][i]; cntsub[x] += cntsub[a]; } ans += cntsub[x] * (n - cntsub[x]);//xä¸ç¥–å…ˆè¿è¾¹è¢«è®¡ç®—çš„æ¬¡æ•° } int main() { int i, j, u, v; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, 0, 0); cout &lt;&lt; ans / k &lt;&lt; endl; return 0; } B.CodeForces - 2Bæ±‚çŸ©é˜µè·¯å¾„ä¸Šæ•°å­—çš„ç§¯æœ«å°¾æœ€å°‘çš„0ä¸ªæ•°ã€‚é‚£ä¹ˆå…¶å®å°±æ˜¯ç»Ÿè®¡è·¯å¾„ä¸Šæœ€å°‘çš„2ä¸ªæ•°ä¸5ä¸ªæ•°ï¼Œå–å…¶ä¸­æ¯”è¾ƒå°çš„å³å¯ã€‚æœ‰ä¸ªé—®é¢˜å°±æ˜¯è·¯å¾„ä¸­å¦‚æœæœ‰0ï¼Œé‚£ä¹ˆå°±éœ€è¦ç‰¹åˆ¤ç­”æ¡ˆåˆ°åº•æ˜¯1è¿˜æ˜¯0äº†ã€‚è·¯å¾„è¾“å‡ºçš„æ—¶å€™ç¨å¾®è¦ç‚¹å°æŠ€å·§ï¼Œæ²¡äº†ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int get2(int x) { int cnt=0; while(x&amp;&amp;x%2==0){ cnt++;x/=2; } return cnt; } int get5(int x) { int cnt=0; while(x&amp;&amp;x%5==0){ cnt++;x/=5; } return cnt; } int num[1005][1005]; typedef pair&lt;int,char&gt;P; P dp2[1005][1005],dp5[1005][1005]; int main() { int i,j,k,n; cin&gt;&gt;n; memset(dp2,0x3f, sizeof(dp2));memset(dp5,0x3f,sizeof(dp5)); int move1[2][2]={1,0,0,1}; bool haszero=false;int zerox,zeroy; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) { scanf(&quot;%d&quot;, &amp;num[i][j]); if(!num[i][j]){ haszero=true;zerox=i,zeroy=j; } } if(num[1][1]) { dp2[1][1].first = get2(num[1][1]), dp5[1][1].first = get5(num[1][1]); } else{ dp2[1][1].first=dp5[1][1].first=1; } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ //if(i==1&amp;&amp;j==1)continue; for(k=0;k&lt;2;k++){ int a=i+move1[k][0],b=j+move1[k][1]; if(num[a][b]==0){ dp2[a][b].first=0;dp5[a][b].first=0; } else { if (dp2[a][b].first &gt; dp2[i][j].first + get2(num[a][b])) { dp2[a][b].first = dp2[i][j].first + get2(num[a][b]); if (k)dp2[a][b].second = &apos;R&apos;; else dp2[a][b].second = &apos;D&apos;; } if (dp5[a][b].first &gt; dp5[i][j].first + get5(num[a][b])) { dp5[a][b].first = dp5[i][j].first + get5(num[a][b]); if (k)dp5[a][b].second = &apos;R&apos;; else dp5[a][b].second = &apos;D&apos;; } } } } int ans=1&lt;&lt;30; int sit=0; //cout&lt;&lt;dp2[n][n].first&lt;&lt;&apos; &apos;&lt;&lt;dp5[n][n].first&lt;&lt;endl; if(haszero&amp;&amp;dp2[n][n].first&gt;1&amp;&amp;dp5[n][n].first&gt;1){ ans=1;sit=1; } else{ if(dp2[n][n].first&gt;dp5[n][n].first){ ans=dp5[n][n].first;sit=3; } else{ ans=dp2[n][n].first;sit=2; } } cout&lt;&lt;ans&lt;&lt;endl; vector&lt;char&gt;way; if(sit==1){ for(i=1;i&lt;zerox;i++)way.push_back(&apos;D&apos;); for(j=1;j&lt;n;j++)way.push_back(&apos;R&apos;); for(i=zerox;i&lt;n;i++)way.push_back(&apos;D&apos;); } else if(sit==2){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp2[i][j].second); if(dp2[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } else if(sit==3){ i=j=n; while(1){ if(i==1&amp;&amp;j==1)break; way.push_back(dp5[i][j].second); if(dp5[i][j].second==&apos;R&apos;)j--; else i--; } reverse(way.begin(),way.end()); } for(auto a:way) cout&lt;&lt;a; return 0; } C.CodeForces - 527Aç­¾åˆ° #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll ans=0; void cal(ll x,ll y) { if(!y)return; ans+=x/y;x%=y; cal(y,x); } int main() { ll a,b; cin&gt;&gt;a&gt;&gt;b; cal(a,b); cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.CodeForces - 785Bä¸»è¦è€ƒå¯Ÿè‹±è¯­é˜…è¯»ç†è§£èƒ½åŠ›ï¼Œæ³¨æ„å…ˆä¸Šå“ªä¸ªè¯¾ç¨‹æ˜¯ä¸ç¡®å®šçš„ã€‚å‚»é€¼é¢˜* 2 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,ans,i,j,a,b,amin=0,amax=1&lt;&lt;30,bmin=0,bmax=1&lt;&lt;30; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); amin = max(amin, a); amax = min(amax, b); } cin&gt;&gt;m; for(i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); bmin = max(bmin, a); bmax = min(bmax, b); } ans=max(amin-bmax,bmin-amax); cout&lt;&lt;(ans&gt;=0?ans:0)&lt;&lt;endl; return 0; } F.CodeForces - 57Cé¦–å…ˆï¼Œæ³¨æ„åˆ°ä¸€ç‚¹ï¼šæ¯ä¸€ä¸ªä¸ä¸‹é™æ•°åˆ—åè¿‡æ¥å°±æ˜¯ä¸€ä¸ªä¸ä¸Šå‡æ•°åˆ—ï¼Œå› æ­¤æˆ‘ä»¬åªè¦è®¡ç®—å‡ºä¸ä¸‹é™æ•°åˆ—çš„ä¸ªæ•°ï¼Œä¹˜2ï¼Œå‡å»nï¼ˆæ‰€æœ‰æ•°å­—ç›¸åŒçš„æ•°åˆ—ä¸ªæ•°ï¼‰ï¼Œå°±æ˜¯ç­”æ¡ˆäº†ã€‚ ç„¶åï¼Œç¬¬ä¸€ä½è‚¯å®šæ˜¯è¦æ”¾ä¸€ä¸ªæ•°çš„ï¼Œæˆ‘ä»¬å§‘ä¸”ä¸ç®¡ã€‚é‚£ä¹ˆåœ¨åé¢çš„n-1ä¸ªä½ç½®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„å–è‹¥å¹²ä¸ªâ€œä¸Šå‡ç‚¹â€ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªç‚¹æ”¾çš„æ•°æ¯”å‰é¢çš„æ•°è¦æ¥çš„å¤§ï¼Œç›¸é‚»â€œä¸Šå‡ç‚¹â€ä¹‹é—´çš„æ•°å­—çš„å€¼æ˜¯ç›¸åŒçš„ã€‚åœ¨n-1ä¸ªä½ç½®ä¸­é€‰kä¸ªä¸Šå‡ç‚¹ï¼Œæ–¹æ¡ˆæ•°æ˜¯$C_{n-1}^{k}$,ç„¶åï¼Œé€‰å®škä¸ªä¸Šå‡ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¿™ä¸ªæ•°åˆ—ä¸­å°±éœ€è¦k+1ä¸ªä¸åŒçš„æ•°ï¼ˆè¿˜è®°å¾—ç¬¬ä¸€ä½ä¹ˆï¼Ÿï¼‰ï¼Œä¼šå‘ç°ï¼Œä»»æ„é€‰æ‹©1~nä¸­çš„k+1ä¸ªæ•°ï¼Œä»–éƒ½å¯¹åº”ç€å”¯ä¸€çš„ä¸€ç§æ’åˆ—æ–¹æ¡ˆï¼Œæ‰€ä»¥ï¼Œæ€»çš„ç­”æ¡ˆå°±æ˜¯$\sum_{i=0}^{n-1}C_{n-1}^{i}\times C_n^{i+1}$,ç®—ç®—ç»„åˆæ•°ç®—ç®—é€†å…ƒå°±okäº†ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; const int maxn=1e5+10; ll c1[maxn],inv[maxn],jc[maxn],c2[maxn]; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int i,j,k,n; cin&gt;&gt;n; jc[1]=1;inv[1]=1,inv[0]=1; for(i=2;i&lt;=n;i++) jc[i]=jc[i-1]*i%mod,inv[i]=pow(jc[i],mod-2,mod); for(i=1;i&lt;=n;i++) { c1[i] = (jc[n - 1] * inv[i] % mod * inv[n - 1 - i]) % mod; c2[i] = (jc[n] * inv[i] % mod * inv[n - i]) % mod; } c1[0]=1;c2[0]=1; ll ans=0; for(i=0;i&lt;n;i++) ans=(ans+c1[i]*c2[i+1])%mod; ans=(ans+ans-n)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } I.HackerRank - game-with-cellså‚»é€¼é¢˜* 3 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; if(n&amp;1)n=n/2+1; else n&gt;&gt;=1; if(m&amp;1)m=m/2+1; else m&gt;&gt;=1; cout&lt;&lt;n*m&lt;&lt;endl; return 0; } J.CodeForces - 145C ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸ºnçš„åºåˆ—aiï¼Œé—®å…¶é•¿åº¦ä¸ºkçš„å­åºåˆ—ä¸­ï¼ŒåŒä¸€ä¸ªå¹¸è¿æ•°å­—è‡³å¤šå‡ºç°ä¸€æ¬¡çš„å­åºåˆ—ä¸ªæ•°ï¼Œå¹¸è¿æ•°å­—å³ä¸ºå…¨éƒ¨ç”±4å’Œ7ç»„æˆçš„æ•°å­— å‡è®¾æœ‰$res$ä¸ªä¸åŒçš„å¹¸è¿æ•°å­—ï¼Œæœ‰$sum$ä¸ªéå¹¸è¿æ•°å­—ï¼Œç¬¬$i$ä¸ªå¹¸è¿æ•°å­—åœ¨åŸåºåˆ—ä¸­å‡ºç°äº†$num[i]$æ¬¡ï¼Œç”¨$dp[i][j]$è¡¨ç¤ºä»å‰$i$ä¸ªå¹¸è¿æ•°å­—ä¸­é€‰$j$ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆæ˜“å¾—è½¬ç§»æ–¹ç¨‹$dp[i][j]=dp[iâˆ’1][j]+num[i]â‹…dp[iâˆ’1][jâˆ’1]$ï¼Œä¹‹åæšä¸¾å­åºåˆ—ä¸­éå¹¸è¿æ•°å­—ä¸ªæ•°å³å¯å¾—åˆ°ç­”æ¡ˆ$ans=\sum_{i=0}^{min(k,sum)}C_{sum}^{i}\times dp[res][k-i]$ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+10; const int mod=1e9+7; ll fac[maxn],dp[3000][3000]; bool islucky(int v)//åˆ¤æ–­æ˜¯å¦lucky number { while (v) { if (v % 10 != 4 &amp;&amp; v % 10 != 7) return false; v /= 10; } return true; } ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } ll C(ll v, ll u) { if (v &lt; u) return 0; ll x = (fac[u] * fac[v - u]) % mod; return (fac[v] * pow(x, mod - 2,mod)) % mod; } int main() { int i, j, n, k,sum=0;ll ans=0; cin&gt;&gt;n&gt;&gt;k; map&lt;int,int&gt;mp1; fac[0] = 1; for (i = 1; i &lt;= n; i++) fac[i] = (fac[i - 1] * i) % mod; for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); if (islucky(j)) mp1[j]++;//ç»Ÿè®¡å¹¸è¿æ•°ä¸ªæ•° else sum++; } dp[0][0] = 1;i = 1; for (auto it = mp1.begin(); it != mp1.end(); it++, i++) for (j = 0; j &lt; i; j++) { dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod; dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j] * it-&gt;second) % mod; } int cnt = mp1.size(); for (i = 0; i &lt;= cnt &amp;&amp; i &lt;= k; i++) ans = (ans + (dp[cnt][i] * C(sum, k - i)) % mod) % mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } K.CodeForces - 691Béš¾ç‚¹åœ¨äºå¦‚ä½•æ‰¾å‡ºæ‰€æœ‰å¯¹ç§°çš„å­—ç¬¦ï¼Œå‚»é€¼é¢˜* 4 #include&lt;bits/stdc++.h&gt; using namespace std; bool check(char x, char y) { if (x == &apos;A&apos; &amp;&amp; y == &apos;A&apos;||x == &apos;H&apos; &amp;&amp; y == &apos;H&apos;||x == &apos;I&apos; &amp;&amp; y == &apos;I&apos;||x == &apos;M&apos; &amp;&amp; y == &apos;M&apos;||x == &apos;O&apos; &amp;&amp; y == &apos;O&apos;) return true; if (x == &apos;T&apos; &amp;&amp; y == &apos;T&apos;||x == &apos;U&apos; &amp;&amp; y == &apos;U&apos;||x == &apos;V&apos; &amp;&amp; y == &apos;V&apos;||x == &apos;W&apos; &amp;&amp; y == &apos;W&apos;||x == &apos;X&apos; &amp;&amp; y == &apos;X&apos;) return true; if (x == &apos;Y&apos; &amp;&amp; y == &apos;Y&apos;||x == &apos;v&apos; &amp;&amp; y == &apos;v&apos;||x == &apos;w&apos; &amp;&amp; y == &apos;w&apos;||x == &apos;x&apos; &amp;&amp; y == &apos;x&apos;||x == &apos;o&apos; &amp;&amp; y == &apos;o&apos;) return true; if (x == &apos;p&apos; &amp;&amp; y == &apos;q&apos;||x == &apos;q&apos; &amp;&amp; y == &apos;p&apos;||x == &apos;b&apos; &amp;&amp; y == &apos;d&apos;||x==&apos;d&apos;&amp;&amp;y==&apos;b&apos;) return true; return false; } int main() { string str1,str2; cin&gt;&gt;str1;str2=str1; reverse(str2.begin(),str2.end()); for(int i=0;i&lt;str1.size();i++){ if(!check(str1[i],str2[i])){ cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰Tarjan]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2FTarjan%2Fe6-a8-a1-e6-9d-bf-ef-bc-89tarjan%2F</url>
    <content type="text"><![CDATA[è¦æ³¨æ„çš„å°±æ˜¯é‚£äº›å•ç‹¬çš„ç‚¹æ¯ä¸ªç‚¹éƒ½ä¼šè¢«å½“åšè‡ªèº«ä¸€ä¸ªå¼ºè”é€šåˆ†é‡ï¼Œä¹Ÿå°±æ˜¯æœ‰ä¸å°‘çš„å¼ºè¿é€šåˆ†é‡é‡Œé¢å¯èƒ½åªæœ‰ä¸€ä¸ªå…ƒç´ â€¦â€¦ int dfn[105],low[105],scccnt=0,sccindex=0,belong[105]; bool instack[105]; stack&lt;int&gt;sta; vector&lt;int&gt;G[105]; void tarjan(int v) { dfn[v]=low[v]=++sccindex; sta.push(v);instack[v]=true;int j; for(auto i=G[v].begin();i!=G[v].end();i++){ int j=*i;//ç†è®ºä¸Šç”¨c++11çš„ç‰¹æ€§ä¼šæ¯”G[v].size()å¿«ä¸€äº›; if(!dfn[j]){ tarjan(j); low[v]=min(low[v],low[j]); } else if(instack[j]&amp;&amp;dfn[j]&lt;low[v]) low[v]=dfn[j]; } if(low[v]==dfn[v]){ scccnt++; do{ j=sta.top();instack[j]=false; sta.pop();belong[j]=scccnt; }while(j!=v);//ä¸€å®šè¦æ³¨æ„è¿™é‡Œå¹¶ä¸æ˜¯è¦æŠŠæ•´ä¸ªæ ˆæ¸…ç©º,åªæ˜¯è¦æŠŠå±äºå½“å‰è”é€šåˆ†é‡çš„å…ƒç´ å…¨éƒ¨æ¸…ç©º } } ä¸»å‡½æ•°ä¸­è°ƒç”¨ï¼š int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ while(cin&gt;&gt;j&amp;&amp;j) G[i].push_back(j); } for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ€å°è·¯å¾„è¦†ç›–]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b7-af-e5-be-84-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[å¯¹äºä¸€ä¸ªç»™å®šçš„æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œæ±‚å…¶æœ€å°è·¯å¾„è¦†ç›–ã€‚é¢˜ç›®å¯å‚è§æ´›è°·P2764ã€‚ ã€é—®é¢˜åˆ†æã€‘ æœ‰å‘æ— ç¯å›¾æœ€å°è·¯å¾„è¦†ç›–ï¼Œå¯ä»¥è½¬åŒ–æˆäºŒåˆ†å›¾æœ€å¤§åŒ¹é…é—®é¢˜ï¼Œä»è€Œç”¨æœ€å¤§æµè§£å†³ã€‚ ã€å»ºæ¨¡æ–¹æ³•ã€‘ æ„é€ äºŒåˆ†å›¾ï¼ŒæŠŠåŸå›¾æ¯ä¸ªé¡¶ç‚¹iæ‹†åˆ†æˆäºŒåˆ†å›¾Xï¼ŒYé›†åˆä¸­çš„ä¸¤ä¸ªé¡¶ç‚¹Xiå’ŒYiã€‚å¯¹äºåŸå›¾ä¸­å­˜åœ¨çš„æ¯æ¡è¾¹(i,j)ï¼Œåœ¨äºŒåˆ†å›¾ä¸­è¿æ¥è¾¹(Xi,Yj)ã€‚ç„¶åæŠŠäºŒåˆ†å›¾æœ€å¤§åŒ¹é…æ¨¡å‹è½¬åŒ–ä¸ºç½‘ç»œæµæ¨¡å‹ï¼Œæ±‚ç½‘ç»œæœ€å¤§æµã€‚ æœ€å°è·¯å¾„è¦†ç›–çš„æ¡æ•°ï¼Œå°±æ˜¯åŸå›¾é¡¶ç‚¹æ•°ï¼Œå‡å»äºŒåˆ†å›¾æœ€å¤§åŒ¹é…æ•°ã€‚æ²¿ç€åŒ¹é…è¾¹æŸ¥æ‰¾ï¼Œå°±æ˜¯ä¸€ä¸ªè·¯å¾„ä¸Šçš„ç‚¹ï¼Œè¾“å‡ºæ‰€æœ‰è·¯å¾„å³å¯ã€‚ ã€å»ºæ¨¡åˆ†æã€‘ å¯¹äºä¸€ä¸ªè·¯å¾„è¦†ç›–ï¼Œæœ‰å¦‚ä¸‹æ€§è´¨ï¼š 1ã€æ¯ä¸ªé¡¶ç‚¹å±äºä¸”åªå±äºä¸€ä¸ªè·¯å¾„ã€‚ 2ã€è·¯å¾„ä¸Šé™¤ç»ˆç‚¹å¤–ï¼Œä»æ¯ä¸ªé¡¶ç‚¹å‡ºå‘åªæœ‰ä¸€æ¡è¾¹æŒ‡å‘è·¯å¾„ä¸Šçš„å¦ä¸€é¡¶ç‚¹ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªé¡¶ç‚¹ç†è§£æˆä¸¤ä¸ªé¡¶ç‚¹ï¼Œä¸€ä¸ªæ˜¯å‡ºå‘ï¼Œä¸€ä¸ªæ˜¯ç›®æ ‡ï¼Œå»ºç«‹äºŒåˆ†å›¾æ¨¡å‹ã€‚è¯¥äºŒåˆ†å›¾çš„ä»»ä½•ä¸€ä¸ªåŒ¹é…æ–¹æ¡ˆï¼Œéƒ½å¯¹åº”äº†ä¸€ä¸ªè·¯å¾„è¦†ç›–æ–¹æ¡ˆã€‚å¦‚æœåŒ¹é…æ•°ä¸º0ï¼Œé‚£ä¹ˆæ˜¾ç„¶è·¯å¾„æ•°=é¡¶ç‚¹æ•°ã€‚æ¯å¢åŠ ä¸€æ¡åŒ¹é…è¾¹ï¼Œé‚£ä¹ˆè·¯å¾„è¦†ç›–æ•°å°±å‡å°‘ä¸€ä¸ªï¼Œæ‰€ä»¥è·¯å¾„æ•°=é¡¶ç‚¹æ•° - åŒ¹é…æ•°ã€‚è¦æƒ³ä½¿è·¯å¾„æ•°æœ€å°‘ï¼Œåˆ™åº”æœ€å¤§åŒ–åŒ¹é…æ•°ï¼Œæ‰€ä»¥è¦æ±‚äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…ã€‚æ³¨æ„ï¼Œæ­¤å»ºæ¨¡æ–¹æ³•æ±‚æœ€å°è·¯å¾„è¦†ç›–ä»…é€‚ç”¨äºæœ‰å‘æ— ç¯å›¾ï¼Œå¦‚æœæœ‰ç¯æˆ–æ˜¯æ— å‘å›¾ï¼Œé‚£ä¹ˆæœ‰å¯èƒ½æ±‚å‡ºçš„ä¸€äº›ç¯è¦†ç›–ï¼Œè€Œä¸æ˜¯è·¯å¾„è¦†ç›–ã€‚ æ´›è°·é¢˜ç›®å‚è€ƒä»£ç ï¼š // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; struct edge { int to, cap, rev; }; vector&lt;edge&gt;G[500]; int level[500], iter[500]; int n, m; void addedge(int from, int to, int cap) { edge e; e.to = to; e.cap = cap; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.rev = G[from].size() - 1;//ä¸€å®šè¦å°å¿ƒåå‘è¾¹çš„capä¸º0ï¼ï¼ï¼ G[to].push_back(e); } void bfs(int s) { memset(level, -1, sizeof(level));//æ¯æ¬¡bfsçš„æ—¶å€™æ„å›¾éƒ½ä¸åŒï¼Œè¦memset queue&lt;int&gt;que; level[s] = 0; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;level[e.to] &lt; 0) { level[e.to] = level[t] + 1; que.push(e.to); } } } } int dfs(int v, int t, int f) { if (v == t) return f; for (int &amp;i = iter[v]; i &lt; G[v].size(); i++) {//å› ä¸ºæ¯æ¬¡dfsçš„æ—¶å€™å¦‚æœæ‰¾åˆ°è§£å°±returnäº†ï¼Œæ‰€ä»¥æœ‰å¿…è¦è®°å½•ä¸Šæ¬¡è¿™ä¸ªç‚¹æœåˆ°å“ªäº† edge &amp;e = G[v][i]; if (e.cap&amp;&amp;level[e.to] &gt; level[v]) { int d = dfs(e.to, t, min(f, e.cap)); if (d) { e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } return 0; } int maxflow(int s, int t) { int flow = 0; for (;;) { bfs(s); if (level[t] &lt; 0)//è¯´æ˜æ­¤æ—¶å·²ç»ä¸å­˜åœ¨æ²¡æœ‰æœè¿‡çš„è·¯äº† return flow; memset(iter, 0, sizeof(iter)); int f; while (f = dfs(s, t, 1 &lt;&lt; 30))//è¦æœå®Œå½“æœŸçŠ¶å†µä¸‹çš„æ‰€æœ‰å¯èƒ½ flow += f; } } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m ; for (i = 1; i &lt;= m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); addedge(a, b+150, 1); } for (i = 1; i &lt;= n; i++) { addedge(0, i, 1); addedge(i+150, 400, 1); } int ans = n - maxflow(0, 400); bool vis[500]; memset(vis, 0, sizeof(vis)); for (i = 1; i &lt;= n; i++) { if (!vis[i]) { cout &lt;&lt; i; int k = i; for (;;) { bool find = false; for (j = 0; j &lt; G[k].size(); j++) { if (G[k][j].cap == 0&amp;&amp;G[k][j].to&gt;150) { cout &lt;&lt; &quot; &quot; &lt;&lt; G[k][j].to-150; k = G[k][j].to - 150; vis[k] = true; find = true; break; } } if (!find)break; } cout &lt;&lt; endl; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ€å°ç”Ÿæˆæ ‘]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[Kruskalæœ€é‡è¦çš„è¿˜æ˜¯è®°å¾—å¹¶æŸ¥é›†è¦åˆå§‹åŒ–ï¼ï¼ // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=1e6,M=1e6; int par[N]; struct edge{ int from,to,len; bool operator&lt;(const edge&amp;v)const{ return len&lt;v.len; } }G[M]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } bool unite(int x,int y) { x=find(x);y=find(y); if(x==y)return false; par[x]=y;return true; } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)par[i]=i; for(i=1;i&lt;=m;i++){ cin&gt;&gt;G[i].from&gt;&gt;G[i].to&gt;&gt;G[i].len; } sort(G+1,G+1+m); int cnt=0,ans=0; for(i=1;i&lt;=m;i++){ if(unite(G[i].from,G[i].to)) cnt++,ans+=G[i].len; if(cnt==n-1)break; } if(cnt&lt;n-1)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; return 0; } Primç®—æ³•è·ŸDijkstraå¾ˆåƒ ï¼Œä½†æ˜¯è¦ç‰¹åˆ«æ³¨æ„ä¸¤ç‚¹ï¼š 1.æœ€å¥½ä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„æ•°ç»„æ¥ä¿è¯æ¯ä¸ªç‚¹åªè¢«è®¿é—®ä¸€æ¬¡ï¼Œå¦åˆ™çš„è¯åº”è¯¥ä¿è¯åœ¨35è¡Œå¤„ä½¿ç”¨e.dis&gt;=dis[e.num]è€Œä¸ä»…æ˜¯&gt;ï¼Œå¦åˆ™ä¼šé€ æˆä¸€äº›ç›¸ç­‰çš„é¢å¤–ç›¸åŠ ã€‚ 2.40è¡Œçš„åœ°æ–¹è¦æ³¨æ„ä¸Dijkstraçš„åŒºåˆ«ï¼ï¼ä¸æ˜¯åŠ è€Œæ˜¯ç›´æ¥æ¢ï¼ï¼ï¼ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); G[b].push_back(edge{a,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[1]=0; priority_queue&lt;d&gt;que;que.push(d{1,0}); int ans=0; while(!que.empty()){ d t=que.top();que.pop(); if(vis[t.num])continue;//å¦‚æœä¸ç”¨é¢å¤–æ•°ç»„è¿™é‡Œè¦æ³¨æ„ ans+=t.dis;vis[t.num]=true; for(i=0;i&lt;G[t.num].size();i++){ edge e=G[t.num][i]; if(dis[e.to]&gt;e.cost){ dis[e.to]=e.cost;//æ³¨æ„è¿™é‡Œä¸Dijkstraçš„åŒºåˆ« que.push(d{e.to,dis[e.to]}); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>æœ€å°ç”Ÿæˆæ ‘</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>æœ€å°ç”Ÿæˆæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰SPFA]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89spfa%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; bool inque[maxn]; int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; int dis[maxn]; for(i=1;i&lt;=n;i++)dis[i]=(1&lt;&lt;31)-1; dis[s]=0; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } queue&lt;int&gt;que;que.push(s);//inque[s]=true; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰Dijkstra]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-a8-a1-e6-9d-bf-ef-bc-89dijkstra%2F</url>
    <content type="text"><![CDATA[è‡ªå®šä¹‰ç»“æ„ä½“#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cost; }; vector&lt;edge&gt;G[maxn]; struct d{//è®°å½•å„ç§è¢«æ¾å¼›åçš„ç‚¹ int num,dis; }; bool operator &lt;(d a,d b) { return a.dis&gt;b.dis; } int main() { int n,m,s,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(i=1;i&lt;=m;i++){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); G[a].push_back(edge{b,c}); } int dis[maxn];memset(dis,0x7f,sizeof(dis));dis[s]=0; priority_queue&lt;d&gt;que; que.push(d{s,0}); while(!que.empty()){ d e=que.top();que.pop(); if(e.dis&gt;dis[e.num])continue;//è¿™é‡Œä¹Ÿå¯ä»¥åˆ©ç”¨ä¸€ä¸ªé¢å¤–çš„æ•°ç»„æ¥ä¿è¯æ¯ä¸ªç‚¹åªè¢«è®¿ //é—®ä¸€æ¬¡ï¼Œæˆ–è€…è¯´æœ€çŸ­è·ç¦»å·²ç»ç¡®å®šçš„ç‚¹ä¸å†è¢«æ›´æ”¹ for(int i=0;i&lt;G[e.num].size();i++){ edge eg=G[e.num][i]; if(dis[eg.to]&gt;dis[e.num]+eg.cost){ dis[eg.to]=dis[e.num]+eg.cost; que.push(d{eg.to,dis[eg.to]}); } } } return 0; } using pair#include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; using namespace std; const int maxn=1e5+5; typedef struct { int to, cost; }Edge; vector&lt;Edge&gt;edge[maxn]; typedef pair&lt;int, int&gt;P; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;q;//ä»å°åˆ°å¤§çš„ä¼˜å…ˆé˜Ÿåˆ— int book[maxn], dis[maxn]; int main(void) { int n, m, s, i, j; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); fill(dis, dis + n+1, 2147483647); dis[s] = 0; for (i = 1; i &lt;= m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge temp; temp.to = b; temp.cost = c; edge[a].push_back(temp); } P p; p.first = 0; p.second = s; q.push(p); while (!q.empty()) { P p = q.top(); q.pop(); if (book[p.second] == 1) continue; book[p.second] = 1; for (i = 0; i &lt; edge[p.second].size(); i++) { Edge temp = edge[p.second][i]; if (dis[temp.to] &gt; dis[p.second] + temp.cost) { dis[temp.to] = dis[p.second] + temp.cost; P p1; p1.first = dis[temp.to]; p1.second = temp.to; q.push(p1); } } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰Floydç®—æ³•ï¼ˆå¤šæºæœ€çŸ­è·¯ï¼‰]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89floyd-e7-ae-97-e6-b3-95-ef-bc-88-e5-a4-9a-e6-ba-90-e6-9c-80-e7-9f-ad-e8-b7-af-ef-bc-89%2F</url>
    <content type="text"><![CDATA[éœ€è¦æ³¨æ„çš„å°±æ˜¯å› ä¸ºæ¯æ¬¡æ˜¯æ‹¿ä¸€ä¸ªç‚¹å‡ºæ¥è€ƒè™‘èƒ½å¦æŠŠåˆ«çš„è·¯å˜çŸ­ï¼Œæ‰€ä»¥kä¸€å®šæ˜¯æœ€å¤–å±‚å¾ªç¯ã€‚ä»¥åŠè¦è®°å¾—åˆå§‹åŒ–ä¸ºæ— ç©·å¤§æˆ–æ— ç©·å°ã€‚ å¯ä»¥é€šè¿‡æ£€æŸ¥æ˜¯å¦æœ‰dis[i][i]&lt;0æ¥åˆ¤å®šæ˜¯å¦æœ‰è´Ÿç¯å­˜åœ¨ int dis[105][105]; memset(dis,0x7f,sizeof(dis)); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;dis[i][j]; for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰å¹¶æŸ¥é›†]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-b9-b6-e6-9f-a5-e9-9b-86%2F</url>
    <content type="text"><![CDATA[ä¸¤ä»¶äº‹ï¼šè®°å¾—åˆå§‹åŒ–parï¼Œä»¥åŠï¼Œè·¯å¾„å‹ç¼©åˆ«å†™é”™äº†â€¦ int par[1005];//è®°å¾—åˆå§‹åŒ–ï¼ int find(int x) { return par[x]==x?x:par[x]=find(par[x]);//åé¢è¿™ä¸€å—ä¸è¦æ¼äº†par[x],å¦åˆ™å°±æ˜¯ä¸å¸¦è·¯å¾„å‹ç¼©! } bool unite(int x,int y) { x=find(x),y=find(y); if(x==y)return false; par[x]=y; return true; } æŒ‰ç§©åˆå¹¶ï¼š int find(int x) { if (x == par[x]) return x; else return par[x] = find(par[x]);//åé¢è¿™ä¸€å—ä¸è¦æ¼äº†par[x]!!!å¦åˆ™å°±æ˜¯ä¸å¸¦è·¯å¾„å‹ç¼©(æœ‰æ—¶å€™æœ‰ç”¨ï¼‰ } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) { par[x] = y; } else { par[y] = x; if (rank[x] == rank[y]) rank[x]++; } } ä¸€å®šè¦åŠ ä¸Šï¼š for(i=1;i&lt;=n;i++){ par[i]=i; }!!!!!!]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å¹¶æŸ¥é›†</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>å¹¶æŸ¥é›†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰SGå‡½æ•°å°ç»“]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89sg-e5-87-bd-e6-95-b0-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[è¯´æ˜¯å°ç»“ï¼Œå…¶å®æˆ‘å¹¶æ²¡æœ‰æ€ä¹ˆå¼„æ‡‚QAQï¼Œç®€å•å†™å†™æ¦‚å¿µè·Ÿæ¿å­å§â€¦ Sprague-Grundyå‡½æ•°ç»™å®šä¸€ä¸ªæœ‰å‘æ— ç¯å›¾å’Œä¸€ä¸ªèµ·å§‹é¡¶ç‚¹ä¸Šçš„ä¸€æšæ£‹å­ï¼Œä¸¤åé€‰æ‰‹äº¤æ›¿çš„å°†è¿™æšæ£‹å­æ²¿æœ‰å‘è¾¹è¿›è¡Œç§»åŠ¨ï¼Œæ— æ³•ç§»åŠ¨è€…åˆ¤è´Ÿã€‚äº‹å®ä¸Šï¼Œè¿™ä¸ªæ¸¸æˆå¯ä»¥è®¤ä¸ºæ˜¯æ‰€æœ‰Impartial Combinatorial Gamesçš„æŠ½è±¡æ¨¡å‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä»»ä½•ä¸€ä¸ªICGéƒ½å¯ä»¥é€šè¿‡æŠŠæ¯ä¸ªå±€é¢çœ‹æˆä¸€ä¸ªé¡¶ç‚¹ï¼Œå¯¹æ¯ä¸ªå±€é¢å’Œå®ƒçš„å­å±€é¢è¿ä¸€æ¡æœ‰å‘è¾¹æ¥æŠ½è±¡æˆè¿™ä¸ªâ€œæœ‰å‘å›¾æ¸¸æˆâ€ã€‚ åŸºæœ¬æ¦‚å¿µä¸‹é¢æˆ‘ä»¬å°±åœ¨æœ‰å‘æ— ç¯å›¾çš„é¡¶ç‚¹ä¸Šå®šä¹‰Sprague-Garundyå‡½æ•°ã€‚ é¦–å…ˆå®šä¹‰$mex$(minimal excludant)è¿ç®—ï¼Œè¿™æ˜¯æ–½åŠ äºä¸€ä¸ªé›†åˆçš„è¿ç®—ï¼Œè¡¨ç¤ºæœ€å°çš„ä¸å±äºè¿™ä¸ªé›†åˆçš„éè´Ÿæ•´æ•°ã€‚ä¾‹å¦‚$mex[0,1,2,4]=3,mex[2,3,5]=0,mex[]=0$ã€‚ å¯¹äºä¸€ä¸ªç»™å®šçš„æœ‰å‘æ— ç¯å›¾ï¼Œå®šä¹‰å…³äºå›¾çš„æ¯ä¸ªé¡¶ç‚¹çš„Sprague-Garundyå‡½æ•°$g$å¦‚ä¸‹ï¼š$g(x)=mex[ g(y) | yæ˜¯xçš„åç»§ ]$ã€‚ SGå‡½æ•°çš„æ€§è´¨é¦–å…ˆï¼Œæ‰€æœ‰çš„terminal positionæ‰€å¯¹åº”çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å‡ºè¾¹çš„é¡¶ç‚¹ï¼Œå…¶SGå€¼ä¸º0ï¼Œå› ä¸ºå®ƒçš„åç»§é›†åˆæ˜¯ç©ºé›†ã€‚ å¯¹äºä¸€ä¸ªg(x)=0çš„é¡¶ç‚¹xï¼Œå®ƒçš„æ‰€æœ‰åç»§yéƒ½æ»¡è¶³g(y)!=0ã€‚ å¯¹äºä¸€ä¸ªg(x)!=0çš„é¡¶ç‚¹ï¼Œå¿…å®šå­˜åœ¨ä¸€ä¸ªåç»§yæ»¡è¶³g(y)=0ã€‚ P ä»¥ä¸Šè¿™ä¸‰å¥è¯è¡¨æ˜ï¼Œé¡¶ç‚¹xæ‰€ä»£è¡¨çš„postionæ˜¯P-positionå½“ä¸”ä»…å½“g(x)=0ï¼ˆè·ŸP-positioin/N-positionçš„å®šä¹‰çš„é‚£ä¸‰å¥è¯æ˜¯å®Œå…¨å¯¹åº”çš„ï¼‰ã€‚æˆ‘ä»¬é€šè¿‡è®¡ç®—æœ‰å‘æ— ç¯å›¾çš„æ¯ä¸ªé¡¶ç‚¹çš„SGå€¼ï¼Œå°±å¯ä»¥å¯¹æ¯ç§å±€é¢æ‰¾åˆ°å¿…èƒœç­–ç•¥äº†ã€‚ æˆ‘ä»¬å¯ä»¥å®šä¹‰æœ‰å‘å›¾æ¸¸æˆçš„å’Œ(Sum of Graph Games)ï¼šè®¾G1ã€G2ã€â€¦â€¦ã€Gnæ˜¯nä¸ªæœ‰å‘å›¾æ¸¸æˆï¼Œå®šä¹‰æ¸¸æˆGæ˜¯G1ã€G2ã€â€¦â€¦ã€Gnçš„å’Œ(Sum)ï¼Œæ¸¸æˆGçš„ç§»åŠ¨è§„åˆ™æ˜¯ï¼šä»»é€‰ä¸€ä¸ªå­æ¸¸æˆGiå¹¶ç§»åŠ¨ä¸Šé¢çš„æ£‹å­ã€‚Sprague-Grundy Theoremå°±æ˜¯ï¼šg(G)=g(G1)^g(G2)^â€¦^g(Gn)ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¸¸æˆçš„å’Œçš„SGå‡½æ•°å€¼æ˜¯å®ƒçš„æ‰€æœ‰å­æ¸¸æˆçš„SGå‡½æ•°å€¼çš„å¼‚æˆ–ã€‚ å†è€ƒè™‘ä¸€ä¸ªæ€§è´¨ï¼šä»»ä½•ä¸€ä¸ªICGéƒ½å¯ä»¥æŠ½è±¡æˆä¸€ä¸ªæœ‰å‘å›¾æ¸¸æˆã€‚æ‰€ä»¥â€œSGå‡½æ•°â€å’Œâ€œæ¸¸æˆçš„å’Œâ€çš„æ¦‚å¿µå°±ä¸æ˜¯å±€é™äºæœ‰å‘å›¾æ¸¸æˆã€‚æˆ‘ä»¬ç»™æ¯ä¸ªICGçš„æ¯ä¸ªpositionå®šä¹‰SGå€¼ï¼Œä¹Ÿå¯ä»¥å®šä¹‰nä¸ªICGçš„å’Œã€‚æ‰€ä»¥è¯´å½“æˆ‘ä»¬é¢å¯¹ç”±nä¸ªæ¸¸æˆç»„åˆæˆçš„ä¸€ä¸ªæ¸¸æˆæ—¶ï¼Œåªéœ€å¯¹äºæ¯ä¸ªæ¸¸æˆæ‰¾å‡ºæ±‚å®ƒçš„æ¯ä¸ªå±€é¢çš„SGå€¼çš„æ–¹æ³•ï¼Œå°±å¯ä»¥æŠŠè¿™äº›SGå€¼å…¨éƒ¨çœ‹æˆNimçš„çŸ³å­å †ï¼Œç„¶åä¾ç…§æ‰¾Nimçš„å¿…èƒœç­–ç•¥çš„æ–¹æ³•æ¥æ‰¾è¿™ä¸ªæ¸¸æˆçš„å¿…èƒœç­–ç•¥äº†ï¼ï¼ˆNimå…¶å®å°±æ˜¯nä¸ªä»ä¸€å †ä¸­æ‹¿çŸ³å­çš„æ¸¸æˆæ±‚SGçš„å˜å‹ï¼Œæ€»SG=nä¸ªsgçš„å¼‚æˆ–ï¼‰ã€‚ æ¨¡æ¿1.æŠŠåŸæ¸¸æˆåˆ†è§£æˆå¤šä¸ªç‹¬ç«‹çš„å­æ¸¸æˆï¼Œåˆ™åŸæ¸¸æˆçš„SGå‡½æ•°å€¼æ˜¯å®ƒçš„æ‰€æœ‰å­æ¸¸æˆçš„SGå‡½æ•°å€¼çš„å¼‚æˆ–ã€‚å³$sg(G)=sg(G1)\oplus sg(G2)\oplus â€¦\oplus sg(Gn)$ã€‚ 2.åˆ†åˆ«è€ƒè™‘æ²¡ä¸€ä¸ªå­æ¸¸æˆï¼Œè®¡ç®—å…¶SGå€¼ã€‚1.å¯é€‰æ­¥æ•°ä¸º1~mçš„è¿ç»­æ•´æ•°ï¼Œç›´æ¥å–æ¨¡å³å¯ï¼Œ$SG(x) = x \ mod\ (m+1)$; 2.å¯é€‰æ­¥æ•°ä¸ºä»»æ„æ­¥ï¼Œ$SG(x) = x$; 3.å¯é€‰æ­¥æ•°ä¸ºä¸€ç³»åˆ—ä¸è¿ç»­çš„æ•°ï¼Œç”¨æ¨¡æ¿è®¡ç®—ã€‚ æ¨¡æ¿1ï¼šæ‰“è¡¨ #include&lt;bits/stdc++.h&gt; using namespace std; //f[]ï¼šå¯ä»¥å–èµ°çš„çŸ³å­ä¸ªæ•° //sg[]:0~nçš„SGå‡½æ•°å€¼ //Mex[]:mex{} int f[N],sg[N],Mex[N]; void getSG(int n) { int i, j; memset(sg, 0, sizeof(sg)); for (i = 1; i &lt;= n; i++) { memset(Mex, 0, sizeof(Mex)); for (j = 1; f[j] &lt;= i; j++) Mex[sg[i - f[j]]] = 1; for (j = 0; j &lt;= n; j++) //æ±‚mes{}ä¸­æœªå‡ºç°çš„æœ€å°çš„éè´Ÿæ•´æ•° { if (Mex[j] == 0) { sg[i] = j; break; } } } } æ¨¡æ¿2ï¼šdfs //æ³¨æ„ Sæ•°ç»„è¦æŒ‰ä»å°åˆ°å¤§æ’åº SGå‡½æ•°è¦åˆå§‹åŒ–ä¸º-1 å¯¹äºæ¯ä¸ªé›†åˆåªéœ€åˆå§‹åŒ–1é //næ˜¯é›†åˆsçš„å¤§å° S[i]æ˜¯å®šä¹‰çš„ç‰¹æ®Šå–æ³•è§„åˆ™çš„æ•°ç»„ int s[110],sg[10010],n; int SG_dfs(int x) { int i; if(sg[x]!=-1) return sg[x]; bool vis[110];//boolæ•°ç»„ä¸€å®šè¦æ”¾åœ¨é‡Œé¢ memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) { if(x&gt;=s[i]) { SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; } } int e; for(i=0;;i++) if(!vis[i]) { e=i; break; } return sg[x]=e; } ä¸€èˆ¬DFSåªåœ¨æ‰“è¡¨è§£å†³ä¸äº†çš„æƒ…å†µä¸‹ç”¨ï¼Œé¦–é€‰æ‰“è¡¨é¢„å¤„ç†ã€‚ è¿˜æœ‰ä¸€ç§dfsï¼Œé¢˜ç›®ç»™å‡ºçš„ä¸æ˜¯ç§»åŠ¨æ¬¡æ•°ï¼Œè€Œæ˜¯å¯ä»¥ç§»åŠ¨çš„æ“ä½œï¼Œç±»ä¼¼äºç»™å®šä¸€å¹…æœ‰å‘å›¾ï¼ŒçŸ¥é“ä¸‹ä¸€æ­¥æœ‰å“ªäº›æ“ä½œæ˜¯å¯é€‰çš„ï¼ˆå‚è§HDU1524ï¼‰ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[1005]; int sg[1005]; int dfs(int x) { if(sg[x]!=-1) return sg[x]; bool vis[1005]={false}; for(int i=0;i&lt;G[x].size();i++){ vis[dfs(G[x][i])]=true; } for(int i=0;;i++) if(!vis[i]) return sg[x]=i; } int main() { int n,i,j,k,x,m; while(cin&gt;&gt;n){ for(i=0;i&lt;=1000;i++)G[i].clear(); memset(sg,-1,sizeof(sg)); for(i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;x); while(x--){ scanf(&quot;%d&quot;,&amp;j); G[i].push_back(j);//åŠ è¾¹,ä¸‹ä¸€æ­¥å¯ä»¥åšçš„æ“ä½œ } } while(scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m){ int ans=0; for(i=0;i&lt;m;i++){ scanf(&quot;%d&quot;,&amp;j); if(sg[j]!=-1) ans^=sg[j]; else ans^=dfs(j); } if(ans)puts(&quot;WIN&quot;); else puts(&quot;LOSE&quot;); } } return 0; } 3.è®¡ç®—$sg(G)=sg(G1)\oplus sg(G2)\oplus â€¦\oplus sg(Gn)$ï¼Œè‹¥$sg(G)=0$,å³P-Position,å³å…ˆæ‰‹æ¯”è´¥ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åšå¼ˆè®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åšå¼ˆè®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #450 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-450-div-2%2F</url>
    <content type="text"><![CDATA[A.å¼±æ™ºé¢˜ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,x,y,cnt[2]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&lt;0)cnt[0]++; else cnt[1]++; } if(cnt[0]&lt;=1||cnt[1]&lt;=1){ puts(&quot;Yes&quot;); } else puts(&quot;No&quot;); return 0; } B.é¦–å…ˆè¦çŸ¥é“ä¸€ä¸ªç»“è®ºï¼šå¯¹äº$a/b$,ä»–çš„å°æ•°éƒ¨åˆ†çš„å¾ªç¯èŠ‚é•¿åº¦ä¸ä¼šè¶…è¿‡$b$ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦æ£€æŸ¥å°æ•°ç‚¹åçš„æœ€å¤š$b$ä½å°±å¯ä»¥çŸ¥é“$c$æ˜¯å¦æœ‰å‡ºç°è¿‡äº†ã€‚ç„¶åå…³é”®å°±æ˜¯å¦‚ä½•æ±‚å°æ•°ç‚¹åçš„ä½æ•°äº†ã€‚è¿™ä¸ªå¯ä»¥ç”¨é•¿é™¤æ³•æ¥åšï¼Œå…·ä½“æ€æƒ³å…¶å®å°±æ˜¯ä¸æ–­æŠŠè¢«é™¤æ•°ä¹˜10ç„¶åé™¤ä»¥é™¤æ•°è·å¾—ä¸‹ä¸€ä½å°æ•°ä½ï¼ˆç›¸å½“äºä¸æ–­åœ°å°†å°æ•°ç‚¹å³ç§»ä¸€ä½ï¼‰ï¼Œå†™å†™å°±æ˜ç™½äº†ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c,i,j,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=1;i&lt;=b;i++){ if(a*10/b==c){ cout&lt;&lt;i&lt;&lt;endl;return 0; } a=a*10%b; } cout&lt;&lt;-1&lt;&lt;endl; return 0; } C.å…¶å®å¾ˆå®¹æ˜“æƒ³åˆ°ä¸€ä¸ªè´ªå¿ƒçš„æƒ³æ³•ï¼Œå°±æ˜¯ä»å‰å¾€åæ‰«ä¸€éï¼Œå¯¹äºæ¯ä¸ªæ•°ï¼Œå¦‚æœå‰é¢æ°å¥½æœ‰ä¸€ä¸ªæ•°å¤§äºç­‰äºå½“å‰æ•°ï¼Œé‚£ä¹ˆé‚£ä¸ªæ•°çš„â€œåˆ é™¤å€¼â€å°±åº”è¯¥+1ï¼Œç„¶åæ‰¾å‡ºâ€åˆ é™¤å€¼â€œæœ€å¤§çš„æ•°å³å¯ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯æ¯ä¸ªæ•°åŒæ—¶å¯èƒ½æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªâ€recordâ€ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªæ•°ï¼Œå¦‚æœä»–æ˜¯â€recordâ€ï¼Œé‚£ä¹ˆä»–çš„åˆ é™¤å€¼å°±æ˜¯1ï¼Œç„¶åæ¯æ¬¡æ‰¾åˆ°ä¸€ä¸ªåé¢çš„æ•°è¦åˆ é™¤è¿™ä¸ªæ•°ï¼Œé‚£ä¹ˆä»–çš„åˆ é™¤å€¼å°±-1ï¼Œæœ€åæ‰¾å‡ºåˆ é™¤å€¼æœ€å°çš„æ•°å³å¯ï¼ˆåˆå§‹åˆ é™¤å€¼éƒ½ä¸º0ï¼‰ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k,maxn=0,ans=0,premaxn=0; cin&gt;&gt;n; int num[100005],pos[100005]={0}; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]&gt;maxn){ pos[i]=1; premaxn=maxn;maxn=num[i];k=i; } else if(num[i]&gt;premaxn){ pos[k]--;premaxn=num[i]; } } int minn=2; for(i=1;i&lt;=n;i++){ if(pos[i]&lt;minn){ ans=num[i];minn=pos[i]; } else if(pos[i]==minn){ ans=min(ans,num[i]); } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.é¦–å…ˆï¼Œå¦‚æœxä¸èƒ½æ•´é™¤yï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥æ»šè›‹äº†ã€‚ ä»¤$f(t)$è¡¨ç¤ºè‹¥å¹²ä¸ªæ•°å’Œä¸º$t$ï¼Œ$gcd$ä¸º1ã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯$f(\frac{y}{x})$. ä»¤$g(t)$è¡¨ç¤ºè‹¥å¹²ä¸ªæ•°å’Œä¸º$t$,é‚£ä¹ˆæ˜¾ç„¶æœ‰$g(t)=2^{t-1}$:æƒ³è±¡ä¸€ä¸‹ï¼ŒæŠŠtåˆ†æˆtä¸ª1ï¼Œé‚£ä¹ˆç›¸é‚»çš„1ä¹‹é—´åˆ†å¼€ä¸å¦éƒ½æ˜¯ä¸åŒçš„ï¼ˆæœ¬é¢˜çš„åºåˆ—æ˜¯æœ‰åºçš„ï¼‰ã€‚ æ³¨æ„åˆ°æœ‰$g(t)=\sum_{i=1}^{t_i}f(\frac{t}{t_i})$($t_i$æ˜¯$t$çš„çº¦æ•°)ï¼Œ æ‰€ä»¥æœ‰$f(t)=g(t)-\sum_{i=2}^{sz}f(\frac{t}{t_i})$. äºæ˜¯å…ˆæŠŠyé™¤ä»¥xï¼Œç„¶åæ±‚å‡ºyçš„æ‰€æœ‰çº¦æ•°ï¼Œä»å°åˆ°å¤§æ’åºåï¼Œä»å¤§åˆ°å°æšä¸¾æ¯ä¸ªçº¦æ•°ï¼Œå¯¹äºæ¯ä¸ªçº¦æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆç®—å‡ºä»–çš„$g(i)$,ç„¶åæšä¸¾æ‰€æœ‰æ¯”ä»–å¤§çš„çº¦æ•°ï¼Œå¦‚æœæŸä¸ªçº¦æ•°èƒ½æ•´é™¤ä»–ï¼Œé‚£ä¹ˆé‚£ä¸ªçº¦æ•°å¯¹åº”çš„$f(i)$å°±åº”è¯¥è¢«å‡å»ã€‚æœ€åè¾“å‡º$f(1)$å³å¯ã€‚ä»¥åŠï¼Œæ³¨æ„å–æ¨¡çš„é—®é¢˜ï¼Œè¦ç”¨å¿«é€Ÿå¹‚&amp;å°å¿ƒè´Ÿæ•°ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; typedef long long ll; ll mod_pow(ll x,ll y) { ll res=1; while(y){ if(y&amp;1){ res=res*x%mod; } y&gt;&gt;=1;x=x*x%mod; } return res; } ll f[100000]; int main() { int x,y,i,j,k; cin&gt;&gt;x&gt;&gt;y; if(y%x){ puts(&quot;0&quot;);return 0; } y/=x;vector&lt;int&gt;ys; for(i=1;i*i&lt;=y;i++){ if(y%i==0){ ys.push_back(i); if(i*i!=y) ys.push_back(y/i); } } sort(ys.begin(),ys.end()); for(i=ys.size()-1;~i;i--){ f[i]=mod_pow(2,y/ys[i]-1); for(j=ys.size()-1;j&gt;i;j--) if(ys[j]%ys[i]==0) f[i]=(f[i]-f[j]+mod)%mod; } cout&lt;&lt;(f[0]+mod)%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #502ï¼ˆDiv. 1 + Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-502-ef-bc-88div-1-div-2%2F</url>
    <content type="text"><![CDATA[A.ç­¾åˆ° #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct mark{ int id,sum; bool operator&lt;(const mark&amp;v)const{ if(sum==v.sum) return id&lt;v.id; return sum&gt;v.sum; } }G[1005]; int main() { int n,i,j,k,a,b,c,d; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;G[i].sum+=a+b+c+d;G[i].id=i; } sort(G+1,G+1+n); for(i=1;i&lt;=n;i++){ if(G[i].id==1){ cout&lt;&lt;i&lt;&lt;endl;return 0; } } } B.é¦–å…ˆï¼Œå¯ä»¥å‘ç°ä¸€ä¸ªäº‹å®ï¼šç¬¬äºŒä¸ªä¸²çš„æŸä¸ªä½ç½®å¦‚æœæ˜¯1ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªä¸²æ˜¯ä»€ä¹ˆæ˜¯ä¸é‡è¦çš„ï¼Œå› ä¸ºæ¢å®Œè¿˜æ˜¯1.å¦åˆ™ï¼Œç¬¬ä¸€ä¸ªä¸²å¦‚æœæ˜¯0ï¼Œæˆ‘ä»¬å°±ç ”ç©¶æœ‰å¤šå°‘ä¸ª1å¯ä»¥æ¢ã€‚ä½†æ˜¯è¿™æ ·å°±ä¼šå¸¦æ¥ä¸€ä¸ªé‡å¤çš„é—®é¢˜ï¼Œå¯¹æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªé¢„å¤„ç†ï¼Œå¯¹äºæ¯ä¸ª1ï¼Œç›¸å½“äºè¦æ¢0ï¼Œè€Œç›¸åº”å‰é¢çš„0çš„ä½ç½®å¿…ç„¶è¦æ¢1ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç»Ÿè®¡ä¸€ä¸‹è¿™ä¸ªé‡å¤çš„é—®é¢˜ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string str1,str2;int n,i,j,k,cnt[2]={0},cnt1[2]={0}; cin&gt;&gt;n&gt;&gt;str1&gt;&gt;str2; for(auto a:str1)cnt[a-&apos;0&apos;]++; long long ans=0; for(i=0;i&lt;n;i++){ if(str2[i]==&apos;0&apos;){ if(str1[i]==&apos;1&apos;){ ans+=cnt[0];ans-=cnt1[1];cnt1[0]++; } else{ ans+=cnt[1];ans-=cnt1[0];cnt1[1]++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C.ä¸å¤ªä¼šè¯æ˜â€¦åˆ©ç”¨äº†ä¸€ç‚¹ç±»ä¼¼åˆ†å—çš„æ€æƒ³ï¼Œåæ­£å¹³æ–¹åˆ†å‰²è‚¯å®šæ˜¯å¯¹çš„â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,pos; cin&gt;&gt;n;pos=n; int len=sqrt(n); while(pos&gt;=len){ for(i=pos-len+1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; pos-=len; } for(i=1;i&lt;=pos;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; } D.æ¯”èµ›çš„æ—¶å€™æ€»è§‰å¾—æ˜¯å»ºæ ‘ï¼Œç„¶åå°±tå¾—æ€€ç–‘äººç”Ÿäº†â€¦ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; struct node{ int son[2]; int cnt=0; bool tag; }ch[1&lt;&lt;14];//æ•°ç»„å¤§å°ç”±æ‰€è¦æ’å…¥å­—ç¬¦çš„æ€»é•¿åº¦å†³å®š void insert(char*str,int n) { int now=0; ch[now].tag=true; for(int i=0;i&lt;n;i++){ int c=str[i]-&apos;0&apos;; now=ch[now].son[c]; ch[now].tag=true; } ch[now].cnt++; ch[now].tag=true; } int w[15],k;int cnt,n; void query(string str,int id,int quan,int ceng) { if(!ch[id].tag)return; if(ceng) { if ((id &amp; 1) != str[ceng - 1] - &apos;0&apos;) quan += w[ceng]; if (quan &gt; k)return; if (ceng == n) { cnt += ch[id].cnt; return; } } query(str,id&lt;&lt;1|1,quan,ceng+1); query(str,(id&lt;&lt;1)+2,quan,ceng+1); } int main() { int i,j; for(i=0;i&lt;(1&lt;&lt;12);i++){ //ch[i].cnt++; ch[i].son[0]=i&lt;&lt;1|1;ch[i].son[1]=(i&lt;&lt;1)+2; } int m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;=m;i++){ char str[15];scanf(&quot;%s&quot;,str); insert(str,n); } while(q--){ string str;cin&gt;&gt;str&gt;&gt;k; cnt=0; query(str,0,0,0); printf(&quot;%d\n&quot;,cnt); } return 0; } æ­£è§£æ˜¯åˆ©ç”¨ç±»ä¼¼bitsetçš„æ€æƒ³ï¼Œå› ä¸ºä¸¤ä¸²ç›¸ä¸åªå¯èƒ½æ˜¯0~2^12ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é¢„å¤„ç†æ‰€æœ‰çš„æƒ…å†µï¼ŒæŠŠä»–ä»¬è½¬10è¿›åˆ¶è¡¨ç¤ºï¼Œç„¶åæŸ¥è¯¢çš„æ—¶å€™å°±æ˜¯$O(1)$çš„äº†. æœ‰ä¸€ç‚¹è¦æ³¨æ„çš„å°±æ˜¯å› ä¸ºä¸¤ä¸ªä¸²éƒ½æ˜¯0æˆ–è€…éƒ½æ˜¯1 çš„æ—¶å€™æƒå€¼éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œä¸ºäº†æ–¹ä¾¿ç»Ÿè®¡ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠseté‡Œé¢çš„ä¸²å…¨éƒ¨å–åï¼Œç„¶åæŸ¥è¯¢çš„æ—¶å€™ä¸¤ä¸ªä¸²å¼‚æˆ–ä¸€ä¸‹ï¼Œæ˜¯1çš„ä½ç½®å°±æ˜¯æƒå€¼æœ‰æ•ˆçš„ä½ç½®äº†ã€‚ans[i][j]ä»£è¡¨æ¨¡å¼ä¸²ä¸ºiçš„æ—¶å€™ä¸¤ä¸²ç›¸ä¸ä¸ºjçš„æƒ…å†µæ•°ã€‚ ä»¥åŠï¼Œstringä¼štle #include&lt;bits/stdc++.h&gt; using namespace std; int w[5000],s[5000],ans[5000][105],f[5000];//sæ˜¯å°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—ä¸²,anså­˜ç­”æ¡ˆ,fé¢„å¤„ç† int main() { int n,m,q; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;w[n - i]);//æ³¨æ„è¿™é‡Œå±‚çº§è¦å€’ç€æ¥,ä¸ç„¶æ²¡æ³•ä»å‰å¾€ååŒ¹é… for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j))//f[i]ä»£è¡¨ä¸¤ä¸ªæ•°ç›¸ä¸ç­‰äºiæ—¶çš„æƒå€¼ f[i] += w[j]; for (int i = 1; i &lt;= m; i++) { char ss[15];scanf(&quot;%s&quot;,ss); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + 1 - (ss[j] - &apos;0&apos;);//æ³¨æ„è¿™é‡Œæ˜¯ä¸åŸæ•°å–åçš„!!! //a=a*2+(ss[j]-&apos;0&apos;); s[a]++;//ç»Ÿè®¡ä¸²ä¸ªæ•° } for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; (1 &lt;&lt; n); j++) if (f[i ^ j] &lt;= 100)//é¢˜æ„:k&lt;=100æ‰æœ‰æ•ˆ ans[i][f[i ^ j]] += s[j];//ans[i][j]ç»Ÿè®¡æ¨¡å¼ä¸²ä¸ºiæ—¶ç›¸ä¸ç­”æ¡ˆä¸ºjçš„ä¸ªæ•° //ans[i][f[i&amp;j]]+=s[j]; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 1; j &lt;= 100; j++) ans[i][j] += ans[i][j - 1];//å› ä¸º&lt;=jéƒ½å¯ä»¥,æ‰€ä»¥,è¦åŠ æˆå‰ç¼€å’Œ for (int i = 1; i &lt;= q; i++) { char ss[15];scanf(&quot;%s&quot;,ss);int k;scanf(&quot;%d&quot;,&amp;k); int a = 0; for (int j = 0; j &lt; n; j++) a = a * 2 + (ss[j] - &apos;0&apos;); printf(&quot;%d\n&quot;, ans[a][k]); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 BUPT Summer Training ç½‘ç»œæµ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F%E5%9B%BE%E8%AE%BA%2F2018-bupt-summer-training-e7-bd-91-e7-bb-9c-e6-b5-81%2F</url>
    <content type="text"><![CDATA[A - Drainage Ditches POJ - 1273æ¿å­é¢˜ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[210]; int level[205],iter[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ for(i=1;i&lt;=200;i++)G[i].clear(); for(i=1;i&lt;=n;i++){ int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);addedge(a,b,c); } cout&lt;&lt;maxflow(1,m)&lt;&lt;endl; } return 0; } C - Reactor Cooling ZOJ - 2314æ— æºæ±‡å¯è¡Œæµæ¨¡æ¿é¢˜ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//è®°å½•è¾¹çš„id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//å­˜ç­”æ¡ˆ for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//åå‘è¾¹æˆ–è€…è¿å‘é™„åŠ æ±‡ç‚¹çš„è¾¹æ— è§† as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//è¿™æ¡è¾¹çš„åå‘è¾¹çš„å®¹é‡+è¿™æ¡è¾¹çš„ä¸‹ç•Œ } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } D - Number HYSBZ - 3275æ³¨æ„é¢˜ç›®æ¡ä»¶æ˜¯åŒæ—¶æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶çš„æ•°æ‰ä¸èƒ½ä¸€èµ·é€‰ã€‚å¯¹äºæ¯ä¸ªç‚¹aï¼Œæˆ‘ä»¬æ‹†æˆ$a_x$å’Œ$a_y$,æºç‚¹è¿æ¥$a_x$,å®¹é‡ä¸ºæ•°å€¼ï¼Œ$a_y$è¿æ¥æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºæ•°å€¼ã€‚å¦‚æœä¸¤ä¸ªæ•°aï¼Œbä¸èƒ½åŒæ—¶é€‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†$a_x$è¿æ¥$b_y$,$b_x$ è¿æ¥$a_y$,å®¹é‡ä¸ºINFã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯æ‰€æœ‰æ•°çš„å’Œ-maxflow/2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[210]; int level[205],iter[205],cha[205],lower[200005],cur[205]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,cap; bool operator&lt;(const ans v)const{ return id&lt;v.id; } }; int main() { int n, m, i, j, k,t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m;memset(cur,0,sizeof(cur)); for(i=0;i&lt;205;i++)G[i].clear(); for (i = 1; i &lt;= m; i++) { int a, b, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;lower[i], &amp;d); cur[b] += lower[i]; cur[a] -= lower[i]; addedge(a, b, d - lower[i]); G[a].back().id = i;//è®°å½•è¾¹çš„id } int sum = 0; for (i = 1; i &lt;= n; i++) { if (cur[i] &gt; 0) { addedge(0, i, cur[i]); sum += cur[i]; } else if (cur[i] &lt; 0) { addedge(i, 201, -cur[i]); } } int flow = maxflow(0, 201); if (flow != sum) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; vector&lt;ans&gt; as;//å­˜ç­”æ¡ˆ for (i = 1; i &lt;= n; i++) { for (j = 0; j &lt; G[i].size(); j++) { edge e = G[i][j]; if (!e.id)continue;//åå‘è¾¹æˆ–è€…è¿å‘é™„åŠ æ±‡ç‚¹çš„è¾¹æ— è§† as.push_back(ans{e.id, G[e.to][e.rev].cap + lower[e.id]});//è¿™æ¡è¾¹çš„åå‘è¾¹çš„å®¹é‡+è¿™æ¡è¾¹çš„ä¸‹ç•Œ } } sort(as.begin(), as.end()); for (i = 0; i &lt; as.size(); i++) { printf(&quot;%d\n&quot;, as[i].cap); } } return 0; } E - è½¯ä»¶å¼€å‘ HYSBZ - 1221éå¸¸ç±»ä¼¼é¤å·¾è®¡åˆ’é—®é¢˜ã€‚å”¯ä¸€çš„ä¸åŒå°±æ˜¯æ´—çš„æ—¶é—´ï¼Œç¬¬iå¤©çš„æ¯›å·¾åœ¨i+1å¤©æ‰å¼€å§‹æ´—ï¼Œæ‰€ä»¥åœ¨ç¬¬i+k+1å¤©æ‰æ´—å¥½ï¼Œå…¶ä»–å°±æ²¡ä»€ä¹ˆåŒºåˆ«äº†ã€‚ å…³äºæ„å›¾ï¼š è¿™æ˜¯ä¸€é“æœ€å°è´¹ç”¨ï¼ˆè´¹ç”¨æŒ‡å•ä»·ï¼‰æœ€å¤§æµçš„é¢˜ç›®ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬æ‹†ç‚¹ï¼Œå°†ä¸€å¤©æ‹†æˆæ™šä¸Šå’Œæ—©ä¸Šï¼Œæ¯å¤©æ™šä¸Šä¼šå—åˆ°è„é¤å·¾ï¼ˆæ¥æºï¼šå½“å¤©æ—©ä¸Šç”¨å®Œçš„é¤å·¾ï¼Œåœ¨è¿™é“é¢˜ä¸­å¯ç†è§£ä¸ºä»åŸç‚¹è·å¾—ï¼‰ï¼Œæ¯å¤©æ—©ä¸Šåˆæœ‰å¹²å‡€çš„é¤å·¾ï¼ˆæ¥æºï¼šè´­ä¹°ã€å¿«æ´—åº—ã€æ…¢æ´—åº—ï¼‰ã€‚ï¼ˆæœ¬é¢˜ä¸­å¯¹åº”ä¸¤ç§æ¸…æ´—æ–¹å¼ï¼Œå…¶å®å°±æ˜¯æ¢äº†ä¸ªåå­—è€Œå·²ï¼‰ 1.ä»åŸç‚¹å‘æ¯ä¸€å¤©æ™šä¸Šè¿ä¸€æ¡æµé‡ä¸ºå½“å¤©æ‰€ç”¨é¤å·¾xï¼Œè´¹ç”¨ä¸º0çš„è¾¹ï¼Œè¡¨ç¤ºæ¯å¤©æ™šä¸Šä»èµ·ç‚¹è·å¾—xæ¡è„é¤å·¾ã€‚ 2.ä»æ¯ä¸€å¤©æ—©ä¸Šå‘æ±‡ç‚¹è¿ä¸€æ¡æµé‡ä¸ºå½“å¤©æ‰€ç”¨é¤å·¾xï¼Œè´¹ç”¨ä¸º0çš„è¾¹ï¼Œæ¯å¤©ç™½å¤©,è¡¨ç¤ºå‘æ±‡ç‚¹æä¾›xæ¡å¹²å‡€çš„é¤å·¾,æµæ»¡æ—¶è¡¨ç¤ºç¬¬iå¤©çš„é¤å·¾å¤Ÿç”¨ ã€‚ 3.ä»æ¯ä¸€å¤©æ™šä¸Šå‘ç¬¬äºŒå¤©æ™šä¸Šè¿ä¸€æ¡æµé‡ä¸ºINFï¼Œè´¹ç”¨ä¸º0çš„è¾¹ï¼Œè¡¨ç¤ºæ¯å¤©æ™šä¸Šå¯ä»¥å°†è„é¤å·¾ç•™åˆ°ç¬¬äºŒå¤©æ™šä¸Šï¼ˆæ³¨æ„ä¸æ˜¯æ—©ä¸Šï¼Œå› ä¸ºè„é¤å·¾åœ¨æ—©ä¸Šä¸å¯ä»¥ä½¿ç”¨ï¼‰ã€‚ 4.ä»æ¯ä¸€å¤©æ™šä¸Šå‘è¿™ä¸€å¤©+å¿«æ´—æ‰€ç”¨å¤©æ•°t1çš„é‚£ä¸€å¤©æ—©ä¸Šè¿ä¸€æ¡æµé‡ä¸ºINFï¼Œè´¹ç”¨ä¸ºå¿«æ´—æ‰€ç”¨é’±æ•°çš„è¾¹ï¼Œè¡¨ç¤ºæ¯å¤©æ™šä¸Šå¯ä»¥é€å»å¿«æ´—éƒ¨,åœ¨åœ°i+t1å¤©æ—©ä¸Šæ”¶åˆ°é¤å·¾ ã€‚ 5.åŒç†ï¼Œä»æ¯ä¸€å¤©æ™šä¸Šå‘è¿™ä¸€å¤©+æ…¢æ´—æ‰€ç”¨å¤©æ•°t2çš„é‚£ä¸€å¤©æ—©ä¸Šè¿ä¸€æ¡æµé‡ä¸ºINFï¼Œè´¹ç”¨ä¸ºæ…¢æ´—æ‰€ç”¨é’±æ•°çš„è¾¹ï¼Œè¡¨ç¤ºæ¯å¤©æ™šä¸Šå¯ä»¥é€å»æ…¢æ´—éƒ¨,åœ¨åœ°i+t2å¤©æ—©ä¸Šæ”¶åˆ°é¤å·¾ ã€‚ 6.ä»èµ·ç‚¹å‘æ¯ä¸€å¤©æ—©ä¸Šè¿ä¸€æ¡æµé‡ä¸ºINFï¼Œè´¹ç”¨ä¸ºè´­ä¹°é¤å·¾æ‰€ç”¨é’±æ•°çš„è¾¹ï¼Œè¡¨ç¤ºæ¯å¤©æ—©ä¸Šå¯ä»¥è´­ä¹°é¤å·¾ ã€‚ æ³¨æ„ï¼Œä»¥ä¸Š6ç‚¹éœ€è¦å»ºåå‘è¾¹ï¼3~6ç‚¹éœ€è¦åšåˆ¤æ–­ï¼ˆå³è¿å‘çš„è¾¹å¿…é¡»&lt;=nï¼‰ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct edge{ int to,cap,cost,rev;//ç»ˆç‚¹,å®¹é‡,è´¹ç”¨,åå‘è¾¹ }; vector&lt;edge&gt;G[5010]; int dis[5010],prevv[5010],preve[5010],n,m,s,t,flow=0,cost=0;//æœ€çŸ­è·¯ä¸­å‰é©±èŠ‚ç‚¹å’Œå¯¹åº”çš„è¾¹ bool inque[5010]; const int INF=1&lt;&lt;30; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//æ³¨æ„åå‘è¾¹çš„åŠ æ³•!!-costå’Œcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f) return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//å…¨æœ€çŸ­è·¯ä¸­çš„æœ€å°æµé‡é™åˆ¶å°±æ˜¯æœ¬æ¬¡æ€»çš„æµé‡é™åˆ¶ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//æ›´æ–°è·¯å¾„ä¿¡æ¯ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int n,a,b,f,fa,fb,i,j,k; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;fa&gt;&gt;fb; int peo[1005]; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;peo[i]); for(i=1;i&lt;=n;i++) add(0,i,peo[i],0); for(i=1;i&lt;=n;i++) add(i+n,2005,peo[i],0); for(i=1;i&lt;n;i++) add(i,i+1,INF,0); for(i=1;i+a+1&lt;=n;i++) add(i,i+a+n+1,INF,fa); for(i=1;i+b+1&lt;=n;i++) add(i,i+b+n+1,INF,fb); for(i=1;i&lt;=n;i++) add(0,i+n,INF,f); mincostmaxflow(0,2005); cout&lt;&lt;cost&lt;&lt;endl; return 0; } F - ä¿®è½¦ HYSBZ - 1070é¢˜ç›®çš„éš¾ç‚¹åœ¨äºæ€ä¹ˆå»è®¡ç®—æ€»çš„ç­‰å¾…æ—¶é—´ã€‚æ–¹æ³•æ˜¯æŠŠä¿®è½¦äººå‘˜æ‹†æˆnä¸ªç‚¹ï¼Œæ¯ä¸ªäººçš„ç¬¬iä¸ªç‚¹åˆ†åˆ«è¡¨ç¤ºè¿™ä¸ªäººåœ¨å€’æ•°ç¬¬iä¸ªå¯¹æŸè¾†è½¦è¿›è¡Œä¿®ç†ï¼Œé‚£ä¹ˆç­‰å¾…ä¿®çš„è½¦è¿å‘è¿™ä¸ªç‚¹çš„è¾¹å°±åº”è¯¥æ˜¯ ä¿®è½¦æ—¶é—´* iï¼Œå› ä¸ºè¿˜æœ‰iä¸ªäººåœ¨ç­‰è¿™ä¸ªä¿®è½¦å¸ˆå‚…ã€‚ç„¶åè·‘æœ€å°è´¹ç”¨æµå³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,cost,rev;//ç»ˆç‚¹,å®¹é‡,è´¹ç”¨,åå‘è¾¹ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//æœ€çŸ­è·¯ä¸­å‰é©±èŠ‚ç‚¹å’Œå¯¹åº”çš„è¾¹, // å°å¿ƒcostçˆ†int,å¤šç»„æ•°æ®æ—¶è®°å¾—æ¸…é›¶ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//æ³¨æ„åå‘è¾¹çš„åŠ æ³•!!-costå’Œcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//å°å¿ƒçˆ†intçš„æƒ…å†µ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//å…¨æœ€çŸ­è·¯ä¸­çš„æœ€å°æµé‡é™åˆ¶å°±æ˜¯æœ¬æ¬¡æ€»çš„æµé‡é™åˆ¶ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//æ›´æ–°è·¯å¾„ä¿¡æ¯ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int m,n,i,j,k,a,b; cin&gt;&gt;m&gt;&gt;n; for(i=1;i&lt;=n;i++) add(0,n*m+i,1,0); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ cin&gt;&gt;a; for(k=1;k&lt;=n;k++){ add(n*m+i,(j-1)*n+k,1,a*k); } } for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) add((i-1)*n+j,900,1,0); mincostmaxflow(0,900); printf(&quot;%.2f\n&quot;,(double)cost/n); return 0; } G - Firing POJ - 2987æœ€å¤§æƒé—­åˆå›¾çš„æ¨¡æ¿é¢˜ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } long long maxflow(int s,int t){ long long flow=0;//å°å¿ƒçˆ†int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//æ³¨æ„å¦‚æœçˆ†intè¿™é‡Œåˆå§‹æœ€å¤§å€¼è¦æ›´æ”¹æœ€å¤§å€¼ flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; } H - Being a Hero HDU - 3251æ·»åŠ æ±‡ç‚¹Tï¼ŒåŸå›¾ä¸Šçš„å•å‘è¾¹ä¾æ¬¡å»ºè¾¹ï¼Œå®¹é‡ä¸ºèŠ±è´¹ï¼Œå…è®¸é€‰æ‹©çš„fä¸ªç‚¹å‘æ±‡ç‚¹Tè¿è¾¹ï¼Œå®¹é‡ä¸ºç‚¹ä¸Šæƒå€¼ã€‚è·‘ä¸€éæœ€å°å‰²å¾—åˆ°èŠ±è´¹å€¼costï¼Œç„¶åç”¨æ€»çš„èƒ½è·å¾—åˆ©æ¶¦ï¼ˆå°±æ˜¯fä¸ªç‚¹çš„æƒå€¼ä¹‹å’Œï¼‰å‡å»cost ä»æºç‚¹Såœ¨æ®‹ç•™ç½‘ç»œä¸­dfséå†èƒ½èµ°åˆ°çš„ç‚¹ï¼Œé‚£ä¹ˆè¿™äº›ç‚¹å°±æ˜¯å±äºSé›†ï¼Œå…¶ä»–å‰©ä¸‹çš„ç‚¹å°±å±äºTé›†äº†ï¼Œ ç„¶ååˆ¤æ–­è¾¹çš„ä¸¤ä¸ªç‚¹æ‰€å±çš„é›†åˆï¼Œå¦‚æœå±äºä¸åŒçš„é›†åˆé‚£ä¹ˆè¿™æ¡è¾¹å°±æ˜¯å‰²è¾¹ã€‚ å¯¹äºåŸå›¾ä¸Šçš„è¾¹å¦‚æœè¢«å‰²åˆ°ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å°±æ˜¯è¦ç ´åçš„ï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ä¸€å®šè¦æ ‡è®°æ¯æ¡è¾¹æ˜¯ä¸æ˜¯åŸå›¾ä¸­çš„è¾¹ï¼Œå¦åˆ™å¾ˆå¯èƒ½åå‘è¾¹ä¼šè¢«è¯¯åˆ¤ä¸ºå‰²è¾¹ï¼ï¼ï¼ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e3+5; struct edge{ int to,cap,rev,id; bool iscor; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap,int id) { G[from].push_back(edge{to,cap,(int)G[to].size(),id,true}); G[to].push_back(edge{from,0,(int)G[from].size()-1,id,false});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0;//å°å¿ƒçˆ†int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//æ³¨æ„å¦‚æœçˆ†intè¿™é‡Œåˆå§‹æœ€å¤§å€¼è¦æ›´æ”¹æœ€å¤§å€¼ flow+=f; } } bool vis[1005]; void dfs(int x) { vis[x]=true; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]){ dfs(G[x][i].to); } } } int main() { int t,i,j,k,n,m,f; cin&gt;&gt;t;int case1=0; while(t--){ case1++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;f; for(i=1;i&lt;=1001;i++)G[i].clear(); //int ava[1005]={0}; for(i=1;i&lt;=m;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w,i);//è¿è¾¹ } long long sum=0; while(f--){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w);sum+=w;//ava[u]=1; addedge(u,1001,w,0);//1001ä¸ºæ±‡ç‚¹ } printf(&quot;Case %d: &quot;,case1); cout&lt;&lt;sum-maxflow(1,1001)&lt;&lt;endl; memset(vis,0,sizeof(vis)); dfs(1); vector&lt;int&gt;road;//ç ´åçš„è¾¹ for(i=1;i&lt;=n;i++){ for(j=0;j&lt;G[i].size();j++){ edge e=G[i][j]; if(vis[i]&amp;&amp;!vis[e.to]&amp;&amp;e.id&amp;&amp;e.iscor){ road.push_back(e.id); } } } cout&lt;&lt;road.size(); //sort(road.begin(),road.end()); for(i=0;i&lt;road.size();i++) cout&lt;&lt;&apos; &apos;&lt;&lt;road[i]; cout&lt;&lt;endl; } return 0; } I - å¿—æ„¿è€…æ‹›å‹Ÿ HYSBZ - 1061æºç‚¹è¿ç¬¬ä¸€å¤©ï¼Œæœ€åä¸€å¤©ï¼ˆn+1ï¼‰è¿æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºINFè´¹ç”¨ä¸º0 è¿™æ ·è·‘ç½‘ç»œæµæ˜¯æ²¿æ—¶é—´æµçš„ï¼ˆå°±æ˜¯ä¾æ¬¡è§£å†³æ¯ä¸€å¤©çš„é—®é¢˜ï¼‰ ç„¶åæ¯ä¸€å¤©å‘åä¸€å¤©è¿ä¸€æ¡å®¹é‡ä¸ºINF-a[i]ï¼Œè´¹ç”¨ä¸º0çš„è¾¹ï¼ˆè¿™å…¶å®æ˜¯æœ¬é¢˜ç²¾é«“ï¼‰ ä¸ºä»€ä¹ˆå®¹é‡ä¸ºINF-a[i]ï¼Ÿè¿™å°±ç›¸å½“äºå°‘äº†a[i]ï¼Œå¾—ç”¨å¸¦æƒè¾¹ä¹Ÿå°±æ˜¯æ‹›æ¥çš„å¿—æ„¿è€…è¡¥å…¨INF è¿™å°±æ˜¯å¿—æ„¿è€…è¿ç»­å¹²æ—¶æ²¿è¿™æ¡è¾¹è·‘ï¼Œå› ä¸ºè¿ç»­å¹²ä¸èŠ±é’±ï¼Œæ‰€ä»¥ä¼˜å…ˆé€‰è¿™ç§è¾¹ ç„¶åå°†æ¯ä¸€ç±»å¿—æ„¿è€…s[i]ä¸t[i]+1è¿ä¸€æ¡å®¹é‡ä¸ºINFèŠ±è´¹ä¸ºc[i]çš„è¾¹ï¼Œå½“è¿ç»­å¹²çš„äººä¸å¤Ÿæ—¶ï¼Œå°±å¾—å……é’±ä½¿åŠ²å¾€é‡Œå¡äººï¼Œè¡¥å…¨INFã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int INF = (1 &lt;&lt; 31) - 1; struct edge { int to, cap, cost, rev; }; vector&lt;edge&gt;G[2010]; int dis[2010], prevv[2010], preve[2010], n, m, flow = 0, cost = 0; bool inque[2010]; void add(int from, int to, int cap, int cost) { edge e; e.to = to; e.cap = cap; e.cost = cost; e.rev = G[to].size(); G[from].push_back(e); e.to = from; e.cap = 0; e.cost = -cost; e.rev = G[from].size() - 1;//-cost! G[to].push_back(e); } bool Spfa(int s, int t) { fill(dis, dis + 2000, 1 &lt;&lt; 30); memset(inque, 0, sizeof(inque)); queue&lt;int&gt;que; dis[s] = 0; inque[s] = true; que.push(s); while (!que.empty()) { int t = que.front(); que.pop(); inque[t] = false; for (int i = 0; i &lt; G[t].size(); i++) { edge e = G[t][i]; if (e.cap&amp;&amp;dis[e.to] &gt; dis[t] + e.cost) { dis[e.to] = dis[t] + e.cost; prevv[e.to] = t; preve[e.to] = i;//ä¸€ä¸ªè¾¹ä¸€ä¸ªç‚¹ä¸è¦æ··æ·†ï¼ if (!inque[e.to]) { que.push(e.to); inque[e.to] = true; } } } } if (dis[t] == 1 &lt;&lt; 30)//å¦‚æœå·²ç»æ— æ³•å¢å¹¿ï¼Œè¿”å› return false; int d = 1 &lt;&lt; 30; for (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);//æ­¤æ¬¡å¯å¢å¹¿å®¹é‡æ˜¯å…¨è·¯å¾„ä¸­å®¹é‡æœ€å°çš„é‚£ä¸ª flow += d; cost += d * dis[t];//disæ˜¯è·¯å¾„ä¸­å•ä½è´¹ç”¨å’Œ for (int v = t; v != s; v = prevv[v]) {//æ›´æ”¹å®¹é‡ edge &amp;e = G[prevv[v]][preve[v]]; e.cap -= d; G[v][e.rev].cap += d;//væˆ–è€…e.toéƒ½å¯ä»¥ } return true; } void mincostmaxflow(int s, int t) { while (Spfa(s, t)&amp;&amp;flow&lt;INF); } int main() { int i, j; cin &gt;&gt; n &gt;&gt; m; add(0, 1, INF, 0); add(n + 1, 1500, INF, 0); for (i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;j); add(i, i + 1, INF - j, 0); } for (i = 1; i &lt;= m; i++) { int s, t, c; scanf(&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;c); add(s, t + 1, INF, c); } mincostmaxflow(0, 1500); cout &lt;&lt; cost &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ‰ä¸Šä¸‹ç•Œçš„ç½‘ç»œæµ æ€»ç»“]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fe6-9c-89-e4-b8-8a-e4-b8-8b-e7-95-8c-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b5-81-e5-81-9a-e6-b3-95-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[æ— æºæ±‡å¯è¡Œæµå»ºå›¾æ–¹æ³•å°†æœ‰ä¸Šä¸‹ç•Œçš„ç½‘ç»œæµå›¾è½¬åŒ–æˆæ™®é€šçš„ç½‘ç»œæµå›¾ é¦–å…ˆå»ºç«‹é™„åŠ æºç‚¹sså’Œé™„åŠ æ±‡ç‚¹tt å¯¹äºåŸå›¾ä¸­çš„è¾¹x-&gt;yï¼Œè‹¥é™åˆ¶ä¸º[b,c]ï¼Œé‚£ä¹ˆè¿è¾¹x-&gt;yï¼Œæµé‡ä¸ºc-b å¯¹äºåŸå›¾ä¸­çš„æŸä¸€ä¸ªç‚¹iï¼Œè®°d(i)ä¸ºæµå…¥è¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œå‡å»æµå‡ºè¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œ ï¼ˆä¸Šé¢åœ¨è¿æ¯ä¸€æ¡è¾¹çš„æ—¶å€™å»ºä¸€ä¸ªcuræ•°ç»„è®°ä¸€ä¸‹è¾“å…¥è¾“å‡ºå³å¯ï¼‰ è‹¥d(i)&gt;0ï¼Œé‚£ä¹ˆè¿è¾¹ss-&gt;iï¼Œæµé‡ä¸ºd(i) ï¼ŒåŒæ—¶æœŸæœ›çš„æµé‡å€¼sum+=dï¼ˆi) è‹¥d(i)&lt;0ï¼Œé‚£ä¹ˆè¿è¾¹i-&gt;ttï¼Œæµé‡ä¸º-d(i) æ±‚è§£æ–¹æ³• åœ¨æ–°å›¾ä¸Šè·‘ssåˆ°ttçš„æœ€å¤§æµ è‹¥æ–°å›¾æ»¡æµï¼ˆæµé‡ç­‰äºsumï¼‰ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ç§å¯è¡Œæµ æ­¤æ—¶ï¼ŒåŸå›¾ä¸­æ¯ä¸€æ¡è¾¹çš„æµé‡åº”ä¸ºæ–°å›¾ä¸­å¯¹åº”çš„è¾¹çš„æµé‡+è¿™æ¡è¾¹çš„æµé‡ä¸‹ç•Œ EXï¼šLOJ115 è¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜ã€‚ nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œæ¯æ¡è¾¹ eæœ‰ä¸€ä¸ªæµé‡ä¸‹ç•Œ $lower(e) $ å’Œæµé‡ä¸Šç•Œ $upper(e)$ï¼Œæ±‚ä¸€ç§å¯è¡Œæ–¹æ¡ˆä½¿å¾—åœ¨æ‰€æœ‰ç‚¹æ»¡è¶³æµé‡å¹³è¡¡æ¡ä»¶çš„å‰æä¸‹ï¼Œæ‰€æœ‰è¾¹æ»¡è¶³æµé‡é™åˆ¶ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev,id; }; vector&lt;edge&gt;G[310]; int level[305],iter[305],cur[305],lower[30500]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } struct ans{ int id,flow; bool operator&lt;(const ans&amp;a)const{ return id&lt;a.id; } }; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int s,t,l,u; scanf(&quot;%d%d%d%d&quot;,&amp;s,&amp;t,&amp;lower[i],&amp;u); cur[s]-=lower[i];cur[t]+=lower[i]; addedge(s,t,u-lower[i]);G[s].back().id=i; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]); sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,250,-cur[i]); } } int flow=maxflow(0,250); if(flow!=sum){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return 0; } vector&lt;ans&gt;as; for(i=1;i&lt;=n;i++){ for(auto a:G[i]){ if(!a.id)continue; as.push_back(ans{a.id,lower[a.id]+G[a.to][a.rev].cap}); } } sort(as.begin(),as.end()); cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(auto a:as){ cout&lt;&lt;a.flow&lt;&lt;endl; } return 0; } æœ‰æºæ±‡å¯è¡Œæµå»ºå›¾æ–¹æ³•åœ¨åŸå›¾ä¸­æ·»åŠ ä¸€æ¡è¾¹t-&gt;sï¼Œæµé‡ä¸ºinf å³è®©æºç‚¹å’Œæ±‡ç‚¹ä¹Ÿæ»¡è¶³æµé‡å¹³è¡¡æ¡ä»¶ è¿™æ ·å°±æ”¹é€ æˆäº†æ— æºæ±‡çš„ç½‘ç»œæµå›¾ï¼Œå…¶ä½™å»ºå›¾æ–¹æ³•ä¸æ— æºæ±‡å¯è¡Œæµç›¸åŒã€‚ æœ‰æºæ±‡æœ‰ä¸Šä¸‹ç•Œæœ€å¤§æµå»ºå›¾æ–¹æ³•å°†æœ‰ä¸Šä¸‹ç•Œçš„ç½‘ç»œæµå›¾è½¬åŒ–æˆæ™®é€šçš„ç½‘ç»œæµå›¾ é¦–å…ˆå»ºç«‹é™„åŠ æºç‚¹sså’Œé™„åŠ æ±‡ç‚¹tt å¯¹äºåŸå›¾ä¸­çš„è¾¹x-&gt;yï¼Œè‹¥é™åˆ¶ä¸º[b,c]ï¼Œé‚£ä¹ˆè¿è¾¹x-&gt;yï¼Œæµé‡ä¸ºc-b å¯¹äºåŸå›¾ä¸­çš„æŸä¸€ä¸ªç‚¹iï¼Œè®°d(i)ä¸ºæµå…¥è¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œå‡å»æµå‡ºè¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œ è‹¥d(i)&gt;0ï¼Œé‚£ä¹ˆè¿è¾¹ss-&gt;iï¼Œæµé‡ä¸ºd(i) è‹¥d(i)&lt;0ï¼Œé‚£ä¹ˆè¿è¾¹i-&gt;ttï¼Œæµé‡ä¸º-d(i) ï¼ˆä»¥ä¸Šä¸æ— æºæ±‡å¯è¡Œæµç›¸åŒï¼‰ åœ¨åŸå›¾ä¸­æ·»åŠ ä¸€æ¡è¾¹t-&gt;sï¼Œæµé‡ä¸ºinf å³è®©æºç‚¹å’Œæ±‡ç‚¹ä¹Ÿæ»¡è¶³æµé‡å¹³è¡¡æ¡ä»¶ è¿™æ ·å°±æ”¹é€ æˆäº†æ— æºæ±‡çš„ç½‘ç»œæµå›¾ ï¼ˆä»¥ä¸Šä¸æœ‰æºæ±‡å¯è¡Œæµç›¸åŒï¼‰ åœ¨æ–°å›¾ä¸Šè·‘ssåˆ°ttçš„æœ€å¤§æµ è‹¥æ–°å›¾æ»¡æµï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ç§å¯è¡Œæµ è®°æ­¤æ—¶$âˆ‘f(s,i)=sum1$ ï¼Œå³æ­¤æ—¶t-&gt;sçš„æœ€å¤§æµï¼Œä¹Ÿå°±æ˜¯æ±‚åå‘è¾¹s-&gt;tçš„æµé‡ å°†t-&gt;sè¿™æ¡è¾¹æ‹†æ‰ï¼Œåœ¨æ–°å›¾ä¸Šè·‘såˆ°tçš„æœ€å¤§æµ è®°æ­¤æ—¶$âˆ‘f(s,i)=sum2 $ï¼Œå³maxflowï¼ˆsï¼Œtï¼‰ æœ€ç»ˆç­”æ¡ˆå³ä¸ºsum1+sum2 EX:LOJ116 è¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜ã€‚ nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œæ¯æ¡è¾¹ eæœ‰ä¸€ä¸ªæµé‡ä¸‹ç•Œ$ lower(e) $å’Œæµé‡ä¸Šç•Œ $upper(e) $ï¼Œç»™å®šæºç‚¹ sä¸æ±‡ç‚¹ tï¼Œæ±‚æºç‚¹åˆ°æ±‡ç‚¹çš„æœ€å¤§æµã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; struct edge{ int to,cap,rev; bool tag; }; vector&lt;edge&gt;G[410]; int level[405],iter[405],cur[405],lower[10005]; void addedge(int from,int to,int cap,int s) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! if(from==s)G[from].back().tag=true; } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,t,up; scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;t,&amp;lower[i],&amp;up); addedge(from,t,up-lower[i],s);cur[from]-=lower[i];cur[t]+=lower[i]; } int sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i],s);sum+=cur[i]; } else{ addedge(i,250,-cur[i],s); } } addedge(t,s,(1&lt;&lt;31)-1,s); int flow=maxflow(0,250); if(sum!=flow){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } int ans=G[s].back().cap; G[s].pop_back();G[t].pop_back(); ans+=maxflow(s,t); cout&lt;&lt;ans&lt;&lt;endl; return 0; } æœ‰æºæ±‡æœ‰ä¸Šä¸‹ç•Œæœ€å°æµå»ºå›¾æ–¹æ³•å°†æœ‰ä¸Šä¸‹ç•Œçš„ç½‘ç»œæµå›¾è½¬åŒ–æˆæ™®é€šçš„ç½‘ç»œæµå›¾ é¦–å…ˆå»ºç«‹é™„åŠ æºç‚¹sså’Œé™„åŠ æ±‡ç‚¹tt å¯¹äºåŸå›¾ä¸­çš„è¾¹x-&gt;yï¼Œè‹¥é™åˆ¶ä¸º[b,c]ï¼Œé‚£ä¹ˆè¿è¾¹x-&gt;yï¼Œæµé‡ä¸ºc-b å¯¹äºåŸå›¾ä¸­çš„æŸä¸€ä¸ªç‚¹iï¼Œè®°d(i)ä¸ºæµå…¥è¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œå‡å»æµå‡ºè¿™ä¸ªç‚¹çš„æ‰€æœ‰è¾¹çš„ä¸‹ç•Œå’Œ è‹¥d(i)&gt;0ï¼Œé‚£ä¹ˆè¿è¾¹ss-&gt;iï¼Œæµé‡ä¸ºd(i) è‹¥d(i)&lt;0ï¼Œé‚£ä¹ˆè¿è¾¹i-&gt;ttï¼Œæµé‡ä¸º-d(i) ï¼ˆä»¥ä¸Šä¸æ— æºæ±‡å¯è¡Œæµç›¸åŒ) æ±‚res=ss-&gt;ttæœ€å¤§æµ è¿è¾¹t-&gt;s,inf æ±‚res+=ss-&gt;ttæœ€å¤§æµ å¦‚æœresï¼=sumä¹Ÿå°±æ˜¯æœŸæœ›ä¸­çš„æ»¡æµï¼Œé‚£ä¹ˆå°±æ²¡æœ‰å¯è¡Œè§£ã€‚ éœ€è¦æ ¼å¤–æ³¨æ„æœ€å°æµåˆ¤æ–­æ˜¯å¦æœ‰å¯è¡Œè§£çš„ä½ç½®ä¸æ—¶æœºä¸å¦å¤–å‡ ç§ä¸Šä¸‹ç•Œç½‘ç»œæµçš„ä¸åŒï¼ï¼ï¼ å¦åˆ™ï¼Œè¾“å‡ºG[s].back().capä¹Ÿå°±æ˜¯ä»tåˆ°s infè¾¹çš„å®é™…æµé‡ï¼Œå³ä¸ºæ‰€æ±‚ã€‚ EX:LOJ117 n ä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œæ¯æ¡è¾¹ eæœ‰ä¸€ä¸ªæµé‡ä¸‹ç•Œ $lower(e) $å’Œæµé‡ä¸Šç•Œ $upper(e)$ï¼Œç»™å®šæºç‚¹ sä¸æ±‡ç‚¹ tï¼Œæ±‚æºç‚¹åˆ°æ±‡ç‚¹çš„æœ€å°æµã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; struct edge{ int to;ll cap;int rev; }; vector&lt;edge&gt;G[50210]; int level[50205],iter[50205],low[125050];ll cur[50205]; void addedge(int from,int to,ll cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } ll dfs(int v,int t,ll f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ ll d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } ll maxflow(int s,int t){ ll flow=0; for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); ll f; while(f=dfs(s,t,0x7f7f7f7f7f7f7f7f)) flow+=f; } } int main() { int n,m,s,t,i,j,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int from,to,up;scanf(&quot;%d%d%d%d&quot;,&amp;from,&amp;to,&amp;low[i],&amp;up); cur[from]-=low[i];cur[to]+=low[i];addedge(from,to,up-low[i]); } ll sum=0; for(i=1;i&lt;=n;i++){ if(cur[i]&gt;0){ addedge(0,i,cur[i]);sum+=cur[i]; } else if(cur[i]&lt;0){ addedge(i,50050,-cur[i]); } } ll flow=maxflow(0,50050); addedge(t,s,(1LL&lt;&lt;63)-1); flow+=maxflow(0,50050); if(flow!=sum){ cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl;return 0; } cout&lt;&lt;G[s].back().cap&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #452 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Fcodeforces-round-452-div-2%2F</url>
    <content type="text"><![CDATA[A.#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k,cnt[3]={0}; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);cnt[j]++; } //cout&lt;&lt;min(cnt[1],cnt[2])&lt;&lt;endl; if(cnt[1]&lt;=cnt[2]){ cout&lt;&lt;cnt[1]&lt;&lt;endl; } else{ if(cnt[1]-cnt[2]&lt;3) cout&lt;&lt;cnt[2]&lt;&lt;endl; else cout&lt;&lt;cnt[2]+(cnt[1]-cnt[2])/3&lt;&lt;endl; } return 0; } B.å°±æ˜¯æ‰“è¡¨æš´åŠ› #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int init[15]={31,31,28,31,30,31,30,31,31,30,31,30,31},days[5][50]; int i,j,n,tar[30],k; for(i=1;i&lt;=4;i++) for(j=1;j&lt;=36;j++){ days[i][j]=init[j%12]; } days[1][2]=29;days[2][14]=29;days[3][26]=29; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;tar[i]); bool isok=false; for(i=1;i&lt;=4;i++){ for(j=1;j&lt;=36-n+1;j++){ for(k=1;k&lt;=n;k++){ if(tar[k]!=days[i][j+k-1]) break; } if(k&gt;n){ isok=true;break; } } } if(isok){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } C.å¦‚æœæ•°å­—ä¸æ˜¯1~nçš„è¯ä¼¼ä¹æ˜¯ä¸€ä¸ªnpé—®é¢˜â€¦å½“ç„¶è¿™é‡Œæ˜¯è¿ç»­çš„ï¼Œå› æ­¤å…¶å®æ˜¯æœ‰è§„å¾‹å¯å¾ªçš„ã€‚è®¨è®ºnæ¨¡4çš„ä½™æ•°ï¼Œç„¶åå°±ä¼šå‘ç°å½“ä½™æ•°ä¸º0æˆ–2çš„æ—¶å€™éƒ½æ˜¯å¯ä»¥æ„é€ å‡ºæ¥å·®ä¸º0çš„ï¼Œå…¶ä»–å°±åªèƒ½å·®ä¸º1äº†ã€‚ æ„é€ æˆ¿ä¸»è¦æ€æƒ³å°±æ˜¯é¦–ä½é…å¯¹ï¼Œå› ä¸ºè¿™æ ·é…å‡ºæ¥çš„æ¯å¯¹çš„å’Œéƒ½æ˜¯ç›¸ç­‰çš„ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j,k; vector&lt;int&gt;ans; cin&gt;&gt;n; int y=n%4; if(y==0){ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; } else if(y==1){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2+1&lt;&lt;&apos; &apos;&lt;&lt;1; for(i=2;i&lt;=n/4+1;i++) cout&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+2; } else if(y==2){ cout&lt;&lt;1&lt;&lt;endl&lt;&lt;n/2&lt;&lt;&apos; &apos;; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;n-i+1&lt;&lt;&apos; &apos;; cout&lt;&lt;n/2&lt;&lt;endl; } else{ cout&lt;&lt;0&lt;&lt;endl&lt;&lt;n/2&lt;&lt;endl; for(i=1;i&lt;=n/4;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; for(i=n-n/4;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&apos; &apos;; } return 0; } D.é¦–å…ˆï¼Œå¦‚æœåœ¨èŒƒå›´å†…æœ€å¤§çš„ä¸¤ä¸ªæ•°åŠ èµ·æ¥æ°å¥½æ˜¯9999â€¦99çš„å½¢å¼çš„è¯ï¼Œé‚£ä¹ˆå¹¶ä¸éœ€è¦å†è®¨è®ºäº†ï¼Œç­”æ¡ˆå°±æ˜¯1.å¦åˆ™æ‰€æ±‚çš„9çš„ä½æ•°å°±æ˜¯æœ€å¤§ä¸¤ä¸ªæ•°çš„å’Œçš„ä½æ•°-1ï¼› ç„¶åæˆ‘ä»¬å°±è¯•ç€åœ¨ç›®æ ‡ä¸ªæ•°çš„9å‰é¢ä¾æ¬¡å¡«ä¸Š0~8ï¼Œçœ‹çœ‹æœ‰å¤šå°‘ç§æ–¹å¼èƒ½åŠ èµ·æ¥ç­‰äºæˆ‘ä»¬å½“å‰æ„é€ çš„å’Œã€‚éœ€è¦æ³¨æ„çš„æ˜¯å½“å’Œpæ¯”è¾ƒå°çš„æ—¶å€™ï¼Œæ–¹å¼å°±æ˜¯p/2ï¼Œä½†æ˜¯å’Œæ¯”è¾ƒå¤§çš„æ—¶å€™å°±æ˜¯n-p/2â€¦ ä»¥åŠï¼Œå¦‚æœn&lt;5çš„æ—¶å€™å¹¶ä¸èƒ½æ„é€ å‡º9ï¼Œé‚£å°±è¦ç‰¹åˆ¤â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,i,j,k; cin&gt;&gt;n; ll maxn=n+n-1; int cnt=0; ll t=maxn; while(t){ cnt++;t/=10; } if(maxn==(ll)pow(10,cnt)-1){ cout&lt;&lt;1&lt;&lt;endl;return 0; } ll ans=0,nine=pow(10,cnt-1)-1;//ans1=n-n/2; for(i=0;i&lt;9;i++){ ll p=(ll)pow(10,cnt-1)*i+nine; if(p&gt;maxn)break; //ans+=((ll)pow(10,cnt-1)*i+nine)/2; ans+=min(n-p/2,p/2); } cout&lt;&lt;(n&lt;5?n*(n-1)/2:ans)&lt;&lt;endl; return 0; } E.é¢˜ç›®åšæ³•å°±æ˜¯æ¨¡æ‹Ÿï¼Œå…³é”®åœ¨äºåˆ å»ä¸€ä¸ªåŒºé—´ä¹‹åï¼Œä»–å·¦å³çš„åŒºé—´å¯èƒ½ä¼šå› ä¸ºæ•°å­—ç›¸åŒè€Œé€ æˆåˆå¹¶ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ç”¨ä¸¤ä¸ªsetï¼Œä¸¤ä¸ªsetä¸­éƒ½å­˜æ”¾pairï¼Œç¬¬ä¸€ä¸ªsetçš„ç¬¬ä¸€å…ƒå­˜æ”¾è¿ç»­æ•°å­—çš„é•¿åº¦*-1ï¼Œç¬¬äºŒå…ƒåˆ™å­˜æ”¾è¿ç»­æ•°å­—çš„èµ·å§‹ä½ç½®ã€‚ç¬¬äºŒä¸ªsetçš„ç¬¬ä¸€å…ƒå­˜æ”¾è¿ç»­æ•°å­—çš„èµ·å§‹ä½ç½®ï¼Œç¬¬äºŒå…ƒå­˜æ”¾è¿ç»­æ•°å­—çš„é•¿åº¦ã€‚ ç„¶åæ¯æ¬¡æˆ‘ä»¬æŠŠç¬¬ä¸€ä¸ªsetä¸­çš„ç¬¬ä¸€ä¸ªpairæ‰¾å‡ºæ¥ï¼Œä»–å°±æ˜¯è¦è¢«åˆ é™¤çš„ï¼Œç„¶åæˆ‘ä»¬ç”¨lowerboundåœ¨ç¬¬äºŒä¸ªsetä¸­æ‰¾å‡ºä»–å‰åçš„ä¸¤ä¸ªpairï¼Œçœ‹çœ‹ä»–ä»¬æ˜¯å¦éœ€è¦åˆå¹¶å³å¯ã€‚å°å¿ƒsetè®¿é—®éæ³•ä½ç½®â€¦ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt;P; int main() { int n,i,j,k; set&lt;P&gt;len,seg; //int pre=0,sum=0; cin&gt;&gt;n;int num[200005]={0},sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i]; if(num[i]!=num[i-1]){ if(i&gt;1){ len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); } sum=1; } else sum++; } len.insert(P(sum*-1,i-sum));seg.insert(P(i-sum,sum)); int ans=0; while(!len.empty()){ ans++; P p=*len.begin();len.erase(len.begin()); auto a=seg.lower_bound(P(p.second,0)); if(seg.size()&gt;=3&amp;&amp;a!=seg.begin()&amp;&amp;a!=--seg.end()){ auto b=a,c=a;b--,c++; if(num[b-&gt;first]==num[c-&gt;first]){ len.erase(P((b-&gt;second)*-1,b-&gt;first)); len.erase(P((c-&gt;second)*-1,c-&gt;first)); len.insert(P((b-&gt;second+c-&gt;second)*-1,b-&gt;first)); seg.insert(P(b-&gt;first,b-&gt;second+c-&gt;second)); seg.erase(b);seg.erase(c); } } seg.erase(a); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } F.å…¶å®åšæ³•ä¹ŸæŒºæš´åŠ›çš„â€¦æˆ‘ä»¬å»ºä¸€å †setï¼Œæ¯ä¸ªé‡Œé¢éƒ½å­˜è¿™ä¸ªå­—ç¬¦å‡ºç°æ‰€æœ‰ä½ç½®ï¼Œç„¶åå¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œæˆ‘ä»¬æ‰¾å‡ºlï¼Œråœ¨åŸå­—ç¬¦ä¸²ä¸­çš„ä½ç½®ï¼Œè¿™ä¸ªå¯ä»¥ç±»ä¼¼æ ‘çŠ¶æ•°ç»„å»ç»´æŠ¤ä¸€ä¸‹ï¼Œä½†æ˜¯æœ‰ç‚¹ä¸åŒï¼Œéœ€è¦å¥½å¥½ç†è§£ä¸€ä¸‹â€¦ç„¶åå»è¿™ä¸ªå­—ç¬¦å¯¹åº”çš„seté‡Œé¢lowerboundä¸€ä¸‹æ‰¾å‡ºlï¼Œrå¯¹åº”åŸä½ç½®åŒºé—´èŒƒå›´å†…çš„æ‰€æœ‰è¿™äº›ä½ç½®ç„¶åæ ‡è®°ä¸€ä¸‹â€¦æœ€åä»å‰å¾€åï¼Œå¦‚æœæ²¡æœ‰è¢«æ ‡è®°è¿‡å°±è¾“å‡ºå³å¯ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e5+10; int bit[maxn],A; void add(int pos,int x) { while(pos&lt;=A){ bit[pos]+=x; pos+=pos&amp;-pos; } } int find(int x) { int s=0,j=A&gt;&gt;1; for(;j;j&gt;&gt;=1) if(x&gt;bit[s+j]) x-=bit[s+j],s+=j; return s+1; } bool vis[maxn]; int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str;cin&gt;&gt;str; set&lt;int&gt;s[150]; for(i=0;i&lt;str.size();i++) s[str[i]].insert(i+1); for(A=1;A&lt;n;A&lt;&lt;=1); for(i=1;i&lt;=n;i++)add(i,1); while(m--){ int l,r;char c[5];scanf(&quot;%d%d%s&quot;,&amp;l,&amp;r,c); l=find(l),r=find(r); //add() for(auto a=s[c[0]].lower_bound(l);a!=s[c[0]].end()&amp;&amp;(*a)&lt;=r;){ vis[*a]=true; add(*a,-1);s[c[0]].erase(a++); } } for(i=1;i&lt;=n;i++) if(!vis[i]) cout&lt;&lt;str[i-1]; cout&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰STè¡¨]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FRMQ%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89st-e8-a1-a8%2F</url>
    <content type="text"><![CDATA[æ¦‚å¿µSTè¡¨å°±æ˜¯ä¸€ä¸ªç”¨æ¥è§£å†³rmqï¼ˆåŒºé—´æœ€å€¼ï¼‰é—®é¢˜çš„ç®—æ³•. STè¡¨ä¸æ”¯æŒåœ¨çº¿ä¿®æ”¹ é¢„å¤„ç†æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼ŒæŸ¥è¯¢æ—¶é—´$O(1)$ ç®—æ³•è¯¦è§£ï¼ˆæ±‚æœ€å°å€¼ï¼‰ï¼šç”¨$mn[i][j]$è¡¨ç¤ºä»$i$åˆ°$i+2^j-1$çš„æœ€å°å€¼ï¼ˆé•¿åº¦æ˜¾ç„¶ä¸º$2^i$ï¼‰ã€‚ ä»»æ„ä¸€æ®µçš„æœ€å°å€¼æ˜¾ç„¶ç­‰äºminï¼ˆå‰åŠæ®µæœ€å°å€¼ï¼ŒååŠæ®µæœ€å°å€¼ï¼‰ã€‚ é‚£ä¹ˆ$mn[i][j]$å¦‚ä½•ç”¨å…¶ä»–çŠ¶æ€æ¥ç»§æ‰¿å‘¢ï¼Ÿ $i$åˆ°$i+2^j-1$çš„é•¿åº¦ä¸º$2^j$ï¼Œé‚£ä¹ˆä¸€åŠçš„é•¿åº¦å°±ç­‰äº$2^{j-1}$ã€‚ é‚£ä¹ˆå‰åŠæ®µçš„çŠ¶æ€è¡¨ç¤ºä¸º$mn[i][j-1]$ã€‚ ååŠæ®µçš„é•¿åº¦ä¹Ÿä¸º$2^{j-1}$ï¼Œèµ·å§‹ä½ç½®ä¸º$i+2^{(j-1)}$ã€‚ é‚£ä¹ˆååŠæ®µçš„çŠ¶æ€è¡¨ç¤ºä¸º$mn[i+2^{j-1}][j-1]$ã€‚ æ‰€ä»¥ï¼š $mn[i][j]=min(mn[i][j-1],mn[i+2^{j-1}][j-1]$ã€‚ æ¨¡æ¿æ³¨æ„ä¿®æ”¹æ•°ç»„å¤§å°ï¼ (æ´›è°·P3865) #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=100010; int a[MAXN],dp[MAXN][50];//ç¬¬äºŒä¸ªæ‹¬å·å†…è¦æ ¹æ®æœ€å¤§æ•°æ®èŒƒå›´æ”¹æˆ2çš„å¹‚æ¬¡èƒ½å¤§äºæœ€å¤§çš„æ•°æ® //int Min(int x,int y)//æœ‰æ—¶å€™å¯ä»¥ç”¨äºè‡ªå®šä¹‰ä¸€äº›ç‰¹æ®Šç±»å‹çš„æ¯”è¾ƒ //{ // return a[x]&lt;=a[y]?x:y; //} void st_init(int n)//nä¸ºåŸå§‹æ•°ç»„çš„é•¿åº¦ { for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); //dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } int query(int l,int r) { int k = log2(r - l + 1); return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); //return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); st_init(n); int l,r; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%dn&quot;,query(l,r)); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>æ•°æ®ç»“æ„</category>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #3]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-3%2F</url>
    <content type="text"><![CDATA[A.HackerRank array-partitioné¦–å…ˆæ³¨æ„åˆ°ä¸€ç‚¹ï¼Œå¦‚æœæœ‰ä¸¤ä¸ªæ•°aï¼Œbï¼Œ$gcd(a,b)\geq 1$,é‚£ä¹ˆaï¼Œbæ˜¾ç„¶æ˜¯è¦æ”¾åœ¨ä¸€ç»„çš„ã€‚è€ƒè™‘åˆ°æ•°ç»„ä¸­çš„æ•°å­—è¿‡å¤šï¼Œå› æ­¤æˆ‘ä»¬å¹¶ä¸èƒ½è¿›è¡Œä¸¤ä¸¤çš„æšä¸¾ï¼Œä½†æ˜¯æ•°æ®çš„èŒƒå›´éƒ½éå¸¸æœ‰é™ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘æšä¸¾æ‰€æœ‰çš„è´¨æ•°ï¼Œç„¶åæšä¸¾è´¨æ•°çš„å€æ•°ï¼Œå¦‚æœåŒä¸€ä¸ªè´¨æ•°å­˜åœ¨ä¸€äº›å€æ•°æ˜¯æ•°ç»„ä¸­çš„æ•°çš„è¯ï¼Œå°±æŠŠè¿™äº›æ•°éƒ½åˆå¹¶èµ·æ¥ï¼ˆæ˜¾ç„¶ç”¨å¹¶æŸ¥é›†æ•ˆç‡æœ€é«˜ï¼‰ã€‚ç„¶åæœ€åæ±‚å‡ºè¿é€šå—çš„æ•°é‡kã€‚æ³¨æ„ï¼Œå› ä¸ºæ•°å­—1çš„ç‰¹æ®Šæ€§ï¼Œæ‰€ä»¥æ¯ä¸ª1éƒ½å¯ä»¥ç®—ä¸€ä¸ªå•ç‹¬çš„è¿é€šå—ï¼Œè¿™ä¸ªè¦é¢å¤–ç»Ÿè®¡ã€‚é‚£ä¹ˆæ–¹æ¡ˆæ•°å°±æ˜¯$2^k-2$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+7; bool notprime[1000005]; vector&lt;int&gt;prime; void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(notprime[i])continue; prime.push_back(i); for(int j=i;j&lt;=n/i;j++) notprime[j*i]=true; } } ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } bool s[1000005]; int par[1000005]; int find(int x) { return x==par[x]?x:par[x]=find(par[x]); } void unite(int x,int y) { x=find(x),y=find(y); if(x==y) return; par[x]=y; } int main() { int t,i,j,k; checkprime(1000000); cin&gt;&gt;t; int num[100005]; while(t--){ int n;cin&gt;&gt;n; int num1=0; int maxn=0; memset(s,0,sizeof(s)); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);s[num[i]]=true; if(num[i]==1)num1++;maxn=max(maxn,num[i]); } for(i=1;i&lt;=maxn;i++)par[i]=i; for(auto a:prime){ int t=0; for(i=1;i*a&lt;=maxn;i++){ if(s[i*a]){ if(!t)t=i*a; else unite(t,i*a); } } } int cnt=1;find(num[1]);set&lt;int&gt;s; for(i=1;i&lt;=n;i++) s.insert(find(num[i])); cnt=s.size(); if(num1&gt;1)cnt+=num1-1; ll ans=mod_pow(2,cnt,mod); ans=(ans-2+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } B.CodeChef - F2NDMAXè¿™é“é¢˜å…¶å®æ˜¯ä¸€å¹…å›¾â€¦è®¾æƒ³ä¸€ä¸‹ï¼Œå¯¹äºä¸¤ä¸ªæ•°aï¼Œbï¼Œå¦‚æœ$a&gt;b$,é‚£ä¹ˆä»aè¿è¾¹æŒ‡å‘bï¼Œé‚£ä¹ˆå½“æ»¡è¶³é¢˜æ„çš„è¯¢é—®å®Œæˆåï¼Œæˆ‘ä»¬ä¸€å®šèƒ½å¾—åˆ°ä¸€å¹…å›¾ï¼Œå…¶ä¸­åªæœ‰ä¸€ä¸ªç‚¹å…¥åº¦ä¸º0ï¼Œå³æœ€å¤§çš„é‚£ä¸ªç‚¹ï¼Œé‚£ä¹ˆç¬¬äºŒå¤§çš„ç‚¹åº”å½“å°±æ˜¯å®ƒçš„ä¸€ä¸ªç›´æ¥çš„å„¿å­ã€‚ äºæ˜¯æˆ‘ä»¬å¯ä»¥å…ˆç»Ÿè®¡æ‰€æœ‰å…¥åº¦ä¸º0çš„ç‚¹ï¼Œå¯¹äºè¿™cntä¸ªç‚¹ï¼Œæˆ‘ä»¬è‡³å°‘è¦è¯¢é—®cnt-1æ¬¡æ‰èƒ½æ˜ç¡®å…¶ä¸­æœ€å¤§çš„æ•°ï¼Œç„¶åä¸ºäº†ä½¿æ€»æ¬¡æ•°æœ€å°‘ï¼Œæˆ‘ä»¬æŠŠè¿™äº›å…¥åº¦ä¸º0çš„ç‚¹çš„å„¿å­ä¸­å½“å‰å…¥åº¦ä¸º1çš„æ•°é‡ä¸¢è¿›ä¸€ä¸ªå°æ ¹å †ï¼Œç„¶åæ¯æ¬¡è¯¢é—®éƒ½åº”å½“æ‰¾å‡ºå †é¡¶æœ€å¤§çš„ä¸¤ä¸ªæ•°aï¼Œbï¼Œé‚£ä¹ˆè‡³å°‘è¦è¯¢é—®max(a,b)+1æ¬¡æ‰èƒ½æ‰¾å‡ºåˆå¹¶è¿™ä¸¤ç»„ä¹‹åç¬¬äºŒå¤§çš„æ•°ã€‚ï¼ˆä¼¼ä¹æœ‰ç‚¹æ··ä¹±ï¼Ÿï¼‰ #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn=3e5+5; int indegree[maxn], outdegree[maxn]; int main() { int t; cin &gt;&gt; t; int n,m,i,j,k; while(t--){ cin &gt;&gt; n &gt;&gt; m; memset(indegree, 0, sizeof(indegree));memset(outdegree, 0, sizeof(outdegree)); vector&lt;int&gt; adj[maxn]; while(m--) { int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adj[u].push_back(v); indegree[v]++; } for(i=1; i&lt;=n; i++) for(auto j : adj[i]) outdegree[i]+=(indegree[j]==1); int cnt=0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; for(i=1; i&lt;=n; i++) { cnt+=indegree[i]==0?1:0; if(!indegree[i]) que.push(outdegree[i]); } cnt--; while(que.size()&gt;1) { int a=que.top();que.pop(); int b=que.top();que.pop(); que.push(max(a, b)+1); } cout &lt;&lt; cnt+que.top()-1 &lt;&lt; endl; } return 0; } J.CodeChef - RINé¦–å…ˆï¼Œæˆ‘ä»¬æŠŠåˆ†æ•°è¿›è¡Œè½¬åŒ–ï¼Œå¾—åˆ°çš„åˆ†æ•°å˜æˆ100-å¾—åˆ°çš„åˆ†æ•°ï¼Œä¹Ÿå°±æ˜¯äºæŸçš„åˆ†æ•°ã€‚å¦‚æœåˆ†æ•°æ˜¯-1é‚£ä¹ˆäºæŸæ— é™å¤§ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„é—®é¢˜å…¶å®å°±å˜æˆäº†å¦‚ä½•é€‰æ‹©ä½¿å¾—äºæŸå°½å¯èƒ½çš„å°ã€‚æˆ‘ä»¬æŠŠæ¯ä¸ªè¯¾çš„æ¯ä¸ªå­¦æœŸéƒ½å»ºæˆç‚¹ï¼Œä»æºç‚¹å‘æ‰€æœ‰è¯¾çš„ç¬¬ä¸€å­¦æœŸè¿æƒå€¼ä¸ºè¯¥äºæŸçš„è¯¾ï¼Œä»ç¬¬ä¸€å­¦æœŸå‘ç¬¬äºŒå­¦æœŸè¿ç¬¬äºŒå­¦æœŸäºæŸçš„è¯¾â€¦ä¾æ¬¡ç±»æ¨ï¼Œæœ€åä¸€å­¦æœŸå‘æ±‡ç‚¹è¿å®¹é‡æ— ç©·çš„è¾¹ã€‚é‚£ä¹ˆï¼Œå¦‚æœä¸è€ƒè™‘å‰ç½®è¯¾ç¨‹çš„è¦æ±‚ï¼Œæˆ‘ä»¬ç°åœ¨çš„é—®é¢˜å…¶å®å°±æ˜¯åœ¨æ±‚å›¾çš„æœ€å°å‰²ã€‚ è€ƒè™‘åˆ°å‰ç½®è¯¾ç¨‹ï¼Œå‡è®¾aæ˜¯bçš„å‰ç½®è¯¾ç¨‹ï¼Œé‚£ä¹ˆå¯¹äºaçš„æ¯ä¸ªå­¦æœŸï¼Œæˆ‘ä»¬éƒ½å‘bçš„ä¸‹ä¸€å­¦æœŸè¿ä¸€æ¡æ— é™çš„è¾¹ç¡®ä¿bçš„å‰²ä¸ä¼šå‘ç”Ÿåœ¨aä¹‹å‰ã€‚æ³¨æ„çš„æ˜¯bçš„ç¬¬ä¸€å­¦æœŸçš„è‚¯å®šä¸èƒ½é€‰çš„ï¼Œå› æ­¤ä»æºç‚¹å‘è¯¥å­¦æœŸè¿æƒå€¼INFçš„è¾¹ã€‚ ç­”æ¡ˆå°±æ˜¯$(n* 100-maxflow)/n$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e4+50; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0;//å°å¿ƒçˆ†int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//æ³¨æ„å¦‚æœçˆ†intè¿™é‡Œåˆå§‹æœ€å¤§å€¼è¦æ›´æ”¹æœ€å¤§å€¼ flow+=f; } } int main() { int n,m,k,i,j; int x[105][105]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++){ int mar; scanf(&quot;%d&quot;,&amp;mar); if(mar==-1)x[i][j]=1&lt;&lt;30; else x[i][j]=100-mar; } for(i=1;i&lt;=n;i++){ addedge(0,(i-1)*m+1,x[i][1]); for(j=2;j&lt;=m;j++){ addedge((i-1)*m+j-1,(i-1)*m+j,x[i][j]); } addedge((i-1)*m+m,10005,1&lt;&lt;30); } while(k--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(i=1;i&lt;m;i++) addedge((a-1)*m+i,(b-1)*m+i+1,1&lt;&lt;30); addedge(0,(b-1)*m+1,1&lt;&lt;30); //addedge((a-1)*m+m,10005,1&lt;&lt;30); } double ans=n*100-maxflow(0,10005); printf(&quot;%.2f\n&quot;,ans/n); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 48 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2FCodeforces%2Feducational-codeforces-round-48-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A.æ˜æ˜¾ç­¾åˆ°ï¼Œéšä¾¿å†™ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; ll pre=0; long long sum=0; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;sum+=j; ll d=sum/m;;cout&lt;&lt;d-pre&lt;&lt;&apos; &apos;; pre=d; } return 0; } B.æ­£è§£åº”è¯¥æ˜¯æƒ³è®©ä½ é¢„å¤„ç†å­—ç¬¦ä¸²åŒ¹é…ï¼Œç„¶åæä¸ªå‰ç¼€å’Œå»å¯¹ä»˜æ¯ä¸ªè¯¢é—®ã€‚ç„¶è€Œä¸²å®åœ¨å¤ªçŸ­äº†ä»¥è‡³äºå¯¹äºæ¯æ¬¡è¯¢é—®æš´åŠ›kmpå°±å¯ä»¥è½»æ¾è¿‡ã€‚ æš´åŠ›kmpï¼š #include&lt;bits/stdc++.h&gt; using namespace std; int next1[1000005]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); while(q--) { int cnt=0; int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); string str3=str1.substr(l-1,r-l+1); int i = 0, j = 0; while (i &lt; str3.size()) { if (j == -1 || str3[i] == str2[j]) { if (j == str2.size() - 1) { cnt++;j = next1[j]; continue; } i++;j++; } else { while (j &gt;= 0 &amp;&amp; str2[j] != str3[i]) j = next1[j]; } } printf(&quot;%d\n&quot;,cnt); } return 0; } é¢„å¤„ç†å‰ç¼€å’Œç‰ˆï¼š(æ•°æ®æœ‰å‘ï¼Œä¸ä¿è¯l&gt;=1) #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; int next1[1050]; void getnext(string str) { next1[0]=-1; int k=-1,j=0; while(j&lt;str.size()-1){ if(k==-1||str[k]==str[j]){ k++;j++; next1[j]=k; } else{ k=next1[k]; } } } int sum[1050]; int main() { int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; getnext(str2); int i=0,j=0; while(i&lt;str1.size()){ if(j==-1||str1[i]==str2[j]){ if(j==str2.size()-1){ sum[i-str2.size()+2]++; j=next1[j];continue; } i++;j++; } else{ while(j&gt;=0&amp;&amp;str2[j]!=str1[i]) j=next1[j]; } } for(i=1;i&lt;=1000;i++)sum[i]+=sum[i-1]; int len=str2.size(); while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(r-len+1&gt;=l&amp;&amp;l&gt;=1) printf(&quot;%d\n&quot;,sum[r-len+1]-sum[l-1]); else printf(&quot;0\n&quot;); } return 0; } C.å…¶å®å°±æ˜¯ä¸€ä¸ªå¤æ‚ç‰ˆçš„å‰ç¼€å’Œé—®é¢˜ã€‚æˆ‘ä»¬ä¼šå‘ç°å…¶å®èµ°çš„æ–¹æ³•å°±æ˜¯æ ·ä¾‹é‡Œçš„é‚£ä¸¤ç§ï¼Œå½“ç„¶ç¬¬ä¸€ç§å¯ä»¥å…ˆèµ°ä¸‹é¢å†èµ°ä¸Šé¢ã€‚æœ€åçš„ç»“æœä¸€å®šæ˜¯å…ˆèµ°ç¬¬äºŒç§ç„¶åèµ°ç¬¬ä¸€ç§ä¸­çš„ä¸€ç§ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é¢„å¤„ç†æ¯ç§èµ°æ³•çš„å‰ç¼€å’Œã€‚ç¬¬äºŒç§æ˜¾ç„¶ä»å·¦å¾€å³é€’æ¨èµ°åˆ°æ¯ä¸ªä½ç½®çš„å‰ç¼€å’Œå³å¯ã€‚è€Œç¬¬ä¸€ç§åˆ™è¦åˆ†ä¸Šä¸‹è®¨è®ºï¼Œå¹¶ä¸”ä»ä¸åŒçš„åˆ—å¼€å§‹ç¬¬ä¸€ç§ï¼Œä»–åé¢çš„å‰ç¼€å’Œè¿˜è¦åŠ ä¸Šèµ°ç¬¬äºŒç§çš„æ—¶å€™æ‰€å¸¦æ¥çš„ç³»æ•°(sum3). sum1æ˜¯ç¬¬äºŒç§çš„å‰ç¼€å’Œï¼Œsum2ï¼Œsum4æ˜¯ç¬¬ä¸€ç§çš„ä¸¤ç§å‰ç¼€å’Œã€‚ æœ€åæšä¸¾æ¯ä¸ªä½ç½®ä¸ºç¬¬äºŒï¼Œç¬¬ä¸€ç§çš„åˆ†ç•Œç‚¹æ±‚æœ€å€¼å³å¯ã€‚ æ³¨æ„ï¼šç¬¬ä¸€ä¸ªä½ç½®çš„ç³»æ•°æ˜¯0ä¸æ˜¯1ï¼ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+5; ll sum1[maxn],sum2[maxn],a[maxn],b[maxn],sum3[maxn],sum4[maxn]; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); for(i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]); for(i=1;i&lt;=n;i++){ //ll t=0; if(i&amp;1){ sum1[i]=(i*2-2)*a[i]+(i*2-1)*b[i]; } else{ sum1[i]=(i*2-2)*b[i]+(i*2-1)*a[i]; } sum1[i]+=sum1[i-1]; } for(i=n;~i;i--){ sum3[i]+=a[i]+b[i]; sum3[i]+=sum3[i+1]; } for(i=n;i;i--){ sum2[i]+=sum2[i+1]+sum3[i+1]; sum2[i]+=b[i]*((n-i+1)*2-1); sum4[i]+=sum4[i+1]+sum3[i+1]; sum4[i]+=a[i]*((n-i+1)*2-1); } ll ans=0; // for(i=1;i&lt;=n;i++) // cout&lt;&lt;sum2[i]&lt;&lt;&apos; &apos;&lt;&lt;sum4[i]&lt;&lt;endl; for(i=0;i&lt;=n;i++){ ll t=sum1[i]; if(i&amp;1){ t+=sum4[i+1]+sum3[i+1]*(i)*2; } else t+=sum2[i+1]+sum3[i+1]*i*2; ans=max(ans,t); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D.å…¶å®åªè¦$a_1\oplus a_2\oplus â€¦a_n=b_1\oplus b_2\oplusâ€¦b_n$å°±æ˜¯ä¸€å®šå¯ä»¥çš„ã€‚ ç„¶åé™¤äº†æœ€åä¸€åˆ—åŠæœ€åä¸€è¡Œä¹‹å¤–çš„æ‰€æœ‰ä½ç½®å…¶å®éƒ½å¯ä»¥éšä¾¿æ”¾ã€‚æ ¹æ®æ”¾çš„æƒ…å†µæ¨æœ€åä¸€è¡Œæœ€åä¸€åˆ—å³å¯ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int ma[105][105]; int a[105],b[106]; int main() { int n,m,i,j,k,sum1=0,sum2=0; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);sum1^=a[i]; } for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;b[i]);sum2^=b[i]; } if(sum1!=sum2){ puts(&quot;NO&quot;);return 0; } for(i=1;i&lt;n;i++){ for(j=1;j&lt;m;j++){ ma[i][j]=1; } if((m-1)&amp;1) sum1=1; else sum1=0; ma[i][m]=a[i]^sum1; } for(i=1;i&lt;=m;i++){ sum1=0; for(j=1;j&lt;n;j++) sum1^=ma[j][i]; ma[j][i]=b[i]^sum1; } puts(&quot;YES&quot;); for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,ma[i][j],j==m?&apos;\n&apos;:&apos; &apos;); } //cout&lt;&lt;(4^2^15)&lt;&lt;&apos; &apos;&lt;&lt;(2^15)&lt;&lt;endl; return 0; } E.å¯¹äºæ¯ä¸ªç‚¹ï¼Œæˆ‘ä»¬è¿æ¥å®ƒä¸a,b. è¿™ä¸¤æ¡çº¿ä¸xè½´çš„äº¤ç‚¹å¯ä»¥æ„æˆä¸€æ¡çº¿æ®µlenï¼Œé‚£ä¹ˆï¼Œè¿™ä¸ªç‚¹åœ¨shadeä¸­çš„æ—¶é•¿å°±æ˜¯ï¼š |lenä¸­æ …æ çš„é•¿åº¦|* |abçš„é•¿åº¦|/|lençš„é•¿åº¦| è®¡ç®—ä¸­ç”¨lowerboundæ‰¾ç›¸äº¤ç‚¹ï¼Œç„¶åç”¨ç›¸ä¼¼ä¸‰è§’å½¢æ±‚è§£ã€‚ ä»£ç ä¸­ç”¨ |å³ç«¯ç‚¹çš„æ …æ å‰ç¼€å’Œ|-|å·¦ç«¯ç‚¹çš„æ …æ å‰ç¼€å’Œ| æ±‚è§£æ …æ é•¿åº¦ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;double&gt;v; const int maxn=2e5+5; double s[maxn]; int main() { double sy,a,b,l[maxn],r[maxn]; int n,i,j,k,q; scanf(&quot;%lf%lf%lf&quot;,&amp;sy,&amp;a,&amp;b); cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf&quot;,&amp;l[i],&amp;r[i]);s[i]+=s[i-1]+r[i]-l[i];//sä¸ºé¢„å¤„ç†çš„æ …æ é•¿çš„å‰ç¼€å’Œ v.push_back(l[i]);v.push_back(r[i]); } cin&gt;&gt;q; while(q--){ double x,y;scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); double pos=a-sy/(y-sy)*(x-a);//åˆ©ç”¨ç›¸ä¼¼ä¸‰è§’å½¢æ±‚çº¿ä¸xè½´çš„äº¤ç‚¹ int p=lower_bound(v.begin(),v.end(),pos)-v.begin();//æ±‚äº¤ç‚¹è½åœ¨å“ªä¸ªä½ç½® double ans=-s[p/2];//å·¦ç«¯ç‚¹å‰ç¼€å’Œ,è¦å‡å»æ‰€ä»¥å¸¦è´Ÿå· if(p&amp;1)ans-=pos-v[p-1];//å¦‚æœäº¤ç‚¹åœ¨åœ¨æ …æ ä¸­é—´,é‚£ä¹ˆè¿™ä¸ªæ …æ åœ¨äº¤ç‚¹å·¦è¾¹çš„ä¸€éƒ¨åˆ†ä¹Ÿæ˜¯è¦å‡å»çš„ pos=b-sy/(y-sy)*(x-b); p=lower_bound(v.begin(),v.end(),pos)-v.begin(); ans+=s[p/2]; if(p&amp;1)ans+=pos-v[p-1];//åŒç†ç®—å³ç«¯ç‚¹ ans=ans/y*(y-sy); printf(&quot;%.7f\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ€å¤§æƒé—­åˆå›¾]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-9d-83-e9-97-ad-e5-90-88-e5-9b-be%2F</url>
    <content type="text"><![CDATA[æ‰€è°“é—­åˆå›¾ï¼ŒæŒ‡çš„æ˜¯å›¾ä¸­æ¯ä¸ªç‚¹çš„åç»­éƒ½åœ¨å›¾ä¸­ã€‚æœ€å¤§æƒé—­åˆå›¾ï¼ŒæŒ‡çš„æ˜¯ç‚¹çš„æƒå€¼ä¹‹å’Œæœ€å¤§çš„é—­åˆå›¾ã€‚ æœ€å¤§æƒé—­åˆå›¾çš„æ±‚è§£æ–¹æ³•1.å…ˆæ„é€ ç½‘ç»œæµNï¼Œæ·»åŠ æºç‚¹sï¼Œä»såˆ°æ­£æƒå€¼ç‚¹åšä¸€æ¡è¾¹ï¼Œå®¹é‡ä¸ºç‚¹çš„æƒå€¼ã€‚ 2.æ·»åŠ æ±‡ç‚¹tï¼Œä»è´Ÿæƒå€¼ç‚¹åˆ°tåšä¸€æ¡è¾¹ï¼Œå®¹é‡ä¸ºç‚¹çš„æƒå€¼çš„ç»å¯¹å€¼ã€‚ 3.åŸæ¥çš„è¾¹çš„å®¹é‡ç»Ÿç»Ÿè®¾ä¸ºæ— ç©·å¤§ 4.æ±‚è§£æœ€å°å‰²ï¼Œæœ€å¤§æƒ=æ­£æƒå€¼ä¹‹å’Œ-æœ€å°å‰²æƒå€¼ 5.æœ€å°å‰²æ‰€äº§ç”Ÿçš„ä¸¤ä¸ªé›†åˆä¸­ï¼Œå…¶æºç‚¹Sæ‰€åœ¨é›†åˆ(é™¤å»S)ä¸ºæœ€å¤§æƒé—­åˆå›¾ã€‚ï¼ˆä¹Ÿå°±æ˜¯POJ2987æ‰€æ±‚çš„è£å‘˜ï¼‰ EX:POJ2987 å…¬å¸å®˜åƒšæˆé£ï¼Œç›˜æ ¹é”™èŠ‚ï¼ŒåŠå®äº‹çš„ç å†œæ²¡å‡ ä¸ªã€‚è€æ¿å†³å®šå¤§è£å‘˜ï¼Œæ¯å¼€é™¤ä¸€ä¸ªäººï¼ŒåŒæ—¶è¦å°†å…¶ä¸‹å±ä¸€å¹¶å¼€é™¤ï¼Œå¦‚æœè¯¥ä¸‹å±è¿˜æœ‰ä¸‹å±ï¼Œç…§æ–©ä¸è¯¯ã€‚ç»™å‡ºæ¯ä¸ªäººçš„è´¡çŒ®å€¼ï¼ˆå¯ä¸ºè´Ÿï¼‰å’Œä»å±å…³ç³»ï¼Œæ±‚æœ€å°è£å‘˜æ•°åŠæœ€å¤§è´¡çŒ®å€¼å’Œã€‚ æ¨¡æ¿é¢˜ï¼Œè®°å¾—å¼€longlongå³å¯ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=5e3+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } long long maxflow(int s,int t){ long long flow=0;//å°å¿ƒçˆ†int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); long long f; while(f=dfs(s,t,0x7f7f7f7f))//æ³¨æ„å¦‚æœçˆ†intè¿™é‡Œåˆå§‹æœ€å¤§å€¼è¦æ›´æ”¹æœ€å¤§å€¼ flow+=f; } } bool vis[maxn];int cnt=0; void dfs(int x) { vis[x]=true;cnt++; for(int i=0;i&lt;G[x].size();i++){ if(G[x][i].cap&gt;0&amp;&amp;!vis[G[x][i].to]) dfs(G[x][i].to); } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; long long sum=0; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&gt;=0){ addedge(0,i,j);sum+=j; } else{ addedge(i,5001,-j); } } for(i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b,1&lt;&lt;30); } sum-=maxflow(0,5001); dfs(0); cout&lt;&lt;cnt-1&lt;&lt;&apos; &apos;&lt;&lt;sum&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ€å°è´¹ç”¨æµ]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e8-b4-b9-e7-94-a8-e6-b5-81%2F</url>
    <content type="text"><![CDATA[æœ€å¤§æµ+SPFA #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,cost,rev;//ç»ˆç‚¹,å®¹é‡,è´¹ç”¨,åå‘è¾¹ }; vector&lt;edge&gt;G[maxn]; int dis[maxn],prevv[maxn],preve[maxn],n,m,s,t,flow=0,cost=0;//æœ€çŸ­è·¯ä¸­å‰é©±èŠ‚ç‚¹å’Œå¯¹åº”çš„è¾¹, // å°å¿ƒcostçˆ†int,å¤šç»„æ•°æ®æ—¶è®°å¾—æ¸…é›¶ bool inque[maxn]; void add(int from,int to,int cap,int cost) { G[from].push_back(edge{to,cap,cost,(int)G[to].size()}); G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//æ³¨æ„åå‘è¾¹çš„åŠ æ³•!!-costå’Œcap=0!! } bool spfa(int s,int t) { memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque)); queue&lt;int&gt;que;que.push(s);dis[s]=0; while(!que.empty()){ int t=que.front();que.pop();inque[t]=false; for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&amp;&amp;dis[e.to]&gt;dis[t]+e.cost){ dis[e.to]=dis[t]+e.cost; prevv[e.to]=t;preve[e.to]=i; if(!inque[e.to]){ que.push(e.to);inque[e.to]=true; } } } } if(dis[t]==0x3f3f3f3f)//å°å¿ƒçˆ†intçš„æƒ…å†µ return false; int d=0x7f7f7f7f; for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);//å…¨æœ€çŸ­è·¯ä¸­çš„æœ€å°æµé‡é™åˆ¶å°±æ˜¯æœ¬æ¬¡æ€»çš„æµé‡é™åˆ¶ flow+=d;cost+=d*dis[t]; for(int v=t;v!=s;v=prevv[v]){ edge&amp;e=G[prevv[v]][preve[v]];//æ›´æ–°è·¯å¾„ä¿¡æ¯ e.cap-=d; G[e.to][e.rev].cap+=d; } return true; } void mincostmaxflow(int s,int t) { while(spfa(s,t)); } int main() { int i,j; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for(i=1;i&lt;=m;i++){ int a,b,c,d; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); add(a,b,c,d); } mincostmaxflow(s,t); cout&lt;&lt;flow&lt;&lt;&apos; &apos;&lt;&lt;cost&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æœ€å¤§æµä¸äºŒåˆ†å›¾çš„ä¸€äº›ç»“è®º]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-a4-a7-e6-b5-81-e4-b8-8e-e4-ba-8c-e5-88-86-e5-9b-be-e7-9a-84-e4-b8-80-e4-ba-9b-e7-bb-93-e8-ae-ba%2F</url>
    <content type="text"><![CDATA[åŒ¹é…ï¼Œè¾¹è¦†ç›–ï¼Œç‹¬ç«‹é›†åˆé¡¶ç‚¹è¦†ç›–æ¦‚å¿µï¼š$V$ï¼šå…¨é›† åŒ¹é…â€”â€”åœ¨å›¾ä¸­ä¸¤ä¸¤æ²¡æœ‰å…¬å…±é¡¶ç‚¹çš„è¾¹çš„é›†åˆ æ³¨æ„ï¼Œå›¾ä¸­çš„åŒ¹é…æœ‰å¾ˆå¤šï¼Œä¸€æ¡è¾¹ä¹Ÿå¯ä»¥ç®—ä¸€ä¸ªåŒ¹é…ã€‚ä½†æ˜¯æœ€å¤§åŒ¹é…å´æ˜¯å¯ä»¥ç¡®å®šçš„ã€‚æœ€å¤§åŒ¹é…ä¹Ÿå°±æ˜¯è¦è®©é€‰å‡ºå°½å¯èƒ½å¤šçš„è¾¹ä½¿å¾—å®ƒä»¬ä¸¤ä¸¤ä¹‹é—´éƒ½æ²¡æœ‰äº¤ç‚¹ï¼ˆç«¯ç‚¹ï¼‰ã€‚ è¾¹è¦†ç›–â€”â€”å›¾ä¸­çš„ä»»æ„é¡¶ç‚¹éƒ½è‡³å°‘æ˜¯é›†åˆ$F$ä¸­æŸæ¡è¾¹çš„çš„ç«¯ç‚¹ï¼Œæ»¡è¶³è¿™æ ·æ¡ä»¶çš„é›†åˆçš„æœ€å°‘çš„è¾¹çš„é›†åˆ$F$ç§°ä¸ºæœ€å°è¾¹è¦†ç›– ç‹¬ç«‹é›†â€”â€”åœ¨å›¾ä¸­ä¸¤ä¸¤ä¸ç›¸è¿çš„é¡¶ç‚¹é›†åˆ æ¯”å¦‚ä¸€æ¡è¾¹$S$çš„é¡¶ç‚¹æ˜¯$S_a,S_b$,é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å°±ä¸èƒ½åŒæ—¶åœ¨ä¸€ä¸ªç‹¬ç«‹é›†ä¸­ã€‚äº‹å®ä¸Šï¼Œç‹¬ç«‹é›†ä¸­çš„ä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´éƒ½ä¸å­˜åœ¨æœ‰è¾¹ä¹‹é—´ç›¸è¿ã€‚ é¡¶ç‚¹è¦†ç›–â€”â€”å›¾ä¸­çš„ä»»æ„è¾¹éƒ½è‡³å°‘æœ‰ä¸€ä¸ªç«¯ç‚¹å±äºé›†åˆ$S$çš„é›†åˆå«åšé¡¶ç‚¹è¦†ç›– ç»“è®º(a)å¯¹äºä¸å­˜åœ¨å­¤ç«‹ç‚¹çš„å›¾ï¼Œ|æœ€å¤§åŒ¹é…|+|æœ€å°è¾¹è¦†ç›–|=|$V$|ï¼ˆè¾¹çš„å…¨é›†ï¼‰ï¼ˆå³ä»»æ„ä¸€ä¸ªé¡¶ç‚¹éƒ½è‡³å°‘åœ¨æŸæ¡è¾¹ä¸­ï¼‰ ï¼ˆbï¼‰|æœ€å¤§ç‹¬ç«‹é›†|+|æœ€å°é¡¶ç‚¹è¦†ç›–|=|$V$|ï¼ˆç‚¹çš„å…¨é›†ï¼‰ ï¼ˆcï¼‰åœ¨äºŒåˆ†å›¾ä¸­ï¼Œæœ‰ï¼š|æœ€å¤§åŒ¹é…|=|æœ€å°é¡¶ç‚¹è¦†ç›–|ï¼ˆå¯ç”¨äºæ±‚è§£äºŒåˆ†å›¾çš„æœ€å¤§ç‹¬ç«‹é›†å’Œæœ€å°é¡¶ç‚¹è¦†ç›–ï¼‰ ï¼ˆdï¼‰|å›¾çš„æœ€å¤§æµ|=|å›¾çš„æœ€å°å‰²|ï¼ˆå›¾æœ‰æºæ±‡ï¼‰]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰ç½‘ç»œæµæœ€å¤§æµ(Dinic)]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9B%BE%E8%AE%BA%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-bd-91-e7-bb-9c-e6-b5-81-e6-9c-80-e5-a4-a7-e6-b5-81dinic%2F</url>
    <content type="text"><![CDATA[æ¨¡æ¿ç»“è®ºï¼šå›¾çš„æœ€å°å‰²=å›¾çš„æœ€å¤§æµï¼ˆæœ€å¤§æµæœ€å°å‰²å®šç†ï¼‰ï¼ˆå›¾æ˜¯æœ‰æºæ±‡çš„ï¼‰ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1e5+5; struct edge{ int to,cap,rev; }; vector&lt;edge&gt;G[maxn]; int level[maxn],iter[maxn]; void addedge(int from,int to,int cap) { G[from].push_back(edge{to,cap,(int)G[to].size()}); G[to].push_back(edge{from,0,(int)G[from].size()-1});//åå‘å®¹é‡ä¸º0!! } void bfs(int s) { memset(level,-1,sizeof(level)); queue&lt;int&gt;que; level[s]=0;que.push(s); while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;G[t].size();i++){ edge e=G[t][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0){ level[e.to]=level[t]+1; que.push(e.to); } } } } int dfs(int v,int t,int f) { if(v==t)return f; for(int&amp;i=iter[v];i&lt;G[v].size();i++){//æ³¨æ„ä¼ å¼•ç”¨! edge&amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[v]&lt;level[e.to]){ int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0;//ä¸è¦æ¼äº†è¿™ä¸ª,å¾ˆå¤šæ—¶å€™å¯èƒ½æ˜¯æ— æ³•å¢å¹¿çš„ } int maxflow(int s,int t){ int flow=0;//å°å¿ƒçˆ†int for(;;){ bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while(f=dfs(s,t,0x7f7f7f7f))//æ³¨æ„å¦‚æœçˆ†intè¿™é‡Œåˆå§‹æœ€å¤§å€¼è¦æ›´æ”¹æœ€å¤§å€¼ flow+=f; } } int main() { return 0; }]]></content>
      <categories>
        <category>ç½‘ç»œæµ</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç½‘ç»œæµ</tag>
        <tag>å›¾è®º</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰åç¼€æ•°ç»„]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-90-8e-e7-bc-80-e6-95-b0-e7-bb-84%2F</url>
    <content type="text"><![CDATA[å®šä¹‰å­—ç¬¦ä¸²$s$è¿ç»­çš„ä¸€æ®µå­—ç¬¦ç»„æˆçš„ä¸²å«åšå­—ç¬¦ä¸²ï¼Œæ›´å¹¿ä¹‰åœ°ï¼Œä»»ä½•ä¸€ä¸ªç”±å¯æ¯”è¾ƒå¤§å°çš„å…ƒç´ ç»„æˆçš„æ•°ç»„éƒ½å¯ç§°ä¸ºå­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²çš„ä¸‹æ ‡ä» 1å¼€å§‹ï¼Œé•¿åº¦ä¸º$length(s)$ ã€‚ åç¼€ï¼š $suffix(i)$è¡¨ç¤ºå­—ç¬¦ä¸²$s$ä»ç¬¬$i$ä¸ªä½ç½®å¼€å§‹çš„åç¼€ï¼Œå³ç”± $s[i]-s[n] $ç»„æˆçš„å­ä¸²ã€‚ å­—ç¬¦ä¸²çš„æ¯”è¾ƒï¼š ä¸¤ä¸ªå­—ç¬¦ä¸²å¤§å°çš„æ¯”è¾ƒï¼Œä»é¦–ä½å¼€å§‹ï¼Œä¸€ä½ä¸€ä½åœ°æŒ‰ç…§ ASCII ç æ¯”è¾ƒï¼Œå¦‚æœä»æŸä½ç½®å¼€å§‹ä¸ç›¸åŒï¼Œåˆ™è®¤ä¸ºè¯¥ä½ç½®å¤„å­—ç¬¦ ASCII ç å°çš„å­—ç¬¦ä¸²å°ï¼› å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²æ¯”è¾ƒå®Œäº†æœ€åä¸€ä½ï¼Œè€Œå¦ä¸€ä¸ªæ²¡æœ‰ï¼Œåˆ™è®¤ä¸ºå‰è€…ï¼ˆé•¿åº¦å°çš„ï¼‰å°ï¼› å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦ç›¸åŒå¹¶ä¸”æ‰€æœ‰ä½ç½®ä¸Šçš„å­—ç¬¦å‡ç›¸åŒï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰ã€‚ æ³¨æ„ï¼ŒåŒä¸€ä¸ªå­—ç¬¦ä¸²çš„ä¸¤ä¸ªåç¼€æ˜¯ä¸å¯èƒ½ç›¸ç­‰çš„ï¼Œå› ä¸ºæ— æ³•æ»¡è¶³ç›¸ç­‰çš„å¿…è¦æ¡ä»¶é•¿åº¦ç›¸åŒã€‚ åç¼€æ•°ç»„ï¼š $sa$æ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œä¿å­˜äº†å¯¹å­—ç¬¦ä¸²$s$çš„æ‰€æœ‰åç¼€æ’åºåçš„ç»“æœã€‚ è¡¨ç¤ºç¬¬$i$å°çš„åç¼€åœ¨åŸä¸²ä¸­çš„èµ·å§‹ä½ç½®ã€‚ åæ¬¡æ•°ç»„ï¼š $rank$æ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼ŒæŒ‰èµ·å§‹ä½ç½®ä¿å­˜äº†æ¯ä¸ªåç¼€åœ¨ $sa$ä¸­çš„æ’åã€‚ è¡¨ç¤º$suffix(i)$çš„æ’åï¼Œå³ $rank[sa[i]]=i$ï¼ˆç¬¬$i$å°çš„åç¼€çš„æ’åä¸º$i$ï¼‰ã€‚ é«˜åº¦æ•°ç»„ï¼š æ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œä¿å­˜äº†ç›¸é‚»ä¸¤ä¸ªåç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆLongest Common Prefixï¼ŒLCPï¼‰é•¿åº¦ã€‚ $height[i]=LCP(suffix(sa[i]),suffix[sa[i-1]))$(i&gt;0) å³$height[i]$è¡¨ç¤ºåœ¨ä½ç½®$i$å­˜åœ¨æœ€å¤§çš„$x$,æ»¡è¶³$\forall k \in [0,x)$æœ‰$s[sa[i]+k]=s[sa[i-1]+k]$ æœ€é•¿å…¬å…±å‰ç¼€ é€šè¿‡é«˜åº¦æ•°ç»„$height$ ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°æ’åç›¸é‚»çš„ä¸¤ä¸ªåç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚ å¯¹äºæ’åä¸ç›¸é‚»çš„ä¸¤ä¸ªåç¼€ï¼Œå®ƒä»¬çš„å‰ç¼€çš„ç›¸ä¼¼æ€§æ¯”ç›¸é‚»åç¼€è¦å·®ã€‚æ˜¾ç„¶æ’åä¸ç›¸é‚»çš„ä¸¤ä¸ªåç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ä¸€å®šä¸ä¼šæ¯”è¿™ä¸¤ä¸ªåç¼€åœ¨åç¼€æ•°ç»„ä¸­ç¡®å®šçš„ä¸€æ®µåŒºé—´ä¸­ä»»æ„ä¸¤ä¸ªç›¸é‚»åç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦æ›´é•¿ã€‚ æ‰€ä»¥ï¼Œæ±‚å‡ºè¿™æ®µåŒºé—´å†…æœ€å°çš„$height$å€¼å³ä¸ºè¿™ä¸¤ä¸ªä¸ç›¸é‚»åç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ã€‚ é—®é¢˜è½¬åŒ–ä¸ºåŒºé—´æœ€å€¼æŸ¥è¯¢ï¼ˆRange Minimum/Maximum Queryï¼ŒRMQï¼‰é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ç¨€ç–è¡¨ï¼ˆSparse Tableï¼ŒSTï¼‰**ç®—æ³•è§£å†³ã€‚è¯¥ç®—æ³•åœ¨$O(n\ logn)$ çš„æ—¶é—´å†…é¢„å¤„ç†ï¼Œå¹¶åœ¨ $O(1) $çš„æ—¶é—´å†…å®Œæˆæ¯ä¸ªè¯¢é—®ã€‚ ä»£ç å­—ç¬¦ä¸²/æ•°ç»„ä¿å­˜åœ¨sæ•°ç»„ä¸­ï¼Œmaxnæ˜¯å­—ç¬¦ä¸²/æ•°ç»„çš„æœ€å¤§é•¿åº¦ï¼Œrkæ˜¯$rank$æ•°ç»„ï¼Œsaå°±æ˜¯$sa$æ•°ç»„ï¼Œhtæ˜¯$height$æ•°ç»„ã€‚ ï¼ˆæŒ‰ç…§æ´›è°·P3809çš„è¦æ±‚ï¼‰ #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e6+5; char s[maxn]; int rk[maxn],sa[maxn],ht[maxn]; inline void suffixArray() { int n=strlen(s+1); static int set[maxn + 1], a[maxn + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; static int fir[maxn + 1], sec[maxn + 1], tmp[maxn + 1], buc[maxn + 1]; for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; for (int t = 1; t &lt;= n; t *= 2) { for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; } for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;,s+1);int n=strlen(s+1); suffixArray(); for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,sa[i],i==n?&apos;\n&apos;:&apos; &apos;); return 0; } è¯¦ç»†å‚è€ƒï¼šåç¼€æ•°ç»„å­¦ä¹ ç¬”è®°]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å­—ç¬¦ä¸²</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training ç»„åˆæ•°å­¦]]></title>
    <url>%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-e7-bb-84-e5-90-88-e6-95-b0-e5-ad-a6%2F</url>
    <content type="text"><![CDATA[D.ç»„åˆæ•°å­¦+å®¹æ–¥åŸç† è¿™ä¸ªæ¯ä¸ªäººå¿…é¡»è¦æ‹¿ä¸€ä¸ªçš„é™åˆ¶æ¡ä»¶éå¸¸è®¨åŒâ€¦æ‰€ä»¥æˆ‘ä»¬å…ˆä¸ç®¡ä»–ã€‚ ç”±äºå„ç§ç‰¹äº§ç›¸äº’ç‹¬ç«‹ï¼Œæ‰€ä»¥å¯ä»¥å…ˆç®—ä¸€ç§ç‰¹äº§çš„åˆ†é…æ–¹æ³•â€¦ è¿™æ ·çš„è¯å°±ç›¸å½“äºæŠŠmä¸ªç›¸åŒçš„å°çƒæ”¾å…¥nä¸ªä¸åŒçš„ç›’å­é‡Œ(ç›’å­å°±æ˜¯äºº)ï¼Œç­”æ¡ˆæ˜¯$C_{m+n-1}^{\ n-1}$ï¼Œç„¶åæŠŠå„ä¸ªç‰¹äº§çš„è¿™ä¸ªå€¼ç›¸ä¹˜å¾—åˆ°ç­”æ¡ˆã€‚ éå¸¸ç§‘å­¦ï¼Œéå¸¸ä¼˜é›…å¯¹ä¸å¯¹â€¦ æ¥ä¸‹æ¥è€ƒè™‘é™åˆ¶æ¡ä»¶ï¼Œæ¯ä¸ªäººè‡³å°‘æ‹¿ä¸€ä¸ªï¼Œæˆ‘ä»¬æŠŠé™åˆ¶å»æ‰åå¾—åˆ°çš„æ˜¯è‡³å°‘0äººæ²¡æœ‰ç‰¹äº§çš„æ–¹æ¡ˆæ•°ã€‚ æ ¹æ®å®¹æ–¥åŸç† $ans=C_n^0 ans[è‡³å°‘0äººæ²¡æœ‰ç‰¹äº§]-C_n^1 ans[è‡³å°‘1äººæ²¡æœ‰ç‰¹äº§]+C_n^2 ans[è‡³å°‘2äººæ²¡æœ‰ç‰¹äº§]-â€¦â€¦+â€¦â€¦+/- C_m^m ans[è‡³å°‘mäººæ²¡æœ‰ç‰¹äº§]$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int mod=1e9+7; ll c[2005][2005]; int main() { int n,m,i,j,k; c[1][1]=c[1][0]=c[0][0]=1; for(i=2;i&lt;=2000;i++) { c[i][0]=1; for (j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//é¢„å¤„ç†ç»„åˆæ•° } } cin&gt;&gt;n&gt;&gt;m; int tc[1005]; for(i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;tc[i]);//ç‰¹äº§æ•°é‡ ll ans=0;int cur=1; for(i=0;i&lt;=n;i++){ ll temp=cur;//å®¹æ–¥åŸç†çš„ç³»æ•°(å†³å®šåŠ å‡) for(j=1;j&lt;=m;j++){ temp=(temp*c[tc[j]+n-i-1][n-i-1])%mod; } ans+=temp*c[n][i]%mod;ans%=mod; cur*=-1; } cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; return 0; } E.æˆ‘ä»¬æŠŠå·¦å³åŒºé—´åˆ†åˆ«å¤„ç†ï¼š $ r = r / k; \ l = (l - 1) / k + 1$; è¿™æ ·é—®é¢˜å°±è½¬åŒ–ä¸ºæ±‚[l,r] åŒºé—´å†…ï¼Œé€‰nä¸ªæ•°å…¶æœ€å¤§å…¬çº¦æ•°ä¸º1çš„æ–¹æ¡ˆæ•° å› ä¸º$r-l&lt;=10^5$, æ‰€ä»¥è¿™ä¸ªåŒºé—´å†…ä»»æ„ä¸¤ä¸ªä¸ç›¸ç­‰çš„æ•°çš„æœ€å¤§å…¬çº¦æ•°æœ€å¤§ä¸è¶…è¿‡$10^5$ è¯æ˜å¾ˆå¥½è¯ï¼šå› ä¸ºä¸¤ä¸ªæ•°p &gt; qçš„æœ€å¤§å…¬çº¦æ•°å¦‚æœä¸ºx,é‚£ä¹ˆ$p / x - q / x \geq 1$,é‚£ä¹ˆ$p - q \geq x$ æ‰€ä»¥å¯ä»¥æš´åŠ›æšä¸¾æ‰€æœ‰çš„æœ€å¤§å…¬çº¦æ•°,è®¾[l,r]ä¸­é€‰nä¸ªä¸å®Œå…¨ç›¸åŒçš„æ•°å…¶æœ€å¤§å…¬çº¦æ•°ä¸ºiçš„æ–¹æ¡ˆæ•°ä¸ºdp[i] é‚£ä¹ˆ[l,r]ä¸­æœ‰å¤šå°‘å«iå› å­çš„æ•°å‘¢ï¼Ÿ æ˜¾ç„¶æœ‰$t = r / i - (l - 1) / i$ä¸ªæ•° é‚£ä¹ˆ$dp[i] = t_n$ ç§æ–¹æ¡ˆï¼Œä½†æ˜¯è¿™é‡Œé¢è‚¯å®šæœ‰nä¸ªæ•°éƒ½ç›¸åŒçš„æ–¹æ¡ˆä¸€å…±æœ‰tä¸ªï¼ˆè¿™æ—¶å€™ä»–ä»¬çš„GCDå°±ä¸ä»…ä»…æ˜¯iäº†ï¼‰ï¼Œæ‰€ä»¥$dp[i] = (tn - t) mod\ p$ç§æ–¹æ¡ˆ ä½†æ˜¯è¿™ä¸ªæ—¶å€™æ±‚å‡ºçš„æ˜¯æ‰€æœ‰nä¸ªæ•°ä¸­æœ‰iå› å­çš„æ–¹æ¡ˆæ•°ï¼Œè€Œä¸æ˜¯gcd=içš„æ–¹æ¡ˆæ•°ï¼Œæ‰€ä»¥$\forall j\ dp[i] = dp[i] - dp[j](j &lt;= r - l \ and\ j | i)$ ç„¶åè¿™æ ·dp[1]å°±æ˜¯æ­£è§£äº† ä½†æ˜¯æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬çš„dp[1]æ˜¯åœ¨[l,r]ä¸­é€‰nä¸ªä¸å®Œå…¨ç›¸åŒçš„æ•°å…¶æœ€å¤§å…¬çº¦æ•°ä¸ºiçš„æ–¹æ¡ˆæ•°ï¼Œä½†æ˜¯å®é™…ä¸Š,å¦‚æœnä¸ªæ•°éƒ½ç­‰äºkçš„è¯ï¼Œé‚£ä¹ˆå…¶å®ä¹Ÿæ˜¯æ»¡è¶³è¦æ±‚çš„ã€‚ æ‰€ä»¥å½“$kâˆˆ[l,r]æ—¶ï¼Œdp[1] = dp[1] + 1$; #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int maxn=(100000 + 10); typedef long long ll; int dp[maxn]; int p = 1e9+7; ll mod_pow(ll n, ll k, ll mod) { ll re = 1; n = n % mod; while(k) { if(k &amp; 1) re = re * n % mod; k = k &gt;&gt; 1; n = n * n % mod; } return re; } int main() { int l,r,n,k; bool flag = false; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;l,&amp;r); if(k &gt;= l &amp;&amp; k &lt;= r)flag = true; r = r / k; l = (l - 1) / k; for(int i = r - l; i &gt;= 1; i --) { int t = r / i - l / i; dp[i] = (mod_pow(t, n, p) - t + p) % p; for(int j = 2; j * i &lt;= r - l; j ++) dp[i] = (dp[i] - dp[i * j] + p) % p; } if(flag == true) dp[1]++; printf(&quot;%d\n&quot;,dp[1] % p); return 0; } F.éå¸¸å¥—è·¯çš„é¢˜ç›®ï¼Œå…¶å®å°±æ˜¯è¦ä½ å¿«é€Ÿæ±‚1~xä¸­æœ‰å¤šå°‘ä¸ªæ•°è·Ÿç»™å®šçš„näº’è´¨ï¼Œé‚£ä¹ˆæŠŠnåˆ†è§£ä¸€ä¸‹è´¨å› æ•°ç„¶åç”¨å®¹æ–¥åŸç†æ±‚ä¸€ä¸‹è¿™äº›è´¨å› æ•°çš„å€æ•°çš„æ€»å’Œå°±å¯ä»¥äº† #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum(ll x,ll n) { vector&lt;ll&gt;prime; ll i,j,y=x; for(i=2;i*i&lt;=n;i++){//æ³¨æ„åˆ†è§£è¦ä»2å¼€å§‹!! if(n%i==0){ prime.push_back(i); } while(n%i==0) n/=i; } ll res=0; if(n&gt;1)prime.push_back(n); for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){//æ³¨æ„ä¸€å®šè¦ä»1å¼€å§‹!!! ll val=1,cnt=0;//äºŒè¿›åˆ¶æšä¸¾æ¯ä¸ªå› æ•°æ˜¯å¦è¦é€‰ for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1LL){ res+=y/val; } else res-=y/val; } //cout&lt;&lt;res&lt;&lt;endl; return x-res; } int main() { int t;ll a,b,n; cin&gt;&gt;t;int cnt=0; while(t--){ cnt++; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;n); printf(&quot;Case #%d: %lld\n&quot;,cnt,sum(b,n)-sum(a-1,n)); } return 0; } G.é¢˜ç›®æ±‚çš„å…¶å®å°±æ˜¯$\forall a_i\ a_ix=b(mod\ m )$ä¸­bçš„å’Œã€‚ é‚£ä¹ˆæ˜¾ç„¶bå¿…é¡»æ»¡è¶³$GCD(a_i,m)|b$,é‚£ä¹ˆæ‰€æœ‰çš„è¿™æ ·çš„bæ˜¾ç„¶éƒ½æ˜¯mçš„æŸä¸ªçº¦æ•°çš„å€æ•°ï¼ˆ mé™¤å¤–ï¼Œå› ä¸º$b\leq m-1$)ã€‚äºæ˜¯ï¼Œå¯¹äºæ¯ä¸ªaiï¼Œæˆ‘ä»¬æšä¸¾å…¶ä¸mçš„gcdä¸å„ä¸ªçº¦æ•°çš„å…³ç³»ï¼Œå¦‚æœå®ƒçš„gcdèƒ½æ•´é™¤æŸä¸ªçº¦æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªçº¦æ•°çš„æ‰€æœ‰å€æ•°éƒ½æ˜¯å¯è¡Œçš„ï¼Œå¹¶ä¸”å’Œå¯ä»¥ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼æ±‚å‡ºã€‚ä½†æ˜¯è¿™æ˜¾ç„¶å°±å¸¦æ¥äº†ä¸€ä¸ªé‡å¤çš„é—®é¢˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨æ±‚å’Œçš„è¿‡ç¨‹ä¸­è¿˜è¦ç»Ÿè®¡æ¯ä¸ªæ•°è¢«æ±‚å’Œçš„æ¬¡æ•°ï¼Œç„¶åè¿›è¡Œå¤„ç†ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; bool vis[10005]; int cnt[10005]; int gcd(int x,int y) { return y?gcd(y,x%y):x; } int main() { int t,i,j,k; cin&gt;&gt;t;int case1=0; while(t--){ case1++; int n,m;vector&lt;int&gt;ys; memset(vis,0,sizeof(vis));memset(cnt,0,sizeof(cnt)); cin&gt;&gt;n&gt;&gt;m; for(i=1;i*i&lt;=m;i++){//æ±‚mçš„çº¦æ•° if(m%i==0){ ys.push_back(i); if(i*i!=m)ys.push_back(m/i); } } sort(ys.begin(),ys.end());ys.pop_back();//ä½¿çº¦æ•°ä»å°åˆ°å¤§æ’åˆ—æ–¹ä¾¿åé¢æ±‚é‡å¤çš„é—®é¢˜ for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;k);// k=gcd(k,m); for(j=0;j&lt;ys.size();j++){ if(ys[j]%k==0) vis[j]=1;//è¿™ä¸ªçº¦æ•°åŠå…¶å€æ•°éƒ½æ˜¯å¯è¡Œçš„ } } ll ans=0; for(i=0;i&lt;ys.size();i++){ if(vis[i]&amp;&amp;cnt[i]!=1){ int last1=(m-1)/ys[i]*ys[i],num=(m-1)/ys[i]+1; ans+=(ll)(0+last1)*num/2*(1-cnt[i]); for(j=i+1;j&lt;ys.size();j++) if(ys[j]%ys[i]==0)//æ‰€æœ‰æ˜¯è¿™ä¸ªçº¦æ•°çš„å€æ•°çš„çº¦æ•°éƒ½è¢«é‡å¤è®¡æ•°äº†,æ ‡è®°ä¸€ä¸‹ cnt[j]+=1-cnt[i]; } } printf(&quot;Case #%d: %lld\n&quot;,case1,ans); //cout&lt;&lt;ans&lt;&lt;endl; } return 0; } H.é¢˜ç›®å¯ä»¥æ¯”è¾ƒæš´åŠ›çš„æ±‚è§£ï¼Œå› ä¸ºæœ‰ä¸ªç»“è®ºï¼šå¦‚æœaå’Œmäº’è´¨ï¼Œé‚£ä¹ˆ$k* m+a$å’Œ$m$ä¹Ÿäº’è´¨ï¼Œäºæ˜¯æˆ‘ä»¬æš´åŠ›æ±‚1~mçš„èŒƒå›´å†…ä¸mäº’è´¨çš„æ•°çš„ä¸ªæ•°nï¼Œç„¶åæ¯mä¸ªæ•°ä¸­å°±æœ‰nä¸ªæ•°ä¸mäº’è´¨ã€‚éœ€è¦æ³¨æ„çš„å°±æ˜¯å½“$n|k$æ—¶è¦ç‰¹åˆ¤ä¸€ä¸‹ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } int main() { ll n,m,i,j,k; while(cin&gt;&gt;m&gt;&gt;k){ vector&lt;ll&gt;rp; for(i=1;i&lt;=m;i++){ if(gcd(i,m)==1) rp.push_back(i); } ll xs=k/rp.size(); ll ans; if(k%rp.size()) ans=m*xs+rp[k%rp.size()-1]; else ans=m*(xs-1)+rp[rp.size()-1];//æ³¨æ„ç‰¹åˆ¤ printf(&quot;%lld\n&quot;,ans); } return 0; } I.éå¸¸å¥—è·¯çš„é¢˜ï¼Œæšä¸¾é›†åˆå†…çš„æ•°ç„¶åæ±‚ä¸€ä¸‹ä»–ä»¬çš„LCMï¼Œç„¶åå®¹æ–¥åŸç†æä¸€æä»–ä»¬çš„å€æ•°çš„ä¸ªæ•°å°±okäº† #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; } ll sum(ll x,vector&lt;int&gt;v) { ll res=0,i,j; for(i=1;i&lt;(1&lt;&lt;v.size());i++){ ll val=1,cnt=0; for(j=0;j&lt;v.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val=val*v[j]/gcd(val,v[j]);//ä¸€å®šè¦æ±‚LCM!é›†åˆé‡Œçš„æ•°ä¸è§å¾—ä¸¤ä¸¤äº’è´¨ cnt++; } } if(cnt&amp;1LL)res+=x/val; else res-=x/val; } return res; } int main() { ll n,m; int i,j,k; while(cin&gt;&gt;n&gt;&gt;m){ vector&lt;int&gt;v;//bool haszero=false; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);if(j)v.push_back(j); } printf(&quot;%lld\n&quot;,sum(n-1,v)); //else cout&lt;&lt;0&lt;&lt;endl; } return 0; } J.å…¶å®å°±æ˜¯æ±‚1~b/kè·Ÿ1~d/kä¸­æœ‰å¤šå°‘å¯¹äº’è´¨çš„æ•°ã€‚å‡è®¾b&gt;dï¼Œæˆ‘å¯ä»¥è®¤ä¸ºä»åä¸€ä¸ªé›†åˆä¸­æŒ‘çš„æ•°ä¸€å®šéƒ½æ˜¯æ¯”è¾ƒå°çš„æ•°ï¼ˆé¿å…é‡å¤ï¼‰ï¼Œé‚£ä¹ˆå¯¹äºäº’è´¨å¯¹(x,y),x&gt;=y,å½“x&lt;=d/kæ—¶ï¼Œå…¶å®yçš„å–å€¼å°±æ˜¯xçš„æ¬§æ‹‰å‡½æ•°å€¼ã€‚è€Œå½“d/k&lt;=x&lt;=b/kæ—¶ï¼Œå°±ç”¨ä¹‹å‰é¢˜ç›®ä¸­æ±‚è¿‡çš„é‚£ç§æ–¹å¼æ±‚1~d/kä¸­ä¸xäº’è´¨çš„æ•°çš„ä¸ªæ•°å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; ll eular(ll x) { ll res = x, a = x; for (ll i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } ll sum(ll x,ll n) { ll i,j; vector&lt;ll&gt;prime; for(i=2;i*i&lt;=n;i++){ if(n%i==0){ prime.push_back(i); while(n%i==0) n/=i; } } if(n&gt;1)prime.push_back(n); ll res=0; for(i=1;i&lt;(1LL&lt;&lt;prime.size());i++){ ll val=1;ll cnt=0; for(j=0;j&lt;prime.size();j++){ if(i&amp;(1LL&lt;&lt;j)){ val*=prime[j];cnt++; } } if(cnt&amp;1){ res+=x/val; } else res-=x/val; } return x-res; } ll phi[1000005]; void phi_table(ll n)///æ¬§æ‹‰å‡½æ•°å€¼è¡¨ { phi[1]=1; for(ll i=2; i&lt;=n; i++) { if(!phi[i]) { for(ll j=i; j&lt;=n; j+=i) { if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); } } } } int main() { int t;ll a,b,c,d,i,j,k; cin&gt;&gt;t; phi_table(100010); for(ll i=2; i&lt;=100000; i++) phi[i]+=phi[i-1];///å‰ç¼€å’Œ int cnt=0; while(t--){ ll ans=0; cnt++; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0 || k &gt; b || k &gt; d) { printf(&quot;Case %d: 0\n&quot;, cnt); continue; } if(b&lt;d)swap(b,d); b/=k;d/=k; // for(i=1;i&lt;=d;i++) // ans+=eular(i); for(i=d+1;i&lt;=b;i++) ans+=sum(d,i); printf(&quot;Case %d: %lld\n&quot;,cnt,ans+phi[d]); } return 0; }]]></content>
      <categories>
        <category>ç»„åˆæ•°å­¦</category>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
        <tag>ç»„åˆæ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰æœ€å°åœ†è¦†ç›–]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e6-9c-80-e5-b0-8f-e5-9c-86-e8-a6-86-e7-9b-96%2F</url>
    <content type="text"><![CDATA[ç®—æ³•ç›®çš„ï¼šåœ¨çº¿æ€§æ—¶é—´å¤æ‚åº¦å†…æ±‚å‡ºè¦†ç›–nä¸ªç‚¹çš„æœ€å°åœ†ç®—æ³•æ­¥éª¤ï¼šâ‘ é¦–å…ˆç°å°†æ‰€æœ‰ç‚¹éšæœºæ’åˆ— â‘¡æŒ‰é¡ºåºæŠŠç‚¹ä¸€ä¸ªä¸€ä¸ªçš„åŠ å…¥ï¼ˆä¸€æ­¥ä¸€æ­¥çš„æ±‚å‰iä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†ï¼‰ï¼Œæ¯åŠ å…¥ä¸€ä¸ªç‚¹å°±è¿›å…¥â‘¢ â‘¢å¦‚æœå‘ç°å½“å‰iå·ç‚¹åœ¨å½“å‰çš„æœ€å°åœ†çš„å¤–é¢ï¼Œé‚£ä¹ˆè¯´æ˜ç‚¹iä¸€å®šåœ¨å‰iä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†è¾¹ç•Œä¸Šï¼Œæˆ‘ä»¬è½¬åˆ°â‘£æ¥è¿›ä¸€æ­¥ç¡®å®šè¿™ä¸ªåœ†ï¼Œå¦åˆ™å‰iä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†ä¸å‰i-1ä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†æ˜¯ä¸€æ ·çš„ï¼Œåˆ™ä¸éœ€è¦æ›´æ–°ï¼Œè¿”å›â‘¡ â‘£æ­¤æ—¶å·²ç»ç¡®è®¤ç‚¹iä¸€å®šåœ¨å‰iä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†çš„è¾¹ç•Œä¸Šäº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æŠŠå½“å‰åœ†çš„åœ†å¿ƒè®¾ä¸ºç¬¬iä¸ªç‚¹ï¼ŒåŠå¾„ä¸º0ï¼Œç„¶åé‡æ–°æŠŠå‰i-1ä¸ªç‚¹åŠ å…¥è¿™ä¸ªåœ†ä¸­ï¼ˆç±»ä¼¼ä¸Šé¢çš„æ­¥éª¤ï¼Œåªä¸è¿‡è¿™æ¬¡æˆ‘ä»¬æå‰ç¡®å®šäº†ç‚¹iåœ¨åœ†ä¸Šï¼Œç›®çš„æ˜¯ä¸€æ­¥ä¸€æ­¥æ±‚å‡ºåŒ…å«ç‚¹içš„å‰jä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†ï¼‰ï¼Œæ¯åŠ å…¥ä¸€ä¸ªç‚¹å°±è¿›å…¥â‘¤ â‘¤å¦‚æœå‘ç°å½“å‰jå·ç‚¹åœ¨å½“å‰çš„æœ€å°åœ†çš„å¤–é¢ï¼Œé‚£ä¹ˆè¯´æ˜ç‚¹jä¹Ÿä¸€å®šåœ¨å‰jä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼‰çš„æœ€å°è¦†ç›–åœ†è¾¹ç•Œä¸Šï¼Œæˆ‘ä»¬è½¬åˆ°â‘¥æ¥å†è¿›ä¸€æ­¥ç¡®å®šè¿™ä¸ªåœ†ï¼Œå¦åˆ™å‰jä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼‰çš„æœ€å°è¦†ç›–åœ†ä¸å‰i-1ä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼‰çš„æœ€å°è¦†ç›–åœ†æ˜¯ä¸€æ ·çš„ï¼Œåˆ™ä¸éœ€è¦æ›´æ–°ï¼Œè¿”å›â‘£ â‘¥æ­¤æ—¶å·²ç»ç¡®è®¤ç‚¹iï¼Œjä¸€å®šåœ¨å‰jä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼‰çš„æœ€å°è¦†ç›–åœ†çš„è¾¹ç•Œä¸Šäº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æŠŠå½“å‰åœ†çš„åœ†å¿ƒè®¾ä¸ºç¬¬iä¸ªç‚¹ä¸ç¬¬jçš„ç‚¹è¿çº¿çš„ä¸­ç‚¹ï¼ŒåŠå¾„ä¸ºåˆ°è¿™ä¸¤ä¸ªç‚¹çš„è·ç¦»ï¼ˆå°±æ˜¯æ‰¾ä¸€ä¸ªè¦†ç›–è¿™ä¸¤ä¸ªç‚¹çš„æœ€å°åœ†ï¼‰ï¼Œç„¶åé‡æ–°æŠŠå‰j-1ä¸ªç‚¹åŠ å…¥è¿™ä¸ªåœ†ä¸­ï¼ˆè¿˜æ˜¯ç±»ä¼¼ä¸Šé¢çš„æ­¥éª¤ï¼Œåªä¸è¿‡è¿™æ¬¡æˆ‘ä»¬æå‰ç¡®å®šäº†ä¸¤ä¸ªç‚¹åœ¨åœ†ä¸Šï¼Œç›®çš„æ˜¯æ±‚å‡ºåŒ…å«ç‚¹iï¼Œjçš„å‰kä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†ï¼‰ï¼Œæ¯åŠ å…¥ä¸€ä¸ªç‚¹å°±è¿›å…¥â‘¦ â‘¦å¦‚æœå‘ç°å½“å‰kå·ç‚¹åœ¨å½“å‰çš„æœ€å°åœ†çš„å¤–é¢ï¼Œé‚£ä¹ˆè¯´æ˜ç‚¹kä¹Ÿä¸€å®šåœ¨å‰kä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼Œjï¼‰çš„æœ€å°è¦†ç›–åœ†è¾¹ç•Œä¸Šï¼Œæˆ‘ä»¬ä¸éœ€è¦å†è¿›ä¸€æ­¥ç¡®å®šè¿™ä¸ªåœ†äº†ï¼ˆå› ä¸ºä¸‰ä¸ªç‚¹èƒ½ç¡®å®šä¸€ä¸ªåœ†ï¼ï¼‰ï¼Œç›´æ¥æ±‚å‡ºè¿™ä¸‰ç‚¹å…±åœ†ï¼Œå¦åˆ™å‰kä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼Œjï¼‰çš„æœ€å°è¦†ç›–åœ†ä¸å‰k-1ä¸ªç‚¹ï¼ˆåŒ…æ‹¬iï¼Œjï¼‰çš„æœ€å°è¦†ç›–åœ†æ˜¯ä¸€æ ·çš„ï¼Œåˆ™ä¸éœ€è¦æ›´æ–°ã€‚ æ—¶é—´å¤æ‚åº¦ï¼šO(N) ç©ºé—´å¤æ‚åº¦ï¼šO(N) æ³¨æ„äº‹é¡¹: ä»¥ä¸Šæ—¶é—´å¤æ‚åº¦çš„è¯æ˜å…¨éƒ¨åŸºäºç‚¹çš„æ’åˆ—éšæœºï¼Œå¦‚æœç‚¹çš„æ’åˆ—ä¸éšæœºï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°†æœ‰å¯èƒ½è¾¾åˆ°O(N3) æ‰€ä»¥æœ€å°åœ†è¦†ç›–ç®—æ³•åªèƒ½åœ¨O(N)æ—¶é—´å†…æ±‚å‡ºNçš„ç‚¹çš„æœ€å°è¦†ç›–åœ†ï¼Œè€Œä¸èƒ½åœ¨O(N)çš„æ—¶é—´å†…æ±‚å‡ºæ‰€æœ‰çš„å‰iä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ† ä»£ç  ç»™å®šnä¸ªç‚¹æ±‚æœ€å°è¦†ç›–åœ†åœ†å¿ƒåŠåŠå¾„ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; const int N=505; using namespace std; struct node { double x, y; }b[N]; node O; double R; double sqr(double x) { return x * x; } double dis(node x,node y)//è·ç¦» { return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y)); } bool incircle(node x)//åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨åœ†å†… { if(dis(O,x)&lt;=R) return true; return false; } node solve(double a,double b,double c,double d,double e,double f) { node t; t.y=(f*a-c*d)/(b*d-e*a); t.x=(f*b-c*e)/(a*e-b*d); return t; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int i, j, k; for (i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;b[i].x, &amp;b[i].y); random_shuffle(b + 1, b + n + 1); R = 0;O.x=O.y=0; for (i = 1; i &lt;= n; i++) if (!incircle(b[i])) { O.x = b[i].x; O.y = b[i].y; R = 0; for (j = 1; j &lt; i; j++) if (!incircle(b[j])) { O.x = (b[i].x + b[j].x) / 2; O.y = (b[i].y + b[j].y) / 2; R = dis(O, b[i]); for (k = 1; k &lt; j; k++) if (!incircle(b[k])) { O = solve( b[i].x - b[j].x, b[i].y - b[j].y, (sqr(b[j].x) + sqr(b[j].y) - sqr(b[i].x) - sqr(b[i].y)) / 2, b[i].x - b[k].x, b[i].y - b[k].y, (sqr(b[k].x) + sqr(b[k].y) - sqr(b[i].x) - sqr(b[i].y)) / 2 ); R = dis(b[i], O); } } } printf(&quot;%.2f %.2f %.2f\n&quot;, O.x, O.y,R);//åæ ‡,åŠå¾„ } return 0; }]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰ä»»æ„å¤šè¾¹å½¢çš„é‡å¿ƒ]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e4-bb-bb-e6-84-8f-e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e9-87-8d-e5-bf-83%2F</url>
    <content type="text"><![CDATA[è®¡ç®—å¤šè¾¹å½¢é‡å¿ƒæ–¹æ³•ï¼šï¼ˆ1ï¼‰åˆ’åˆ†å¤šè¾¹å½¢ä¸ºä¸‰è§’å½¢ï¼š ä»¥å¤šè¾¹å½¢çš„ä¸€ä¸ªé¡¶ç‚¹Vä¸ºæºç‚¹ï¼ˆVå¯å–è¾“å…¥çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹ï¼‰ï¼Œä½œè¿ç»“Vä¸æ‰€æœ‰éç›¸é‚»é¡¶ç‚¹çš„çº¿æ®µï¼Œå³å°†åŸNè¾¹å½¢æˆ–åˆ†ä¸ºï¼ˆN-2ï¼‰ä¸ªä¸‰è§’å½¢ï¼› ï¼ˆ2ï¼‰æ±‚æ¯ä¸ªä¸‰è§’å½¢çš„é‡å¿ƒå’Œé¢ç§¯ï¼š è®¾æŸä¸ªä¸‰è§’å½¢çš„é‡å¿ƒä¸º$Gï¼ˆc_xï¼Œc_yï¼‰$ï¼Œé¡¶ç‚¹åæ ‡åˆ†åˆ«ä¸º$A_1ï¼ˆx_1ï¼Œy_1ï¼‰ï¼ŒA_2ï¼ˆx_2ï¼Œy_2ï¼‰ï¼ŒA_3ï¼ˆx_3ï¼Œy_3ï¼‰$ï¼Œåˆ™æœ‰$C_x = \frac{(x_1 + x_2 + x_3)}{3}$.åŒç†æ±‚å¾—cyã€‚æ±‚é¢ç§¯çš„æ–¹æ³•æ˜¯ $S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$ï¼Œå½“$A_1,A_2,A_3$é¡ºæ—¶é’ˆæ’åˆ—æ—¶å–-ï¼Œå¦åˆ™å–æ­£ï¼ˆå‰ç§¯ï¼‰ã€‚äº‹å®ä¸Šï¼Œåœ¨æ±‚æ¯ä¸ªä¸‰è§’å½¢æ—¶ä¸éœ€è¦è¾¨åˆ«æ­£è´Ÿï¼Œä¹‹åæœ‰æ–¹æ³•æŠµæ¶ˆè´Ÿå·ã€‚ ï¼ˆ3ï¼‰æ±‚åŸå¤šè¾¹å½¢çš„é‡å¿ƒï¼š å…¬å¼ï¼š$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ï¼Œå…¶ä¸­$C_{xi},C_{yi},S_i$åˆ†åˆ«æ˜¯æ‰€åˆ’åˆ†ä¸‰è§’å½¢çš„é‡å¿ƒåæ ‡å’Œé¢ç§¯ï¼›æ³¨æ„å¦‚æœåœ¨æ±‚å„ä¸ªä¸‰è§’å½¢é‡å¿ƒçš„æ—¶å€™æ²¡æœ‰é™¤ä»¥3åˆ™æœ€åè¦ç»Ÿä¸€é™¤ä»¥3ï¼› æ€»ç»“æ¯ä¸ªä¸‰è§’å½¢é‡å¿ƒï¼š$C_x = \frac{(x_1 + x_2 + x_3)}{3}$ï¼›cyåŒç†ã€‚ æ¯ä¸ªä¸‰è§’å½¢é¢ç§¯ï¼š$S = \frac{( (x_2 - x_1) \times (y_3 - y_1) - (x_3 - x_1) \times (y_2 - y_1) )}{ 2}$ï¼› å¤šè¾¹å½¢é‡å¿ƒï¼š$C_x=\frac{\sum (C_{xi}\times S_i)}{\sum S_i}$ $C_y=\frac{\sum (C_{yi}\times S_i)}{\sum S_i}$ ä»£ç  ç»™å®šä¸€ä¸ªnè¾¹å½¢ï¼Œæ±‚é‡å¿ƒåæ ‡ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;double,double&gt;P; P node[105]; P mass_node(P a,P b,P c)//æ±‚é‡å¿ƒ { return P((a.first+b.first+c.first)/3,(a.second+b.second+c.second)/3); } double square(P a,P b,P c)//æ±‚é¢ç§¯ { double s = ((b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second)) / 2; return s; } int main() { int n,i,j,k;int cnt=0; while(cin&gt;&gt;n&amp;&amp;n){ cnt++; for(i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].first,&amp;node[i].second); vector&lt;P&gt;mass;vector&lt;double&gt;s; double tots=0; for(i=2;i&lt;n;i++){ P t=mass_node(node[1],node[i],node[i+1]);mass.push_back(t);//åˆ’åˆ†ä¸‰è§’å½¢æ±‚é‡å¿ƒ double s1=square(node[1],node[i],node[i+1]);s.push_back(s1);//æ±‚é¢ç§¯ tots+=s1; } double cx=0,cy=0; for(i=0;i&lt;mass.size();i++){ cx+=mass[i].first*s[i];cy+=mass[i].second*s[i];//æ±‚å¤šè¾¹å½¢é‡å¿ƒ } cout&lt;&lt;&quot;Stage #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;; printf(&quot;%.6f %.6f\n&quot;,cx/tots,cy/tots); } return 0; }]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summer Training #2]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%AF%94%E8%B5%9B%E6%9D%82%E9%9B%86%2F%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%2F2018-summer-training-2%2F</url>
    <content type="text"><![CDATA[A. æœ‰ä¸¤ä¸ªæ•°ç»„Aï¼ŒBï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸€ä¸ªAï¼ŒBä¸­å‡ºç°è¿‡çš„æ•°å­—xå¹¶å°†å®ƒæ›¿æ¢ä¸ºå¦ä¸€ä¸ªéšæ„çš„æ•°yï¼Œä¸€æ¬¡æ“ä½œä¼šæŠŠAï¼ŒBä¸­çš„æ‰€æœ‰çš„xéƒ½æ¢æˆyï¼Œå¹¶ä¸”ï¼Œæœ€ååº”å½“ä½¿å¾—Aï¼ŒBå®Œå…¨ç›¸ç­‰ï¼Œå³å¯¹åº”ä½ä¸Šçš„æ•°ä¸€æ ·ã€‚åŒæ—¶ï¼Œé—®åœ¨æ“ä½œæ•°æœ€å°‘æ—¶æœ‰å¤šå°‘ç§æ“ä½œçš„æ–¹æ³•ã€‚ é¦–å…ˆï¼Œåº”è¯¥æƒ³åˆ°çš„ä¸€ç‚¹æ˜¯å› ä¸ºä¸€ä¸ªæ•°å¯èƒ½é‡å¤å‡ºç°å¾ˆå¤šæ¬¡ï¼Œè€Œä»–åœ¨ä¸åŒä½ç½®å‡ºç°æ—¶ä¸ä»–åŒä¸€ä½ç½®çš„ä¸åŒæ•°ç»„çš„æ•°å¾ˆå¯èƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œè¿™å°±æ„å‘³ç€æ‰€æœ‰çš„è¿™äº›æ•°æœ€åæ˜¯è¦å˜æˆä¸€ä¸ªç›¸åŒçš„æ•°çš„ã€‚é‚£ä¹ˆä¸ºäº†ç¡®å®šæœ‰å¤šå°‘ç»„è¿™æ ·æœ€åè¦å˜æˆä¸€æ ·çš„æ•°ï¼Œå¯ä»¥æœç´ æˆ–è€…å¹¶æŸ¥é›†æä¸€æ³¢ã€‚æ³¨æ„çš„æ˜¯æ¯ä¸€ç»„é‡Œé¢å¦‚æœæœ‰nä¸ªæ•°ï¼Œé‚£ä¹ˆä»–åªéœ€è¦åšn-1æ¬¡å˜æ¢ã€‚ å¯¹äºç¬¬äºŒé—®ï¼Œé¦–å…ˆæˆ‘ä»¬å‡è®¾è¿™ä¸€ç»„ä¸­æœ‰nä¸ªæ•°ï¼ˆç›¸åŒçš„æ•°æœç´¢çš„æ—¶å€™ä¼šè¢«åˆå¹¶ï¼Œæ‰€ä»¥è®¡ç®—çš„æ—¶å€™è‚¯å®šä¸ä¼šæœ‰é‡å¤ï¼‰ï¼Œé‚£ä¹ˆæœ€åå˜æˆçš„æ•°å°±æœ‰nç§é€‰æ‹©ï¼Œè¿™ä¸ªæ•°ç¡®å®šäº†ä»¥åï¼Œå¯¹äºå…¶ä½™n-1ä¸ªæ•°è€Œè¨€ï¼Œä»–ä»¬å…ˆåå˜æ¢ä¸€æ¬¡ï¼ˆä¸ä¸€å®šä¸€æ¬¡å°±å˜ä¸ºé€‰å®šçš„è¿™ä¸ªæ•°ï¼‰ï¼Œé‚£ä¹ˆå¯èƒ½æœ‰$(n-1)!$ç§ã€‚åŒæ—¶ï¼Œæ¯ä¸ªæ•°å˜æ¢çš„æ—¶å€™ä¸€å®šæ˜¯å˜ä¸ºè¿™ä¸€ç»„ä¸­å‰©ä¸‹æ•°ä¸­çš„ä¸€ä¸ªï¼ˆæ¯å½“ä¸€ä¸ªæ•°å‘ç”Ÿäº†å˜æ¢ï¼Œä»–å°±æ°¸ä¹…ä»æ•°ç»„ä¸­æ¶ˆå¤±äº†ï¼Œå› ä¸ºæˆ‘ä»¬è¦æ±‚æ€»æ“ä½œæ¬¡æ•°æœ€å°‘ï¼‰ï¼Œæ‰€ä»¥å¯¹äºç¬¬ä¸€ä¸ªå˜çš„æ•°è€Œè¨€ï¼Œå®ƒçš„é€‰æ‹©æ˜¯$n-1$ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯$n-2$â€¦ï¼Œå› æ­¤ï¼Œæ¯ä¸€ç»„å¤§å°ä¸ºnçš„æ•°çš„å¯èƒ½æ˜¯$n\times (n-1)!\times (n-1)!$ç§ã€‚è€Œå¯¹äºå…¨ä½“æ•°è€Œè¨€ï¼Œæˆ‘ä»¬çš„å…ˆåé¡ºåºæ˜¯æ— æ‰€è°“çš„ï¼Œæ‰€ä»¥å¯èƒ½æ•°åº”è¯¥æ˜¯$m!$,ä½†æ˜¯å› ä¸ºå¯¹äºæ¯ä¸€ç»„æ•°ï¼Œå…¶å†…éƒ¨çš„é¡ºåºå·²ç»è®¡ç®—è¿‡äº†ä¸€æ¬¡ï¼Œæ ¹æ®é™¤æ³•åŸç†ï¼Œæ¯ä¸€ç»„å¤§å°ä¸ºnçš„æ•°éƒ½ä¼šå¸¦æ¥$(n-1)!$çš„é‡å¤ï¼Œæ‰€ä»¥åº”å½“é™¤å»ã€‚æ‰€ä»¥æœ€åæ€»çš„å¯èƒ½æ•°å°±æ˜¯$\prod {n!}\ \times m!$ ä»£ç #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int mod=1e9+7; vector&lt;int&gt; G[maxn]; bool vis[maxn]; ll fac[maxn]; int cnt; void dfs(int u) { vis[u]=true;cnt++; for(auto a:G[u]) if(!vis[a]) dfs(a); } int main() { fac[0] = 1;int t; cin &gt;&gt; t; while (t--) { for (int i = 0; i &lt; maxn; i++) { G[i].clear(); } memset(vis,0,sizeof(vis)); for (int i = 1; i &lt; maxn; i++) fac[i] = (fac[i - 1] * i) % mod; int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = 0; ll a[maxn], b[maxn]; for (int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;,&amp;b[i]); if (b[i] != a[i]) { G[a[i]].push_back(b[i]);G[b[i]].push_back(a[i]); } } ll ans1 = 1; for (int i = 0; i &lt; n; i++) { if (vis[a[i]])continue; cnt = 0;dfs(a[i]); ans += (cnt - 1); ans1 = ans1 * fac[cnt] % mod; } ans1 = ans1 * fac[ans] % mod; cout &lt;&lt; ans &lt;&lt; &quot; &quot;; if (k == 2)cout &lt;&lt; ans1; cout &lt;&lt; endl; } return 0; } D.ç”»ç”»å›¾å¤§èƒ†çŒœç»“è®ºå•Šï¼Œå…¶å®æˆ‘ä»¬ä¼šå‘ç°å¦‚æœä¸€ä¸ªå›¾å½¢èƒ½è¢«åˆ†å‰²ä¸ºæœ‰é™ä¸ªå¹³è¡Œå››è¾¹å½¢çš„è¯ï¼Œé‚£ä¹ˆå®ƒä¸€å®šå¯ä»¥è¢«åˆ†å‰²ä¸ºéšæ„æ•°é‡çš„æ›´å¤šçš„å¹³è¡Œå››è¾¹å½¢ï¼ˆåœ¨åˆ†å‰²å¥½çš„å¹³è¡Œå››è¾¹å½¢é‡Œé¢ä¸æ–­åšå¹³è¡Œçº¿ä¸å°±å¥½äº†ï¼‰ã€‚å› æ­¤å°±æ˜¯è¦åˆ¤æ–­ä¸€ä¸ªå›¾å½¢èƒ½ä¸èƒ½åˆ†æˆè‹¥å¹²ä¸ªå¹³è¡Œå››è¾¹å½¢ã€‚ çŒœç»“è®ºï¼šæ¯æ¡è¾¹è‡³å°‘æœ‰å¦å¤–ä¸€æ¡è¾¹ä¸å…¶å¹³è¡Œä¸”é•¿åº¦ç›¸ç­‰ã€‚ è®¡ç®—æ–œç‡çš„æ—¶å€™ä¸ºäº†é¿å…åˆ†æ¯ä¸º0è¦æ³¨æ„ä¸€ä¸‹ã€‚ ä»£ç #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,ll&gt;P; const double eps=1e-6; int main() { int n,i,j,k; cin&gt;&gt;n; vector&lt;P&gt;v; for(i=1;i&lt;=n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b);v.push_back(P(a,b));//è¾¹ } vector&lt;P&gt;xl;vector&lt;double&gt;len; for(i=0;i&lt;v.size();i++){ xl.push_back(P(v[(i+1)%n].first-v[i].first, v[(i+1)%n].second-v[i].second));//æ–œç‡(é˜²æ­¢åˆ†æ¯0æ²¡æœ‰ç›´æ¥é™¤) len.push_back(sqrt((v[(i+1)%n].first-v[i].first) * (v[(i+1)%n].first-v[i].first) + (v[(i+1)%n].second-v[i].second)*(v[(i+1)%n].second-v[i].second)));//è¾¹é•¿åº¦ } for(i=0;i&lt;xl.size();i++){ bool isok=false; for(j=0;j&lt;xl.size();j++){//æš´åŠ›æšä¸¾ if(i==j)continue; if(xl[i].first*xl[j].second==xl[i].second*xl[j].first&amp;&amp;fabs(len[i]-len[j])&lt;eps){ isok=true;break; } } if(!isok){ puts(&quot;no&quot;);return 0; } } puts(&quot;yes&quot;); return 0; } H.é¦–å…ˆæ˜ç¡®ä¸€ç‚¹ï¼Œå³é¢˜ç›®ä¸­ç»™çš„å‡½æ•°$f(l,r)$ä»–çš„å€¼æ˜¯å”¯ä¸€ç¡®å®šçš„ï¼ˆ$ï¼ˆlï¼Œrï¼‰$ä»£è¡¨å…¶å·¦å³è¾¹ç•Œä½ç½®ï¼‰ï¼Œä½†æ˜¯æˆ‘ä»¬è¦æ±‚çš„æ˜¯åœ¨$(l,r)$èŒƒå›´å†…çš„æ‰€æœ‰$f(l_1,r_1)$çš„æœ€å¤§å€¼ï¼Œè¿™å°±ä¸ç¡®å®šäº†ã€‚å› æ­¤æƒ³æ³•å¾ˆç®€å•ï¼šå…ˆç®—å‡ºæ‰€æœ‰çš„$f$ï¼Œç„¶ååŒºé—´dpæ±‚ç­”æ¡ˆã€‚ å½“ç„¶ï¼Œé¦–å…ˆè¦ç®€å•å†™å†™ï¼Œæ¨å‡ºå…¬å¼ï¼š $f(l,r)=f(l,r-1)\ \oplus\ f(l+1,r)=f(l,r-2)\ \oplus\ f(l+2,r)$ï¼ˆæ‹¿å“ªä¸ªå…¬å¼æ¥æ¨éƒ½æ²¡é—®é¢˜ï¼‰ ä»£ç #include&lt;bits/stdc++.h&gt; using namespace std; int num[5005][5005],f[5005][5005]; int main() { int n,i,j,k,len; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ cin&gt;&gt;num[i][i];f[i][i]=num[i][i]; num[i-1][i]=num[i-1][i-1]^num[i][i]; } for(len=2;len&lt;n;len++) for(i=1;i+len&lt;=n;i++){ num[i][i+len]=num[i][i+len-2]^num[i+2][i+len]; } for(len=1;len&lt;n;len++){ for(i=1;i+len&lt;=n;i++){ f[i][i+len]=max(num[i][i+len],max(f[i+1][i+len],f[i][i+len-1]));//æ³¨æ„è¿™é‡Œçš„æ¯”è¾ƒ } } int q,l,r; cin&gt;&gt;q; while(q--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\n&quot;,f[l][r]); } return 0; } I. ç»™å®šä¸¤ä¸ªç­‰é•¿æ•°ç»„Aï¼ŒBï¼Œè¦æ±‚å¯¹äºæ¯ä¸ª$a_i$,åœ¨Bä¸­æ‰¾ä¸€ä¸ªæ•°ä¸å…¶å¼‚æˆ–ï¼Œå¹¶ä¸”Bä¸­æ¯ä¸ªæ•°åªèƒ½ç”¨ä¸€æ¬¡ï¼Œæ±‚å¼‚æˆ–åå­—å…¸åºæœ€å°çš„Aæ•°ç»„ æ˜¾ç„¶å°±æ˜¯å¯¹Aä»å‰å¾€åæ‰¾å®ƒå¼‚æˆ–åæœ€å°çš„bå°±è¡Œäº†å‘€ï¼Œä¸ºäº†æ‰¾å‡ºæœ€å°çš„bï¼Œå»ºç«‹ä¸€æ£µäºŒè¿›åˆ¶trieæ ‘å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; const int maxn=3e6+5; struct node{ int sum; node*next1[2]; bool tag,ask; node(){//æ–°å»ºå‡½æ•° sum=0;tag=false;ask=false;next1[0]=next1[1]=NULL; } }*root=new node(); void add(int x) { int i,j; struct node*p=root; for(i=30;~i;i--) { if((1&lt;&lt;i)&amp;x){ if(!p-&gt;next1[1]) { node*t=new node(); p-&gt;next1[1] = t; } p=p-&gt;next1[1]; } else { if(!p-&gt;next1[0]) { node*t=new node(); p-&gt;next1[0] = t; } p=p-&gt;next1[0]; } p-&gt;sum++; } } int query(int x) { int i,j;node*p=root,*pre; int res=0; for(i=30;~i;i--){ pre=p; if((1&lt;&lt;i)&amp;x){ if(p-&gt;next1[1]&amp;&amp;p-&gt;next1[1]-&gt;sum) p=p-&gt;next1[1],res=res&lt;&lt;1|1; else p=p-&gt;next1[0],res&lt;&lt;=1; } else{ if(p-&gt;next1[0]&amp;&amp;p-&gt;next1[0]-&gt;sum) p=p-&gt;next1[0],res&lt;&lt;=1; else p=p-&gt;next1[1],res=res&lt;&lt;1|1; } p-&gt;sum--; } return res; } int main() { int n,i,j,k; cin&gt;&gt;n;int a[maxn]; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j);add(j); } for(i=1;i&lt;=n;i++){ int ans=query(a[i]);ans^=a[i]; cout&lt;&lt;ans&lt;&lt;&apos; &apos;; } return 0; } J. ç»™å®šnä¸ªå½¢å¦‚$y=(x-a_i)^2+b_i$çš„æŠ›ç‰©çº¿ï¼Œæ±‚å®ƒä»¬åˆ’åˆ†å¹³é¢çš„åŒºåŸŸæ•°ã€‚ æ³¨æ„åˆ°ç»™å®šçš„æŠ›ç‰©çº¿éƒ½æ˜¯åŒä¸€ç§å½¢å¼çš„ï¼Œå½“$a_i\neq a_j$æ—¶ï¼Œè¿™ä¸¤ä¸ªæŠ›ç‰©çº¿å°±æœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå¦åˆ™æ²¡æœ‰ã€‚å› æ­¤å¯ä»¥ç±»æ¯”ç›´çº¿åˆ’åˆ†å¹³é¢æ¥åšï¼šå¯¹äºæ¯ä¸€æ¡æ–°çš„æŠ›ç‰©çº¿ï¼Œæˆ‘ä»¬è®¡ç®—å®ƒä¸ä¹‹å‰æŠ›ç‰©çº¿çš„äº¤ç‚¹æ•°ï¼Œå®ƒåˆ’åˆ†å‡ºæ¥çš„æ–°åŒºåŸŸæ•°å°±æ˜¯ï¼ˆäº¤ç‚¹æ•°+1ï¼‰ã€‚æ³¨æ„æŸ¥é‡ï¼Œå³äº¤ç‚¹é‡å¤é—®é¢˜ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; pair&lt;int,int&gt; p[1010]; pair&lt;double,double&gt; s[1010]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second); sort(p + 1, p + n + 1); n = unique(p + 1, p + n + 1) - p - 1; int ans = 1; for (int i = 1; i &lt;= n; i++) { int tot = 0; for (int j = 1; j &lt; i; j++) if (p[i].first != p[j].first) { double x = (double) (p[i].first * p[i].first + p[i].second - p[j].first * p[j].first - p[j].second) / (2 * (p[i].first - p[j].first)); double y = (double) (x - p[i].first) * (x - p[i].first) + p[i].second; s[++tot] = make_pair(x, y); } sort(s + 1, s + tot + 1); tot = unique(s + 1, s + tot + 1) - s - 1; ans += tot + 1; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¯”èµ›æ‚é›†</category>
        <category>æš‘å‡è®­ç»ƒ</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¯”èµ›æ‚é›†</tag>
        <tag>æš‘å‡è®­ç»ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰çŸ©é˜µå¿«é€Ÿå¹‚]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e7-9f-a9-e9-98-b5-e5-bf-ab-e9-80-9f-e5-b9-82%2F</url>
    <content type="text"><![CDATA[çŸ©é˜µä¹˜æ³•çš„è®¡ç®—å…¬å¼ï¼šï¼ˆç¬¬ä¸€ä¸ªçŸ©é˜µä¸ºm s,ç¬¬äºŒä¸ªä¸ºs nï¼Œç»“æœä¸ºm* nçŸ©é˜µï¼‰ $C_{ij}=\sum a_{ik}\times b_{kj}$ æš´åŠ›è®¡ç®—ä»£ç ï¼ˆæ¨¡æ‹Ÿï¼‰ï¼š const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//næ˜¯çŸ©é˜µå¤§å°ï¼Œn&lt;N { memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } çŸ©é˜µå¿«é€Ÿå¹‚ ç»™å®š$n\times n$çš„çŸ©é˜µ$A$ï¼Œæ±‚$A^k$ #include&lt;bits/stdc++.h&gt; using namespace std; const int mod=1e9+7; const int maxn=105; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//æš´åŠ›è®¡ç®—çŸ©é˜µä¹˜æ³•,Nä¸ºçŸ©é˜µå¤§å° { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////næ˜¯å¹‚ï¼ŒNæ˜¯çŸ©é˜µå¤§å° { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01çŸ©é˜µ while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;å¤åˆ¶ç›´æ¥åœ¨multié‡Œé¢å®ç°äº†ï¼› multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn],k; cin&gt;&gt;n&gt;&gt;k;//nä¸ºçŸ©é˜µå¤§å°,kä¸ºå¹‚æ¬¡ for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cin&gt;&gt;matrci[i][j]; Pow(matrci,k,n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,res[i][j],j==n?&apos;\n&apos;:&apos; &apos;); return 0; } åº”ç”¨ä¸»è¦é€šè¿‡æŠŠæ•°æ”¾åˆ°çŸ©é˜µçš„ä¸åŒä½ç½®ï¼Œç„¶åæŠŠæ™®é€šé€’æ¨å¼å˜æˆâ€çŸ©é˜µçš„ç­‰æ¯”æ•°åˆ—â€ï¼Œæœ€åå¿«é€Ÿå¹‚æ±‚è§£é€’æ¨å¼ï¼› POJ3070 é¢˜ç›®ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—f(n),ç»™ä¸€ä¸ªnï¼Œæ±‚f(n)%10000,n&lt;=1e9; (è¿™é¢˜æ˜¯å¯ä»¥ç”¨fiboçš„å¾ªç¯èŠ‚å»åšçš„ï¼Œä¸è¿‡è¿™é‡Œä¸è®²ï¼Œåæ­£æ˜¯æ°´é¢˜) çŸ©é˜µå¿«é€Ÿå¹‚æ˜¯ç”¨æ¥æ±‚è§£é€’æ¨å¼çš„ï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥å…ˆè¦åˆ—å‡ºé€’æ¨å¼: $ f(n)=f(n-1)+f(n-2)$ ç¬¬äºŒæ­¥æ˜¯å»ºç«‹çŸ©é˜µé€’æ¨å¼ï¼Œæ‰¾åˆ°è½¬ç§»çŸ©é˜µ: $\binom{1\ 1}{1\ 0}\times \binom{f_{n-1}}{f_{n-2}}=\binom{f_n}{f_{n-1}}$ æ‰€ä»¥é€šé¡¹å°±æ˜¯ï¼š$A_n=T^{n-1}\times A_1\ $,$\ T$å°±æ˜¯é‚£ä¸ªè½¬ç§»çŸ©é˜µã€‚ é‚£ä¹ˆæˆ‘ä»¬è¦æ±‚çš„å…¶å®å°±æ˜¯res[1][1]; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int mod=1e4; const int maxn=5; typedef long long ll; ll tmp[maxn][maxn]; void multi(ll a[][maxn],ll b[][maxn],int N)//æš´åŠ›è®¡ç®—çŸ©é˜µä¹˜æ³•,Nä¸ºçŸ©é˜µå¤§å° { memset(tmp,0,sizeof tmp); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) for(int k=1;k&lt;=N;k++) tmp[i][j]+=a[i][k]*b[k][j]%mod,tmp[i][j]%=mod; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) a[i][j]=tmp[i][j]; } ll res[maxn][maxn]; void Pow(ll a[][maxn],ll n,int N)////næ˜¯å¹‚ï¼ŒNæ˜¯çŸ©é˜µå¤§å° { memset(res,0,sizeof res); for(int i=1;i&lt;=N;i++) res[i][i]=1;//01çŸ©é˜µ while(n) { if(n&amp;1) multi(res,a,N);//res=res*a;å¤åˆ¶ç›´æ¥åœ¨multié‡Œé¢å®ç°äº†ï¼› multi(a,a,N);//a=a*a n&gt;&gt;=1; } } int main() { int n,i,j;ll matrci[maxn][maxn]={0},k; while(cin&gt;&gt;n&amp;&amp;n!=-1){ if(n==0){ cout&lt;&lt;0&lt;&lt;endl;continue; } matrci[1][1]=1,matrci[1][2]=1,matrci[2][1]=1,matrci[2][2]=0; Pow(matrci,n-1,2); ll fibo[5][5]={0};fibo[1][1]=1; multi(res,fibo,2); cout&lt;&lt;res[1][1]&lt;&lt;endl; } return 0; } ç®€å•é€’æ¨å¼ï¼š $1.\ f(n)=a\times f(n-1)+b\times f(n-2)+c\ $ (a,b,cä¸ºå¸¸æ•°) $\binom{a\ b\ 1}{\binom{1\ 0\ 0}{0\ 0\ 1}}\times \binom{f_{n-1}}{\binom{f_{n-2}}{c}}=\binom{f_{n}}{\binom{f_{n-1}}{c}}$(å› ä¸ºçŸ©é˜µæœ‰ç‚¹é—®é¢˜æ‰€ä»¥æš‚æ—¶è¿™æ ·) $2.f(n)=c^n-f(n-1)$ï¼ˆcæ˜¯å¸¸æ•°ï¼‰ $\binom{-1\ c}{0\ \ c}\times \binom{f_{n-1}}{c^{n-1}}=\binom{f_n}{c^n}$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰çº¿æ€§åŒä½™æ–¹ç¨‹ç»„ï¼ˆä¸­å›½å‰©ä½™å®šç†ï¼‰]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b-e7-bb-84-ef-bc-88-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86-ef-bc-89%2F</url>
    <content type="text"><![CDATA[ä¸­å›½å‰©ä½™å®šç†æ±‚åŒä½™æ–¹ç¨‹ç»„ $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $â€¦$ $x\equiv c_k(mod\ m_k)$ å…¶ä¸­ï¼Œ$\forall i,j$æœ‰$gcd(m_i,m_j)=1$, çš„æœ€å°æ­£æ•´æ•°ï¼ˆéè´Ÿæ•´æ•°ï¼‰è§£ï¼› ç»“è®ºä»¤$M=m_1\times m_2\times â€¦\times m_k$ï¼Œ åˆ™$x=(\sum c_i\times \frac{M}{m_i}\times inv(\frac{M}{m_i},m_i))$; å…¶ä¸­,$inv(\frac{M}{m_i},m_i)$å³$\frac{M}{m_i}$ç›¸å¯¹äº$m_i$çš„ä¹˜æ³•é€†å…ƒã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; ll extgcd(ll a,ll b,ll&amp;x,ll&amp;y) { if(b==0){ x=1,y=0;return a;//è¿”å›çš„æ˜¯åˆå§‹æ—¶a,bçš„æœ€å¤§å…¬çº¦æ•° } ll d=extgcd(b,a%b,x,y); ll z=x;x=y;y=z-y*(a/b); return d; } int main() { ll n,a,b,i,j,m[20],k[20];//mä¸ºå„ä¸ªæ¨¡æ•°,kä¸ºä½™æ•° cin&gt;&gt;n; ll M=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;m[i]&gt;&gt;k[i]; M*=m[i];//æ±‚M } ll x,y;ll X=0; for(i=1;i&lt;=n;i++){ ll a=M/m[i];ll b=m[i]; extgcd(a,b,x,y); x=(x+b)%b; if(!x)x+=b; X+=k[i]*a*x; } X%=M; } æ¨¡æ¿é¢˜ æ‰©å±•ä¸­å›½å‰©ä½™å®šç†æ±‚åŒä½™æ–¹ç¨‹ç»„ $x\equiv c_1(mod\ m_1)$ $x\equiv c_2(mod\ m_2)$ $â€¦$ $x\equiv c_k(mod\ m_k)$ çš„æœ€å°æ­£æ•´æ•°ï¼ˆéè´Ÿæ•´æ•°ï¼‰è§£ï¼›ï¼ˆå³åˆ å»äº†æ¨¡æ•°äº’è´¨çš„æ¡ä»¶ï¼‰ ç»“è®ºå¯¹äºä¸¤ä¸ªæ–¹ç¨‹ $x\equiv c_1(mod\ m_1)$åŠ$x\equiv c_2(mod\ m_2)$ï¼Œå°†å…¶åˆå¹¶ä¸ºä¸€ä¸ªæ–¹ç¨‹ï¼Œæœ‰è§£æ¡ä»¶ä¸º$gcd(m_1,m_2)|(c_2-c_1)$. é‚£ä¹ˆï¼ˆæœ‰è§£æ—¶ï¼‰ï¼Œ$m=\frac{m_1\times m_2}{gcd(m_1,m_2)}$, $c=(inv(\frac{m_1}{gcd(m_1,m_2)},\frac{m_2}{gcd(m_1,m_2)})\times \frac{c_2-c_1}{gcd(m_1,m_2)}\ mod \ \frac{m_2}{gcd(m_1,m_2)}\times m_1+c_1$ï¼Œ å¦‚æ­¤ä»å‰å¾€åé€’æ¨ä¸‹å»ï¼Œç›´åˆ°æ±‚å‡ºä¸€ä¸ªå¼å­ï¼š $x\equiv c(mod\ m)$ï¼Œ é‚£ä¹ˆåŸæ–¹ç¨‹ç»„çš„ä¸€ä¸ªè§£å³ä¸º$x=c\ mod\ m$ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; const int N=1005; int k; ll c[N],m[N],c1,c2,m1,m2,t;//cä¸ºä½™æ•°,mä¸ºæ¨¡æ•° bool flag; ll gcd(ll a,ll b) { if (!b) return a; else return gcd(b,a%b); } void exgcd(ll a,ll b,ll &amp;x,ll &amp;y) { if (!b) x=1LL,y=0LL; else exgcd(b,a%b,y,x),y-=a/b*x; } ll inv(ll a,ll b) { ll x=0LL,y=0LL; exgcd(a,b,x,y); x=(x%b+b)%b; if (!x) x+=b; return x; } int main() { while (~scanf(&quot;%d&quot;,&amp;k))//åŒä½™æ–¹ç¨‹ä¸ªæ•° { flag=true; for (int i=1;i&lt;=k;i++) scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;c[i]); for (int i=2;i&lt;=k;i++) { m1=m[i-1],m2=m[i],c1=c[i-1],c2=c[i]; t=gcd(m1,m2); if ((c2-c1)%t!=0) { flag = false; break;//ä¸æ•´é™¤åˆ™æ— è§£ } m[i]=m1*m2/t; c[i]=inv(m1/t,m2/t)*((c2-c1)/t)%(m2/t)*m1+c1; c[i]=(c[i]%m[i]+m[i])%m[i]; } if (!flag) puts(&quot;-1&quot;); else printf(&quot;%lld\n&quot;,c[k]); } return 0; } æ­¤æ—¶çš„æœ€å°æ­£æ•´æ•°è§£å°±æ˜¯$c[k]$ï¼ˆå°äº0å°±åŠ ä¸Š$m_1\times m_2$) æ¨¡æ¿è¿è¡Œè¿‡ç¨‹ä¸­ä¼¼ä¹ä¼šé‡åˆ°å–æ¨¡æ—¶å€¼ä¸ºè´Ÿæ•°å¯¼è‡´å‡ºé”™çš„é—®é¢˜ï¼Œè§£å†³æ–¹æ³•å¦‚ä¸‹ï¼š a[i] = m1 * m2 / t; ll temp=(c2 - c1) / t; if(temp&lt;0){ ll t1=abs(temp)/(m2/t);temp+=(m2/t)*(t1+1); } ll temp2=inv(m1 / t, m2 / t); if(temp2&lt;0){ ll t1=abs(temp2)/(m2/t);temp2+=(m2/t)*(t1+1); } c[i] = (temp2)%(m2 / t) * ((temp) % (m2 / t)) % (m2 / t)* m1 + c1; c[i] = (c[i] % a[i] + a[i]) % a[i]; æ¨¡æ¿é¢˜ï¼šPOJ2891]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰çº¿æ€§åŒä½™æ–¹ç¨‹]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fe6-a8-a1-e6-9d-bf-ef-bc-89-e7-ba-bf-e6-80-a7-e5-90-8c-e4-bd-99-e6-96-b9-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[å®šä¹‰:a,bæ˜¯æ•´æ•°ï¼Œå½¢å¦‚$axâ‰¡b(mod \ m)$ï¼Œä¸”xæ˜¯æœªçŸ¥æ•´æ•°çš„åŒä½™å¼ç§°ä¸ºä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹ã€‚ å®šç†ï¼ša,b,mæ˜¯æ•´æ•°ä¸”m&gt;0,$gcd(a,m)=d$,å¦‚æœ$d|b$ï¼Œåˆ™æ–¹ç¨‹æ°å¥½æœ‰dä¸ªæ¨¡mä¸åŒä½™çš„è§£ï¼Œå¦åˆ™æ–¹ç¨‹æ— è§£ã€‚ ç”±åŒä½™æ–¹ç¨‹çš„å®šä¹‰å¼å¯å¾—$ax+my=b$ï¼Œè¿™ä¸ªæ–¹ç¨‹ç§°ä¸ºäºŒå…ƒä¸€æ¬¡ä¸å®šæ–¹ç¨‹ã€‚ ç”±æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•å¯æ±‚å‡ºæ–¹ç¨‹$ax+my=gcd(a,m)$çš„ç‰¹è§£ï¼Œåˆ™åŸæ–¹ç¨‹çš„é€šè§£ä¸º $ x = x_0 \times \frac{b}{gcd(a,m)}+ \frac{m}{gcd(a,m)}\times t$ $ y = y_0 \times \frac{b}{gcd(a,m)}â€“ \frac{a}{gcd(a,m)}\times t$ $t=0,1,2,3â€¦$ æ‰©å±•æ¬§å‡ é‡Œå¾—ï¼š int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//è¿”å›çš„æ˜¯åˆå§‹æ—¶a,bçš„æœ€å¤§å…¬çº¦æ•° } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } xï¼Œyå³ä¸º$ax+my=gcd(a,m)$çš„ç‰¹è§£ã€‚ ä¾‹å­ï¼šNOIP2012 åŒä½™æ–¹ç¨‹ æ±‚å…³äº x çš„åŒä½™æ–¹ç¨‹ $axâ‰¡1(mod\ b) $çš„æœ€å°æ­£æ•´æ•°è§£ã€‚ å› ä¸ºé¢˜ç›®ä¿è¯äº†ä¸€å®šæœ‰è§£ï¼Œæ‰€ä»¥ç›´æ¥æ±‚å³å¯ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//è¿”å›çš„æ˜¯åˆå§‹æ—¶a,bçš„æœ€å¤§å…¬çº¦æ•° } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } int main() { int a,b,x,y; cin&gt;&gt;a&gt;&gt;b; extgcd(a,b,x,y); x=(x+b)%b; cout&lt;&lt;x&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰é«˜ç²¾åº¦ç®—æ³•]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[__int128æœ€ç®€å•ç²—æš´çš„åšæ³•ã€‚ è¿™ç§ç±»å‹åªæœ‰éƒ¨åˆ†GCCç¼–è¯‘å™¨æ”¯æŒã€‚ç»æµ‹è¯•ï¼Œæ­£å¸¸è¿ç®—ä¸æ™®é€šintæ— å¼‚ï¼Œä½†æ˜¯è¾“å…¥è¾“å‡ºæ—¶æ— è®ºæ˜¯cinï¼Œcoutè¿˜æ˜¯printféƒ½ä¼šæŠ¥é”™ï¼Œæ‰€ä»¥å¿…é¡»è‡ªå·±å†™è¾“å…¥è¾“å‡ºå‡½æ•°ã€‚ å®šä¹‰æ—¶ä¸åˆ«çš„æ•°æ®ç±»å‹å¹¶æ²¡æœ‰ä»€ä¹ˆåŒºåˆ« eg: __int128 a,b,c; è¾“å…¥æš‚æ—¶é‡‡ç”¨å­—ç¬¦ä¸²è¯»å…¥æ–¹å¼ã€‚ æ–¹æ³•ä¸€ï¼šé‡è½½è¾“å‡º std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, __int128 T) { if (T&lt;0) os&lt;&lt;&quot;-&quot;;if (T&gt;=10 ) os&lt;&lt;T/10;if (T&lt;=-10) os&lt;&lt;(-(T/10)); return os&lt;&lt;( (int) (T%10) &gt;0 ? (int) (T%10) : -(int) (T%10) ) ; } æ–¹æ³•äºŒï¼šå˜ä¸ºå­—ç¬¦ä¸²å¼è¾“å…¥è¾“å‡º è¾“å…¥ï¼š void scan(__int128 &amp;x)//è¾“å…¥ { x = 0; int f = 1; char ch; if((ch = getchar()) == &apos;-&apos;) f = -f; else x = x*10 + ch-&apos;0&apos;; while((ch = getchar()) &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) x = x*10 + ch-&apos;0&apos;; x *= f; } è¾“å‡ºï¼š void print(__int128 x) { if(x &lt; 0) { x = -x; putchar(â€˜-â€˜); } if(x &gt; 9) print(x/10); putchar(x%10 + â€˜0â€˜); } ç®€å•æ¨¡æ¿ï¼ˆä¸æ”¯æŒè´Ÿæ•°ï¼‰#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 1000; struct bign{ int d[maxn], len; void clean() { while(len &gt; 1 &amp;&amp; !d[len-1]) len--; } bign() { memset(d, 0, sizeof(d)); len = 1; } bign(int num) { *this = num; } bign(char* num) { *this = num; } bign operator = (const char* num){ memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &apos;0&apos;; clean(); return *this; } bign operator = (int num){ char s[20]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; } bign operator + (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; } while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; } bign operator - (const bign&amp; b){ bign c = *this; int i; for (i = 0; i &lt; b.len; i++){ c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; } while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; } bign operator * (const bign&amp; b)const{ int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; } bign operator / (const bign&amp; b){ int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; } c.clean(); return c; } bign operator % (const bign&amp; b){ int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) { a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; } return a; } bign operator += (const bign&amp; b){ *this = *this + b; return *this; } bool operator &lt;(const bign&amp; b) const{ if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; } bool operator &gt;(const bign&amp; b) const{return b &lt; *this;} bool operator&lt;=(const bign&amp; b) const{return !(b &lt; *this);} bool operator&gt;=(const bign&amp; b) const{return !(*this &lt; b);} bool operator!=(const bign&amp; b) const{return b &lt; *this || *this &lt; b;} bool operator==(const bign&amp; b) const{return !(b &lt; *this) &amp;&amp; !(b &gt; *this);} string str() const{ char s[maxn]={}; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&apos;0&apos;; return s; } }; istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) { string s; in &gt;&gt; s; x = s.c_str(); return in; } ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) { out &lt;&lt; x.str(); return out; } æ›´å®Œå–„çš„æ¨¡æ¿æ”¯æŒè´Ÿæ•°ä¹‹ç±»çš„æ“ä½œã€‚éœ€è¦æ³¨æ„çš„æ˜¯å¦‚æœæ¶‰åŠbignä¸å¸¸è§„ç±»å‹çš„æ•°å€¼ä¹‹é—´çš„ä¹‹é—´è®¡ç®—ï¼Œæ¯”å¦‚ä¸€ä¸ªbign+llï¼Œå¯èƒ½éœ€è¦é¢å¤–æ–°å¢é‡è½½è¿ç®—ç¬¦ï¼Œå› ä¸ºé»˜è®¤çš„ä¼¼ä¹åªæœ‰bign+intçš„é‡è½½ï¼Œå¦åˆ™å¯èƒ½æº¢å‡ºå‡ºé”™ã€‚ ä»¥åŠï¼Œå¤§æ•°çš„é•¿åº¦éœ€è¦é¢å¤–æ³¨æ„ï¼Œå¼€å¤ªå¤§å®¹æ˜“çˆ†å†…å­˜ã€‚ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define MAX_L 100 //æœ€å¤§é•¿åº¦ï¼Œå¯ä»¥ä¿®æ”¹ using namespace std; class bign { public: int len, s[MAX_L];//æ•°çš„é•¿åº¦ï¼Œè®°å½•æ•°ç»„ //æ„é€ å‡½æ•° bign(); bign(const char *); bign(int); bool sign;//ç¬¦å· 1æ­£æ•° 0è´Ÿæ•° string toStr() const;//è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œä¸»è¦æ˜¯ä¾¿äºè¾“å‡º friend istream &amp;operator&gt;&gt;(istream &amp;, bign &amp;);//é‡è½½è¾“å…¥æµ friend ostream &amp;operator&lt;&lt;(ostream &amp;, bign &amp;);//é‡è½½è¾“å‡ºæµ //é‡è½½å¤åˆ¶ bign operator=(const char *); bign operator=(int); bign operator=(ll); bign operator=(const string); //é‡è½½å„ç§æ¯”è¾ƒ bool operator&gt;(const bign &amp;) const; bool operator&gt;=(const bign &amp;) const; bool operator&lt;(const bign &amp;) const; bool operator&lt;=(const bign &amp;) const; bool operator==(const bign &amp;) const; bool operator!=(const bign &amp;) const; //é‡è½½å››åˆ™è¿ç®— bign operator+(const bign &amp;) const; bign operator++(); bign operator++(int); bign operator+=(const bign &amp;); bign operator-(const bign &amp;) const; bign operator--(); bign operator--(int); bign operator-=(const bign &amp;); bign operator*(const bign &amp;) const; bign operator*(const int num) const; bign operator*=(const bign &amp;); bign operator/(const bign &amp;) const; bign operator/=(const bign &amp;); //å››åˆ™è¿ç®—çš„è¡ç”Ÿè¿ç®— bign operator%(const bign &amp;) const;//å–æ¨¡ï¼ˆä½™æ•°ï¼‰ bign factorial() const;//é˜¶ä¹˜ bign Sqrt() const;//æ•´æ•°å¼€æ ¹ï¼ˆå‘ä¸‹å–æ•´ï¼‰ bign pow(const bign &amp;) const;//æ¬¡æ–¹ //ä¸€äº›ä¹±ä¹±çš„å‡½æ•° void clean(); //~bign(); }; bign::bign() { memset(s, 0, sizeof(s)); len = 1; sign = 1; } bign::bign(const char *num) { *this = num; } bign::bign(int num) { *this = num; } string bign::toStr() const { string res; res = &quot;&quot;; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + &apos;0&apos;) + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign&amp;&amp;res != &quot;0&quot;) res = &quot;-&quot; + res; return res; } istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;num) { string str; in&gt;&gt;str; num=str; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, bign &amp;num) { out&lt;&lt;num.toStr(); return out; } bign bign::operator=(const char *num) { memset(s, 0, sizeof(s)); char a[MAX_L] = &quot;&quot;; if (num[0] != &apos;-&apos;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == &apos;-&apos;); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this; } bign bign::operator=(int num) { char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this; } bign bign::operator=(ll num) { char temp[MAX_L]; sprintf(temp, &quot;%lld&quot;, num); *this = temp; return *this; } bign bign::operator=(const string num) { const char *tmp; tmp = num.c_str(); *this = tmp; return *this; } bool bign::operator&lt;(const bign &amp;num) const { if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign; } bool bign::operator&gt;(const bign&amp;num)const { return num &lt; *this; } bool bign::operator&lt;=(const bign&amp;num)const { return !(*this&gt;num); } bool bign::operator&gt;=(const bign&amp;num)const { return !(*this&lt;num); } bool bign::operator!=(const bign&amp;num)const { return *this &gt; num || *this &lt; num; } bool bign::operator==(const bign&amp;num)const { return !(num != *this); } bign bign::operator+(const bign &amp;num) const { if (sign^num.sign) { bign tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } bign result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result; } bign bign::operator++() { *this = *this + 1; return *this; } bign bign::operator++(int) { bign old = *this; ++(*this); return old; } bign bign::operator--() { *this = *this - 1; return *this; } bign bign::operator--(int) { bign old = *this; --(*this); return old; } bign bign::operator+=(const bign &amp;num) { *this = *this + num; return *this; } bign bign::operator-=(const bign &amp;num) { *this = *this - num; return *this; } bign bign::operator-(const bign &amp;num) const { bign b=num,a=*this; if (!num.sign &amp;&amp; !sign) { b.sign=1; a.sign=1; return b-a; } if (!b.sign) { b.sign=1; return a+b; } if (!a.sign) { a.sign=1; b=bign(0)-(a+b); return b; } if (a&lt;b) { bign c=(b-a); c.sign=false; return c; } bign result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result; } bign bign::operator * (const bign &amp;num)const { bign result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result; } bign bign::operator*(const int num)const { bign x = num; bign z = *this; return x*z; } bign bign::operator*=(const bign&amp;num) { *this = *this * num; return *this; } bign bign::operator /(const bign&amp;num)const { bign ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } bign divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + &apos;0&apos;; bign dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; bign temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans; } bign bign::operator/=(const bign&amp;num) { *this = *this / num; return *this; } bign bign::operator%(const bign&amp; num)const { bign a = *this, b = num; a.sign = b.sign = 1; bign result, temp = a / b*b; result = a - temp; result.sign = sign; return result; } bign bign::pow(const bign&amp; num)const { bign result = 1; for (bign i = 0; i &lt; num; i++) result = result*(*this); return result; } bign bign::factorial()const { bign result = 1; for (bign i = 1; i &lt;= *this; i++) result *= i; return result; } void bign::clean() { if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == &apos;\0&apos;) len--; } bign bign::Sqrt()const { if(*this&lt;0)return -1; if(*this&lt;=1)return *this; bign l=0,r=*this,mid; while(r-l&gt;1) { mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; } return l; } bign sum[200005];]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æ¬§æ‹‰å‡½æ•°]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e6-8b-89-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[1~nä¸­ä¸näº’è´¨çš„æ•°çš„ä¸ªæ•°ç§°ä¸ºæ¬§æ‹‰å‡½æ•° int eular(int x) { int res = x, a = x; for (int i = 2; i*i &lt;= a; i++) { if (a%i == 0) { res = res / i*(i - 1); while (a%i == 0) a /= i; } } if (a &gt; 1) res = res / a*(a - 1); return res; } æ€§è´¨1ï¼š1~nä¸­ä¸näº’è´¨çš„æ•°çš„å’Œä¸º$n\times eularï¼ˆnï¼‰\div2$; æ€§è´¨2ï¼šè‹¥aï¼Œbäº’è´¨ï¼Œåˆ™$eularï¼ˆa\times bï¼‰=eularï¼ˆaï¼‰\times eularï¼ˆbï¼‰$ï¼›]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰è´¨æ•°ç­›æ³•]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-b4-a8-e6-95-b0-e7-ad-9b-e6-b3-95%2F</url>
    <content type="text"><![CDATA[åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; bool notprime[10000005]; void checkprime(int n) { for(int i=2;i&lt;=n;i++){//æ³¨æ„çº¿æ€§ç­›æ³•åšå®Œä»¥å1æ˜¯æ²¡æœ‰è¢«æ ‡è®°çš„... if(notprime[i])continue;//å¦‚æœå·²ç»è¢«æ ‡è®°ä¸ºåˆæ•°,é‚£å°±æ»šè›‹ for(int j=i;j&lt;=n/i;j++)//æ³¨æ„è¿™é‡Œä¸€å®šè¦å°å¿ƒj*iå¯èƒ½çˆ†intçš„äº‹å®ï¼Œå†™æˆ //j=i*içš„æ—¶å€™ä¹Ÿæ˜¯ä¸€æ ·è¦å°å¿ƒï¼ï¼ï¼æœ€å¥½ç”¨long long notprime[j*i]=true;//æ ‡è®°åˆæ•° } } int main() { int n,m,i; cin&gt;&gt;n&gt;&gt;m; checkprime(n);notprime[1]=true;//ç‰¹åˆ«æ³¨æ„è¦æ ‡è®°1 for(i=1;i&lt;=m;i++){ int t; scanf(&quot;%d&quot;,&amp;t); if(notprime[t])cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } return 0; } çº¿æ€§ç­›ï¼ˆä¼¼ä¹ä¸å¤§å¸¸ç”¨ï¼‰ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int v[10000005],prime[10000000],cnt=0;//vè®°å½•æ¯ä¸ªæ•°çš„æœ€å°è´¨å› æ•°,primeè®°å½•ç´ æ•° void checkprime(int n) { for(int i=2;i&lt;=n;i++){ if(v[i]==0){//å¦‚æœiæ˜¯ç´ æ•° v[i]=i; prime[++cnt]=i; } for(int j=1;j&lt;=cnt;j++){ if(prime[j]&gt;v[i]||prime[j]&gt;n/i)//å¦‚æœå½“å‰çš„è´¨æ•°å·²ç»æ¯”Içš„æœ€å°è´¨å› æ•°å¤§äº†,é‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦å†ç»§ç»­ä¸‹å»äº†,å› ä¸ºåé¢çš„i*prime[j] break;//è‚¯å®šå·²ç»è¢«v[i]æˆ–è€…å…¶ä»–æ›´å°çš„è´¨æ•°æ ‡è®°è¿‡äº†;åŒæ—¶,è¶…è¿‡nè‡ªç„¶ä¹Ÿæ˜¯ä¸ç”¨ç®¡äº† v[i*prime[j]]=prime[j];//æ ‡è®°æœ€å°è´¨å› æ•° } } } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; checkprime(n); for(int i=1;i&lt;=m;i++){ int t;scanf(&quot;%d&quot;,&amp;t); if(v[t]==t)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æ±‚ä¹˜æ³•é€†å…ƒ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-b1-82-e4-b9-98-e6-b3-95-e9-80-86-e5-85-83%2F</url>
    <content type="text"><![CDATA[ä¹˜æ³•é€†å…ƒ$x\times x^{-1}=1\ (mod\ p)$ è´¹é©¬å°å®šç†å‰ææ˜¯æ¨¡æ•°å¿…é¡»æ˜¯è´¨æ•°ï¼›å› ä¸º$a^{p-1}\ mod\ p=1$,æ‰€ä»¥aæ¨¡pçš„ä¹˜æ³•é€†å…ƒå°±æ˜¯$a^{p-2}$ è¿ç”¨å¿«é€Ÿå¹‚: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; ll pow(ll x,ll n,ll mod) { ll ans=1; x%=mod; while(n){ if(n&amp;1) ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; } return ans; } int main() { int n,p,i,j; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt;ans; for(i=1;i&lt;=n;i++){ ll t=pow(i,p-2,p); ans.push_back(t); } for(i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; } æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ç»™å®šæ¨¡æ•°mï¼Œæ±‚açš„é€†ç›¸å½“äºæ±‚è§£$ax=1(mod \ m) $ è¿™ä¸ªæ–¹ç¨‹å¯ä»¥è½¬åŒ–ä¸º$ax-my=1 $ ç„¶åå¥—ç”¨æ±‚äºŒå…ƒä¸€æ¬¡æ–¹ç¨‹çš„æ–¹æ³•ï¼Œç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚å¾—ä¸€ç»„x0,y0å’Œgcd æ£€æŸ¥$gcd(a,m)$æ˜¯å¦ä¸º1 gcdä¸ä¸º1åˆ™è¯´æ˜é€†å…ƒä¸å­˜åœ¨ è‹¥ä¸º1ï¼Œåˆ™è°ƒæ•´ x0 åˆ°0~m-1çš„èŒƒå›´ä¸­å³å¯ void exgcd (ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return ; } exgcd (b, a % b, x, y); ll tmp = x; x = y; y = tmp - a / b * y; } //ä¸»å‡½æ•°éƒ¨åˆ†è°ƒç”¨ ll x, y; exgcd (a, b, x, y);//æ±‚aåœ¨æ¨¡bæ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒ x = (x + p) % p; printf (&quot;%d\n&quot;, x); é€’æ¨æ±‚é€†å…ƒç”¨äºæ±‚è¿ç»­å¾ˆå¤šæ•°çš„ä¹˜æ³•é€†å…ƒï¼Œæ—¶é—´å¤æ‚åº¦åŸºæœ¬ä¸Šæ˜¯çº¿æ€§ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; typedef long long ll; int main() { ll n,p,i,j; cin&gt;&gt;n&gt;&gt;p; ll inv[3000005]; inv[1]=1; for(i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p;//å…³é”® for(i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,inv[i]); return 0; } æ±‚è¿ç»­é˜¶ä¹˜çš„ä¹˜æ³•é€†å…ƒå…ˆæ±‚å‡º$n!$çš„é€†å…ƒï¼Œå€’åºé€’æ¨ã€‚ $inv_i = (inv_{i+1}* (i+1))mod\ p$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰æ¬§å‡ é‡Œå¾—ç®—æ³•]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e6-ac-a7-e5-87-a0-e9-87-8c-e5-be-97-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼ˆGCDï¼‰ï¼š #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;gcd(x,y)&lt;&lt;endl; return 0; } æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼š int extgcd(int a,int b,int&amp;x,int&amp;y) { if(b==0){ x=1,y=0;return a;//è¿”å›çš„æ˜¯åˆå§‹æ—¶a,bçš„æœ€å¤§å…¬çº¦æ•° } int d=extgcd(b,a%b,x,y); int z=x;x=y;y=z-y*(a/b); return d; } æ‰©æ¬§æ±‚å‡ºçš„$x$,$y$ æ˜¯$a x + b y = gcd(a,b)$çš„ä¸€ä¸ªç‰¹è§£ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨ x0 å’Œ y0 è¡¨ç¤ºå‡ºæ•´ä¸ªä¸å®šæ–¹ç¨‹çš„é€šè§£ï¼š $ x = x_0 + (b/gcd) t$ $ y = y_0 â€“ (a/gcd) t$]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰å¿«é€Ÿå¹‚ä¸å¿«é€Ÿä¹˜æ³•]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e5-bf-ab-e9-80-9f-e5-b9-82-e4-b8-8e-e5-bf-ab-e9-80-9f-e4-b9-98-e6-b3-95%2F</url>
    <content type="text"><![CDATA[å¿«é€Ÿå¹‚å¯¹äºä»»ä½•ä¸€ä¸ªæ•´æ•°çš„æ¨¡å¹‚è¿ç®— $a^b\ mod \ c$ å¯¹äºbæˆ‘ä»¬å¯ä»¥æ‹†æˆäºŒè¿›åˆ¶çš„å½¢å¼ $b=b_0+b_1 2+b_2 2^2+â€¦+b_n* 2^n$ è¿™é‡Œæˆ‘ä»¬çš„$b_0$å¯¹åº”çš„æ˜¯bäºŒè¿›åˆ¶çš„ç¬¬ä¸€ä½ ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n) { if (n &amp; 1) res = res*x%mod; x = x*x%mod; n &gt;&gt;= 1; } return res; } å¿«é€Ÿä¹˜æ³• ç”±äºè®¡ç®—æœºåº•å±‚è®¾è®¡çš„åŸå› ï¼ŒåšåŠ æ³•å¾€å¾€æ¯”ä¹˜æ³•å¿«çš„å¤šï¼Œå› æ­¤å°†ä¹˜æ³•è½¬æ¢ä¸ºåŠ æ³•è®¡ç®—å°†ä¼šå¤§å¤§æé«˜ï¼ˆå¤§æ•°ï¼Œæ¯”è¾ƒå°çš„æ•°ä¹Ÿæ²¡å¿…è¦ï¼‰ä¹˜æ³•è¿ç®—çš„é€Ÿåº¦ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå½“æˆ‘ä»¬è®¡ç®—a* b%modçš„æ—¶å€™ï¼Œå¾€å¾€è¾ƒå¤§çš„æ•°è®¡ç®—aï¼Šbä¼šè¶…å‡ºlong long intçš„èŒƒå›´ï¼Œè¿™ä¸ªæ—¶å€™ä½¿ç”¨å¿«é€Ÿä¹˜æ³•æ–¹æ³•ä¹Ÿèƒ½è§£å†³ä¸Šè¿°é—®é¢˜ï¼ å¿«é€Ÿä¹˜æ³•çš„åŸç†å°±æ˜¯åˆ©ç”¨ä¹˜æ³•åˆ†é…ç‡æ¥å°†aï¼Šbè½¬åŒ–ä¸ºå¤šä¸ªå¼å­ç›¸åŠ çš„å½¢å¼æ±‚è§£ï¼ˆæ³¨æ„è¿™æ—¶ä½¿ç”¨ä¹˜æ³•åˆ†é…ç‡çš„æ—¶å€™åé¢çš„ä¸€ä¸ªä¹˜æ•°è½¬åŒ–ä¸ºäºŒè¿›åˆ¶çš„å½¢å¼è®¡ç®—ï¼‰ï¼ EXï¼š$ 20ï¼Š 14 ï¼ 20ï¼Š (1110)_2 = 20 ï¼Š (2^3)ï¼Š1 + 20ï¼Š(2^2)ï¼Š1+20ï¼Š(2^1)ï¼Šï¼‘+20ï¼Š (2^0)ï¼Š 0 = 160+80+40=280$ ä¸Šé¢å³ä¸ºå¿«é€Ÿä¹˜æ³•çš„åŸºæœ¬åŸç† ll quick_mul(ll a, ll b, ll c) { ll ans = 0; a %= c; b %= c; while (b) { if (b &amp; 1)//å¦‚æœå¯¹åº”ä½ä¸º1 ans = (ans + a) % c; a &lt;&lt;= 1; a %= c;//å¯¹åº”bçš„ä½æ¯æ¬¡çš„å¹‚æ¬¡ä¼šå¢åŠ ï¼ŒåŠ åœ¨aä¸Š b &gt;&gt;= 1; } return ans; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åŸºç¡€æ•°å­¦</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åŸºç¡€æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰è®¡ç®—å‡ ä½•]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F%E6%A8%A1%E6%9D%BF%2Fef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89-e8-ae-a1-e7-ae-97-e5-87-a0-e4-bd-95%2F</url>
    <content type="text"><![CDATA[æ¨¡æ¿å¦‚ä¸‹ï¼Œè§£é‡Šè§æ³¨é‡Šï¼š #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 100000; const double EPS = 1e-8; // å¸¦è¯¯å·®æ¯”è¾ƒ inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } /* * å‘é‡ï¼ˆVectorï¼‰æˆ–ç‚¹ * * ä½¿ç”¨åŸç‚¹åˆ°ä¸€ä¸ªç‚¹ (x, y) çš„æœ‰å‘çº¿æ®µè¡¨ç¤ºå‘é‡ * ä»ç‚¹ A åˆ°ç‚¹ B çš„å‘é‡è¡¨ç¤ºä¸º A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // ç›¸åŠ  Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // ç›¸å‡ Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // æ•°ä¹˜ï¼ˆä¼¸é•¿ã€ç¼©çŸ­ï¼‰ Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // èŒƒæ•°ï¼Œç”¨æ¥æ¯”è¾ƒé•¿åº¦ï¼Œç­‰äºé•¿åº¦çš„å¹³æ–¹ double norm() const { return x * x + y * y; } } Pt; // ç‚¹ä¹˜ double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // å‰ä¹˜ double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } // çº¿æ®µï¼ˆSegmentï¼‰ï¼Œç”¨ä¸¤ä¸ªç‚¹è¡¨ç¤º struct Seg { Pt a, b; Seg(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} // çº¿æ®µåŒ…å«ç‚¹ï¼ˆç‚¹åœ¨çº¿æ®µä¸Šï¼‰ bool include(const Pt &amp;p) { // PA Ã— PB = 0ï¼šPA ä¸ PB å…±çº¿ï¼Œå³ç‚¹åœ¨çº¿æ®µæ‰€åœ¨çš„ç›´çº¿ä¸Š // PA Â· PB = 0ï¼šPA ä¸ PB æ–¹å‘ä¸åŒï¼ˆA å’Œ B åˆ†åˆ«åœ¨ P çš„ä¸¤è¾¹ï¼‰ï¼Œå¦‚æœ PA Â· PB = 0 åˆ™ P = A æˆ– P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } }; // ç›´çº¿ï¼Œç”¨ä¸¤ä¸ªç‚¹è¡¨ç¤º struct Line { Pt a, b; Line() {} // æä¾›ä¸€ä¸ªä¸éœ€è¦å‚æ•°çš„æ„é€ å‡½æ•° Line(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } // ä¸¤ç›´çº¿å…³ç³»ï¼ˆäº¤ç‚¹ä¸ªæ•°ï¼‰ // 0 è¡¨ç¤ºå¹³è¡Œï¼ˆæ— äº¤ç‚¹ï¼‰ // 1 è¡¨ç¤ºç›¸äº¤ï¼ˆä¸€ä¸ªäº¤ç‚¹ï¼‰ // -1 è¡¨ç¤ºé‡åˆï¼ˆæ— æ•°ä¸ªäº¤ç‚¹ï¼‰ static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } // æ±‚ä¸¤ç›´çº¿äº¤ç‚¹ï¼ˆéœ€è¦ä¿è¯ä¸¤ç›´çº¿æœ‰äº¤ç‚¹ï¼‰ static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } }; // æ±‚å‡¸åŒ…ç”¨çš„ç‚¹ int n; Pt a[MAXN + 1]; // å‡¸åŒ…æè§’æ’åºçš„æ¯”è¾ƒå‡½æ•° inline bool compare(const Pt &amp;a, const Pt &amp;b) { // ä¸¤ä¸ªå‘é‡ Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB æ˜¯é€†æ—¶é’ˆï¼Œåˆ™ A æè§’åºåœ¨å…ˆ else return va.norm() &lt; vb.norm(); // norm è¾ƒå°çš„é•¿åº¦è¾ƒå° } struct Poly { std::vector&lt;Pt&gt; pts; //å¦‚æœä¸æ±‚å‡¸åŒ…çš„è¯,æŠŠå¤šè¾¹å½¢çš„ç‚¹ç›´æ¥ä¿å­˜åœ¨è¿™é‡Œ,å¦åˆ™æŠŠå¤šè¾¹å½¢çš„ç‚¹ä¿å­˜åœ¨å¤–é¢çš„aæ•°ç»„ä¸­ bool include(const Pt &amp;p) const { int cnt = 0; // åˆ¤æ–­ä¸æ¯æ¡è¾¹æœ‰æ²¡æœ‰äº¤ç‚¹ for (size_t i = 0; i &lt; pts.size(); i++) { // æšä¸¾ç›¸é‚»çš„æ¯ä¸¤ä¸ªç‚¹ const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // å¦‚æœç‚¹ P åœ¨è¾¹ AB ä¸Š if (Seg(a, b).include(p)) return true; // è¯¦è§å›¾ double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // å¥‡æ•°çš„äº¤ç‚¹ return cnt % 2 == 1; } // å¤šè¾¹å½¢é¢ç§¯ï¼ˆæœ‰å‘é¢ç§¯ï¼‰ double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // æšä¸¾æ¯ä¸¤ä¸ªç‚¹ const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } // æ±‚å‡¸åŒ…ï¼ˆConvexï¼‰ï¼Œç»“æœå‚¨å­˜åœ¨è‡ªèº« pts ä¸­ void convex() { // æ‰¾å‡ºæœ€å·¦ä¸‹è§’çš„ç‚¹ int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // æ’åº std::sort(a + 2, a + n + 1, &amp;compare); // æè§’åºæ‰«æ pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // æ¯”è¾ƒï¼Œå¦‚æœæœ€åä¸€ä¸ªç‚¹éœ€è¦è¢«åˆ æ‰åˆ™å¼¹å‡ºï¼ˆpop_backï¼‰ while (pts.size() &gt;= 2 &amp;&amp; cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) &gt;= 0) pts.pop_back(); pts.push_back(a[i]); } } }; æ—‹è½¬å¡å£³ï¼ˆåœ¨åŸæœ‰æ¨¡æ¿ä¸Šæ±‚å‡ºå‡¸åŒ…åå¢åŠ ä»¥ä¸‹ä»£ç å³å¯ï¼‰ï¼šæ³¨æ„ï¼šæ¨¡æ¿é‡Œçš„ansæ²¡æœ‰å¼€æ–¹ï¼è¿”å›çš„æ˜¯æœ€è¿œç‚¹å¯¹è·ç¦»çš„å¹³æ–¹ï¼è§£é‡Šï¼šhttp://www.cnblogs.com/Booble/archive/2011/04/03/2004865.html double cross(Pt a,Pt b,Pt c)//æ±‚å‰ç§¯ { return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x); } double dist2(Pt a,Pt b)//æ±‚è·ç¦» { Pt x=a-b; return (x.norm());//å› ä¸ºæœ¬é¢˜åªè¦æ±‚æ±‚è·ç¦»çš„å¹³æ–¹æ‰€ä»¥æ²¡æœ‰å¼€æ–¹ } double rotating_calipers(Poly p)//æ—‹è½¬å¡å£³ { int j=1,n=p.pts.size();p.pts.push_back(p.pts[0]); double ans=0; for(int i=0;i&lt;n;i++) { while(cross(p.pts[i],p.pts[i+1],p.pts[j])&lt;cross(p.pts[i],p.pts[i+1],p.pts[j+1])) j=(j+1)%n; ans=max(ans,max(dist2(p.pts[i],p.pts[j]),dist2(p.pts[i+1],p.pts[j+1]))); } return ans; }]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ¨¡æ¿</tag>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(æ¨¡æ¿ï¼‰Splayç»´æŠ¤åŒºé—´ç¿»è½¬]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fe6-a8-a1-e6-9d-bf-ef-bc-89splay-e7-bb-b4-e6-8a-a4-e5-8c-ba-e9-97-b4-e7-bf-bb-e8-bd-ac%2F</url>
    <content type="text"><![CDATA[æ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼ˆå¯å‚è€ƒé¢˜ç›®æ ‡é¢˜ï¼‰ï¼Œæ¥ç»´æŠ¤ä¸€ä¸ªæœ‰åºæ•°åˆ—ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼šç¿»è½¬ä¸€ä¸ªåŒºé—´ï¼Œä¾‹å¦‚åŸæœ‰åºåºåˆ—æ˜¯5 4 3 2 1ï¼Œç¿»è½¬åŒºé—´æ˜¯[2,4]çš„è¯ï¼Œç»“æœæ˜¯5 2 3 4 1 è¾“å…¥è¾“å‡ºæ ¼å¼è¾“å…¥æ ¼å¼ï¼šç¬¬ä¸€è¡Œä¸ºn,m nè¡¨ç¤ºåˆå§‹åºåˆ—æœ‰nä¸ªæ•°ï¼Œè¿™ä¸ªåºåˆ—ä¾æ¬¡æ˜¯ $(1,2,â€¦n-1,n)$ ,mè¡¨ç¤ºç¿»è½¬æ“ä½œæ¬¡æ•° æ¥ä¸‹æ¥mè¡Œæ¯è¡Œä¸¤ä¸ªæ•°$ [l,r][l,r]$ æ•°æ®ä¿è¯ $1â‰¤lâ‰¤râ‰¤n$ è¾“å‡ºæ ¼å¼ï¼šè¾“å‡ºä¸€è¡Œnä¸ªæ•°å­—ï¼Œè¡¨ç¤ºåŸå§‹åºåˆ—ç»è¿‡mæ¬¡å˜æ¢åçš„ç»“æœ ç±»ä¼¼çº¿æ®µæ ‘çš„lazytabæ“ä½œ. Splayå¯ä»¥ç”¨æ¥ç»´æŠ¤åºåˆ—ã€‚è¿™æ ·çš„è¯æ˜¯æŠŠSplayå½“ä½œä¸€æ£µåŒºé—´æ ‘ã€‚ æ‰€è°“åŒºé—´æ ‘å’Œæƒå€¼æ ‘çš„åŒºåˆ«ï¼Œå¤§æ¦‚å°±æ˜¯åŒºé—´æ ‘æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„æ˜¯ä¸€æ®µåŒºé—´ï¼ˆå…¸å‹ä»£è¡¨å°±æ˜¯ä¸€èˆ¬çš„çº¿æ®µæ ‘ï¼‰ æƒå€¼æ ‘å¥½ç†è§£ä¸€ç‚¹ï¼Œå°±æ˜¯æ¯ä¸ªç‚¹çœŸçš„ä»£è¡¨ä¸€ä¸ªç‚¹ã€‚ è‡³äºç¿»è½¬æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨Splayçš„è¿‡ç¨‹å®ç°ã€‚ #include&lt;bits/stdc++.h&gt; #define N 100005 using namespace std; int n,m; int fa[N],ch[N][2],size[N],rev[N],rt; inline void pushup(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; } void pushdown(int x){ if(rev[x]){ swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;rev[x]=0; } } void rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],kind; if(ch[y][0]==x)kind=1;else kind=0; if(y==k)k=x; else{if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} ch[y][kind^1]=ch[x][kind];fa[ch[y][kind^1]]=y; ch[x][kind]=y;fa[y]=x;fa[x]=z; pushup(x);pushup(y); } void splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } void build(int l,int r,int f){ if(l&gt;r)return; int mid=(l+r)/2; if(mid&lt;f)ch[f][0]=mid;else ch[f][1]=mid; fa[mid]=f;size[mid]=1; if(l==r)return; build(l,mid-1,mid);build(mid+1,r,mid); pushup(mid); } int find(int x,int k){ pushdown(x);int s=size[ch[x][0]]; if(k==s+1)return x; if(k&lt;=s)return find(ch[x][0],k); else return find(ch[x][1],k-s-1); } void rever(int l,int r){ int x=find(rt,l),y=find(rt,r+2); splay(x,rt);splay(y,ch[x][1]);int z=ch[y][0]; rev[z]^=1; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt=(n+3)/2;build(1,n+2,rt); for(int i=1;i&lt;=m;i++){ int L,R;scanf(&quot;%d%d&quot;,&amp;L,&amp;R); rever(L,R); } for(int i=2;i&lt;=n+1;i++)printf(&quot;%d &quot;,find(rt,i)-1); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>å¹³è¡¡æ ‘</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>å¹³è¡¡æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #499 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-499-div-2%2F</url>
    <content type="text"><![CDATA[A. æš´åŠ›ææå°±è¡Œ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int main() { int n,k,i,j; string str; cin&gt;&gt;n&gt;&gt;k&gt;&gt;str; vector&lt;char&gt;v; for(auto a:str)v.push_back(a); sort(v.begin(),v.end()); int pre=0;int cnt=0,w=0; for(i=0;i&lt;v.size();i++){ if(v[i]-pre&lt;2)continue; else{ cnt++;pre=v[i];w+=v[i]-&apos;a&apos;+1; } if(cnt==k)break; } if(cnt&lt;k){ puts(&quot;-1&quot;); } else{ cout&lt;&lt;w&lt;&lt;endl; } return 0; } B. æ¯”èµ›çš„æ—¶å€™å‚»é€¼äº†ï¼Œå†™äº†åŠå¤©ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ•°æ®é‚£ä¹ˆå°éª‘å£«æš´åŠ›æšä¸¾æ¯ä¸ªäººèƒ½åˆ†å¤šå°‘ä¸ªå°±å¯ä»¥äº†ï¼Œæ•°æ®è¦æ˜¯å¤§ä¸€ç‚¹äºŒåˆ†ä¹Ÿè¡Œã€‚ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int cnt[105], b[105]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; cnt[i]; b[cnt[i]]++; } for (int i = 100; i &gt;= 1; i--) { int t = 0; for (int j = 1; j &lt;= 100; j++) { t += b[j] / i; } if (t &gt;= n) { cout &lt;&lt; i; return 0; } } cout &lt;&lt; 0; return 0; } C. æ„Ÿè§‰è¿™é¢˜éå¸¸ç­¾åˆ°å‘€ï¼Œç›´æ¥é€’æ¨å°±è¡Œäº† #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,m,i,j,k,a[1005],b[1005]; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; if(a[i]==1){ puts(&quot;-1&quot;);return 0; } } for(i=1;i&lt;=n;i++){ cin&gt;&gt;b[i]; if(b[i]==1){ puts(&quot;-1&quot;);return 0; } } double w=m; w+=w/(b[1]-1); for(i=n;i&gt;1;i--){ w+=w/(a[i]-1); w+=w/(b[i]-1); } w+=w/(a[1]-1); printf(&quot;%.10f\n&quot;,w-m); return 0; } D. é¢˜ç›®æ¯”è¾ƒé•¿ï¼Œéš¾åº¦ä¸»è¦æ˜¯åœ¨è¯»é¢˜ä¸Šè¿˜æœ‰è¾“å‡ºflushä¸Šã€‚å…¶å®æœ¬èº«ä¸å¤ªéš¾ï¼Œé¦–å…ˆæˆ‘ä»¬ä¸çŸ¥é“çœŸå‡åºåˆ—æ˜¯ä»€ä¹ˆçš„è¯æ˜¾ç„¶æ˜¯æ— ä»ä¸‹æ‰‹çš„ï¼Œå› æ­¤æˆ‘ä»¬åªè¦é—®næ¬¡æœ€å¤§å€¼mæˆ–è€…næ¬¡1å°±å¯ä»¥äº†ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“è¿™ç§æƒ…å†µä¸‹çš„ç­”æ¡ˆï¼ˆå¦‚æœè¿”å›0çš„è¯é‚£ç›´æ¥ç»“æŸç¨‹åºå°±è¡Œäº†ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥æ±‚å‡ºæ•´ä¸ªåºåˆ—äº†ã€‚ç„¶åå› ä¸ºmçš„èŒƒå›´æœ‰é™ï¼Œè€Œæˆ‘ä»¬çŸ¥é“ä»»ä½•ä¸€ä¸ªæ­£æ•´æ•°éƒ½å¯ä»¥ç”¨2çš„è‹¥å¹²ä¸ªå¹‚æ¬¡çš„å’Œè¡¨ç°å‡ºæ¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥äºŒåˆ†ä¸€ä¸‹ã€‚ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int wrong[31], poww[31]; int main() { int m, n, q1,i,j,k; cin &gt;&gt; m &gt;&gt; n; poww[0] = 1; for (i = 1; i &lt; 31; i++) { poww[i] = poww[i - 1] &lt;&lt; 1;//é¢„å¤„ç†2çš„å¹‚æ¬¡æ–¹ } for (i = 0; i &lt; n; i++) { printf(&quot;%d\n&quot;, m);//è¯¢é—®næ¬¡m fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (q1 == -1) wrong[i] = 1; else if (q1 == 1) wrong[i] = 0; else return 0;//å¦‚æœæ˜¯0ç›´æ¥è¿”å› } int ans = 0;int num = 0; for (i = 29; ~i ; i--) { if (ans + poww[i]&gt;m)continue; printf(&quot;%d\n&quot;, ans + poww[i]); fflush(stdout); scanf(&quot;%d&quot;, &amp;q1); if (wrong[num%n] == 0)q1 *= -1;//æ ¹æ®é¢„å¤„ç†çœŸå‡åºåˆ—æ”¹å˜ if (q1 == 1) { ans += poww[i]; } else if (q1 == 0) { return 0; } num++; } printf(&quot;%d\n&quot;, ans); return 0; } E. é¢˜ç›®çœŸçš„æŒºéš¾æ‡‚çš„ã€‚å…¶å®å°±æ˜¯ç»™å®šnç§æ•°åŠkï¼Œæ¯ä¸ªæ•°å¯ä»¥ç”¨æ— é™æ¬¡ï¼Œé—®è¿™äº›æ•°éšæ„ç»„åˆçš„å’Œ%kæœ‰å¤šå°‘ç§å¯èƒ½ï¼Œå¹¶è¾“å‡ºæ‰€æœ‰å¯èƒ½ã€‚ å…¶å®å°±æ˜¯æ±‚åŒä½™æ–¹ç¨‹$a_1 x_1+a_2 x_2+â€¦+a_n* x_n=m (mod k)$ä¸­æ‰€æœ‰çš„mã€‚ æ ¹æ®è´ç¥–å®šç†å¯ä»¥çŸ¥é“ï¼Œè¿™ç­‰ä»·äºé—®æœ‰å¤šå°‘ä¸ªmæ»¡è¶³$gcd(a_1,a_2,a_3â€¦a_n)|m$ é‚£ä¹ˆå…¶å®å°±å¾ˆå¥½æ±‚äº†ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; int gcd(int a,int b) { return b?gcd(b,a%b):a; } int main() { int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; //set&lt;int&gt;s; int d=k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); d=gcd(d,j%k); } int cnt=0; for(i=0;i&lt;k;i+=d) cnt++; cout&lt;&lt;cnt&lt;&lt;endl; for(i=0;i&lt;k;i+=d) cout&lt;&lt;i&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2486 æ ‘é“¾å‰–åˆ†ï¼ˆåŒºé—´æ›´æ”¹ï¼ŒåŒºé—´æŸ¥é‡ï¼‰]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fp2486-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8c-ba-e9-97-b4-e6-9b-b4-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-9f-a5-e9-87-8d-ef-bc-89%2F</url>
    <content type="text"><![CDATA[æ ‘å‰–ï¼Œç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼š æ•°ç»„a[N]è¡¨ç¤ºæ­¤æ—¶çš„é¢œè‰²æ®µæ•°ã€‚ æ•°ç»„left1[N]è¡¨ç¤ºæ­¤æ—¶æœ€å·¦è¾¹çš„èŠ‚ç‚¹çš„é¢œè‰²ã€‚ æ•°ç»„right1[N]è¡¨ç¤ºæ­¤æ—¶æœ€å³è¾¹çš„èŠ‚ç‚¹çš„é¢œè‰²ã€‚ åˆ™ï¼š é¦–å…ˆæˆ‘ä»¬è¦æ˜ç¡®ï¼Œçº¿æ®µæ ‘çš„å¶å­èŠ‚ç‚¹ä¸€å®šåªæœ‰ä¸€ç§é¢œè‰²ï¼Œä¹Ÿå°±æ˜¯ä¸€æ¡é¢œè‰²æ®µã€‚ a[çˆ¶äº²]=a[å·¦å„¿å­]+a[å³å„¿å­]ï¼› if (left1[å³å„¿å­]==right1[å·¦å„¿å­]) {a[çˆ¶äº²]â€“;} å³å¦‚æœå³å„¿å­çš„æœ€å·¦è¾¹é¢œè‰²å’Œå·¦å„¿å­çš„æœ€å³è¾¹é¢œè‰²ç›¸åŒï¼Œé‚£ä¹ˆè‚¯å®šæœ‰ä¸­é—´éƒ¨åˆ†å±äºåŒä¸€é¢œè‰²æ®µã€‚ ä»¥åŠå¾€ä¸Šè·³çš„æ—¶å€™é‡é“¾è¿æ¥å¤„é¢œè‰²æ˜¯å¦ç›¸åŒçš„é—®é¢˜ï¼Œç›¸åŒçš„è¯ä¹Ÿè¦å‡ã€‚ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=100000+10; vector&lt;int&gt;G[maxn]; //int mod; //è§é¢˜æ„ int w[maxn],wt[maxn]; //w[]ã€wt[]åˆå§‹ç‚¹æƒæ•°ç»„ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],left1[maxn&lt;&lt;2],right1[maxn&lt;&lt;2]; //çº¿æ®µæ ‘æ•°ç»„ã€lazyæ“ä½œ int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]é‡å„¿å­ç¼–å·,id[]æ–°ç¼–å·,fa[]çˆ¶äº²èŠ‚ç‚¹,cnt dfs_clock/dfsåº,dep[]æ·±åº¦,siz[]å­æ ‘å¤§å°,top[]å½“å‰é“¾é¡¶ç«¯èŠ‚ç‚¹ //int res=0; //æŸ¥è¯¢ç­”æ¡ˆ //-------------------------------------- ä»¥ä¸‹ä¸ºçº¿æ®µæ ‘ inline void pushdown(int rt) { a[rt&lt;&lt;1]=a[rt&lt;&lt;1|1]=1; lazytab[rt&lt;&lt;1]=lazytab[rt&lt;&lt;1|1]=left1[rt&lt;&lt;1]=right1[rt&lt;&lt;1]=left1[rt&lt;&lt;1|1]=right1[rt&lt;&lt;1|1]=lazytab[rt]; lazytab[rt]=0; } void pushup(int r) { a[r]=a[r&lt;&lt;1]+a[r&lt;&lt;1|1]; left1[r]=left1[r&lt;&lt;1];right1[r]=right1[r&lt;&lt;1|1]; if(right1[r&lt;&lt;1]==left1[r&lt;&lt;1|1])a[r]--; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=1; left1[rt]=right1[rt]=wt[l]; //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); //a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); pushup(rt); } inline int query(int rt,int l,int r,int L,int R) { int ans=0; if(L&lt;=l&amp;&amp;r&lt;=R){ return a[rt]; } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))ans+=query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)ans+=query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); if(L&lt;=((l+r)&gt;&gt;1)&amp;&amp;R&gt;(l+r)&gt;&gt;1&amp;&amp;right1[rt&lt;&lt;1]==left1[rt&lt;&lt;1|1])ans--;//è¿™é‡Œä¹Ÿè¦æ³¨æ„çš„ä¸¤è¾¹éƒ½æœ‰çš„æƒ…å†µä¸‹æ‰è¦å‡ } return ans; } inline void update(int rt,int l,int r,int L,int R,int color) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]=color;left1[rt]=right1[rt]=color;a[rt]=1; return; //a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,color); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,color); pushup(rt); } } //---------------------------------ä»¥ä¸Šä¸ºçº¿æ®µæ ‘ int QAQ(int rt, int l, int r, int p) { if (l==r) return left1[rt]; if (lazytab[rt]) pushdown(rt); if (p&gt;(l+r&gt;&gt;1)) return QAQ((rt &lt;&lt; 1 | 1), (l + r &gt;&gt; 1) + 1, r, p); else return QAQ((rt &lt;&lt; 1), l, (l + r &gt;&gt; 1), p); }//è¿”å›é‡é“¾é¡¶ç‚¹çš„é¢œè‰² inline int queryrange(int x, int y,int n)//æŸ¥è¯¢ä»xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹çš„æƒå€¼ä¹‹å’Œ,nå°±æ˜¯èŠ‚ç‚¹çš„æ€»æ•° { int ans=0; while(top[x]!=top[y]){//å½“ä¸¤ä¸ªç‚¹ä¸åœ¨åŒä¸€æ¡é“¾ä¸Š if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//æŠŠxç‚¹æ”¹ä¸ºæ‰€åœ¨é“¾é¡¶ç«¯çš„æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ //res=0; ans+=query(1,1,n,id[top[x]],id[x]);//ansåŠ ä¸Šxç‚¹åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯ è¿™ä¸€æ®µåŒºé—´çš„ç‚¹æƒå’Œ int nc= QAQ(1, 1, n, id[top[x]]);//å¾€é¡¶ç«¯è·³çš„æ—¶å€™è¿˜è¦ç•™æ„ä¸€ä¸ªé—®é¢˜,å°±æ˜¯ä¸åŒé‡é“¾ä¹‹é—´çš„è¿æ¥å¤„é¢œè‰²æ˜¯å¦ç›¸åŒçš„é—®é¢˜ int fc= QAQ(1, 1, n, id[fa[top[x]]]); if(nc==fc) ans--; x=fa[top[x]];//æŠŠxè·³åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯çš„é‚£ä¸ªç‚¹çš„ä¸Šé¢ä¸€ä¸ªç‚¹ } //ç›´åˆ°ä¸¤ä¸ªç‚¹å¤„äºä¸€æ¡é“¾ä¸Š if(dep[x]&gt;dep[y])swap(x,y);//æŠŠxç‚¹æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ //res=0; ans+=query(1,1,n,id[x],id[y]);//è¿™æ—¶å†åŠ ä¸Šæ­¤æ—¶ä¸¤ä¸ªç‚¹çš„åŒºé—´å’Œå³å¯ //ans+=res; return ans?ans:1;//%mod; } inline void addrange(int x, int y, int color,int n)//xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹éƒ½åŠ ä¸Šk {//åŒä¸Š //color%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],color); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],color); } inline void dfs1(int x,int f,int deep) {//xå½“å‰èŠ‚ç‚¹ï¼Œfçˆ¶äº²ï¼Œdeepæ·±åº¦ dep[x]=deep;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ·±åº¦ fa[x]=f;//æ ‡è®°æ¯ä¸ªç‚¹çš„çˆ¶äº² siz[x]=1;//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„å­æ ‘å¤§å° int maxson=-1;//è®°å½•é‡å„¿å­çš„å„¿å­æ•° for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//è‹¥ä¸ºçˆ¶äº²åˆ™continue dfs1(y,x,deep+1);//dfså…¶å„¿å­ siz[x]+=siz[y];//æŠŠå®ƒçš„å„¿å­æ•°åŠ åˆ°å®ƒèº«ä¸Š if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„é‡å„¿å­ç¼–å· } } inline void dfs2(int x,int topf) {//xå½“å‰èŠ‚ç‚¹ï¼Œtopfå½“å‰é“¾çš„æœ€é¡¶ç«¯çš„èŠ‚ç‚¹ id[x]=++cnt;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ–°ç¼–å· wt[cnt]=w[x];//æŠŠæ¯ä¸ªç‚¹çš„åˆå§‹å€¼èµ‹åˆ°æ–°ç¼–å·ä¸Šæ¥ top[x]=topf;//è¿™ä¸ªç‚¹æ‰€åœ¨é“¾çš„é¡¶ç«¯ if(!son[x])return;//å¦‚æœæ²¡æœ‰å„¿å­åˆ™è¿”å› dfs2(son[x],topf);//æŒ‰å…ˆå¤„ç†é‡å„¿å­ï¼Œå†å¤„ç†è½»å„¿å­çš„é¡ºåºé€’å½’å¤„ç† for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//å¯¹äºæ¯ä¸€ä¸ªè½»å„¿å­éƒ½æœ‰ä¸€æ¡ä»å®ƒè‡ªå·±å¼€å§‹çš„é“¾ } } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(i=1;i&lt;n;i++){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); G[x].push_back(y);G[y].push_back(x); } dfs1(1,0,1);dfs2(1,1);build(1,1,n); for(i=1;i&lt;=m;i++){ char con;cin&gt;&gt;con; if(con==&apos;C&apos;){ int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); addrange(a,b,c,n); } else{ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,queryrange(a,b,n)); } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ ‘é“¾å‰–åˆ†</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ´›è°·P2590 æ ‘é“¾å‰–åˆ†ï¼ˆå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æ±‚å’Œandå•ç‚¹æŸ¥è¯¢ï¼‰]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-b4-9b-e8-b0-b7p2590-e6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e5-8d-95-e7-82-b9-e4-bf-ae-e6-94-b9-ef-bc-8c-e5-8c-ba-e9-97-b4-e6-b1-82-e5-92-8cand-e5-8d-95-e7-82-b9-e6-9f-a5-e8-af-a2-ef-bc-89%2F</url>
    <content type="text"><![CDATA[ä¸€æ£µæ ‘ä¸Šæœ‰nä¸ªèŠ‚ç‚¹ï¼Œç¼–å·åˆ†åˆ«ä¸º1åˆ°nï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªæƒå€¼wã€‚ æˆ‘ä»¬å°†ä»¥ä¸‹é¢çš„å½¢å¼æ¥è¦æ±‚ä½ å¯¹è¿™æ£µæ ‘å®Œæˆä¸€äº›æ“ä½œï¼š I. CHANGE u t : æŠŠç»“ç‚¹uçš„æƒå€¼æ”¹ä¸ºt II. QMAX u v: è¯¢é—®ä»ç‚¹uåˆ°ç‚¹vçš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹çš„æœ€å¤§æƒå€¼ III. QSUM u v: è¯¢é—®ä»ç‚¹uåˆ°ç‚¹vçš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹çš„æƒå€¼å’Œ æ³¨æ„ï¼šä»ç‚¹uåˆ°ç‚¹vçš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹åŒ…æ‹¬uå’Œvæœ¬èº« åœ¨æ¿å­çš„åŸºç¡€ä¸Šç±»ä¼¼çº¿æ®µæ ‘é‚£æ ·ä¿®æ”¹å³å¯ï¼Œæ³¨æ„nçš„ä½ç½®ï¼ï¼å®šä¹‰åœ¨äº†æ‰€æœ‰å‡½æ•°å‰é¢ #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;string&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int n,m,r; //è§é¢˜æ„ int w[maxn],wt[maxn]; //w[]ã€wt[]åˆå§‹ç‚¹æƒæ•°ç»„ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2],mx[maxn]; //çº¿æ®µæ ‘æ•°ç»„ã€lazyæ“ä½œ int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]é‡å„¿å­ç¼–å·,id[]æ–°ç¼–å·,fa[]çˆ¶äº²èŠ‚ç‚¹,cnt dfs_clock/dfsåº,dep[]æ·±åº¦,siz[]å­æ ‘å¤§å°,top[]å½“å‰é“¾é¡¶ç«¯èŠ‚ç‚¹ int res=0; //æŸ¥è¯¢ç­”æ¡ˆ //-------------------------------------- ä»¥ä¸‹ä¸ºçº¿æ®µæ ‘ inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l];mx[rt]=wt[l];//å¢åŠ maxæ•°ç»„ //if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);//æ›´æ–°æ—¶æ›´æ–°max } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];return;//æ±‚å’Œçš„è¯¢é—® } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } int query1(int rt,int l,int r,int L,int R) { int q1=-99999999,q2=-99999999;//åˆå§‹åŒ–ä¸èƒ½ä¸º0!å¯èƒ½æœ‰å¾ˆå¤šè´Ÿæ•°! if(L&lt;=l&amp;&amp;r&lt;=R){ return mx[rt];//æ±‚æœ€å¤§å€¼çš„è¯¢é—® } else{ //if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))q1=query1(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)q2=query1(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } return max(q1,q2); } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ //lazytab[rt]+=k; a[rt]=k;mx[rt]=k; } else{ //if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1]); mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]); } } //---------------------------------ä»¥ä¸Šä¸ºçº¿æ®µæ ‘ inline int queryrange(int x, int y)//æŸ¥è¯¢ä»xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹çš„æƒå€¼ä¹‹å’Œ { int ans=0; while(top[x]!=top[y]){//å½“ä¸¤ä¸ªç‚¹ä¸åœ¨åŒä¸€æ¡é“¾ä¸Š if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//æŠŠxç‚¹æ”¹ä¸ºæ‰€åœ¨é“¾é¡¶ç«¯çš„æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ res=0; query(1,1,n,id[top[x]],id[x]);//ansåŠ ä¸Šxç‚¹åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯ è¿™ä¸€æ®µåŒºé—´çš„ç‚¹æƒå’Œ ans+=res; //ans%=mod;//æŒ‰é¢˜æ„å–æ¨¡ x=fa[top[x]];//æŠŠxè·³åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯çš„é‚£ä¸ªç‚¹çš„ä¸Šé¢ä¸€ä¸ªç‚¹ } //ç›´åˆ°ä¸¤ä¸ªç‚¹å¤„äºä¸€æ¡é“¾ä¸Š if(dep[x]&gt;dep[y])swap(x,y);//æŠŠxç‚¹æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ res=0; query(1,1,n,id[x],id[y]);//è¿™æ—¶å†åŠ ä¸Šæ­¤æ—¶ä¸¤ä¸ªç‚¹çš„åŒºé—´å’Œå³å¯ ans+=res; return ans;//%mod; } inline int querymax(int x, int y)//æŸ¥è¯¢ä»xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹çš„æœ€å¤§æƒå€¼ { int ans=-99999999;//åˆå§‹åŒ–! while(top[x]!=top[y]){//å½“ä¸¤ä¸ªç‚¹ä¸åœ¨åŒä¸€æ¡é“¾ä¸Š if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//æŠŠxç‚¹æ”¹ä¸ºæ‰€åœ¨é“¾é¡¶ç«¯çš„æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ //res=0; ans=max(ans,query1(1,1,n,id[top[x]],id[x]));//ansåŠ ä¸Šxç‚¹åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯ è¿™ä¸€æ®µåŒºé—´çš„æœ€å¤§æƒå€¼ x=fa[top[x]];//æŠŠxè·³åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯çš„é‚£ä¸ªç‚¹ çš„ä¸Šé¢ä¸€ä¸ªç‚¹ } //ç›´åˆ°ä¸¤ä¸ªç‚¹å¤„äºä¸€æ¡é“¾ä¸Š if(dep[x]&gt;dep[y])swap(x,y);//æŠŠxç‚¹æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ //res=0; ans=max(ans,query1(1,1,n,id[x],id[y])); //ans+=res; //return ans%mod; return ans; } inline void addrange(int x, int y, int k)//xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹å˜ä¸ºk {//åŒä¸Š //k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline void dfs1(int x,int f,int deep) {//xå½“å‰èŠ‚ç‚¹ï¼Œfçˆ¶äº²ï¼Œdeepæ·±åº¦ dep[x]=deep;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ·±åº¦ fa[x]=f;//æ ‡è®°æ¯ä¸ªç‚¹çš„çˆ¶äº² siz[x]=1;//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„å­æ ‘å¤§å° int maxson=-1;//è®°å½•é‡å„¿å­çš„å„¿å­æ•° for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//è‹¥ä¸ºçˆ¶äº²åˆ™continue dfs1(y,x,deep+1);//dfså…¶å„¿å­ siz[x]+=siz[y];//æŠŠå®ƒçš„å„¿å­æ•°åŠ åˆ°å®ƒèº«ä¸Š if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„é‡å„¿å­ç¼–å· } } inline void dfs2(int x,int topf) {//xå½“å‰èŠ‚ç‚¹ï¼Œtopfå½“å‰é“¾çš„æœ€é¡¶ç«¯çš„èŠ‚ç‚¹ id[x]=++cnt;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ–°ç¼–å· wt[cnt]=w[x];//æŠŠæ¯ä¸ªç‚¹çš„åˆå§‹å€¼èµ‹åˆ°æ–°ç¼–å·ä¸Šæ¥ top[x]=topf;//è¿™ä¸ªç‚¹æ‰€åœ¨é“¾çš„é¡¶ç«¯ if(!son[x])return;//å¦‚æœæ²¡æœ‰å„¿å­åˆ™è¿”å› dfs2(son[x],topf);//æŒ‰å…ˆå¤„ç†é‡å„¿å­ï¼Œå†å¤„ç†è½»å„¿å­çš„é¡ºåºé€’å½’å¤„ç† for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//å¯¹äºæ¯ä¸€ä¸ªè½»å„¿å­éƒ½æœ‰ä¸€æ¡ä»å®ƒè‡ªå·±å¼€å§‹çš„é“¾ } } int main() { int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); dfs1(1,0,1);dfs2(1,1);build(1,1,n); int q;cin&gt;&gt;q; while(q--){ string str;int u,t; cin&gt;&gt;str&gt;&gt;u&gt;&gt;t; if(str==&quot;CHANGE&quot;){ addrange(u,u,t); } else if(str==&quot;QMAX&quot;){ printf(&quot;%d\n&quot;,querymax(u,t)); } else{ printf(&quot;%d\n&quot;,queryrange(u,t)); } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>æ ‘é“¾å‰–åˆ†</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ‘é“¾å‰–åˆ†ï¼ˆæ¨¡æ¿ï¼‰]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fe6-a0-91-e9-93-be-e5-89-96-e5-88-86-ef-bc-88-e6-a8-a1-e6-9d-bf-ef-bc-89%2F</url>
    <content type="text"><![CDATA[å…ˆæ¥å›é¡¾ä¸¤ä¸ªé—®é¢˜ï¼š 1ï¼Œå°†æ ‘ä»xåˆ°yç»“ç‚¹æœ€çŸ­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šz è¿™ä¹Ÿæ˜¯ä¸ªæ¨¡æ¿é¢˜äº†å§ æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œæ ‘ä¸Šå·®åˆ†å¯ä»¥ä»¥O(n+m)çš„ä¼˜ç§€å¤æ‚åº¦è§£å†³è¿™ä¸ªé—®é¢˜ 2ï¼Œæ±‚æ ‘ä»xåˆ°yç»“ç‚¹æœ€çŸ­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼ä¹‹å’Œ lcaå¤§æ°´é¢˜ï¼Œæˆ‘ä»¬åˆå¾ˆå®¹æ˜“åœ°æƒ³åˆ°ï¼Œdfs O(n)é¢„å¤„ç†æ¯ä¸ªèŠ‚ç‚¹çš„disï¼ˆå³åˆ°æ ¹èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼‰ ç„¶åå¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæ±‚å‡ºx,yä¸¤ç‚¹çš„lcaï¼Œåˆ©ç”¨lcaçš„æ€§è´¨distance ( x , y ) = dis ( x ) + dis ( y ) - 2 * dis ( lca )æ±‚å‡ºç»“æœ æ—¶é—´å¤æ‚åº¦O(mlogn+n) ç°åœ¨æ¥æ€è€ƒä¸€ä¸ªbugï¼š å¦‚æœåˆšæ‰çš„ä¸¤ä¸ªé—®é¢˜ç»“åˆèµ·æ¥ï¼Œæˆä¸ºä¸€é“é¢˜çš„ä¸¤ç§æ“ä½œå‘¢ï¼Ÿ æ¨¡æ¿è¦æ±‚ï¼š å¦‚é¢˜ï¼Œå·²çŸ¥ä¸€æ£µåŒ…å«Nä¸ªç»“ç‚¹çš„æ ‘ï¼ˆè¿é€šä¸”æ— ç¯ï¼‰ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸ŠåŒ…å«ä¸€ä¸ªæ•°å€¼ï¼Œéœ€è¦æ”¯æŒä»¥ä¸‹æ“ä½œï¼š æ“ä½œ1ï¼š æ ¼å¼ï¼š 1 x y z è¡¨ç¤ºå°†æ ‘ä»xåˆ°yç»“ç‚¹æœ€çŸ­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šz æ“ä½œ2ï¼š æ ¼å¼ï¼š 2 x y è¡¨ç¤ºæ±‚æ ‘ä»xåˆ°yç»“ç‚¹æœ€çŸ­è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼ä¹‹å’Œ æ“ä½œ3ï¼š æ ¼å¼ï¼š 3 x z è¡¨ç¤ºå°†ä»¥xä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å†…æ‰€æœ‰èŠ‚ç‚¹å€¼éƒ½åŠ ä¸Šz æ“ä½œ4ï¼š æ ¼å¼ï¼š 4 x è¡¨ç¤ºæ±‚ä»¥xä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å†…æ‰€æœ‰èŠ‚ç‚¹å€¼ä¹‹å’Œ ä»¥ä¸‹æ¨¡æ¿è¯·åŠ¡å¿…æ³¨æ„ï¼š ä¸éœ€è¦modçš„æ—¶å€™è¯·æ³¨æ„ç‰¹æ®Šå¤„ç†ï¼ï¼ï¼ä»¥åŠæ¯ä¸ªå‡½æ•°é‡ŒåŸºæœ¬éƒ½æœ‰çš„nè¿™ä¸ªå‚æ•°ï¼Œå°±æ˜¯è¯»å…¥çš„æ—¶å€™èŠ‚ç‚¹çš„æ€»æ•°ï¼ï¼ï¼#include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef long long ll ; const int maxn=200000+10; vector&lt;int&gt;G[maxn]; int mod; //è§é¢˜æ„ int w[maxn],wt[maxn]; //w[]ã€wt[]åˆå§‹ç‚¹æƒæ•°ç»„ int a[maxn&lt;&lt;2],lazytab[maxn&lt;&lt;2]; //çº¿æ®µæ ‘æ•°ç»„ã€lazyæ“ä½œ int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; //son[]é‡å„¿å­ç¼–å·,id[]æ–°ç¼–å·,fa[]çˆ¶äº²èŠ‚ç‚¹,cnt dfs_clock/dfsåº,dep[]æ·±åº¦,siz[]å­æ ‘å¤§å°,top[]å½“å‰é“¾é¡¶ç«¯èŠ‚ç‚¹ int res=0; //æŸ¥è¯¢ç­”æ¡ˆ //-------------------------------------- ä»¥ä¸‹ä¸ºçº¿æ®µæ ‘ inline void pushdown(int rt,int lenn) { lazytab[rt&lt;&lt;1]+=lazytab[rt]; lazytab[rt&lt;&lt;1|1]+=lazytab[rt]; a[rt&lt;&lt;1]+=lazytab[rt]*(lenn-(lenn&gt;&gt;1)); a[rt&lt;&lt;1|1]+=lazytab[rt]*(lenn&gt;&gt;1); a[rt&lt;&lt;1]%=mod; a[rt&lt;&lt;1|1]%=mod; lazytab[rt]=0; } inline void build(int rt,int l,int r) { if(l==r){ a[rt]=wt[l]; if(a[rt]&gt;mod)a[rt]%=mod; return; } build(rt&lt;&lt;1,l,(l+r)&gt;&gt;1); build(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } inline void query(int rt,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R){ res+=a[rt];res%=mod;return; } else{ if(lazytab[rt])pushdown(rt,r-l+1); if(L&lt;=((l+r)&gt;&gt;1))query(rt&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R); if(R&gt;(l+r)&gt;&gt;1)query(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R); } } inline void update(int rt,int l,int r,int L,int R,int k) { if(L&lt;=l&amp;&amp;r&lt;=R){ lazytab[rt]+=k; a[rt]+=k*(r-l+1); } else{ if(lazytab[rt])pushdown(rt,(r-l+1)); if(L&lt;=((l+r)&gt;&gt;1))update(rt&lt;&lt;1,l,((l+r)&gt;&gt;1),L,R,k); if(R&gt;((l+r)&gt;&gt;1))update(rt&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; } } //---------------------------------ä»¥ä¸Šä¸ºçº¿æ®µæ ‘ inline int queryrange(int x, int y,int n)//æŸ¥è¯¢ä»xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹çš„æƒå€¼ä¹‹å’Œ,nå°±æ˜¯èŠ‚ç‚¹çš„æ€»æ•° { int ans=0; while(top[x]!=top[y]){//å½“ä¸¤ä¸ªç‚¹ä¸åœ¨åŒä¸€æ¡é“¾ä¸Š if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//æŠŠxç‚¹æ”¹ä¸ºæ‰€åœ¨é“¾é¡¶ç«¯çš„æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ res=0; query(1,1,n,id[top[x]],id[x]);//ansåŠ ä¸Šxç‚¹åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯ è¿™ä¸€æ®µåŒºé—´çš„ç‚¹æƒå’Œ ans+=res; ans%=mod;//æŒ‰é¢˜æ„å–æ¨¡ x=fa[top[x]];//æŠŠxè·³åˆ°xæ‰€åœ¨é“¾é¡¶ç«¯çš„é‚£ä¸ªç‚¹çš„ä¸Šé¢ä¸€ä¸ªç‚¹ } //ç›´åˆ°ä¸¤ä¸ªç‚¹å¤„äºä¸€æ¡é“¾ä¸Š if(dep[x]&gt;dep[y])swap(x,y);//æŠŠxç‚¹æ·±åº¦æ›´æ·±çš„é‚£ä¸ªç‚¹ res=0; query(1,1,n,id[x],id[y]);//è¿™æ—¶å†åŠ ä¸Šæ­¤æ—¶ä¸¤ä¸ªç‚¹çš„åŒºé—´å’Œå³å¯ ans+=res; return ans%mod; } inline void addrange(int x, int y, int k,int n)//xåˆ°yæœ€çŸ­è·¯å¾„ä¸Šçš„ç‚¹éƒ½åŠ ä¸Šk {//åŒä¸Š k%=mod; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k); } inline int qSon(int x,int n)//æŸ¥è¯¢xçš„å­æ ‘çš„æƒå€¼å’Œ { res=0; query(1,1,n,id[x],id[x]+siz[x]-1);//å­æ ‘åŒºé—´å³ç«¯ç‚¹ä¸ºid[x]+siz[x]-1 return res; } inline void updSon(int x,int k,int n)//xçš„å­æ ‘ä¸­çš„ç‚¹éƒ½åŠ ä¸Šk {//åŒä¸Š update(1,1,n,id[x],id[x]+siz[x]-1,k); } inline void dfs1(int x,int f,int deep) {//xå½“å‰èŠ‚ç‚¹ï¼Œfçˆ¶äº²ï¼Œdeepæ·±åº¦ dep[x]=deep;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ·±åº¦ fa[x]=f;//æ ‡è®°æ¯ä¸ªç‚¹çš„çˆ¶äº² siz[x]=1;//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„å­æ ‘å¤§å° int maxson=-1;//è®°å½•é‡å„¿å­çš„å„¿å­æ•° for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==f)continue;//è‹¥ä¸ºçˆ¶äº²åˆ™continue dfs1(y,x,deep+1);//dfså…¶å„¿å­ siz[x]+=siz[y];//æŠŠå®ƒçš„å„¿å­æ•°åŠ åˆ°å®ƒèº«ä¸Š if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//æ ‡è®°æ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„é‡å„¿å­ç¼–å· } } inline void dfs2(int x,int topf) {//xå½“å‰èŠ‚ç‚¹ï¼Œtopfå½“å‰é“¾çš„æœ€é¡¶ç«¯çš„èŠ‚ç‚¹ id[x]=++cnt;//æ ‡è®°æ¯ä¸ªç‚¹çš„æ–°ç¼–å· wt[cnt]=w[x];//æŠŠæ¯ä¸ªç‚¹çš„åˆå§‹å€¼èµ‹åˆ°æ–°ç¼–å·ä¸Šæ¥ top[x]=topf;//è¿™ä¸ªç‚¹æ‰€åœ¨é“¾çš„é¡¶ç«¯ if(!son[x])return;//å¦‚æœæ²¡æœ‰å„¿å­åˆ™è¿”å› dfs2(son[x],topf);//æŒ‰å…ˆå¤„ç†é‡å„¿å­ï¼Œå†å¤„ç†è½»å„¿å­çš„é¡ºåºé€’å½’å¤„ç† for(int i=0;i&lt;G[x].size();i++){ int y=G[x][i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//å¯¹äºæ¯ä¸€ä¸ªè½»å„¿å­éƒ½æœ‰ä¸€æ¡ä»å®ƒè‡ªå·±å¼€å§‹çš„é“¾ } } int main() { int n,m,r; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;n;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b);G[b].push_back(a); } dfs1(r,0,1); dfs2(r,r); build(1,1,n);//å»ºæ ‘ while(m--){ int k,x,y,z; cin&gt;&gt;k; if(k==1){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addrange(x, y, z,n); } else if(k==2){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\n&quot;, queryrange(x, y, n)); } else if(k==3){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); updSon(x,y,n); } else{ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\n&quot;,qSon(x,n)); } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>æ ‘é“¾å‰–åˆ†</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #455 (Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-455-div-2%2F</url>
    <content type="text"><![CDATA[A. æš´åŠ›æšä¸¾å³å¯ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;set&gt; using namespace std; int main() { set&lt;string&gt;s; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int i,j; for(i=0;i&lt;str1.size();i++){ string str11=str1.substr(0,i+1); for(j=0;j&lt;str2.size();j++){ string str22=str2.substr(0,j+1); s.insert(str11+str22); } } cout&lt;&lt;*s.begin()&lt;&lt;endl; return 0; } B. ç»“è®ºé¢˜ã€‚é¦–å…ˆæƒ³è±¡å¯¹äºä¸€ä¸ªåŒºé—´[i,i+1],æ‰€æœ‰è¦†ç›–è¿™ä¸ªåŒºé—´çš„çº¿æ®µéƒ½å¿…ç„¶å±äºä¸åŒçš„å±‚ï¼Œå¦åˆ™ä»»æ„ä¸¤ä¸ªçº¿æ®µéƒ½ä¼šç›¸äº¤ï¼Œæ˜¾ç„¶ä¸è¡Œã€‚é‚£ä¹ˆæˆ‘ä»¬æœ‰ä¸€ä¸ªå¤§èƒ†çš„æƒ³æ³•ï¼šæšä¸¾æ‰€æœ‰çš„iï¼Œæ‰¾å‡º(i+1)* (n-i)ä¸­æœ€å¤§çš„å³æ˜¯ç­”æ¡ˆã€‚äº‹å®ä¸Šç¡®å®å¦‚æ­¤ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,i,j,ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++){ ans=max(ans,(i+1)*(n-i)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. é¢˜æ„ï¼šfä»£è¡¨forè¯­å¥ï¼Œå®ƒåé¢çš„è¯­å¥è‡³å°‘æœ‰ä¸€å¥æ˜¯å®ƒå†…éƒ¨çš„ï¼Œå…¶ä»–è¯­å¥è¦ä¹ˆåœ¨å†…éƒ¨è¦ä¹ˆåœ¨å¤–éƒ¨ï¼Œsè¯­å¥æ˜¯æ™®é€šè¯­å¥ã€‚ç»™ä¸€ä¸ªæ²¡æœ‰ç¼©è¿›çš„f, sä»£ç ï¼Œæ±‚ä¸€å…±æœ‰å¤šå°‘ç§æ»¡è¶³ä¸Šè¿°çš„ç¼©è¿›æ–¹æ¡ˆï¼Œç»“æœæ¨¡1e9+7ã€‚ ä»¤f[i][j]ä»£è¡¨ç¬¬iè¡Œæœ‰jä¸ªç¼©è¿›çš„å¯èƒ½æ•°ã€‚é‚£ä¹ˆå¯¹äºæ¯ä¸€è¡Œçš„è¯­å¥ï¼Œå¦‚æœä»–æ˜¯fçš„è¯ï¼Œé‚£ä¹ˆæ˜¾ç„¶ï¼Œè¿™ä¸€è¡Œçš„ç¼©è¿›åªèƒ½++ï¼›ä½†å¦‚æœè¿™ä¸€è¡Œæ˜¯sçš„è¯ï¼Œé‚£ä¹ˆå…¶å®è¿™ä¸€ä¸ªè¯­å¥å¯ä»¥æ˜¯ä¸Šé¢ä»»æ„ä¸€ä¸ªfçš„ç¼©è¿›ã€‚å› æ­¤å¯¹äºj=1â€¦cnt,æœ‰f[i][j]+=f[i-1]kï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è¶æœºå‹ç¼©ä¸€ç»´ï¼ˆå‰ç¼€å’Œdpï¼‰ï¼Œå¯¹äºj=1..cntï¼Œæœ‰f[j]+=f[j-1]å³å¯ï¼Œå½“ç„¶è¦å–æ¨¡ï¼› æœ€åä¸€è¡Œå¦‚æœä¸æ˜¯ç´§æ¥ç€fçš„ï¼Œé‚£ä¹ˆf[cnt]å°±æ˜¯å‰ç¼€å’Œdpï¼Œå¦åˆ™å°±æ˜¯fåœ¨æœ‰cntä¸ªç¼©è¿›ä¸‹çš„æƒ…å†µï¼Œå› æ­¤è¾“å‡ºf[cnt]å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; long long f[5005]; const int mod=1e9+7; int main() { int n,i,j,cnt=0;char c; cin&gt;&gt;n; f[0]=1; for(i=1;i&lt;=n;i++){ cin&gt;&gt;c; if(c==&apos;f&apos;) cnt++; else{ for(j=1;j&lt;=cnt;j++) f[j]=(f[j]+f[j-1])%mod; } } cout&lt;&lt;f[cnt]&lt;&lt;endl; return 0; } D. æˆ‘ä»¬å¯ä»¥è®¾æƒ³ï¼Œå¦‚æœæˆ‘ä»¬æŠŠè¿™äº›ç‚¹æŒ‰ç…§ç›¸é‚»çš„ç›¸åŒé¢œè‰²ä¸ºæ ‡å‡†åˆ†ä¸ºè¿ç»­çš„ä¸€ç»„ç»„çš„è¯ï¼Œé‚£ä¹ˆæ¯æ¬¡æ“ä½œåè¢«åˆ å»çš„ç‚¹è‚¯å®šéƒ½æ˜¯æ¯ä¸€ç»„å·¦å³ä¸¤ç«¯çš„ä¸¤ä¸ªç‚¹ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‚¹ä¸ä¸åŒé¢œè‰²çš„æ®µæ¥å£¤ï¼ˆå½“ç„¶ç¬¬ä¸€æ®µä¸æœ€åä¸€æ®µé™¤å¤–ï¼Œä»–ä»¬æ¯æ¬¡åªå‡1ï¼‰ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é‡å¤æ­¤æ“ä½œï¼Œç›´åˆ°è‡³å°‘æœ‰ä¸€æ®µè¢«åˆ å…‰ï¼Œè¿™æ—¶ï¼Œä»–çš„å·¦å³ä¸¤ä¸ªåŒºé—´å¯èƒ½å› ä¸ºé¢œè‰²ç›¸åŒå˜æˆä¸€ä¸ªåŒºé—´ï¼Œè¿™æ—¶å€™å°±å¿…è¦é‡æ–°å®‰æ’äº†ã€‚å†™æ³•è¿˜æ˜¯æŒºç²¾å¦™çš„ ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef pair&lt;char,int&gt;P; const int maxn=1e6+5; char s[maxn]; int main() { int cnt,i,j,ans=0,tot=0; scanf(&quot;%s&quot;,s+1); P pa[maxn]; int n=strlen(s+1); for(i=1;i&lt;=n;i++) { if (s[i] != s[i - 1]) pa[++tot] = P(s[i], 1);//é¢„å¤„ç†æ®µ else pa[tot].second++; } for(;tot&gt;1;tot=cnt,ans++){ pa[1].second--;pa[tot].second--;//å¤„ç†å¤´å°¾ for(i=2;i&lt;tot;i++)//ä¸­é—´å„æ®µ-=2 pa[i].second-=2; for(cnt=0,i=1;i&lt;=tot;i++){ if(pa[i].second&gt;0) {//å¦‚æœè¿™ä¸€æ®µè¿˜æ²¡æœ‰è¢«åˆ å®Œ if (pa[i].first != pa[cnt].first)//å¦‚æœä»–è·Ÿå‰é¢æ¥å£¤çš„åŒºé—´é¢œè‰²ä¸ç›¸åŒ,è®°ä¸ºæ–°çš„åŒºé—´ pa[++cnt]=pa[i]; else pa[cnt].second += pa[i].second;//å¦åˆ™é‡æ–°è®¡é‡è¯¥åŒºé—´ } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } E. å¯ä»¥æƒ³è±¡ï¼Œæ˜¯ä»€ä¹ˆæƒ…å†µä¸‹åˆ†ç»™å‰¯æ ¸çš„ä»»åŠ¡éœ€è¦åˆ†æˆå‡ æ¬¡ï¼Ÿæ˜¾ç„¶æ˜¯å› ä¸ºå‰¯æ ¸ä¾èµ–ä¸€ä¸ªä¸»æ ¸çš„ä»»åŠ¡ï¼Œè€Œè¿™ä¸ªä¸»æ ¸çš„ä»»åŠ¡åˆä¾èµ–äºä¸€ä¸ªå‰¯æ ¸çš„ä»»åŠ¡ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå…¶ä½™ä»»åŠ¡éƒ½æ˜¯å¯ä»¥ä¸€æ¬¡ä¸¢è¿›æ ¸ä¸­å®Œæˆçš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œæ¯æ¬¡æŠŠæ‰€æœ‰å¯ä»¥ä¸€æ¬¡å®Œæˆçš„ä»»åŠ¡åˆ†åˆ«ä¸¢è¿›ä¸»å‰¯æ ¸çš„é˜Ÿåˆ—ä¸­ï¼ˆç±»ä¼¼æ‹“æ‰‘æ’åºçš„æ€æƒ³ï¼‰ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚ #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; const int N=100050; vector&lt;int&gt; E[N]; queue&lt;int&gt; q[2]; int c=0,in[N],col[N],sol=0; int main() { int n,m,u,v,i; scanf(&quot;%i %i&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;col[i]); while(m--) { scanf(&quot;%d%d&quot;,&amp;u,&amp;v); E[v].push_back(u); in[u]++;//å…¥åº¦ } for(i=0;i&lt;n;i++) if(!in[i]) q[col[i]].push(i); while(!q[0].empty() || !q[1].empty()) { if(q[c].empty()) {//æ­¤é˜Ÿåˆ—ç©ºäº†è€Œå¦ä¸€ä¸ªé˜Ÿåˆ—æœªç©º,è¯´æ˜éœ€è¦æ¢é˜Ÿåˆ—æ‰§è¡Œä»»åŠ¡äº† if (!c) sol++;//å‰¯æ ¸æ¸…ç©ºè€Œä¸»æ ¸æœªæ¸…ç©º,æ˜¾ç„¶å‰¯æ ¸éœ€è¦æ¬¡æ•°++ c ^= 1;//æ¢æ ¸ } u=q[c].front(); q[c].pop(); for(i=0;i&lt;E[u].size();i++) { v=E[u][i]; in[v]--; if(!in[v]) q[col[v]].push(v); } } printf(&quot;%d\n&quot;,sol); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucaså®šç†]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Flucas-e5-ae-9a-e7-90-86%2F</url>
    <content type="text"><![CDATA[Lucaså®šç†æ˜¯ç”¨æ¥è§£å†³å¤§ç»„åˆæ•°å–æ¨¡çš„ï¼Œå³æ±‚$C_n ^m \ mod\ p$,å…¶ä¸­$p$ä¸ºè´¨æ•°ã€‚ å…¬å¼ï¼š$C_n ^m\ mod\ p=C_{n/p}^{m/p}\times C_{n\ mod\ p}^{m\ mod\ p}\ mod\ p$ å½“æ¨¡æ•°påœ¨å˜åŒ–æ—¶è¿ç”¨æš´åŠ›æ–¹æ³•è®¡ç®—ç»„åˆæ•°ï¼š#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; ll Power_mod(ll a, ll b, ll p)//å¿«é€Ÿå¹‚ { ll res = 1; while(b!=0) { if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; } return res; } ll Comb(ll a,ll b, ll p)//æš´åŠ›è®¡ç®—ç»„åˆæ•° { if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b;//ç»„åˆæ•°çš„æ€§è´¨,C(m,n)=C(m,m-n); ll ans = 1, ca = 1, cb = 1; for(ll i=0; i&lt;b; ++i) {//æš´åŠ›è®¡ç®—é˜¶ä¹˜ ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; } ans = (ca*Power_mod(cb, p-2, p))%p; return ans; } ll Lucas(int n, int m, int p)//Lucas { ll ans = 1; while(n &amp;&amp; m &amp;&amp; ans) { ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; } return ans; } int main() { int n,m,p; while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p) !=EOF) { printf(&quot;%lld\n&quot;, Lucas(n, m, p)); } return 0; } å½“æ¨¡æ•°på›ºå®šæ—¶åˆ™å¯¹ç»„åˆæ•°è¿›è¡Œé¢„å¤„ç†ï¼Œé€’æ¨æ±‚é€†å…ƒï¼›#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1e5+5; typedef long long ll; ll inv[maxn],fac[maxn];ll p; void init() { fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=fac[i-1]*i%p;//æ±‚é˜¶ä¹˜ inv[0] = inv[1] = 1; for (int i = 2; i &lt; maxn; i++) inv[i] = (p - p / i) * inv[p % i] % p;//é€’æ¨æ±‚é€†å…ƒ } ll C(ll n,ll m) { if (n&lt;m) return 0; return fac[n]*inv[fac[m]]*inv[fac[n-m]]%p;//åˆ©ç”¨é€†å…ƒæ±‚ç»„åˆæ•° } ll lucas(ll n,ll m) { if (!m) return 1ll; return C(n%p,m%p)*lucas(n/p,m/p)%p;//Lucas } int main() { return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç»„åˆæ•°]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe7-bb-84-e5-90-88-e6-95-b0%2F</url>
    <content type="text"><![CDATA[ç»„åˆæ•°å…¬å¼ï¼š $C_{m}^{n}=\frac{m!}{n!(m-n)!}$ æ–¹æ³•ä¸€ï¼šåˆ©ç”¨å…¬å¼ $C_m^n=C_{m-1}^{n-1}+C_{m-1}^{n}$ ä»mä¸ªå…ƒç´ é‡ŒæŒ‘nä¸ªå…ƒç´ ï¼Œé’ˆå¯¹ç¬¬ä¸€ä¸ªå…ƒç´ è¦ä¹ˆæ˜¯nä¸ªé‡Œçš„è¦ä¹ˆä¸æ˜¯ï¼Œå¦‚æœæ˜¯çš„,é‚£ä¹ˆå°±ä»å‰©ä¸‹çš„m-1ä¸ªé‡ŒæŒ‘n-1ä¸ª å°±æ˜¯c(m-1,n-1);å¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ ä¸æ˜¯né‡Œçš„ï¼Œå°±ä»å‰©ä¸‹çš„m-1ä¸ªå…ƒç´ é‡ŒæŒ‘nä¸ªï¼Œå°±æ˜¯c(m-1,n)ã€‚ é€’å½’æ±‚æ³•ï¼š #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long comb(int m,int n) { if(n==0) return 1; if(n==1) return m; if(n&gt;m/2) return comb(m,m-n); if(n&gt;1) return (comb(m-1,n-1)+comb(m-1,n)); } int main() { int m,n; while(cin&gt;&gt;m&gt;&gt;n) cout&lt;&lt;comb(m,n)&lt;&lt;endl; return 0; } æ–¹æ³•äºŒï¼š 1ã€æ±‚å–1åˆ°nçš„é˜¶ä¹˜å¯¹ mod å–æ¨¡çš„ç»“æœå­˜å…¥æ•°ç»„ JC ä¸­ï¼› 2ã€æ±‚å– C(n,r) æ—¶ï¼Œ å…ˆåˆ©ç”¨â€œæ‹“å±•æ¬§å‡ é‡Œå¾—ç®—æ³•â€æˆ–è€…â€œè´¹é©¬å°å®šç†+å¿«é€Ÿå¹‚â€æ±‚ JC[r]çš„é€†å…ƒå­˜å…¥ä¸´æ—¶å˜é‡ x1 ; 3ã€ç„¶åè®¡ç®— JC[n] âˆ— x1 % mod å­˜å…¥ä¸´æ—¶å˜é‡ x2;ï¼ˆx2 å³ä¸ºn!/r! %mod çš„å€¼ï¼‰ 4ã€æ±‚å–JC[n - r] çš„é€†å…ƒå­˜å…¥ä¸´æ—¶å˜é‡ x3; 5ã€åˆ™å¯ä»¥å¾—åˆ° C(n,r)=x2âˆ—x3%mod]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 35 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-35-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. æš´åŠ›æ‰«å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } B. æœ€å¤§åŒ–æœ€å°å€¼ï¼Œä¸€çœ‹å°±å¯ä»¥äºŒåˆ†ã€‚æ³¨æ„æ¯ä¸ªè›‹ç³•éƒ½è¦æœ‰å»å¤„â€¦æ‰€ä»¥è¦æ³¨æ„å¦‚æœæœ‰ä¸€ç§è›‹ç³•éå¸¸å°‘çš„è¯ä¹Ÿæ˜¯è¦å•ç‹¬å ä¸€ç›˜çš„â€¦ç„å­¦äºŒåˆ†å±…ç„¶æ²¡æ­»å¾ªç¯ï¼Œå¼€å¿ƒ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int a[100005]; int main() { int n,i,j,k; cin&gt;&gt;n; int minn=1e9; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);minn=min(minn,a[i]); } int pre=0,ans=1e6; for(i=1;i&lt;=n;i++){ if(a[i]==minn){ if(pre){ ans=min(ans,i-pre); } pre=i; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. è¯´ç™½äº†å°±æ˜¯æšä¸¾æ‰¾è§„å¾‹ï¼Œä¼šå‘ç°æœ‰1çš„æ—¶å€™ï¼Œæˆ–è€…æœ‰ä¿©2ï¼Œæˆ–è€…3ä¸ªéƒ½æ˜¯3ï¼Œåˆæˆ–è€…ä¸€ä¸ª2é…ä¿©4æ˜¯å¯ä»¥çš„ï¼Œå…¶ä»–éƒ½æ˜¯ä¸è¡Œçš„ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int k,cnt[1505]={0},i; for(i=1;i&lt;=3;i++){ cin&gt;&gt;k;cnt[k]++; } if(cnt[1]||cnt[2]&gt;=2||cnt[3]==3||(cnt[2]==1&amp;&amp;cnt[4]==2)){ puts(&quot;YES&quot;); } else puts(&quot;NO&quot;); return 0; } D. ç»™å‡ºä¸€ä¸ªå«æœ‰ n ä¸ªæ•°çš„åºåˆ—ï¼Œè®©ä½ æ±‚æ¯æ¬¡åè½¬åŒºé—´ [ l , r ] åæ•´ä¸ªåºåˆ—çš„é€†åºæ•°æ˜¯å¥‡æ˜¯å¶ã€‚ é¦–å…ˆæœ‰ä¸€ä¸ªæœ´ç´ çš„æƒ³æ³•å°±æ˜¯æš´åŠ›æšä¸¾ï¼Œå½“ç„¶å°±ç®—ç”¨å½’å¹¶æ’åºå»è®¡ç®—é€†åºå¯¹ä¹Ÿæ˜¯ä¼štleçš„â€¦ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int cnt; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } int main() { int n,i,j,a[1600],a1[1600],t[1600],m,l,r; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); cin&gt;&gt;m; for(i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);cnt=0; reverse(a+l,a+r+1); memcpy(a1,a,sizeof(a)); mergesort(a1,1,n,t); //cout&lt;&lt;cnt&lt;&lt;endl; if(cnt&amp;1) puts(&quot;odd&quot;); else puts(&quot;even&quot;); } return 0; } å½“å°†åŒºé—´$ [ l , r ]$ åè½¬åï¼Œåªæœ‰è¯¥åŒºé—´å†…çš„é€†åºæ•°äº§ç”Ÿäº†å˜åŒ–ï¼Œå…¶ä»–çš„ä¸å˜ã€‚å…·ä½“å˜åŒ–æ˜¯è¯¥åŒºé—´ä¹‹å‰æ˜¯æ­£åºçš„å˜æˆäº†é€†åºï¼Œä¹‹å‰æ˜¯é€†åºçš„å˜æˆäº†æ­£åºã€‚å¦‚æœæˆ‘ä»¬çŸ¥é“åè½¬å‰é€†åºæ•°æ˜¯å¥‡æ˜¯å¶ï¼Œå†åŠ ä¸ŠçŸ¥é“åè½¬åé€†åºå¯¹ç›¸å·®æ˜¯å¥‡æ˜¯å¶å°±å¯ä»¥çŸ¥é“ç»“æœäº†ã€‚ è®¾è¯¥åŒºé—´é•¿åº¦ä¸º lenï¼Œåˆ™è¯¥åŒºé—´å…±æœ‰ $len (len-1)/2$ ä¸ªæ•°å¯¹ï¼Œè®¾åè½¬åé€†åºçš„æœ‰ num ä¸ªï¼Œåˆ™æ­£åºçš„æœ‰ $len(len-1)/2 - num$ ä¸ªï¼Œåè½¬å‰åé€†åºå¯¹ç›¸å·® $num-( len(len-1)/2 - num )$ ä¸ªï¼ŒåŒ–ç®€å¾— $num 2 - len(len-1)/2$ ä¸ªï¼Œ$num 2$ ä¸€å®šä¸ºå¶æ•°ï¼Œä¸å½±å“å¥‡å¶æ€§ï¼Œæ‰€ä»¥åªçœ‹ $len(len-1)/2 $çš„å¥‡å¶æ€§å°±å¯ä»¥äº†ã€‚ åˆ¤æ–­å¥‡å¶å¯ä»¥ç”¨å¼‚æˆ–æ¥åš #include&lt;cstdio&gt; int main() { int n,i,j,a[1505],m,l,r,x=0; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); for(i=1;i&lt;n;++i) for(j=i+1;j&lt;=n;++j) x^=a[i]&gt;a[j]; scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r);i=r-l+1; x^=(i*(i-1)&gt;&gt;1)&amp;1; puts(x?&quot;odd&quot;:&quot;even&quot;); } return 0; } E. å¯¹äºç»™å®šçš„å‰kä¸ªï¼Œå…¶å®æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œå°±æ˜¯æ¨¡æ‹Ÿï¼Œçœ‹é‡Œé¢æœ‰å¯¹å°‘ä¸ªæ•°èƒ½å¤Ÿç›´æ¥æ”¾åˆ°bé‡Œé¢ï¼Œæ‰«å®Œè¿™kä¸ªä¹‹åï¼Œå¦‚æœæ ˆé‡Œè¿˜æœ‰é‚£ä¹ˆè‚¯å®šæ˜¯é‚£äº›ç¼ºä¹å°çš„æ•°ä»¥è‡´äºæ— æ³•æ”¾è¿›bçš„ï¼Œè¿™æ—¶å€™æˆ‘ä»¬ä¸ºäº†èƒ½å¤ŸæŠŠè¿™äº›æ•°é¡ºåˆ©æ”¾è¿›bï¼Œè‚¯å®šæ˜¯è¦é€æ­¥è¡¥é½æ ˆé¡¶é¡¹åˆ°bä¸­å·²æœ‰é¡¹ä¹‹é—´ç¼ºå¤±çš„é¡¹çš„ï¼Œè¿™åŒæ—¶è‚¯å®šä¹Ÿæ˜¯å­—å…¸åºæœ€å¤§å€¼ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; const int N=2e5+1; int n,k,a[N],t=1; stack&lt;int&gt;s; int main() { cin&gt;&gt;n&gt;&gt;k; s.push(n+1);//å…ˆç½®å…¥ä¸€ä¸ªn+1ä»¥é˜²æ ˆç©ºre for(int i=0;i&lt;n;i++){ if(i&lt;k)cin&gt;&gt;a[i]; else a[i]=s.top()-1;//å‰©ä¸‹çš„éƒ½æ˜¯ç¼ºå°é¡¹æ— æ³•å‡ºæ ˆçš„ s.push(a[i]); while(s.size()&amp;&amp;s.top()==t)s.pop(),t++; } if(s.size())puts(&quot;-1&quot;);//å¦‚æœè¿˜æœ‰å‰©ä½™è¯´æ˜åŸæ¥çš„é¡ºåºæœ‰é—®é¢˜ else for(int i=0;i&lt;n;i++)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å½’å¹¶æ’åº]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2Fe5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[å¤ä¹ ä¸€æ³¢ï¼Œå‘ç°éƒ½å¿«å¿˜å…‰äº†QAQâ€¦ åˆ©ç”¨äºŒåˆ†çš„æ€æƒ³ï¼Œä¸æ–­åˆ†å‰²æ’åºåŒºé—´ã€‚ void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++]; } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i];//è¿™é‡Œè¦æ³¨æ„å‰é¢æ•°ç»„çš„ä¸‹æ ‡ } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } } å½’å¹¶æ’åºè¯¾ç”¨äºè®¡ç®—é€†åºå¯¹ï¼Œå› ä¸ºå¦‚æœæ˜¯éé€†åºçš„æ•°ï¼Œé‚£ä¹ˆåœ¨mergearrayçš„æ—¶å€™å‰é¢çš„è‚¯å®šæ¯”åé¢çš„å°ï¼Œå¦‚æœå‡ºç°ä¸€ä¸ªæ¯”åé¢å¤§çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°åé¢çš„æ‰€æœ‰å‰é¢çš„æ•°éƒ½ä¸€å®šæ¯”åé¢çš„æ•°å¤§ã€‚ int cnt=0; void mergearray(int*a, int first, int mid, int last, int*temp) { int i = first, j = mid+1, k = last,m=0; while (i &lt;= mid&amp;&amp;j &lt;= last) { if (a[i] &lt; a[j]) temp[++m] = a[i++]; else temp[++m] = a[j++],cnt+=mid-i+1;//å…¶å®åªæœ‰è¿™é‡Œä¸åŒ } while (i &lt;= mid) temp[++m] = a[i++]; while (j &lt;= last) temp[++m] = a[j++]; for (i = 1; i &lt;= m; i++) a[first+i-1] = temp[i]; } void mergesort(int*a, int first, int last, int*temp) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp); mergesort(a, mid + 1, last, temp); mergearray(a, first, mid, last, temp); } }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim æ¸¸æˆ]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2Fnim-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[Nimæ¸¸æˆæ˜¯ç»„åˆæ¸¸æˆ(Combinatorial Games)çš„ä¸€ç§ï¼Œå‡†ç¡®æ¥è¯´ï¼Œå±äºâ€œImpartial Combinatorial Gamesâ€ï¼ˆä»¥ä¸‹ç®€ç§°ICGï¼‰ã€‚æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æ¸¸æˆæ˜¯ICGï¼ˆå¯èƒ½ä¸å¤ªä¸¥è°¨ï¼‰ï¼š1ã€æœ‰ä¸¤åé€‰æ‰‹ï¼›2ã€ä¸¤åé€‰æ‰‹äº¤æ›¿å¯¹æ¸¸æˆè¿›è¡Œç§»åŠ¨(move)ï¼Œæ¯æ¬¡ä¸€æ­¥ï¼Œé€‰æ‰‹å¯ä»¥åœ¨ï¼ˆä¸€èˆ¬è€Œè¨€ï¼‰æœ‰é™çš„åˆæ³•ç§»åŠ¨é›†åˆä¸­ä»»é€‰ä¸€ç§è¿›è¡Œç§»åŠ¨ï¼›3ã€å¯¹äºæ¸¸æˆçš„ä»»ä½•ä¸€ç§å¯èƒ½çš„å±€é¢ï¼Œåˆæ³•çš„ç§»åŠ¨é›†åˆåªå–å†³äºè¿™ä¸ªå±€é¢æœ¬èº«ï¼Œä¸å–å†³äºè½®åˆ°å“ªåé€‰æ‰‹æ“ä½œã€ä»¥å‰çš„ä»»ä½•æ“ä½œã€éª°å­çš„ç‚¹æ•°æˆ–è€…å…¶å®ƒä»€ä¹ˆå› ç´ ï¼› 4ã€å¦‚æœè½®åˆ°æŸåé€‰æ‰‹ç§»åŠ¨ï¼Œä¸”è¿™ä¸ªå±€é¢çš„åˆæ³•çš„ç§»åŠ¨é›†åˆä¸ºç©ºï¼ˆä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶æ— æ³•è¿›è¡Œç§»åŠ¨ï¼‰ï¼Œåˆ™è¿™åé€‰æ‰‹è´Ÿã€‚æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œå¾ˆå¤šæ—¥å¸¸çš„æ¸¸æˆå¹¶éICGã€‚ä¾‹å¦‚è±¡æ£‹å°±ä¸æ»¡è¶³æ¡ä»¶3ï¼Œå› ä¸ºçº¢æ–¹åªèƒ½ç§»åŠ¨çº¢å­ï¼Œé»‘æ–¹åªèƒ½ç§»åŠ¨é»‘å­ï¼Œåˆæ³•çš„ç§»åŠ¨é›†åˆå–å†³äºè½®åˆ°å“ªåé€‰æ‰‹æ“ä½œã€‚ ç»å…¸Nimæ¸¸æˆé€šå¸¸çš„Nimæ¸¸æˆçš„å®šä¹‰æ˜¯è¿™æ ·çš„ï¼šæœ‰è‹¥å¹²å †çŸ³å­ï¼Œæ¯å †çŸ³å­çš„æ•°é‡éƒ½æ˜¯æœ‰é™çš„ï¼Œåˆæ³•çš„ç§»åŠ¨æ˜¯â€œé€‰æ‹©ä¸€å †çŸ³å­å¹¶æ‹¿èµ°è‹¥å¹²é¢—ï¼ˆä¸èƒ½ä¸æ‹¿ï¼‰â€ï¼Œå¦‚æœè½®åˆ°æŸä¸ªäººæ—¶æ‰€æœ‰çš„çŸ³å­å †éƒ½å·²ç»è¢«æ‹¿ç©ºäº†ï¼Œåˆ™åˆ¤è´Ÿï¼ˆå› ä¸ºä»–æ­¤åˆ»æ²¡æœ‰ä»»ä½•åˆæ³•çš„ç§»åŠ¨ï¼‰ã€‚ æˆ‘ä»¬å®šä¹‰Position: Pï¼šè¡¨ç¤ºå½“å‰å±€é¢ä¸‹å…ˆæ‰‹å¿…è´¥ Nï¼šè¡¨ç¤ºå½“å‰å±€é¢ä¸‹å…ˆæ‰‹å¿…èƒœ ç»“è®ºï¼š(Boutonâ€™s Theorem)ï¼š å¯¹äºä¸€ä¸ªNimæ¸¸æˆçš„å±€é¢(a1,a2,â€¦,an)ï¼Œå®ƒæ˜¯P-positionï¼ˆåæ‰‹å¿…èƒœï¼‰å½“ä¸”ä»…å½“ a1^a2^â€¦^an=0ï¼Œå…¶ä¸­^è¡¨ç¤ºå¼‚æˆ–(xor)è¿ç®—ã€‚ å¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶æ¥è¯æ˜ï¼Œè¯¦ç»†è¯æ˜è¿‡ç¨‹ï¼šhttps://blog.csdn.net/Summer\_\_show\_/article/details/70185470 å¦‚æœNimæ¸¸æˆä¸­çš„è§„åˆ™ç¨å¾®å˜åŠ¨ä¸€ä¸‹,æ¯æ¬¡æœ€å¤šåªèƒ½å–Kä¸ª,æ€ä¹ˆå¤„ç†? Ansï¼šå°†æ¯å †çŸ³å­æ•°mod (k+1). Nimçš„å„ç§å˜å½¢Mooreâ€™s Nimk nå †çŸ³å­ï¼Œæ¯æ¬¡ä»ä¸è¶…è¿‡kå †ä¸­å–ä»»æ„å¤šä¸ªçŸ³å­ï¼Œæœ€åä¸èƒ½å–çš„äººå¤±è´¥ã€‚ è¿™æ˜¯ä¸€ä¸ªnimæ¸¸æˆçš„å˜å½¢ï¼Œä¹Ÿæ˜¯æœ‰ç»“è®ºçš„ã€‚ ç»“è®ºä¸ºï¼šæŠŠnå †çŸ³å­çš„çŸ³å­æ•°ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œç»Ÿè®¡æ¯ä¸ªäºŒè¿›åˆ¶ä½ä¸Š1çš„ä¸ªæ•°ï¼Œè‹¥æ¯ä¸€ä½ä¸Š1çš„ä¸ªæ•°mod(k+1)å…¨éƒ¨ä¸º0ï¼Œåˆ™å¿…è´¥ï¼Œå¦åˆ™å¿…èƒœã€‚ anti-nim(åNimæ¸¸æˆ) æ­£å¸¸çš„nimæ¸¸æˆæ˜¯å–èµ°æœ€åä¸€é¢—çš„äººè·èƒœï¼Œè€Œånimæ¸¸æˆæ˜¯å–èµ°æœ€åä¸€é¢—çš„äººè¾“ã€‚ ä¸€ä¸ªçŠ¶æ€ä¸ºå¿…èƒœæ€ï¼Œå½“ä¸”ä»…å½“ï¼š 1ï¼‰æ‰€æœ‰å †çš„çŸ³å­ä¸ªæ•°ä¸º1ï¼Œä¸”NIM_sum=0 2ï¼‰è‡³å°‘æœ‰ä¸€å †çš„çŸ³å­ä¸ªæ•°å¤§äº1ï¼Œä¸” NIM_sumâ‰ 0 ä¾‹å­ï¼šBzoj1022 : https://www.lydsy.com/JudgeOnline/problem.php?id=1022 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int t,i,j,k,n; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; bool onlyone=true; int sum=0; while(n--){ scanf(&quot;%d&quot;,&amp;j); if(j!=1)onlyone=false; sum^=j; } if((onlyone&amp;&amp;!sum)||(!onlyone&amp;&amp;sum)){ puts(&quot;John&quot;); } else puts(&quot;Brother&quot;); } return 0; } å¨ä½å¤«åšå¼ˆ ä¸¤å †çŸ³å­ï¼Œæ¯æ¬¡å¯ä»¥ä»ä¸€å †æˆ–ä¸¤å †ä¸­å–ä»»æ„æ•°ç›®çš„çŸ³å­ï¼Œä»ä¸¤å †ä¸­å–å¾—æ—¶å€™,ä»ä¸åŒå †å–çš„çŸ³å­ä¸ªæ•°å¿…é¡»ç›¸åŒï¼Œå…ˆå–å®Œçš„è·èƒœã€‚ è¿™ç§æƒ…å†µä¸‹æ˜¯é¢‡ä¸ºå¤æ‚çš„ã€‚æˆ‘ä»¬ç”¨ï¼ˆakï¼Œbkï¼‰ï¼ˆak â‰¤ bk ,k=0ï¼Œ1ï¼Œ2ï¼Œâ€¦,n)è¡¨ç¤ºä¸¤å †ç‰©å“çš„æ•°é‡å¹¶ç§°å…¶ä¸ºå±€åŠ¿ï¼Œå¦‚æœç”²é¢å¯¹ï¼ˆ0ï¼Œ0ï¼‰ï¼Œé‚£ä¹ˆç”²å·²ç»è¾“äº†ï¼Œè¿™ç§å±€åŠ¿æˆ‘ä»¬ ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚å‰å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯ï¼šï¼ˆ0ï¼Œ0ï¼‰ã€ï¼ˆ1ï¼Œ2ï¼‰ã€ï¼ˆ3ï¼Œ5ï¼‰ã€ï¼ˆ4ï¼Œ7ï¼‰ã€ï¼ˆ6ï¼Œ10ï¼‰ã€ï¼ˆ8ï¼Œ13ï¼‰ã€ï¼ˆ9ï¼Œ15ï¼‰ã€ï¼ˆ11ï¼Œ18ï¼‰ã€ï¼ˆ12ï¼Œ20ï¼‰ã€‚ å¥‡å¼‚å±€åŠ¿çš„3æ¡æ€§è´¨ï¼š 1.ä»»ä½•è‡ªç„¶æ•°éƒ½åŒ…å«åœ¨ä¸€ä¸ªä¸”ä»…æœ‰ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ä¸­ã€‚ 2.ä»»æ„æ“ä½œéƒ½å¯å°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéå¥‡å¼‚å±€åŠ¿ã€‚ 3.é‡‡ç”¨é€‚å½“çš„æ–¹æ³•ï¼Œå¯ä»¥å°†éå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚ å‡è®¾é¢å¯¹çš„å±€åŠ¿æ˜¯ï¼ˆa,bï¼‰ï¼š 1.è‹¥ b = aï¼Œåˆ™åŒæ—¶ä»ä¸¤å †ä¸­å–èµ° a ä¸ªç‰©ä½“ï¼Œå°±å˜ä¸ºäº†å¥‡å¼‚å±€åŠ¿ï¼ˆ0ï¼Œ0ï¼‰ï¼› 2.å¦‚æœa = ak ï¼Œb &gt; bkï¼Œé‚£ä¹ˆï¼Œå–èµ°b â€“ bkä¸ªç‰©ä½“ï¼Œå³å˜ä¸ºå¥‡å¼‚å±€åŠ¿ï¼› 3.å¦‚æœ a = ak ï¼Œ b &lt; bk ,åˆ™åŒæ—¶ä»ä¸¤å †ä¸­æ‹¿èµ° ak â€“ ab â€“ akä¸ªç‰©ä½“,å˜ä¸ºå¥‡å¼‚å±€ åŠ¿ï¼ˆ ab â€“ ak , ab â€“ ak+ b â€“ akï¼‰ï¼› 4.å¦‚æœa &gt; ak ï¼Œb= ak + k,åˆ™ä»ç¬¬ä¸€å †ä¸­æ‹¿èµ°å¤šä½™çš„æ•°é‡a â€“ ak å³å¯ï¼› 5.å¦‚æœa &lt; ak ï¼Œb= ak + k,åˆ†ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€ç§ï¼Œa=aj ï¼ˆj &lt; kï¼‰,ä»ç¬¬äºŒå †é‡Œé¢æ‹¿èµ° b â€“ bj å³å¯ï¼›ç¬¬äºŒç§ï¼Œa=bj ï¼ˆj &lt; kï¼‰,ä»ç¬¬äºŒå †é‡Œé¢æ‹¿èµ° b â€“ aj å³å¯ã€‚ ä»å¦‚ä¸Šæ€§è´¨å¯çŸ¥ï¼Œä¸¤ä¸ªäººå¦‚æœéƒ½é‡‡ç”¨æ­£ç¡®æ“ä½œï¼Œé‚£ä¹ˆé¢å¯¹éå¥‡å¼‚å±€åŠ¿ï¼Œå…ˆæ‹¿è€…å¿…èƒœ ï¼›åä¹‹ï¼Œï¼ˆé¢å¯¹å¥‡å¼‚å±€åŠ¿ï¼‰åˆ™åæ‹¿è€…å–èƒœã€‚ ä»»ç»™ä¸€ä¸ªå±€åŠ¿ï¼ˆaï¼Œbï¼‰ï¼Œåˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯å¥‡å¼‚å±€åŠ¿ï¼ˆå…ˆæ‰‹è´Ÿï¼‰ï¼š $a_k =[k\times \frac{ï¼ˆ1+âˆš5ï¼‰}{2}]ï¼Œ b_k= a_k + k $ ï¼ˆk=0ï¼Œ1ï¼Œ2ï¼Œâ€¦,n ï¼Œæ–¹æ‹¬å·è¡¨ç¤ºå‘ä¸‹å–æ•´å‡½æ•°) å…¶ä¸­kç”±bk-akæ±‚å¾—ï¼Œå¦‚æœä¸¤ä¸ªæ•°ä¸ç¬¦åˆè¿™æ ·çš„å½¢å¼ï¼Œåˆ™ä¸æ˜¯å¥‡å¼‚å±€åŠ¿ æ³¨æ„ä¸€å®šè¦æ»¡è¶³a&lt;=bï¼Œä¸æ»¡è¶³æ—¶å¯¹è°ƒaï¼Œb ä¾‹å­ï¼šhttp://poj.org/problem?id=1067 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { double t=(1+sqrt(5.0))/2;//ç³»æ•° int a,b,k; while(cin&gt;&gt;a&gt;&gt;b){ if(a&gt;b)swap(a,b); k=b-a; if(a==(int)(k*t)){//è®¡ç®—aæ˜¯å¦ç¬¦åˆè¯¥å½¢å¼ cout&lt;&lt;0&lt;&lt;endl; } else cout&lt;&lt;1&lt;&lt;endl; } return 0; } å·´ä»€åšå¥• åªæœ‰ä¸€å †çŸ³å­å…±nä¸ªã€‚æ¯æ¬¡ä»æœ€å°‘å–1ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å…‰çš„äººå–èƒœã€‚ å¦‚æœ$n=(m+1)* k+s (s!=0)$ é‚£ä¹ˆå…ˆæ‰‹ä¸€å®šå¿…èƒœï¼Œå› ä¸ºç¬¬ä¸€æ¬¡å–èµ°sä¸ªï¼Œæ¥ä¸‹æ¥æ— è®ºå¯¹æ‰‹æ€ä¹ˆå–ï¼Œæˆ‘ä»¬éƒ½èƒ½ä¿è¯å–åˆ°æ‰€æœ‰(m+1)å€æ•°çš„ç‚¹ï¼Œé‚£ä¹ˆå¾ªç¯ä¸‹å»ä¸€å®šèƒ½å–åˆ°æœ€åä¸€ä¸ªã€‚(ä¹Ÿå°±æ˜¯è¯´åªè¦nä¸æ˜¯m+1çš„å€æ•°å…ˆæ‰‹å¿…èƒœ) staircase nim é¡¾åæ€ä¹‰å°±æ˜¯åœ¨é˜¶æ¢¯ä¸Šè¿›è¡Œï¼Œæ¯å±‚æœ‰è‹¥å¹²ä¸ªçŸ³å­ï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©ä»»æ„å±‚çš„ä»»æ„ä¸ªçŸ³å­&gt;å°†å…¶ç§»åŠ¨åˆ°è¯¥å±‚çš„ä¸‹ä¸€å±‚ã€‚æœ€åä¸èƒ½æ“ä½œçš„äººè¾“ã€‚ ï¼ˆè¿™ä¸ªåšå¼ˆçš„è§£é‡Šä¸æ˜¯ç‰¹åˆ«æ˜ç™½QAQï¼‰ é˜¶æ¢¯åšå¼ˆç»è¿‡è½¬æ¢å¯ä»¥å˜ä¸ºNimï¼ŒæŠŠæ‰€æœ‰å¥‡æ•°é˜¶æ¢¯çœ‹æˆNå †çŸ³å­åšnimã€‚æŠŠçŸ³å­ä»å¥‡æ•°å †ç§»åŠ¨åˆ°å¶æ•°å †å¯ä»¥ç†è§£ä¸ºæ‹¿èµ°çŸ³å­ï¼Œå°±ç›¸å½“äºå‡ ä¸ªå¥‡æ•°å †çš„çŸ³å­åœ¨åšNimã€‚ ç»“è®ºï¼šæ‰€æœ‰å¥‡æ•°é˜¶æ¢¯ï¼ˆå¥‡æ•°å †ï¼‰çš„çŸ³å­çš„Nim sumå¦‚æœä¸ä¸º0ï¼Œå…ˆæ‰‹èƒœï¼Œå¦åˆ™åæ‰‹èƒœ ï¼ˆä»¥ä¸‹ä»…ä¾›å‚è€ƒï¼Œæ²¡å¤ªçœ‹æ‡‚ï¼‰ å‡è®¾æˆ‘ä»¬æ˜¯å…ˆæ‰‹ï¼Œæ‰€ç»™çš„é˜¶æ¢¯çŸ³å­çŠ¶æ€çš„å¥‡æ•°å †åšNimå…ˆæ‰‹èƒ½å¿…èƒœ.æˆ‘å°±æŒ‰ç…§èƒ½èµ¢çš„æ­¥éª¤å°†å¥‡æ•°å †çš„çŸ³å­ç§»åŠ¨åˆ°å¶æ•°å †.å¦‚æœå¯¹æ‰‹ä¹Ÿæ˜¯ç§»åŠ¨å¥‡æ•°å †ï¼Œæˆ‘ä»¬ç»§ç»­ç§»åŠ¨å¥‡æ•°å †.å¦‚æœå¯¹æ‰‹å°†å¶æ•°å †çš„çŸ³å­ç§»åŠ¨åˆ°äº†å¥‡æ•°å †..é‚£ä¹ˆæˆ‘ä»¬ç´§æ¥ç€å°†å¯¹æ‰‹æ‰€ç§»åŠ¨çš„è¿™ä¹ˆå¤šçŸ³å­ä»é‚£ä¸ªå¥‡æ•°å †ç§»åŠ¨åˆ°ä¸‹é¢çš„å¶æ•°å †.ä¸¤æ¬¡æ“ä½œå.ç›¸å½“äºå¶æ•°å †çš„çŸ³å­å‘ä¸‹ç§»åŠ¨äº†å‡ ä¸ªã€‚è€Œå¥‡æ•°å †ä¾ç„¶æ˜¯åŸæ¥çš„æ ·å­ï¼Œå³ä¸ºå¿…èƒœçš„çŠ¶æ€ã€‚å°±ç®—åæ‰‹ä¸€ç›´åœ¨ç§»åŠ¨å¶æ•°å †çš„çŸ³å­åˆ°å¥‡æ•°å †ï¼Œæˆ‘ä»¬å°±ä¸€ç›´è·Ÿç€ä»–å°†çŸ³å­ç»§ç»­å¾€ä¸‹ç§»ï¼Œä¿æŒå¥‡æ•°å †ä¸å˜ã€‚æˆ‘å¯ä»¥è·Ÿç€åæ‰‹æŠŠå¶æ•°å †çš„çŸ³å­æœ€ç»ˆç§»åŠ¨åˆ°0ï¼Œç„¶åå¯¹æ‰‹å°±ä¸èƒ½ç§»åŠ¨è¿™äº›çŸ³å­äº†.æ‰€ä»¥æ•´ä¸ªè¿‡ç¨‹.å°†å¶æ•°å †ç§»åŠ¨åˆ°å¥‡æ•°å †ä¸ä¼šå½±å“å¥‡æ•°å †åšNimåšå¼ˆçš„è¿‡ç¨‹..æ•´ä¸ªè¿‡ç¨‹å¯ä»¥æŠ½è±¡ä¸ºå¥‡æ•°å †çš„Nimåšå¼ˆ. ä¸ºä»€ä¹ˆæ˜¯åªå¯¹å¥‡æ•°å †åšNimå°±å¯ä»¥è€Œä¸æ˜¯å¶æ•°å †å‘¢ï¼Ÿå› ä¸ºå¦‚æœæ˜¯å¯¹å¶æ•°å †åšNimï¼Œå¯¹æ‰‹ç§»åŠ¨å¥‡æ•°å †çš„çŸ³å­åˆ°å¶æ•°å †ï¼Œæˆ‘ä»¬è·Ÿç€ç§»åŠ¨è¿™äº›çŸ³å­åˆ°ä¸‹ä¸€ä¸ªå¥‡æ•°å †ã€‚é‚£ä¹ˆæœ€åæ˜¯å¯¹æ‰‹æŠŠè¿™äº›çŸ³å­ç§»åŠ¨åˆ°äº†0ï¼Œæˆ‘ä»¬ä¸èƒ½ç»§ç»­è·Ÿç€ç§»åŠ¨ï¼Œå°±åªèƒ½å»ç ´ååŸæœ‰çš„Nimè€Œå¯¼è‡´èƒœè´Ÿå…³ç³»çš„ä¸ç¡®å®šã€‚æ‰€ä»¥åªè¦å¯¹å¥‡æ•°å †åšNimåˆ¤æ–­å³å¯çŸ¥é“èƒœè´Ÿæƒ…å†µã€‚ ä¾‹å­ï¼šhttp://poj.org/problem?id=1704 ï¼ˆ POJ1704ï¼‰ ï¼ˆå¯å‚è€ƒæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›P312ï¼‰ æœ¬é¢˜çš„åšæ³•ä¸ä¸Šé¢æè¿°çš„åˆä¸å®Œå…¨ä¸€è‡´ã€‚æˆ‘ä»¬æŠŠæ£‹å­æŒ‰ä½ç½®å‡åºæ’åˆ—åï¼ˆæ²¡æœ‰ä¿è¯ä¸€å®šæŒ‰å‡åºç»™å‡ºï¼‰ï¼Œä»åå¾€å‰æŠŠä»–ä»¬ä¸¤ä¸¤ç»‘å®šæˆä¸€å¯¹ã€‚å¦‚æœæ€»ä¸ªæ•°æ˜¯å¥‡æ•°ï¼Œå°±æŠŠæœ€å‰é¢ä¸€ä¸ªå’Œè¾¹ç•Œï¼ˆä½ç½®ä¸º0ï¼‰ç»‘å®šã€‚ åœ¨åŒä¸€å¯¹æ£‹å­ä¸­ï¼Œå¦‚æœå¯¹æ‰‹ç§»åŠ¨å‰ä¸€ä¸ªï¼Œä½ æ€»èƒ½å¯¹åä¸€ä¸ªç§»åŠ¨ç›¸åŒçš„æ­¥æ•°ï¼Œæ‰€ä»¥ä¸€å¯¹æ£‹å­çš„å‰ä¸€ä¸ªå’Œå‰ä¸€å¯¹æ£‹å­çš„åä¸€ä¸ªä¹‹é—´æœ‰å¤šå°‘ä¸ªç©ºä½ç½®å¯¹æœ€ç»ˆçš„ç»“æœæ˜¯æ²¡æœ‰å½±å“çš„ã€‚äºæ˜¯æˆ‘ä»¬åªéœ€è¦è€ƒè™‘åŒä¸€å¯¹çš„ä¸¤ä¸ªæ£‹å­ä¹‹é—´æœ‰å¤šå°‘ç©ºä½ã€‚ è¿™æ ·ä¸€æ¥å°±æˆäº†Nå †å–çŸ³å­æ¸¸æˆäº†. #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,k; int s[1010]; int main() { int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;s[i]); sort(s+1, s+n+1); int ans; if(n%2 == 0) { ans = s[2]-s[1]-1; for(int i=4; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } else { ans = s[1]-1; for(int i=3; i&lt;=n; i+=2) ans ^= (s[i]-s[i-1]-1); if(ans == 0) cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl; } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>åšå¼ˆè®º</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>åšå¼ˆè®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Good Bye 2017]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-good-bye-2017%2F</url>
    <content type="text"><![CDATA[A. æ¨¡æ‹Ÿå³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str;int cnt=0; cin&gt;&gt;str; for(auto a:str){ if(a==&apos;a&apos;||a==&apos;i&apos;||a==&apos;o&apos;||a==&apos;e&apos;||a==&apos;u&apos;||a==&apos;1&apos;||a==&apos;3&apos;||a==&apos;5&apos;||a==&apos;7&apos;||a==&apos;9&apos;) cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. æš´åŠ›æšä¸¾24ç§æ˜ å°„çš„æƒ…å†µå³å¯â€¦.é¢˜ç›®å¾ˆç®€å•ï¼Œä½†æ˜¯ä¸æ˜¯å¾ˆå¥½å†™ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; using namespace std; typedef pair&lt;int,int&gt;P; vector&lt;int&gt;per; void rotate(P*a,P*b) { for(int i=0;i&lt;4;i++) a[i]=b[per[i]]; } int main() { P mps[4]={ {0,1},{-1,0},{0,-1},{1,0}},mp[4]; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; string str; for(i=0;i&lt;4;i++)per.push_back(i); char mp1[55][55]; int x,y; for(i=1;i&lt;=n;i++){ cin&gt;&gt;mp1[i]+1; for(j=1;j&lt;=m;j++){ if(mp1[i][j]==&apos;S&apos;){ x=j,y=i;break; } } } cin&gt;&gt;str;int ans=0; for(int r=1;r&lt;=24;r++){ if(r&gt;1)next_permutation(per.begin(),per.end()); rotate(mp,mps); int x1=x,y1=y; for(auto a:str){ int p=a-&apos;0&apos;; x1+=mp[p].first;y1+=mp[p].second; if(x1&lt;1||x1&gt;m||y1&lt;1||y1&gt;n||mp1[y1][x1]==&apos;#&apos;)break; if(mp1[y1][x1]==&apos;E&apos;){ ans++;break; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C. æœ¬æ¥æƒ³ç€å¯¹äºæ¯ä¸ªæ–°åŠ å…¥çš„åœ†æ‰¾å‡ºæ‰€æœ‰å¯èƒ½è·Ÿä»–å†²çªçš„åœ†è¿›è¡Œè®¡ç®—çš„ï¼Œä½†æ˜¯è¾¹ç•Œä¸å¤ªå¥½æŠŠæ¡â€¦åæ¥å‘ç°è¿™ä¸ªæ•°æ®èŒƒå›´â€¦ç›´æ¥æš´åŠ›æšä¸¾ä¹‹å‰åŠ å…¥çš„æ‰€æœ‰åœ†ä¸è¿™åœ†å†²çªçš„å¯èƒ½å³å¯â€¦ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int n,r,x[1005]={0},t,i,j;double y[1005]={0}; scanf(&quot;%d%d&quot;,&amp;n,&amp;r); for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x[i]);y[i]=r; for(j=1;j&lt;i;j++) { t = x[i] - x[j], y[i] = max(y[i], y[j] + sqrt(4 * r * r - t * t)); } printf(&quot;%.10f &quot;,y[i]); } return 0; } F. æˆ‘ä»¬å¯ä»¥ç”¨ç»¿è‰²çš„ç‚¹æŠŠæ•´ä¸ªçº¿æ®µåˆ†å¼€ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€ä¸ªåŒºé—´ï¼ˆä¸¤ç«¯æ˜¯ç»¿è‰²çš„ç‚¹ï¼‰ï¼Œæœ‰ä¸¤ç§é€‰æ‹©ï¼š1.ä¸¤ä¸ªç»¿è‰²çš„ç‚¹ä¸è¿æ¥ï¼Œé‚£ä¹ˆå°±éœ€è¦æŠŠé‡Œé¢æ‰€æœ‰çš„çº¢è‰²ç‚¹è“è‰²ç‚¹éƒ½è¿æ¥èµ·æ¥ï¼Œé•¿åº¦æ˜¯2 åŒºé—´é•¿åº¦ 2.è¿æ¥ç»¿è‰²ç‚¹ï¼Œé‚£ä¹ˆé•¿åº¦å°±æ˜¯åŒºé—´é•¿åº¦ 3-é•¿åº¦æœ€é•¿çš„è¿æ¥çº¢ç‚¹çš„è¾¹-é•¿åº¦æœ€é•¿çš„è¿æ¥è“ç‚¹çš„è¾¹ #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,x,pr,pb,pg,mr,mb,ans=0; char s[10]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%s&quot;,&amp;x,s); if(s[0]==&apos;R&apos;||s[0]==&apos;G&apos;){ if(pr){ ans+=x-pr; mr=max(mr,x-pr); } pr=x; } if(s[0]==&apos;B&apos;||s[0]==&apos;G&apos;){ if(pb){ ans+=x-pb; mb=max(mb,x-pb); } pb=x; } if(s[0]==&apos;G&apos;){ if(pg)ans+=min(0,x-pg-mr-mb); pg=x;mr=0;mb=0; } } printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #498 (Div. 3)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-498-div-3%2F</url>
    <content type="text"><![CDATA[A. å¼±æ™ºé¢˜ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(j&amp;1)cout&lt;&lt;j&lt;&lt;&apos; &apos;; else cout&lt;&lt;j-1&lt;&lt;&apos; &apos;; } return 0; } B. ä»å¤§åˆ°å°æ’åºï¼Œå‰kå¤§å°±æ˜¯æ‰€æ±‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;set&gt; using namespace std; bool cmp(int x,int y) { return x&gt;y; } int main() { int n,k,i,j; int num[2005],num1[2005]; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;num[i]);num1[i]=num[i]; } sort(num1+1,num1+1+n,cmp); map&lt;int,int&gt;mp1; int sum=0; for(i=1;i&lt;=k;i++)mp1[num1[i]]++,sum+=num1[i]; int pre=1; cout&lt;&lt;sum&lt;&lt;endl; for(i=1;i&lt;=n;i++){ if(mp1.count(num[i])){ k--; if(k)cout&lt;&lt;i-pre+1&lt;&lt;&apos; &apos;; else cout&lt;&lt;n-pre+1&lt;&lt;endl; pre=i+1;mp1[num[i]]--; if(mp1[num[i]]==0)mp1.erase(num[i]); } } return 0; } C. å‰åæ±‚å‰ç¼€å’Œå³å¯ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll sum[200005]; int main() { int n,i,j,k,d[200005]; cin&gt;&gt;n; map&lt;ll,int&gt;mp1; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;d[i]); sum[i]+=sum[i-1]+d[i]; mp1[sum[i]]=i; } ll ans=0,sum1=0; for(i=n;i;i--){ sum1+=d[i]; if(mp1.count(sum1)){ if(mp1[sum1]&gt;=i) break; else{ ans=sum1; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. æ³¨æ„åªèƒ½æ¢aä¸­çš„å­—æ¯ï¼ï¼ åˆ†æä¸€ä¸‹å¯ä»¥å‘ç°a[i],a[n-i+1],b[i],b[n-i+1]è¿™å‡ ä¸ªå­—æ¯ä¹‹é—´çš„ä½ç½®æ˜¯å¯ä»¥éšä¾¿æ¢çš„ï¼Œå› æ­¤åªè¦æšä¸¾æ‰€æœ‰è¿™æ ·çš„å­—æ¯ç»„å³å¯ã€‚ å½“4ä¸ªå­—æ¯å…¨éƒ½ä¸åŒçš„æ—¶å€™ï¼Œaé‡Œé¢ä¸¤ä¸ªå­—æ¯è‚¯å®šè¦æ¢ï¼› å½“æœ‰ä¸¤ä¸ªç›¸åŒæ—¶ï¼Œå¦ä¸¤ä¸ªä¸åŒï¼ˆä¹Ÿå°±æ˜¯æœ‰3ç§å­—æ¯ï¼‰ï¼Œå¦‚æœä¸¤ä¸ªç›¸åŒçš„åœ¨aï¼Œé‚£ä¹ˆå°±è¦ä¸¤ä¸ªéƒ½æ¢ï¼Œå¦åˆ™çš„è¯éƒ½æ˜¯æ¢1ä¸ªå°±å¤Ÿäº†ã€‚ å½“æœ‰3ä¸ªç›¸åŒæ—¶ï¼Œæ¢ä¸€ä¸ªå³å¯ã€‚ å¦‚æœ4ä¸ªéƒ½ç›¸åŒæˆ–è€…ä¸¤ä¸¤ç›¸åŒï¼Œä¸ç”¨æ¢ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; int main() { char a[100005],b[100005]; int i,j,k,n; cin&gt;&gt;n&gt;&gt;a+1&gt;&gt;b+1; int sum=0; for(i=1;i&lt;=n/2;i++){ map&lt;char,int&gt;mp1; mp1[a[i]]++;mp1[a[n-i+1]]++;mp1[b[i]]++;mp1[b[n-i+1]]++; if(mp1.size()==4){ sum+=2; } else if(mp1.size()==2){ if(mp1.begin()-&gt;second==2); else{ sum+=1; } } else if(mp1.size()==1); else{ if(a[i]==a[n-i+1])sum+=2; else sum+=1; } } if(n&amp;1){ if(a[n/2+1]!=b[n/2+1])sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; } E. é¢˜ç›®å¾ˆé•¿ï¼Œä½†å…¶å®å°±æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„dfsã€‚å› ä¸ºä»–çš„dfsé¡ºåºæ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šå‘ç°å…¶å®åªè¦ä»æ ¹å¼€å§‹dfsä¸€éï¼Œå¹¶æŠŠç»“æœä¿å­˜èµ·æ¥å³å¯ï¼Œä»¥åæ¯æ¬¡è¯¢é—®æŸ¥è¯¢ä¸€ä¸‹å³å¯ã€‚å®Œå…¨æ¨¡æ‹Ÿä¼štleï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¿å­˜è‡ªå·±çš„å­æ ‘åˆ™ä¼šmleï¼Œæ‰€ä»¥åªèƒ½åœ¨æ ¹é‚£é‡Œä¿å­˜ç»“æœã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N=2e5+5; vector&lt;int&gt;G[N]; vector&lt;int&gt;ans; int child[N]; int pos[N]; int dfs(int x) { ans.push_back(x); pos[x]=ans.size()-1; child[x]++; for(auto a:G[x]){ child[x]+=dfs(a); } return child[x]; } int main() { int n,q,i,j,k,u; cin&gt;&gt;n&gt;&gt;q; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); for(i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;k); if(child[u]&lt;k){ printf(&quot;-1\n&quot;); } else{ printf(&quot;%d\n&quot;,ans[pos[u]+k-1]); } } return 0; } F. æœ‰ä¸€ä¸ªéå¸¸simpleçš„dpåšæ³•ï¼Œä½†æ˜¯ä¼šmleï¼Œå³ä½¿æ¢æˆæ»šåŠ¨æ•°ç»„ä¹Ÿä¼štleâ€¦ #include &lt;bits/stdc++.h&gt; using namespace std; long long n,m,k; map&lt;long long,long long&gt; a[25][25]; long long b[25][25]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) cin&gt;&gt;b[i][j]; a[1][1][b[1][1]]++; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { for (auto k:a[i-1][j]) { a[i][j][k.first^b[i][j]]+=k.second; } for (auto k:a[i][j-1]) { a[i][j][k.first^b[i][j]]+=k.second; } } cout&lt;&lt;a[n][m][k]; } æ­£è§£çš„è¯ï¼Œæ˜¯äººä¸ºçš„åˆ’äº†ä¸€æ¡çº¿ï¼Œå³i+j==n+1ï¼Œè¿™æ˜¯ä¸€æ¡æ–œå¯¹è§’çº¿ï¼Œæˆ‘ä»¬åˆ†åˆ«ä»ï¼ˆ1ï¼Œ1ï¼‰å’Œï¼ˆnï¼Œmï¼‰å¤„å¼€å§‹æœç´¢ï¼Œå¦‚æœèƒ½å¤Ÿåˆ°è¾¾ä¸­çº¿ï¼Œå°±åšä¸€ä¸ªè®°å½•ï¼Œç„¶åç»Ÿè®¡ç­”æ¡ˆã€‚ #include &lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll num[25][25]; map&lt;ll,ll&gt;mp[25]; ll n,m,k; void dfs1(int i,int j,ll v) { v^=num[i][j]; if(i+j==n+1){ mp[i][v]++;return;//å¦‚æœåˆ°è¾¾ä¸­çº¿å°±ä¸ç”¨å†æœä¸‹å»äº† } if(i&lt;n)dfs1(i+1,j,v); if(j&lt;m)dfs1(i,j+1,v); } ll ans=0; void dfs2(int i,int j,ll v) { if(i+j==n+1) { ans += mp[i][v ^ k];return;//åˆ°è¾¾ä¸­çº¿,æˆ‘ä»¬å¸Œæœ›é‡åˆ°çš„ä¸­çº¿å¤„çš„å€¼æ˜¯v^k, // å› ä¸ºåœ¨ä¸­çº¿ä¸‹åŠéƒ¨åˆ†çš„xorå’Œä¸ºv,v^k^v=k,æ»¡è¶³é¢˜æ„ } v^=num[i][j]; if(i&gt;1)dfs2(i-1,j,v); if(j&gt;1)dfs2(i,j-1,v); } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int i,j; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf(&quot;%lld&quot;,&amp;num[i][j]); dfs1(1,1,0);dfs2(n,m,0); cout&lt;&lt;ans&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 47 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Feducational-codeforces-round-47-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. æŒ‰ç…§é¢˜æ„æ¨¡æ‹Ÿå³å¯ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;deque&gt; using namespace std; int main() { deque&lt;int&gt;a; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; int c[1005]; for(i=1;i&lt;=n;i++)cin&gt;&gt;c[i]; for(i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;j);a.push_back(j); } int cnt=0; for(i=1;i&lt;=n;i++){ if(!a.empty()&amp;&amp;a.front()&gt;=c[i]){ a.pop_front();cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0; } B. é¦–å…ˆæˆ‘ä»¬æ³¨æ„åˆ°1æ˜¯å¯ä»¥ä»»æ„ç§»åŠ¨çš„ï¼Œä¹Ÿå°±æ˜¯è¯´1å¯ä»¥ç§»åŠ¨åˆ°ä»»ä½•ä¸€ä¸ªä½ç½®ï¼Œè€Œ2æ˜¯æ¯”è¾ƒéº»çƒ¦çš„ï¼Œå› æ­¤æˆ‘ä»¬ä»å‰å¾€åæ‰«æï¼Œæ¯æ‰«æåˆ°ä¸€ä¸ª2å°±è®°å½•ä¸€ä¸‹å½“å‰æ‰«æåˆ°çš„è¿™æ®µ0 çš„æ•°ç›®ï¼Œç„¶åä¸¢è¿›vectoré‡Œè®°å½•ä¸‹æ¥ã€‚æ³¨æ„ï¼šè¦è®°å¾—ç‰¹åˆ¤æ²¡æœ‰2 çš„æƒ…å½¢ï¼ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string s; int num0(0), num1(0); vector &lt;int&gt; v; bool pd(false); int main() { cin &gt;&gt; s; for (auto i : s) { if (i == &apos;0&apos;)num0++;//ç»Ÿè®¡0 else if (i == &apos;1&apos;)num1++;//ç»Ÿè®¡1 else {//é‡åˆ°2 v.push_back(num0); num0 = 0; } } for (auto i : v) {//2æŠŠè¿ç»­çš„0åˆ†æˆäº†å¾ˆå¤šæ®µ for (int j = 1; j &lt;= i; j++)cout &lt;&lt; 0; if (!pd) for (int j = 1; j &lt;= num1; j++)cout &lt;&lt; 1;//1å¯ä»¥å…¨éƒ¨ç§»åˆ°ç¬¬ä¸€ä¸ªä¹‹å‰ cout &lt;&lt; 2; pd = true; } for (int j = 1; j &lt;= num0; j++)cout &lt;&lt; 0; if(!pd){//ä¸€å®šè¦ç‰¹åˆ¤æ²¡æœ‰2çš„æƒ…å½¢ for(int i=1;i&lt;=num1;i++)cout&lt;&lt;1; } return 0; } C. å…¶å®è¿™é¢˜çœ‹æ‡‚ä¹‹åä¼¼ä¹æ˜¯æŒºç®€å•çš„â€¦?æ˜¾ç„¶då¦‚æœæ˜¯æ­£çš„ï¼Œæˆ‘ä»¬ å°±å¸Œæœ›distä¹‹å’Œæœ€å¤§ï¼Œå¯ä»¥å‘ç°æ˜¯æ”¾æ•°åˆ—çš„ä¸¤ç«¯æœ€ä½³ï¼Œå¦åˆ™çš„è¯å°±é€‰åœ¨æ•°åˆ—çš„ä¸­é—´å¯ä»¥ä½¿å¾—distä¹‹å’Œæœ€å°ã€‚è®°å¾—å¼€longlongå³å¯ã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; int main() { ll n, m; ll ans=0, x, d; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; d; ans += x * n; if (d &gt; 0) { ans += d * n * (n - 1) / 2; } else { ans += ((n % 2 == 0) ? (n / 2 * n / 2 * d) : ((n + 1) / 2 * (n - 1) / 2 * d)); } } printf(&quot;%.20lf&quot;,(double)ans / n); return 0; } D. è¦æ³¨æ„ä¸€ç‚¹ï¼Œå°±æ˜¯æ„é€ çš„å›¾å¿…é¡»æ˜¯è”é€šçš„ã€‚è™½ç„¶é¢˜ç›®èŒƒå›´çœ‹ä¼¼å¾ˆå¤§ï¼Œç†è®ºæ˜¯æš´åŠ›æšä¸¾å¤æ‚åº¦1e10,ä½†æ˜¯må°å“‡ï¼Œæš´åŠ›ä»å°åˆ°å¤§æšä¸¾æˆå¯¹çš„äº’è´¨çš„æ•°ï¼Œå…¶å®å¾ˆå¿«å°±å¤Ÿäº†ï¼Œå¦‚æœimpossibleçš„è¯åªå¯èƒ½æ˜¯næ¯”è¾ƒå°mæ¯”è¾ƒå¤§çš„æƒ…å†µã€‚ç„¶åæ³¨æ„må¦‚æœå°äºn-1çš„è¯é‚£ä¹ˆè¿™å¹…å›¾æ€ä¹ˆçœ‹éƒ½ä¸å¯èƒ½çš„è”é€šçš„ï¼ˆè¦æ±‚æ˜¯æ¯ä¸ªç‚¹éƒ½å¿…é¡»åœ¨è¿™ä¸ªå›¾é‡Œé¢ï¼Œæ‰€ä»¥ä¸€ä¸ªè¡Œä¹‹æœ‰æ•ˆçš„åŠæ³•å°±æ˜¯æ¯ä¸ªç”µè„‘éƒ½è·Ÿ1è¿æ¥èµ·æ¥ï¼‰ï¼› #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int gcd(int x,int y) { return y?gcd(y,x%y):x; } typedef pair&lt;int,int&gt;P; int main() { int n,m,i,j,k,cnt=0; cin&gt;&gt;n&gt;&gt;m; vector&lt;P&gt;ans; if(m&lt;n-1){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } for(i=1;i&lt;n;i++) for(j=i+1;j&lt;=n;j++){ if(gcd(i,j)==1){ m--;ans.push_back(P(i,j)); if(!m)goto step; } } if(m){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;return 0; } step:cout&lt;&lt;&quot;Possible&quot;&lt;&lt;endl; for(auto a:ans) printf(&quot;%d %d\n&quot;,a.first,a.second); return 0; } E. æŸäººä»x=0æ—…è¡Œè‡³x=nï¼Œåœ¨ä¸Šæ¬¡ä¼‘æ¯è¿‡åèµ°å½“å‰å…¬é‡Œçš„ç–²åŠ³å€¼ä¸ºaiï¼Œä¼‘æ¯ç‚¹çš„ä½ç½®ä¸ç¡®å®šï¼Œæ±‚ç–²åŠ³å€¼ä¹‹å’Œçš„æ•°å­¦æœŸæœ›ã€‚ å¯¹äºæŸä¸ªä½ç½®x=iï¼Œç–²åŠ³å€¼ä¸ºaiçš„å¯èƒ½ä¼‘æ¯ç‚¹æƒ…å†µæ•°ä¸º2^(n-i)ç§ï¼Œç–²åŠ³å€¼ä¸ºaj(j&lt;i)çš„å¯èƒ½ä¼‘æ¯ç‚¹æƒ…å†µæ•°ä¸º2^(n-i-1)ç§ã€‚å¤„ç†è¿‡åå‘ç°å¯¹äºæŸä¸ªç–²åŠ³å€¼aiï¼Œå…¶æ€»çš„å‡ºç°æƒ…å†µæ•°ä¸º2^(n-i)+2^(n-i-1)* (n-i)ã€‚ä¹‹åç›´æ¥å¥—å…¬å¼å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int mod=998244353; long long a[1000005],b[1000005]; int main() { int n,i,j,k; cin&gt;&gt;n; b[0]=1; for(i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); b[i]=(b[i-1]&lt;&lt;1)%mod; } long long ans=0; for(i=1;i&lt;=n;i++){ ans+=a[i]*b[n-i]%mod; ans+=a[i]*b[n-i-1]%mod*(n-i)%mod;//æ³¨æ„å¤šmodé˜²æ­¢çˆ†int } cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F20172018%2F</url>
    <content type="text"><![CDATA[è¿‡å»çš„ä¸€å¹´å‰å‡ å¤©è€ƒå®Œäº†è¿™å­¦æœŸçš„æœ€åä¸€ç§‘ï¼Œé‚£ä¹ˆï¼Œå¤§ä¸€ä¹Ÿå°±ç®—æ˜¯ç»“æŸäº†å§ï¼Œå›æƒ³è¿‡å»çš„ä¸€å¹´ï¼Œæ€»æƒ³å†™ç‚¹ä»€ä¹ˆï¼Œå´åˆä¸çŸ¥é“å¦‚ä½•å…¥æ‰‹ï¼Œé‚£ç°åœ¨å°±çº¯å½“æµæ°´è´¦éšä¾¿å†™å†™å§ã€‚ å»å¹´ï¼Œ2017ï¼Œæ˜¯ç›¸å½“å¥‡å¹»çš„ï¼Œä¸€åœºé«˜è€ƒå°†ä¸€å¹´æ¨ªåŠˆä¸ºäºŒã€‚åˆšè€ƒå®Œé‚£å¤©ä¸‹åˆæ‹¿å‡ºäº†å°˜å°å·²ä¹…çš„iPadï¼Œæ‰“äº†ä¸€ä¼šwotbï¼Œä½†æ˜¯ä¼¼ä¹åº”äº†é‚£å¥è¯â€”â€”æ¸¸æˆè¿˜æ˜¯è€ƒè¯•å‰çš„å¥½ç©ï¼Œè€ƒå®Œä¹‹åå˜å¾—æœ‰äº›ç´¢ç„¶æ— å‘³èµ·æ¥ã€‚4å¤©ä¹‹åå‰äº†ä¸ªæ¸¸æˆæœ¬ï¼Œç„¶åå¼€å¯äº†æš‘å‡çš„æ²‰è¿·æ¸¸æˆä¹‹æ—…ã€‚ä¸è¿‡åæ¥å¼€å­¦åå¾ˆå¿«å°±åæ‚”ä¹°äº†ä¸ªå¦‚æ­¤åšé‡çš„æ¸¸æˆæœ¬ï¼Œå½“ç„¶è¿™æ˜¯åè¯äº†ã€‚ æš‘å‡å…ˆæ˜¯è·ŸåŒå­¦ä¸€èµ·å»äº†è¶Ÿè´µå·ï¼Œç°åœ¨æƒ³æƒ³è¿™è¶Ÿæ—…ç¨‹å…¶å®æ˜¯æœ‰äº›ä»¤äººå¤±æœ›çš„ã€‚è´µå·æœ¬èº«å¹¶ä¸å¤ªå¥½ç©ï¼ŒèŠ±åœ¨è·¯ä¸Šçš„æ—¶é—´å¥‡é•¿æ— æ¯”ã€‚æ›´é‡è¦çš„æ˜¯é«˜ä¸­çš„ä¸€ç¾¤åŒå­¦ï¼Œä¼¼ä¹æ€»æœ‰äº›è¯´ä¸æ¸…çš„éš”é˜‚æ„Ÿå§ï¼Œä¹Ÿè®¸æ˜¯ä¸€ç¾¤æ¸…åŒ—èšèšå®åœ¨è·Ÿæˆ‘è¿™ç§è£¸è€ƒå¼±æ¸£å·®åˆ«è¿‡å¤§å§ã€‚è€Œä¸”æ„Ÿè§‰èµ·æ¥ï¼Œé«˜ä¸­åŒå­¦æ€»ä½“è¿˜æ˜¯æ¯”è¾ƒå¥‡ç‰¹çš„ï¼Œæ•´ä¸ªç­çº§æ€»æ˜¯ç¼ºå°‘äº›å‡èšåŠ›ï¼Œæˆ–è®¸æ˜¯å¤§å®¶éƒ½å¤ªæœ‰ä¸ªæ€§äº†ï¼Œä¹Ÿå¯èƒ½æ˜¯å¤§å®¶é«˜ä¸­éƒ½å¿™ï¼Œæ€»è€Œè¨€ä¹‹ï¼Œå¹¶æ²¡æœ‰éå¸¸å¥½çš„ä½“éªŒã€‚ å›æ¥ä¹‹åå¡«äº†ä¸ªå¿—æ„¿ã€‚æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘å°±æƒ³æŠ¥è®¡ç®—æœºï¼Œä¹Ÿè®¸æ˜¯è¢«æŸä¹æ´—è„‘äº†å§ï¼Œè‡ªå·±ä¹Ÿçœ‹èµ·æ¥æ˜¯æœ‰ç‚¹å…´è¶£ã€‚ è®°å¾—å½“æ—¶è¿˜è·Ÿçˆ¶æ¯åµäº†ä¸€æ¶ï¼Œå› ä¸ºä¸çŸ¥é“é€‰å“ªä¸ªå­¦æ ¡ã€‚å½“æ—¶ä¹Ÿä¸çŸ¥é“ä¸ºä½•å°±é€‰å®šäº†å°ç ´é‚®ï¼Œä¸è¿‡ç°åœ¨æƒ³æƒ³å“ˆæ·±çš„è®¡ç®—æœºæˆ‘è¿˜ä¸å¤Ÿåˆ†æ¥ç€ï¼Œå½“æ—¶å¦‚æœå¡«äº†ç°åœ¨å¯èƒ½å°±åœ¨å­¦æœºæ¢°äº†ï¼ˆæ‘”ï¼‰ã€‚ç°åœ¨æƒ³æƒ³ä¼¼ä¹å€’ä¹Ÿä¸ç®—ä»€ä¹ˆé”™è¯¯çš„å†³å®šâ€”â€”å°ç ´é‚®è™½ç ´ï¼Œä½†æ˜¯åè¿œçš„æ²™æ²³å€’ä¹Ÿèƒ½è®©äººä¸“å¿ƒä¸‹æ¥å­¦ä¹ ï¼Œè€Œä¸”è¯´å®è¯å§ï¼ŒåŸºæœ¬ä¸Šè¯¥æœ‰çš„è®¾æ–½ä¹Ÿéƒ½ç®—æœ‰äº†ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå°ç ´é‚®çš„åŒå­¦æ€»ä½“ä¸Šæ„Ÿè§‰è¿˜æ˜¯æŒºå¥½çš„~æ€»ä½“è€Œè¨€å­¦é£è‰¯å¥½ï¼Œè€Œä¸”ä¹Ÿæœ‰éå¸¸å¤šåœ¨æˆ‘çœ‹èµ·æ¥éå¸¸å‰å®³çš„åŒå­¦ï¼Œè®©æˆ‘æ„Ÿè§‰è‡ªå·±éå¸¸çš„è’Ÿè’»QAQã€‚ åæ¥çš„å‡æœŸåŸºæœ¬ä¸Šå°±æ˜¯æ‰“æ¸¸æˆï¼Œå­¦æ¶å­é¼“ï¼Œè¸¢è¶³çƒï¼Œå¥èº«å‡ æ ·ä¹‹é—´è½®æ¢ã€‚ä¸å¾—ä¸è¯´æˆ‘è¿˜æ˜¯æŒºéš¾å»åšæŒä¸€äº›çˆ±å¥½çš„â€¦ç°åœ¨é™¤äº†å¶å°”å»å»å¥èº«æˆ¿ï¼Œå…¶ä»–å‡ é¡¹åŸºæœ¬éƒ½è’åºŸäº†ï¼Œè™½è¯´è¿™ä¸€å¹´æ¥ç¡®å®å¿™ç¢Œï¼Œä½†æ˜¯éš¾ä»¥æŒä¹‹ä»¥æ’ä¼¼ä¹ä¹Ÿæˆä¸ºäº†æˆ‘ä¸€è´¯ä»¥æ¥çš„åæ¯›ç—…å§ã€‚8æœˆå»äº†è¶Ÿæ–°ç–†ï¼Œæ€»ä½“è€Œè¨€ï¼Œæ™¯è‰²æ˜¯ä¼˜ç¾çš„ï¼Œä½†æ˜¯æš‘å‡æµ©æµ©è¡è¡çš„äººæµå®åœ¨æ˜¯ä»¤äººéš¾ä»¥æèµ·ä»»ä½•æ¸¸ç©çš„å…´è‡´ã€‚è€Œååˆå»è¥¿å®‰æäº†è¶Ÿç–¯ç‹‚ä¹‹æ—…ï¼Œç°åœ¨æƒ³æƒ³æ˜¯æœ‰äº›åæ‚”çš„ï¼Œæµªè´¹é’±ï¼Œæµªè´¹æ—¶é—´ã€‚ æ‰“æ¸¸æˆçš„å‡æœŸè¿˜æ˜¯è¿‡å¾—æŒºå¿«çš„ï¼Œä¸€è½¬çœ¼å°±å¼€å­¦äº†ã€‚ä¸¤å‘¨çš„å†›è®­ä»¤äººå°è±¡æ·±åˆ»ï¼Œå¤§æ¦‚æ˜¯è¿™è¾ˆå­è¿„ä»Šä¸ºæ­¢è¿‡å¾—æœ€éš¾å—çš„ä¸¤å‘¨äº†ï¼Œç”Ÿæ´»è´¨é‡å¥‡å·®ï¼Œè€Œä¸”æ¯«æ— æ„ä¹‰ã€‚ç”¨ä¸€å¥æ”¿æ²»ä¸æ­£ç¡®çš„è¯æ¥è¯´ï¼Œå°±æ˜¯ä¸¤å‘¨çš„å‚å†›åŠé€€è¯¾ï¼Œé™¤äº†æ²¡æ‹”è‰ï¼Œéƒ¨é˜Ÿé‡Œå¯ä»¥å¹²çš„æ— èŠäº‹ä¼¼ä¹éƒ½ä½“éªŒçš„å·®ä¸å¤šäº†ã€‚åæ­£ï¼Œä¸ªäººæ˜¯éå¸¸åæ„Ÿè¿™ç§æ¯«æ— æ„ä¹‰çš„å®˜åƒšæ€§è¯¾ç¨‹çš„ã€‚ å›æ¥ä»¥åå°±å¼€å­¦ï¼Œä¸è¿‡å›½åº†å‰åŸºæœ¬ä¸Šå•¥éƒ½æ²¡çœ‹ï¼Œæ¯å¤©å°±æ˜¯ç©ä¸€ç©ï¼Œçœ‹ä¸€çœ‹ï¼Œå€’ä¹Ÿæ‚ å“‰æ‚ å“‰ã€‚åŠ äº†å­¦ç”Ÿä¼šçš„ä¸€ä¸ªéƒ¨é—¨ï¼Œç°åœ¨æƒ³æƒ³è¿™ä¸ªè¿˜æ˜¯æŒºæœ‰æ„ä¹‰çš„â€¦å› ä¸ºæ²¡è¿›è¿™éƒ¨é—¨çš„è¯ï¼Œ|æ²¡è®¤è¯†æŸèŠè‹£çš„è¯ï¼Œæˆ‘å¯èƒ½å·²ç»è¢«ç¼–ç¨‹åŠé€€äº†ï¼Œæ›´ä¸ä¼šæ··è¿›å®éªŒç­äº†â€¦ä¹Ÿå°±æ²¡æœ‰å¾ˆå¤šæ•…äº‹äº†233â€¦ä¸­é—´ä¹Ÿæ²¡å•¥äº‹ï¼Œç›´åˆ°9.27â€”â€”é‚£ä¸€å¤©ï¼Œæˆ‘çªç„¶å¼€å§‹ç ”ç©¶äº†ä¸€æ³¢C Primer Plusï¼Œå†™äº†ç¬¬ä¸€ä¸ªCç¨‹åºï¼Œå•¥å†…å®¹ä¸è®°å¾—äº†ï¼Œæ€»ä¹‹ï¼Œæ„Ÿè§‰æŒºå¥½ç©çš„ï¼Œä¹Ÿè®©æˆ‘å¯¹è¿™ç©æ„å„¿çªç„¶æ„Ÿå…´è¶£èµ·æ¥ã€‚ç°åœ¨æƒ³æƒ³ï¼Œé™¤äº†ä¸€å¼€å§‹çš„å…´è¶£ä»¥å¤–ï¼Œå¤§æ¦‚ä¹Ÿè·Ÿç¨‹åºçš„åé¦ˆæ€§æœ‰å…³å§â€”â€”å³æ—¶çš„è¾“å‡ºï¼Œè™½ç„¶åªæ˜¯æ§åˆ¶å°é‚£ä¸ªé»‘æ¡†æ¡†ã€‚ä»¥åŠåæ¥çš„å„ç§OJï¼ŒACï¼ŒWAï¼ŒTLEï¼Œå…¶å®éƒ½ä»¤äººåˆºæ¿€ï¼Œä¸åƒé‚£è‰¹è›‹çš„é«˜æ•°ï¼Œè‡³ä»Šéƒ½æä¸èµ·ä»€ä¹ˆå…´è¶£ã€‚ åé¢å¤§æ¦‚å°±æ˜¯ä¸Šè¯¾ï¼Œä¸Šè¯¾ï¼Œå…¶å®å°è±¡éƒ½ä¸æ˜¯å¾ˆæ·±ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªå­¦æœŸå…¶å®åªæœ‰ä¸€ä»¶äº‹ä»¤æˆ‘æ„Ÿå…´è¶£ï¼Œé‚£å°±æ˜¯ç¼–ç¨‹ã€‚å½“æ—¶èŠ±äº†å¤§æ¦‚ä¸€ä¸ªæœˆå¤§è‡´çœ‹äº†çœ‹Cçš„åŸºæœ¬è¯­æ³•ï¼Œç„¶åå°±å¼€å§‹å¯¹ç®—æ³•æœ‰äº†äº›å…´è¶£â€”â€”å¤§æ¦‚è·Ÿå¤´å‡ æ¬¡æœºè€ƒçš„æ—¶å€™æ¿€åŠ¨äººå¿ƒçš„æ’è¡Œæ¦œä¹Ÿæœ‰ç‚¹å…³ç³»å§ã€‚æ€»ä¹‹æœŸä¸­ä¹‹åï¼Œé™¤äº†ç ”ç©¶æ–°ç®—æ³•å†™OJï¼Œå½“æ—¶å•¥éƒ½ä¸æƒ³å¹²ï¼Œè¿æ¸¸æˆéƒ½æ²¡ç¢°è¿‡ï¼Œå¯¼è‡´æˆ‘å¯’å‡æŠŠæ¸¸æˆæœ¬ç»™å–äº†ï¼ˆç¬‘ï¼‰ã€‚ä¸è¿‡å¹³å¿ƒè€Œè®ºï¼Œç ”ç©¶ä¸€ä¸ªç®—æ³•ï¼Œè¯•ç€ç”¨å®ƒå»å¥—ä¸€äº›ç®€å•æ¨¡æ¿é¢˜ï¼Œè·å¾—ä¸€ä¸ªä¸ªACï¼ŒçœŸçš„æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œè®©æˆ‘å¤§åŠä¸ªå­¦æœŸä¹æ­¤ä¸ç–²ã€‚ç¬¬ä¸€å­¦æœŸæ€ä¹ˆè¯´å‘¢ï¼Œå…¶å®è‡ªæˆ‘æ„Ÿè§‰è¿˜æ˜¯æŒºè®¤çœŸçš„ï¼Œå¯æƒœå°±æ˜¯å¯¹è¯¾å†…çš„äº‹æƒ…ä¸å¤ªä¸Šå¿ƒï¼Œæœ€åæˆç»©ä¹Ÿä¸æ€ä¹ˆå¥½çœ‹ï¼Œé«˜æ•°å­¦å¾—ä¹±ä¸ƒå…«ç³ŸæŸç§æ„ä¹‰ä¸Šä¹Ÿå½±å“äº†ç¬¬äºŒå­¦æœŸçš„é«˜æ•°ã€‚å½“æ—¶æƒ³ç€ç¬¬äºŒå­¦æœŸä¸€å®šè¦å¥½å¥½åšäººï¼Œä¸èƒ½å¿½è§†è¯¾å†…çš„ä¸œè¥¿ï¼Œç„¶è€Œä¸€è¿ä¸²çš„æ„å¤–è¿˜æ˜¯è®©è¿™ä¸ªè®¾æƒ³è½ç©ºäº†â€¦äº‹å®ä¸Šï¼Œè¿™å­¦æœŸæ€»ä½“è€Œè¨€ä¾ç„¶çš„æŒºç³Ÿç³•çš„ã€‚ å¯’å‡è¿‡çš„å…¶å®ä¸æ˜¯å¾ˆå¦™ã€‚å›å®¶å‰å»äº†è¶Ÿå¤©æ´¥ï¼Œå…¶å®å¹¶ä¸å¥½ç©ï¼Œä¸è¿‡ä¸€èµ·å»çš„å°ä¼™ä¼´è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ã€‚å›å®¶ä¹‹åå®åœ¨æ˜¯æœ‰ç‚¹é¢“ï¼Œæœ¬æ¥æƒ³å¥½å¥½ç ”ç©¶ä¸€æ³¢ç®—æ³•çš„ï¼Œä½†æ˜¯ç°åœ¨æƒ³æƒ³å¥½åƒå½“æ—¶ä¹Ÿæ²¡å¹²ä»€ä¹ˆï¼Œåæ¥æ—¥å­ä¹Ÿå°±è¿‡å»äº†ã€‚å¹´åå»äº†è¶ŸåŸƒåŠï¼Œå½“æ—¶çš„æ—¥ç¨‹å®‰æ’çš„ä¸æ˜¯ç‰¹åˆ«å¥½ï¼Œå½“ç„¶è¿™ä¸ªå›½å®¶ä¸ä¸€æ ·çš„é£æƒ…è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå¯’å‡å»¶ç»­äº†æˆ‘ä¸€è´¯ä»¥æ¥æ”¾å‡é¢“åºŸçš„ä½œé£ã€‚ å¼€å­¦å°±æ˜¯æ–°ç”Ÿèµ›ï¼Œæœ€åç»“æœè¿˜æ˜¯okçš„ï¼Œæ¯•ç«Ÿä¸€ç¾¤OIèŠè‹£ä»¬å‹é˜µï¼Œä¸€ä¸ªå°ç™½ä¹Ÿå°±è¿™æ ·äº†å§ã€‚ç„¶åå°±æ˜¯æ ¡èµ›çš„ç½‘ç»œèµ›ï¼Œç¬¬ä¸€æ¬¡ç»„é˜Ÿæäº†ä¸€æ³¢ï¼Œä¹Ÿç®—æ˜¯è®¤è¯†äº†ç¬¬ä¸€æ³¢é˜Ÿå‹å§ã€‚å†åé¢å°±æ˜¯å®éªŒç­çš„é€‰æ‹”ï¼Œä¸å¾—ä¸è¯´è¿™äº‹è¿˜æ˜¯æŒºç³Ÿå¿ƒçš„ï¼Œä¸çŸ¥é“æ˜¯è°åŠ çš„æŠ¥åé™åˆ¶â€”â€”æ™ºè‚²å‰40%ã€‚åæ­£å°±è®°å¾—é‚£å‘¨æŒºéš¾å—çš„ï¼Œå¹³å¿ƒè€Œè®ºå­¦é™¢è¿™ä¹ˆå®šå…¶å®ä¹Ÿæ— å¯åšéï¼Œä½†æˆ‘è¿˜æ˜¯éå¸¸çš„éƒé—·ã€‚æ¯•ç«Ÿä¸€ä¸ªæœºè€ƒé€‰æ‹”ï¼Œå¦‚æœè¿å‚åŠ çš„æœºä¼šéƒ½æ²¡æœ‰çš„è¯ï¼Œè¿˜æ˜¯ä»¤äººæŒºéš¾ä»¥æ¥å—çš„ã€‚å¹¸å¥½åæ¥å¥½åƒå¹¶æ²¡æœ‰äººè®°å¾—æœ‰è¿™ä¹ˆä¸€å›äº‹ï¼Œæœºè€ƒä¹Ÿé¡ºåˆ©çš„å‚åŠ äº†ã€‚ä¸è¿‡é‚£æ®µæ—¶é—´å¤§æ¦‚çŠ¶æ€ä¸å¤ªå¥½å§ï¼ŒåŠ ä¸Šå†…å¿ƒå¿§éƒï¼Œæ‰€ä»¥æœºè€ƒçš„çš„æ—¶å€™çº¯ç²¹æ˜¯é ç½šæ—¶å°‘æŠŠæ’åæ‹‰äº†ä¸Šæ¥ã€‚ç„¶åå°±æ˜¯é¢è¯•ï¼Œå¿å¿‘åœ°é‚“ç»“æœã€‚å½“æ—¶é¢è¯•çš„æ—¶å€™è¢«è€å¸ˆé—®äº†ä¸€å †è¯¾å†…æˆç»©çš„æƒ…å†µï¼Œæ„Ÿè§‰è‡ªå·±å¿«å‡‰äº†ï¼Œå¹¸å¥½æœ€åè¿˜æ˜¯è¿‡äº†ã€‚æ ¡èµ›çš„è¯æˆ‘ä»¬é˜Ÿæ„Ÿè§‰éƒ½ä¸åœ¨çŠ¶æ€ï¼Œç½šæ—¶çˆ†ç‚¸æ··äº†ä¸ªé“œï¼Œä¸è¿‡å½“æ—¶æƒ³æƒ³ï¼Œä¹Ÿç®—æ˜¯æ··è¿›å®éªŒç­äº†ï¼Œä¹Ÿä¸èƒ½å¤ªå¸Œæœ›ä¸€åˆ‡éƒ½å¾ˆé¡ºåˆ©å§ã€‚ ä¸è¿‡ï¼Œå¼€å­¦é‚£ä¼šå¿™äºå‡†å¤‡å„ç§èµ›ï¼Œä¹‹ååˆæ˜¯ç³Ÿå¿ƒçš„é€‰æ‹”ï¼Œç„¶åè½¬ç­åˆæ˜¯ä¸€ç‰‡æ··ä¹±ï¼ŒæŸç§æ„ä¹‰ä¸Šä¹Ÿå¾ˆå¤§çš„å½±å“äº†è¿™å­¦æœŸåç»­çš„è¯¾ç¨‹ã€‚ç‰¹åˆ«æ˜¯æ¨¡ç”µï¼Œè½¬è¿‡å»ä¹‹åå‘ç°ä»–ä»¬å·²ç»ä¸Šå®Œäº†ï¼Œäºæ˜¯åˆ°æœ€åæˆ‘ä¹Ÿæ²¡æ€ä¹ˆå­¦è¿™ç©æ„å„¿ï¼ŒæœŸæœ«ä¹Ÿæ˜¯ä¸æ˜ä¸ç™½æ··è¿‡å»äº†ã€‚æœŸæœ«çš„åŠä¸ªæœˆå…¶å®ä¹ŸåŠªåŠ›äº†ä¸€ä¸‹å¸Œæœ›æ‹¯æ•‘ä¸€ä¸‹è¯¾å†…ï¼Œä½†å…¶å®æœ€åä¹Ÿå°±é‚£æ ·äº†ï¼Œç§¯é‡éš¾è¿”ã€‚ åº”è¯¥è¯´ï¼Œè¿™ä¸ªç­ç‰›äººè¿˜æ˜¯å¾ˆå¤šçš„ï¼Œæ¯”èµ·æ¥æˆ‘å…¶å®å•¥éƒ½ä¸è¡Œâ€”â€”ä»£ç ä¸å¦‚OIå…šï¼Œè¯¾å†…æˆç»©ä¸€å¡Œç³Šæ¶‚ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“è¯´ä»€ä¹ˆå¥½äº†QAQï¼Œå¸Œæœ›å¯ä»¥åœ¨ä¼—å¤šèŠè‹£çš„åˆºæ¿€ä¸‹ä»¥ååšçš„æ›´å¥½å§â€¦ç„¶åè¿™åŠä¸ªå­¦æœŸä¹Ÿæœ‰å¹¸é‡åˆ°äº†å‡ ä½æŒºå¥½çš„åŒå­¦ï¼Œå‡ ä½èŠè‹£æ„¿æ„æ­ç†æˆ‘è¿™ä¸ªè’Ÿè’»ï¼Œå…¶å®è¿˜æ˜¯æŒºå¼€å¿ƒçš„ï¼Œä¹Ÿç®—æœ‰äº›æ„Ÿè°¢å§â€¦ä¹‹å‰è¿˜æœ‰ç‚¹æ‹…å¿ƒä¼šä¸ä¼šæ··æˆå­¤å®¶å¯¡äººçš„æ„Ÿè§‰â€¦. æµæ°´è´¦å†™äº†å†™ï¼Œå‘ç°æ—¶é—´è¿˜æ˜¯è¿‡å¾—å¾ˆå¿«çš„ã€‚æ€»ä½“ä¸Šæ¥è¯´ï¼Œè¿™ä¸€å¹´è¿˜æ˜¯æŒºå¿™çš„ï¼Œæ¯å¤©éƒ½è¿‡å¾—å¾ˆå¿«ï¼Œä¹Ÿç®—æ˜¯æŒºå……å®äº†ã€‚å½“ç„¶åæ¥è¿˜æ˜¯æœ‰ç‚¹é¢“äº†ï¼Œè€Œä¸”ç»©ç‚¹åº”è¯¥ç®—æ˜¯æŒºç³Ÿç³•äº†â€¦â€¦ä¸€å¹´æ¢äº†ä¸¤ä¸ªç­ï¼Œè®¤è¯†äº†ä¸€å¤§æ³¢æ–°åŒå­¦ï¼Œè¿˜æ˜¯è›®å¼€å¿ƒçš„ã€‚å¸Œæœ›æš‘å‡çš„è®­ç»ƒï¼Œä»¥åŠåé¢çš„å¤§äºŒï¼Œå¯ä»¥å¸å–ç»éªŒï¼Œè¿‡å¾—æ›´é¡ºåˆ©ä¸€äº›å§ï¼Œä¹Ÿäº‰å–æ··ä¸ªæ›´å¥½çš„æˆç»©ã€‚åŠ æ²¹ï¼]]></content>
      <categories>
        <category>ç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>ç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #456 (Div. 2) D.Fishes]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-round-456-div-2-d-fishes%2F</url>
    <content type="text"><![CDATA[æ˜¾ç„¶ï¼Œæš´åŠ›æ¨¡æ‹Ÿæ¯ä¸ªr* rçš„æ¡†è¦†ç›–æ˜¯ä¼štleçš„ï¼Œæˆ‘ä»¬ä¸å¦¨æ¢ä¸€ç§æ€è·¯ï¼Œå³è®¡ç®—æ¯ä¸ªcellè¢«å¤šå°‘ä¸ªæ¡†æ‰€è¦†ç›–ã€‚ å¯ä»¥å‘ç°ï¼Œåœ¨ä½ç½®xï¼Œyçš„cellçš„æ¡†è¦†ç›–æ•°ä¸ºï¼š å› æ­¤ï¼Œæ€»çš„æ¡†è¦†ç›–æ•°å°±æ˜¯ æ³¨æ„åˆ°æ— è®ºæ˜¯æ€ä¹ˆæ ·çš„æƒ…å†µï¼Œä½äº(n+1)/2,(m+1)/2å¤„çš„cellçš„æ¡†è¦†ç›–æ•°ä¸€å®šæ˜¯æœ€å¤§çš„ä¹‹ä¸€ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä»è¿™ä¸ªcellå¼€å§‹bfsï¼Œä½†æ˜¯è¿™é‡Œçš„queueué‡‡ç”¨æœ‰é™é˜Ÿåˆ—ï¼Œå³ä»¥æ¡†è¦†ç›–æ•°ä¸ºä¼˜å…ˆå€¼ã€‚æœ€åæ³¨æ„ä¸€ä¸‹é‡å¤çš„é—®é¢˜å³å¯ï¼ˆå†™çš„æ—¶å€™ç”¨setåˆ¤äº†ä¸€ä¸‹é‡ï¼‰ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;set&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt;P; struct cell{ int x,y;ll f; bool operator&lt;(const cell&amp;v)const{ return f&lt;v.f; } }; int n,m,r,k; ll cal(int x,int y) { return (ll)(min(n+1,x+r)-max(x,r))*(min(m+1,y+r)-max(y,r)); } bool ch(int x,int y) { if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return false; return true; } int main() { int i,j; int move1[4][2]={-1,0,1,0,0,-1,0,1}; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;k; priority_queue&lt;cell&gt;que; set&lt;P&gt;ck; ll sum=0; que.push(cell{(n+1)/2,(m+1)/2,cal((n+1)/2,(m+1)/2)}); ck.insert(P((n+1)/2,(m+1)/2)); while(!que.empty()){ k--; cell t=que.top();que.pop(); sum+=t.f; for(i=0;i&lt;4;i++){ int x1=t.x+move1[i][0],y1=t.y+move1[i][1]; if(ch(x1,y1)&amp;&amp;!ck.count(P(x1,y1))){ que.push(cell{x1,y1,cal(x1,y1)});ck.insert(P(x1,y1)); } } if(!k)break; } printf(&quot;%.10f\n&quot;,(double)sum/((ll)(n-r+1)*(m-r+1))); return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Hello 2018]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-hello-2018%2F</url>
    <content type="text"><![CDATA[A. 2çš„å¹‚æ¬¡æ¯”è¾ƒå¤§çš„æ—¶å€™æ˜¾ç„¶ç›´æ¥è¾“å‡ºmå°±è¡Œäº†ï¼Œæ¯”è¾ƒå°çš„æ—¶å€™æš´åŠ›ç®—ä¸€ä¸‹å°±è¡Œã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { long long n,m; cin&gt;&gt;n&gt;&gt;m; if(n&gt;=63){ cout&lt;&lt;m&lt;&lt;endl; } else{ cout&lt;&lt;m%(1LL&lt;&lt;n)&lt;&lt;endl; } return 0; } B. dfsåˆ¤æ–­ä¸€ä¸‹å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;G[1005]; bool dfs(int x) { if(G[x].empty()) return true; if(G[x].size()&amp;&amp;G[x].size()&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } int cnt=0; for(auto a:G[x]) if(dfs(a)) cnt++; if(cnt&lt;3){ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;exit(0); } return false; } int main() { int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;j); G[j].push_back(i+1); } dfs(1); cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; return 0; } C. å’‹ä¸€çœ‹æ„Ÿè§‰æ˜¯ä¸ªå®Œå…¨èƒŒåŒ…ï¼Œç„¶è€Œ1e9çš„èŒƒå›´åŠ ä¸Šå¯ä»¥è¶…è¿‡Lï¼Œä½¿å¾—èƒŒåŒ…ä¸å¤ªå¯èƒ½ã€‚ å› ä¸ºå®¹é‡éƒ½æ˜¯2çš„å¹‚æ¬¡ï¼Œå› æ­¤ä¸€ä¸ªæ˜¾ç„¶çš„ä¼˜åŒ–å°±æ˜¯ï¼Œå¦‚æœci+1&gt;ci * 2ï¼Œé‚£ä¹ˆæ˜¾ç„¶ä¹°i+1ä¸å¦‚ä¹°ä¸¤ä¸ªiï¼Œå› æ­¤å¯ä»¥æŠŠi+1ç»™æ¢æ‰ã€‚ åšå®Œè¿™ä¸ªæ›¿æ¢ä¹‹åï¼Œæœ‰ä¸€ç‚¹æ˜¾ç„¶çš„å°±æ˜¯å¦‚æœæœ€ç»ˆä¹°çš„æ€»å®¹é‡ä¸è¶…è¿‡Lçš„è¯ï¼Œé‚£ä¹ˆæ˜¾ç„¶æ˜¯ä¹°å°å®¹é‡çš„ä¸å¦‚ä¹°å¤§å®¹é‡çš„ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯æœ‰å¯èƒ½ä¹°è¶…å‡ºLçš„æ€»å®¹é‡ä¼šæ›´åˆ’ç®—ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»å¤§å®¹é‡æšä¸¾åˆ°å°å®¹é‡ï¼Œå¯¹äºæ¯ä¸ªå®¹é‡ï¼Œæˆ‘ä»¬éƒ½è€ƒè™‘å¦‚æœæœ€å°çš„å®¹é‡å°±æ˜¯ä»–çš„æƒ…å†µï¼Œå¹¶ç”¨æ­¤å»æ›´æ–°ç­”æ¡ˆã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;c; typedef long long ll; int main() { int n,i,j,k,l; cin&gt;&gt;n&gt;&gt;l; for(i=1;i&lt;=n;i++){ cin&gt;&gt;j;c.push_back(j); } for(i=0;i&lt;c.size()-1;i++){ c[i+1]=min(c[i+1],c[i]&lt;&lt;1); } ll sum=0,ans=1LL&lt;&lt;62; for(i=n-1;~i;i--){ int need=l/(1&lt;&lt;i); sum+=(ll)need*c[i]; l-=need*(1&lt;&lt;i); ans=min(ans,sum+(l?c[i]:0)); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } D. è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„æ’åºé—®é¢˜ã€‚ é¦–å…ˆæˆ‘ä»¬å°†è€ƒè¯•æŒ‰aä»å¤§åˆ°å°æ’åºï¼Œaç›¸åŒæ—¶æŒ‰tä»å°åˆ°å¤§æ’åºã€‚ç„¶åä¾æ¬¡æ‹¿å‡ºæ¯ä¸ªè€ƒè¯•ï¼Œç”¨ä¸€ä¸ªå¤§æ ¹å †ç»´æŠ¤æˆ‘ä»¬é€‰æ‹©çš„è€ƒè¯•ï¼Œå¤§æ ¹å †æ ¹æ®æ¯ä¸ªè€ƒè¯•çš„tæ’åºã€‚å¯¹äºæ¯ä¸ªä»åºåˆ—ä¸­æ‹¿å‡ºçš„è€ƒè¯•ï¼Œå¦‚æœå®ƒçš„é—¨æ•°==å †ä¸­çš„è€ƒè¯•æ•°ï¼Œé‚£ä¹ˆåªæœ‰è¿™ä¸ªè€ƒè¯•çš„tæ¯”å †é¡¶çš„è€ƒè¯•çš„tå°çš„æ—¶å€™æˆ‘ä»¬æ‰æœ‰å¿…è¦æŠŠä»–ä¸¢è¿›å»ã€‚å¦‚æœæ‹¿å‡ºçš„è€ƒè¯•çš„a&gt;=å †ä¸­é—¨æ•°+1ï¼Œé‚£ä¹ˆå¦‚æœå †ä¸­æ€»å’Œ+æ‹¿å‡ºçš„t&lt;=æ€»æ—¶é•¿ï¼Œå°±ç›´æ¥ä¸¢è¿›å †ã€‚å¦åˆ™æŠŠæ‹¿å‡ºçš„è€ƒè¯•ä¸å †é¡¶è€ƒè¯•ä¸­tæ¯”è¾ƒå°çš„æ”¾è¿›å»å³å¯ã€‚æœ€åå †ä¸­è€ƒè¯•å³ä¸ºæ‰€æ±‚ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct test{ int id,a,t; bool operator&lt;(const test&amp;v)const{ return t&lt;v.t; } }T[200005]; bool cmp(test a,test b) { if(a.a==b.a) return a.t&lt;b.t; return a.a&gt;b.a; } int main() { int n,t,i,j,cnt=0; cin&gt;&gt;n&gt;&gt;t; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;T[i].a,&amp;T[i].t);T[i].id=i; } sort(T+1,T+1+n,cmp); priority_queue&lt;test&gt;que; for(i=1;i&lt;=n;i++){ if(T[i].a==que.size()){ if(!que.empty()){ if(que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } else if(T[i].a&gt;=que.size()+1){ if(cnt+T[i].t&lt;=t){ que.push(T[i]);cnt+=T[i].t; } else{ if(!que.empty()&amp;&amp;que.top().t&gt;T[i].t){ cnt-=que.top().t;que.pop();que.push(T[i]);cnt+=T[i].t; } } } } cout&lt;&lt;que.size()&lt;&lt;endl&lt;&lt;que.size()&lt;&lt;endl; while(!que.empty()){ cout&lt;&lt;que.top().id&lt;&lt;&apos; &apos;;que.pop(); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mash upå å‘]]></title>
    <url>%2F%E4%B9%B1%E6%90%9E%2Fmash-up-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>ä¹±æ</category>
      </categories>
      <tags>
        <tag>ä¹±æ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Life å å‘]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2Flife-e5-8d-a0-e5-9d-91%2F</url>
    <content type="text"><![CDATA[23333333]]></content>
      <categories>
        <category>ç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>ç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 36 (Rated for Div. 2)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FCodeforces%2Fcodeforces-educational-codeforces-round-36-rated-for-div-2%2F</url>
    <content type="text"><![CDATA[A. ç­¾åˆ°é¢˜ä¸è§£é‡Š #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; bool cmp(int a,int b) { return a&gt;b; } int main() { int n,k,i,j; //cin&gt;&gt;n; vector&lt;int&gt;v; cin&gt;&gt;n&gt;&gt;k; for(i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;j); if(k%j==0)v.push_back(j); } sort(v.begin(),v.end(),cmp); cout&lt;&lt;k/v[0]&lt;&lt;endl; return 0; } B. æ€»å…±åªæœ‰ä¸¤ç§æƒ…å†µï¼šå…ˆå…³å·¦è¾¹å†å…³å³è¾¹ï¼Œæˆ–è€…åè¿‡æ¥ï¼Œè®¨è®ºä¸€ä¸‹ç‰¹æ®Šè¾¹ç•Œæƒ…å½¢å³å¯ï¼Œç­¾åˆ°*2 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n,pos,l,r,i,j,k; cin&gt;&gt;n&gt;&gt;pos&gt;&gt;l&gt;&gt;r; if(l==1&amp;&amp;r==n){ cout&lt;&lt;0&lt;&lt;endl;return 0; } else if(l==1&amp;&amp;r!=n){ cout&lt;&lt;abs(pos-r)+1&lt;&lt;endl; } else if(l!=1&amp;&amp;r==n){ cout&lt;&lt;abs(pos-l)+1&lt;&lt;endl; } else{ int a=abs(pos-l)+1+abs(r-l)+1; int b=abs(pos-r)+1+abs(l-r)+1; cout&lt;&lt;min(a,b)&lt;&lt;endl; } return 0; } C. æ˜¾ç„¶æˆ‘ä»¬æ˜¯æƒ³æ±‚ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å­—å…¸åºæœ€å¤§çš„æ’åˆ—ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€ä½ï¼Œæˆ‘ä»¬ä»å¯æ”¾ç½®çš„æœ€å¤§æ•°å‡ºå‘ï¼Œæ‰¾å‡ºåœ¨å½“å‰çŠ¶å†µä¸‹åç»­èƒ½æ’å‡ºçš„æœ€å°åºåˆ—ï¼Œè·Ÿbå‰©ä¸‹çš„ä½æ•°æ¯”è¾ƒï¼Œå¦‚æœæœ€å°åºåˆ—æ¯”bå°ï¼Œé‚£ä¹ˆè¿™ä¸€ä½å°±å¯ä»¥æ”¾æœ€å¤§çš„æ•°ã€‚å¦åˆ™è¿™ä¸€ä½å°±å¿…é¡»æ”¾æ¯”è¾ƒå°çš„æ•°ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; int cnt[15]; string build(void) { string res; for(int i=0;i&lt;10;i++){ for(int j=1;j&lt;=cnt[i];j++) res+=char(i+&apos;0&apos;); } return res; } int main() { string a,b;int i,j,k; cin&gt;&gt;a&gt;&gt;b; int num[25]; for(i=0;i&lt;b.size();i++) num[i]=b[i]-&apos;0&apos;;//æ¯ä½æ•°å­—,ä¾¿äºæ¯”è¾ƒ for(i=0;i&lt;a.size();i++)//ç»Ÿè®¡æ¯ç§æ•°å­—çš„ä¸ªæ•° cnt[a[i]-&apos;0&apos;]++; if(a.size()&lt;b.size()){//å¦‚æœä½æ•°å°‘ç›´æ¥è¾“å‡ºæœ€å¤§æ’åˆ— for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl;return 0; } string ans;bool ismall=false; for(i=0;i&lt;a.size();i++){ if(ismall)break; for(j=num[i];~j;j--){//å¯»æ‰¾è¿™ä¸€ä½æœ€å¤§çš„å¯èƒ½ if(cnt[j]){ cnt[j]--; if(j&lt;num[i]){//å¦‚æœè¿™ä¸€ä½å·²ç»æ¯”bå°äº†,ç›´æ¥è¾“å‡ºåç»­æœ€å¤§æ’åˆ—å³å¯ ismall=true;ans+=char(j+&apos;0&apos;);break; } string minn=build();string bnow=b.substr(i+1);//å¯»æ‰¾åœ¨å½“å‰æƒ…å†µä¸‹åç»­èƒ½æ’å‡ºçš„æœ€å°æ’åˆ— if(minn&lt;=bnow){ ans+=char(j+&apos;0&apos;); break; } cnt[j]++; } } } cout&lt;&lt;ans; for(i=9;~i;i--){ for(j=cnt[i];j;j--) cout&lt;&lt;i; } cout&lt;&lt;endl; return 0; } D. ç»™å®šä¸€å¹…æœ‰å‘å›¾ï¼Œé—®æ˜¯å¦å¯ä»¥æœ€å¤šå»æ‰ä¸€æ¡è¾¹ä½¿å¾—è¯¥æœ‰å‘å›¾æ— ç¯ï¼Ÿ é¢˜ç›®çš„åšæ³•æ¯”è¾ƒç¥å¥‡ã€‚ä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯å…ˆæ±‚ä¸€æ³¢å¼ºè¿é€šåˆ†é‡ï¼Œç„¶åç‰¹åˆ¤ä¸€ä¸‹å¼ºè¿é€šåˆ†é‡ä¸º1çš„æƒ…å†µï¼Œç„¶è€Œtest56 GGäº†ã€‚ çœ‹åˆ°ä¸€ç§åšæ³•ï¼Œå³ä»1~nï¼Œæ¯æ¬¡ä»¥ä¸åŒçš„èµ·ç‚¹å¼€å§‹dfsæ‰¾ç¯ï¼Œåˆ¤æ–­å›¾ä¸­æ˜¯å¦å¯èƒ½å­˜åœ¨åªå»æ‰ä¸€æ¡è¾¹å°±æ— ç¯çš„æƒ…å†µï¼ˆå½“ç„¶è¦æ˜¯æœ¬æ¥å°±æ²¡ç¯é‚£å°±æ˜¯åºŸè¯ï¼‰ã€‚ ä¸ºä»€ä¹ˆä»ä¸åŒçš„ç‚¹å¼€å§‹dfsç»“æœä¼šä¸ä¸€æ ·ï¼Ÿå› ä¸ºè¿™é“é¢˜ä¸­ä¼šæœ‰ä¸€ç§æ¯”è¾ƒå¥‡ç‰¹çš„æƒ…å½¢ï¼Œæœ‰å¯èƒ½æœ‰å¤šä¸ªç¯éƒ½ä¾èµ–äºä¸€æ¡æœ‰å‘è¾¹è€Œå­˜åœ¨ï¼Œæ¯”å¦‚æ ·ä¾‹1ï¼ˆå¦‚å›¾ï¼‰ åœ¨è¿™é‡Œä¼šå‘ç°2-&gt;3çš„è¾¹æ˜¯ä¸€æ¡å…³é”®è¾¹ï¼Œä»3å¼€å§‹æœç´¢æ—¶å› ä¸ºå…ˆåˆ°2ï¼Œå†å¼€å§‹æœç´¢1ï¼Œå› æ­¤vis[2]=1è€Œä¸ä¼šè¢«1æœç´¢åˆ°ï¼Œäºæ˜¯cntåªæœ‰1.å› æ­¤è¿™å°±æ˜¯â€œYESâ€ã€‚ çœ‹èµ·æ¥ä¼¼ä¹è¿˜æ˜¯æŒºå¥‡å¦™çš„233 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; vector&lt;int&gt;G[505]; int cnt; int vis[505]; void dfs(int x) { vis[x]=2;//æ­£åœ¨å½“å‰æœç´¢åºåˆ—ä¸­çš„æ ‡è®°ä¸º2 for(auto a:G[x]){ if(vis[a]==2) cnt++;//æ¯æ‰¾åˆ°ä¸€ä¸ªç¯cnt++ else if(!vis[a]) dfs(a); } vis[x]=1;//å·²ç»è®¿é—®è¿‡ä½†ä¸æ˜¯å½“å‰æœç´¢åºåˆ—ä¸­çš„æ ‡è®°ä¸º1 } int main() { int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); } for(i=1;i&lt;=n;i++){ memset(vis,0,sizeof(vis));cnt=0; dfs(i); for(j=1;j&lt;=n&amp;&amp;cnt&lt;=1;j++) if(!vis[j]) dfs(j); if(cnt&lt;=1){//å¦‚æœä»è¿™ä¸ªç‚¹å‡ºå‘åªæ‰¾åˆ°ä¸€ä¸ªç¯(å…³å»ºè¾¹) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return 0; } } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } E. ç»™å®šä¸€ä¸ªåˆå§‹å…¨ä¸º1çš„åºåˆ—ï¼Œä¸åœåœ°ç»™å‡ºä¸€ä¸ªæ¯”è¾ƒçŸ­çš„åºåˆ—(l,r),å°†(l,r)èŒƒå›´å†…æ•°å…¨éƒ¨å˜ä¸º1æˆ–0ï¼ˆæ ¹æ®kçš„å€¼å†³å®šï¼‰ã€‚åºåˆ—èŒƒå›´è¾ƒå¤§ã€‚ ä¸€çœ¼çœ‹ä¸‹å»æ„Ÿè§‰çº¿æ®µæ ‘èƒ½æï¼Œä¸€çœ‹èŒƒå›´1e9â€¦äº‹å®ä¸Šè¿™é“é¢˜åˆæ˜¯ä¸€ä¸ªç”¨mapç»´æŠ¤åŒºé—´ä¿¡æ¯çš„å…¸ä¾‹â€¦æˆ‘ä»¬å°†è¿ç»­çš„å·¥ä½œæ—¥åŒºé—´æŒ‰å³ç«¯ç‚¹ä¸ºå…³é”®å€¼æ’å…¥mapä¸­ï¼Œmapçš„ç¬¬äºŒä¸ªé”®å€¼å°±æ˜¯åŒºé—´çš„å·¦ç«¯ç‚¹ã€‚é‚£ä¹ˆåˆå§‹æ—¶æœ‰range[n]=1 å¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œæˆ‘ä»¬æ‰¾å‡ºå¤§äºlçš„çš„æœ€å°çš„åœ¨mapä¸­çš„å·¥ä½œåŒºé—´ï¼ŒæŠŠå®ƒä¸è¿™æ¬¡è¯¢é—®çš„åŒºé—´ç›¸äº¤çš„éƒ¨åˆ†å…¨éƒ¨åˆ å»ï¼Œç„¶åä¾æ¬¡ç±»æ¨ç›´è‡³mapä¸­çš„åŒºé—´ä¸ä¸è¯¢é—®åŒºé—´ç›¸äº¤ã€‚å¦‚æœk=2ï¼Œé‚£ä¹ˆç­”æ¡ˆåŠ ä¸Šr-l+1å³å¯ã€‚ä¸ºä»€ä¹ˆä¸è®¨è®ºk=1ï¼Ÿå› ä¸ºå³ä½¿æ˜¯k=1ï¼Œè¯¢é—®çš„ç©ºé—´ä¹Ÿå¯èƒ½æ˜¯æ”¯ç¦»ç ´ç¢çš„ï¼Œå¹¶ä¸å®¹æ˜“ç»Ÿè®¡ï¼Œä¸å¦‚æŠŠä»–ä»¬å…¨éƒ¨åˆ æ‰é‡ç½®ã€‚ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int main() { map&lt;int,int&gt;range;//æ ‡è®°å‘¨æœŸ int n,i,j,k,q; cin&gt;&gt;n&gt;&gt;q; range[n]=1;int ans=n; for(i=1;i&lt;=q;i++){ int l,r,k; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); auto a=range.lower_bound(l);//æ‰¾å‡ºå¤§äºç­‰äºè¯¢é—®åŒºé—´çš„ç¬¬ä¸€ä¸ªmapçš„å³ç«¯ç‚¹ while(a!=range.end()){ int cl=a-&gt;second,cr=a-&gt;first; if(cl&gt;r)break;//å¦‚æœåŒºé—´çš„å·¦ç«¯ç‚¹å·²ç»å¤§äºè¯¢é—®åŒºé—´çš„å³ç«¯ç‚¹,æ˜¾ç„¶æ²¡æœ‰äº¤é›†äº† ans-=(min(cr,r)-max(cl,l)+1);//é™¤å»è¯¢é—®åŒºé—´çš„æ‰€æœ‰å·¥ä½œæ—¥ range.erase(a++);//åˆ å»é‡å åŒºé—´ if(cr&gt;r)range[cr]=r+1;//å¦‚æœå¤§åŒºé—´è¢«è¯¢é—®åŒºé—´è‚¢è§£äº†,åŠ å…¥å°çš„æœªæ¶‰åŠåŒºé—´ if(cl&lt;l)range[l-1]=cl; } if(k==2){ range[r]=l;ans+=r-l+1;//k=2æ—¶åŠ å…¥è¯¢é—®åŒºé—´ } printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ï¼ˆæ¨¡æ¿ï¼‰Splay å¹³è¡¡æ ‘]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%9D%BF%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2Fsplay%2F</url>
    <content type="text"><![CDATA[æ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼ˆå¯å‚è€ƒé¢˜ç›®æ ‡é¢˜ï¼‰ï¼Œæ¥ç»´æŠ¤ä¸€äº›æ•°ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼š 1.æ’å…¥ xx æ•° 2.åˆ é™¤ xx æ•°(è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œå› åªåˆ é™¤ä¸€ä¸ª) 3.æŸ¥è¯¢ xx æ•°çš„æ’å(æ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° +1+1 ã€‚è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œå› è¾“4.å‡ºæœ€å°çš„æ’å) 5.æŸ¥è¯¢æ’åä¸º xx çš„æ•° 6.æ±‚ xx çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº xx ï¼Œä¸”æœ€å¤§çš„æ•°) 7.æ±‚ xx çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº xx ï¼Œä¸”æœ€å°çš„æ•°) æ´›è°·P3369 ä¸è®²è§£ï¼Œç›´æ¥ä¸Šä»£ç ï¼š #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int MAXN=1000000; int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN]; int nodecnt,root; void clear(int x)//æ¸…é™¤(å½“è¿™ä¸ªç‚¹è¢«åˆ é™¤ä¹‹å) { ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0; } bool get(int x)//åˆ¤æ–­æ˜¯çˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹è¿˜æ˜¯å³èŠ‚ç‚¹ { return ch[f[x]][1]==x; } void update(int x)//æ›´æ–°å½“å‰ç‚¹ä»¥ä¸‹çš„å…ƒç´ ä¸ªæ•°(å‘ç”Ÿä¿®æ”¹ä»¥åæ›´æ–°) { if (x){ size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; } } void rotate(int x)//æ—‹è½¬ { int old=f[x],oldf=f[old],whichx=get(x); ch[old][whichx]=ch[x][whichx^1]; f[ch[old][whichx]]=old; ch[x][whichx^1]=old; f[old]=x; f[x]=oldf; if (oldf) ch[oldf][ch[oldf][1]==old]=x; update(old); update(x); } void splay(int x)//splay,ä¸åœåœ°rotateç›´åˆ°æ»¡è¶³è¦æ±‚ { for (int fa;fa=f[x];rotate(x)) if (f[fa]) rotate((get(x)==get(fa))?fa:x); root=x; } void insert(int x)//æ’å…¥ { if (root==0) { nodecnt++; ch[nodecnt][0] = ch[nodecnt][1] = f[nodecnt] = 0; root = nodecnt; size[nodecnt] = cnt[nodecnt] = 1; key[nodecnt] = x; return; } int now=root,fa=0; while(1){ if (x==key[now]){ cnt[now]++; update(now); update(fa); splay(now); break; } fa=now; now=ch[now][key[now]&lt;x]; if (now==0){ nodecnt++; ch[nodecnt][0]=ch[nodecnt][1]=0; f[nodecnt]=fa; size[nodecnt]=cnt[nodecnt]=1; ch[fa][key[fa]&lt;x]=nodecnt; key[nodecnt]=x; update(fa); splay(nodecnt); break; } } } int find(int x)//æŸ¥è¯¢xçš„æ’å(æ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° +1+1 ã€‚è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”è¾“å‡ºæœ€å°çš„æ’å) { int now=root,ans=0; while(1){ if (x&lt;key[now]) now=ch[now][0]; else{ ans+=(ch[now][0]?size[ch[now][0]]:0); if (x==key[now]){ splay(now); return ans+1; } ans+=cnt[now]; now=ch[now][1]; } } } int findx(int x)//å¯»æ‰¾æ’åä¸ºxçš„æ•° { int now=root; while(1){ if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else{ int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp; now=ch[now][1]; } } } int pre()//æ±‚ xx çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº xx ï¼Œä¸”æœ€å¤§çš„æ•°),æ³¨æ„è¿™ä¸ªæ•°ä¸ä¸€å®šåœ¨æ ‘ä¸­ { int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now; } //æ³¨æ„,æŸ¥æ‰¾æŸä¸ªæ•°çš„å‰é©±åé©±æ—¶,è¦å…ˆæŠŠè¿™ä¸ªæ•°æ’è¿›æ ‘ä¸­,ç„¶åæŠŠè¿™ä¸ªæ•°è½¬åˆ°æ ¹èŠ‚ç‚¹(insertä¸­å·²é›†æˆ), //æ±‚xçš„å‰é©±å…¶å®å°±æ˜¯æ±‚xçš„å·¦å­æ ‘çš„æœ€å³è¾¹çš„ä¸€ä¸ªç»“ç‚¹ï¼Œåç»§æ˜¯æ±‚xçš„å³å­æ ‘çš„å·¦è¾¹ä¸€ä¸ªç»“ç‚¹,æ±‚å®Œåè¦åˆ é™¤è¿™ä¸ªç‚¹ int next1()//æ±‚ xx çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº xx ï¼Œä¸”æœ€å°çš„æ•°) { int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now; } void del(int x)//åˆ é™¤å€¼ä¸ºxçš„èŠ‚ç‚¹ { int whatever=find(x);//ä¸»è¦ä½œç”¨å°±æ˜¯æŠŠxæ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹...ä¸èƒ½çœç•¥ if (cnt[root]&gt;1) { cnt[root]--; update(root); return; } if (!ch[root][0]&amp;&amp;!ch[root][1]) { clear(root); root = 0; return; } if (!ch[root][0]) { int oldroot = root; root = ch[root][1]; f[root] = 0; clear(oldroot); return; } else if (!ch[root][1]) { int oldroot = root; root = ch[root][0]; f[root] = 0; clear(oldroot); return; } int leftbig=pre(),oldroot=root; splay(leftbig); ch[root][1]=ch[oldroot][1]; f[ch[oldroot][1]]=root; clear(oldroot); update(root); } int main() { int n,i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;j,&amp;k); if(j==1){ insert(k); } else if(j==2){ del(k); } else if(j==3){ cout&lt;&lt;find(k)&lt;&lt;endl; } else if(j==4){ cout&lt;&lt;findx(k)&lt;&lt;endl; } else if(j==5){ insert(k);cout&lt;&lt;key[pre()]&lt;&lt;endl;del(k); } else if(j==6){ insert(k);cout&lt;&lt;key[next1()]&lt;&lt;endl;del(k); } } return 0; }]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ¨¡æ¿</category>
        <category>æ•°æ®ç»“æ„</category>
        <category>å¹³è¡¡æ ‘</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ¨¡æ¿</tag>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å¹³è¡¡æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2FUncategorized%2Ftest-1%2F</url>
    <content type="text"><![CDATA[testtesttest#include&lt;iostream&gt; int main() { std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; return 0; } hjsfkwhfkhfh fsdfggs hkjhka jhhhj njhkkjk $f^2+2f+4$ ~hjkahfh~ ä¸­æ–‡æµ‹è¯• æµ‹è¯•æµ‹è¯•]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2FUncategorized%2Fe4-bd-a0-e5-a5-bd-e4-b8-96-e7-95-8c%2F</url>
    <content type="text"><![CDATA[Welcome to WordPress. This is your first post. Edit or delete it, then start writing!]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>Uncategorized</tag>
      </tags>
  </entry>
</search>
